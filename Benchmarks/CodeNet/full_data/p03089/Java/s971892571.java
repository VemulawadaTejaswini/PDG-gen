#include<iostream>
using namespace std; // 575

int main() {
	int N;
	static int b[101];
	cin >> N;
	for (int i = 1;i <= N;++ i) cin >> b[i];
	int ans[100];
	b[0] = 0;
	b[N + 1] = 1;
	for (int i = N, j = 0, k;i >= 0;-- i) {
		k = b[i + 1];
		if (b[i] + 1 < b[i + 1]) { // 不可能
			cout << -1;
			return 0;
		}
		else for (;k <= b[i];++ k) ans[j++] = k;
	}
	for (int i = 0;i < N;++ i) cout << ans[i] << endl;
	return 0;
}
/*
31536000のコメント解説欄
ここテンプレで用意してるから、A問題とかだとこの先空欄の危険あり
また、コンテスト後に https://31536000.hatenablog.com/ で解説していると思うので、良かったら読んでねー

逆順に考える
また、最後に0を入れているものとして考える
まず、数字が減るとき、これはその数字をそのまま入れられるとして良い
数字が増えるとき、その間に補完する数字を入れていく
例えば2→3にするなら2と1を補完し、1 2 2 3にする必要がある(この時1と2があることが前提になる)

例えば1 2 2 2 3 2が作れるか考える
1. 2……(1 2)を追加
2. 3……(2 3)を追加、1 2 2 3とする(1 2 3 2)
3. 2……あるので飛ばす
4. 2……(2)を追加、1 2 2 3 2とする(1 2 2 3 2)
5. 2……(2)を追加、1 2 2 3 2 2とする(1 2 2 2 3 2)

例えばサンプル3でも考える
1. 2……(1 2)を追加、現時点(1 2)
2. 3……(2 3)を追加、(1 2 3 2)となる
3. 2……スキップ
4. 1……スキップ
5. 2……(1 2)を追加、(1 2 1 2 3 2)となる
6. 2……(2)を追加、(1 2 2 1 2 3 2)となる
7. 1……スキップ
8. 1……(1)を追加、(1 1 2 2 1 2 3 2)となる
9. 1……(1)を追加、(1 1 1 2 2 1 2 3 2)となる

じゃ1 2 3 1 3が作れるか？
答えは無理、隣り合った数字しか作れん！
結論: 1減少はスキップ、2以上減少は不可、1以上増加は途中数字の追加
末尾に0をあるものとして考えれば良い
*/