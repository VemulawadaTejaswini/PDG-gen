import java.awt.Point;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Main {

	/** ????§??????? */
	static final String WHITE_SPACE = " ";

	/** ????????????????´¢??¨???????????? */
	static final Pattern np = Pattern.compile("[GS]|[1-5]");

	/** ??????????????°??????????´¢??¨???????????? */
	static final Pattern sp = Pattern.compile("[S]");

	/** ??´????????°??????????´¢??¨???????????? */
	static final Pattern gp = Pattern.compile("[G]");

	/** ???????????¢?????°???????´¢??¨???????????? */
	static final Pattern pp = Pattern.compile("[1-5]");

	/** ??????????????????_X */
	static int mapSizeX = 0;

	/** ??????????????????_Y */
	static int mapSizeY = 0;

	//	/** ????????? */
	//	static String[] map = new String[1000 * 1000];

	/** ??????????????° */
	static int maxNode = 0;

	/** ????????¢??????????????? */
	static List<Point> pachimonList = new ArrayList<Point>();

	/**
	 * @param args
	 * @throws IOException
	 */
	public static int main(String[] args) throws IOException {
		Scanner scanner = new Scanner(System.in);

		while (scanner.hasNextLine()) {
			readMap(scanner);
			int[] adjacent = createAdjacent();
			Point output = createPos(0, Integer.MAX_VALUE);

			for (int type = 1; type <= 5; type++) {
				// ??????????????¶????????¢??????????????£??\???????????????????????¨??´???????????????????????±????¨????
				adjacent = addStartGoal(adjacent, type);

				// ??????????????????????????¢??????????????????????????????????????????????´¢
				int cost = searchRoute(adjacent, type);
				if (cost < output.y) {
					output.x = type;
					output.y = cost;
				}
			}

			// ???????????????
			if (output.y == Integer.MAX_VALUE) {
				System.out.println("NA");
			} else {
				System.out.println(output.x + WHITE_SPACE + output.y);
			}
		}
		return 0;
	}

	/**
	 * ?????????????????????????????????
	 * @param scanner ????????£??????
	 */
	private static void readMap(Scanner scanner) {
		String[] mapSizeLine = scanner.nextLine().split(WHITE_SPACE);

		// ??????????????±????????????
		initializeMap();
		pachimonList.removeAll(pachimonList);
		maxNode = 0;
		mapSizeX = Integer.parseInt(mapSizeLine[0]);
		mapSizeY = Integer.parseInt(mapSizeLine[1]);
		boolean startFlg = false;
		boolean goalFlg = false;


		Collections.sort(pachimonList, new Comparator<Point>() {
			@Override
			public int compare(Point o1, Point o2) {
				return o1.x - o2.x;
			}
		});
	}

	/**
	 * X????????????????????´?????????????????¢???????±???§????¨????<br>
	 * ????????????:0?????´??????:6???????????¢???????±???§:1???5<br>
	 * Y????????????????????????????????????????´?
	 * @param type ?????????????????´?????????????????¢???????±???§
	 * @param index ??????????????????????????????
	 * @return
	 */
	private static Point createPos(int type, int index) {
		return new Point(type, index);
	}

	/**
	 * ??????????????¨??????????´???????????????§?????????
	 */
	private static void initializeMap() {
		for (int i = 0; i < 1000000; i++) {
//			map[i] = "";
		}
	}

	/**
	 * ??¨???????????????????????£??\??????????±???????
	 * @return ??£??\??????
	 */
	private static int[] createAdjacent() {
		int[] adjacent = new int[maxNode * maxNode];

		for (int i = 1; i < pachimonList.size() - 1; i++) {
			if (pachimonList.get(i).x < 5) {
				for (int j = i + 1; j < pachimonList.size() - 1; j++) {
					if (pachimonList.get(j).x - pachimonList.get(i).x > 2)
						break;

					if (pachimonList.get(j).x == pachimonList.get(i).x + 1)
						adjacent[i * maxNode + j] = clucCost(pachimonList.get(i), pachimonList.get(j));
				}
			} else {
				for (int j = 0; j < pachimonList.size() - 1; j++) {
					if (pachimonList.get(j).x == pachimonList.get(i).x - 4)
						adjacent[i * maxNode + j] = clucCost(pachimonList.get(i), pachimonList.get(j));
				}
			}
		}
		return adjacent;
	}

	/**
	 * ??????????????????????????¢????????????????????????????????????????±???§???????????¢??????????????????<br>
	 * ?????????????????????????????¢?????????????????????????¨????
	 * @param adjacent ??£??\??????
	 * @param firstType ??????????????????????????¢???????±???§
	 * @return ??£??\??????
	 */
	private static int[] addStartGoal(int[] adjacent, int firstType) {
		// ??????????????????????????¢????????????????¬??????????????????????????????¢?????¨??????????????£??\??????????¨????
		int startRow = 0;
		int goalRow = maxNode - 1;

		// ??????????????????????????¢????????????????????????????????????1?¨?????????????????????????4?¨??????????????????????
		int nextType = getNextType(firstType);
		int endType = getEndType(firstType);
		// ??????????????¨??´???????????±?????????????????????
		resetStartGoal(adjacent);

		for (int i = 0; i < pachimonList.size(); i++) {
			if (pachimonList.get(i).x == nextType)
				adjacent[startRow * maxNode + i] = clucCost(pachimonList.get(0), pachimonList.get(i));

			if (pachimonList.get(i).x == endType)
				adjacent[i * maxNode + goalRow] = clucCost(pachimonList.get(i), pachimonList.get(maxNode - 1));
		}
		return adjacent;
	}

	/**
	 * ??????????????¨??´?????????????????????????????????????????????
	 * @return ????????????????????£??\??????
	 */
	private static void resetStartGoal(int[] adjacent) {
		int goalRow = maxNode;
		for (int i = 0; i < maxNode; i++) {
			adjacent[i] = 0;
			adjacent[goalRow * (i + 1) - 1] = 0;
		}
	}

	/**
	 * ??????????????????????????¢???????????????????????????????????????????????¢???????±???§?????????
	 * @param firstType ??????????????????????????¢???????±???§
	 * @return ?????????????????????????????¢???????±???§
	 */
	private static int getNextType(int firstType) {
		if (firstType > 4) {
			return 1;
		}
		return firstType + 1;
	}

	/**
	 * ??????????????????????????¢?????????????????????????????????????????¢???????±???§?????????
	 * @param firstType ??????????????????????????¢???????±???§
	 * @return ?????????????????????????????¢???????±???§
	 */
	private static int getEndType(int firstType) {
		if (firstType > 1)
			return firstType - 1;

		return 5;
	}

	/**
	 * ??£??\??????????¨?????????????????????????????????´???????????§???<br>
	 * ????????????????????????????±???????
	 * @param adjacent ??£??\??????
	 * @return ????????????????????????
	 */
	private static int searchRoute(int[] adjacent, int firstType) {
		// ?????????????¨??????????????????????????´???????
		boolean[] visited = new boolean[maxNode];
		// ???????????????????????????
		int[] cost = new int[maxNode];
		// ??????????????°???
		int start = 0;
		// ??´????????°???
		int goal = maxNode - 1;

		for (int i = 0; i < maxNode; i++) {
			cost[i] = Integer.MAX_VALUE;
			visited[i] = false;
		}

		// ??????????????°????????§???????????????0
		cost[start] = 0;

		while (true) {
			// ?¨?????????????????????????????????§?????????????????????????±???????
			int node = minIndex(cost, visited);
			if (node < 0) {
				return cost[goal];
			}
			// ??¢?´¢???????????????????????????????????°????????????
			visited[node] = true;
			for (int j = 0; j < maxNode; j++) {
				if (adjacent[node * maxNode + j] > 0 && !visited[j] && pachimonList.get(node).x != firstType) {
					int nextNodeCost = cost[node] + adjacent[node * maxNode + j];
					// ????????§????????¢??????????°????????????°???????????¢??¨???????¨???¶
					if (nextNodeCost < cost[j]) {
						cost[j] = nextNodeCost;
					}
				}
			}
		}
	}

	/**
	 * ?¨???????????????????????????????????????????????????????????????????????????????????±???????
	 * @param cost ???????????????????????????
	 * @param visited ?????????????¨??????????????????????????´???????
	 * @return ??????????????????
	 */
	private static int minIndex(int[] cost, boolean[] visited) {
		int index = 0;
		for (; index < visited.length; index++) {
			if (!visited[index])
				break;
		}
		if (index == visited.length)
			return -1;
		for (int i = index + 1; i < visited.length; i++) {
			if (!visited[i] && cost[i] < cost[index])
				index = i;
		}
		return index;
	}

	/**
	 * ????????????????????????????????´???????????§????????????????¨?????????????
	 * @param sx ???????????????X??§?¨?
	 * @param sy ???????????????Y??§?¨?
	 * @param gx ??´?????????X??§?¨?
	 * @param gy ??´?????????Y??§?¨?
	 * @param nextType ?¬????????????????????????¢????±???§
	 */
	private static int clucCost(Point from, Point to) {
		int fx = from.y / mapSizeY;
		int fy = from.y % mapSizeY;
		int tx = to.y / mapSizeY;
		int ty = to.y % mapSizeY;
		return Math.abs(tx - fx) + Math.abs(ty - fy);
	}

	/**
	 * X??§?¨???¨Y??§?¨???????????????£?????????????????????????????????????????´?????????
	 *
	 * @param x X??§?¨?
	 * @param y Y??§?¨?
	 * @return
	 */
	private static int calcIndex(int x, int y) {
		return x * mapSizeY + y;
	}
}