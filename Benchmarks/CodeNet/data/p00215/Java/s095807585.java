import java.awt.Point;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Scanner;

public class Main {

	/** ????§??????? */
	static final String WHITE_SPACE = " ";

	/** ??????????????????_X */
	static int mapSizeX = 0;

	/** ??????????????????_Y */
	static int mapSizeY = 0;

	/** ??????????????° */
	static int maxNode = 0;

	/** ????????? */
	static String[] map = new String[1000 * 1000];

	/** ?????????????¨??????????????????????????´??????? */
	static boolean[] visited = new boolean[1000 * 1000];

	/** ??????????????????????????? */
	static int[] cost = new int[1000 * 1000];

	/** ????????¢??????????????? */
	/** ????????? */
	static List<Point> pachimonList = new ArrayList<Point>();

	//	static Point[] pachimonList = new Point[1000 * 1000];

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		while (scanner.hasNextLine()) {
			readMap(scanner);
			int[] adjacent = createAdjacent();
		}

	}

	/**
	 * ?????????????????????????????????
	 * @param scanner ????????£??????
	 */
	private static void readMap(Scanner scanner) {
		String[] mapSizeLine = scanner.nextLine().split(WHITE_SPACE);
		if (mapSizeLine.length < 2) {
			return;
		}

		// ??????????????±????????????
		pachimonList.removeAll(pachimonList);
		maxNode = 0;
		//		mapSizeX = Integer.parseInt(mapSizeLine[0]);
		//		mapSizeY = Integer.parseInt(mapSizeLine[1]);
		//		initializeMap(mapSizeX, mapSizeY);

		for (int i = 0; i < mapSizeY; i++) {
			String mapInfoLine = scanner.nextLine();
			mapInfoLine = mapInfoLine.replaceAll(".", "9");
			mapInfoLine = mapInfoLine.replaceAll("S", "0");
			mapInfoLine = mapInfoLine.replaceAll("G", "6");
			for (int j = 0; j < mapSizeX; j++) {
				int val = Integer.valueOf(mapInfoLine.charAt(j));
				if (val < 9) {
					// ???????????¢????????°????¨????
					pachimonList.add(createPos(Integer.valueOf(val), calcIndex(j, i)));
					//					pachimonList[maxNode] = createPos(Integer.valueOf(val), calcIndex(j, i));
					maxNode++;
				}
			}
		}

		Collections.sort(pachimonList, new Comparator<Point>() {
			@Override
			public int compare(Point o1, Point o2) {
				return o1.x - o2.x;
			}
		});
	}

	/**
	 * ??¨???????????????????????£??\??????????±???????
	 * @return ??£??\??????
	 */
	private static int[] createAdjacent() {
		int[] adjacent = new int[maxNode * maxNode];

		for (int i = 1; i < pachimonList.size() - 1; i++) {
			if (pachimonList.get(i).x < 5) {
				for (int j = i + 1; j < pachimonList.size() - 1; j++) {
					if (pachimonList.get(j).x - pachimonList.get(i).x > 2)
						break;

					if (pachimonList.get(j).x == pachimonList.get(i).x + 1)
						adjacent[i * maxNode + j] = clucCost(pachimonList.get(i), pachimonList.get(j));
				}
			} else {
				for (int j = 0; j < pachimonList.size() - 1; j++) {
					if (pachimonList.get(j).x == pachimonList.get(i).x - 4)
						adjacent[i * maxNode + j] = clucCost(pachimonList.get(i), pachimonList.get(j));
				}
			}
		}
		return adjacent;
	}

	//	/**
	//	 * ??????????????¨??????????´???????????????§?????????
	//	 */
	//	private static void initializeMap(int sizeX, int sizeY) {
	//		for (int i = 0; i < sizeX * sizeY; i++) {
	//			map[i] = "";
	//		}
	//	}

	/**
	 * X????????????????????´?????????????????¢???????±???§????¨????<br>
	 * ????????????:0?????´??????:6???????????¢???????±???§:1???5<br>
	 * Y????????????????????????????????????????´?
	 * @param type ?????????????????´?????????????????¢???????±???§
	 * @param index ??????????????????????????????
	 * @return
	 */
	private static Point createPos(int type, int index) {
		return new Point(type, index);
	}

	/**
	 * ????????????????????????????????´???????????§????????????????¨?????????????
	 * @param sx ???????????????X??§?¨?
	 * @param sy ???????????????Y??§?¨?
	 * @param gx ??´?????????X??§?¨?
	 * @param gy ??´?????????Y??§?¨?
	 * @param nextType ?¬????????????????????????¢????±???§
	 */
	private static int clucCost(Point from, Point to) {
		int fx = from.y / mapSizeY;
		int fy = from.y % mapSizeY;
		int tx = to.y / mapSizeY;
		int ty = to.y % mapSizeY;
		return Math.abs(tx - fx) + Math.abs(ty - fy);
	}

	/**
	 * X??§?¨???¨Y??§?¨???????????????£?????????????????????????????????????????´?????????
	 *
	 * @param x X??§?¨?
	 * @param y Y??§?¨?
	 * @return
	 */
	private static int calcIndex(int x, int y) {
		return x * mapSizeY + y;
	}
}