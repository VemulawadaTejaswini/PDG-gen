import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

/**
 * 
 * @author DemonSong
 * 
 *         558. Cheese
 * 
 *         ????????? (Cheese) ?????? ?????´??? JOI ?????????????????\??´????????????????????£????§?????????????????????£????????????????????????JOI
 *         ????????±?\??????????????????´???????????????????????????????????£??????????????\??´???????????????????????°?????????????????§???????????????????????£????????????????????¨?????????????????\??´????¨????????????????
 *         1 ??????????£??????????
 * 
 *         ??????????????????N ?????????????????\??´????????????????????\??´???????¨??????????????????????????????£?????????????????????????????¬????????\??´????????£?????°?????£??????????????¬??? 1 ??????
 *         N ?????§????????????????????£?????????????????\??´??????????????? 1 ??????????????????
 * 
 *         ?????????????????????????????? 1 ??§????????????????????? 1 ????£????????????¨???????????? 1
 *         ?¢????????????????????????????????????????????????????????????¬????????????????£????????????¨?????§????????????
 * 
 *         ?????????????????±?\????????????£?????????????????? 1
 *         ?????§?§???????????????¨?????§??????????????????????????????????????\????????¨?????§???????????????????????\??´????????????????£??????????????????????????????¨?????§??????????????????????????????????£??????????????????§????????????????????????????±???????????????°???????????????????????????????????????????????????????£???????????????????????????????????????§?????????
 * 
 *         ??\??? ??\?????? H+1 ????????????1 ???????????? 3 ????????´??° H???W???N (1 ??? H ??? 1000???1 ??? W ??? 1000???1 ??? N ???
 *         9) ???????????????????????§????????????????????????????????????2 ???????????? H+1 ???????????§??????????????????'S'???'1', '2', ...,
 *         '9'???'X'???'.' ???????????? W ?????????????????????????????????????????????????????????????????¶????????¨???????????????????????? i ??????????\??????? j
 *         ?????????????????? (i,j) ??¨?¨???°???????????¨???????????¨ (1 ??? i ??? H, 1 ??? j ??? W)????¬¬ i+1 ????????? j ???????????????????????????
 *         (i,j) ?????£??§????????´?????? 'S' ??¨????????????????????§????????´?????? 'X' ??¨?????????????????°??§????????´?????? '.' ??¨???????????¬??? 1, 2,
 *         ..., 9 ????????????????????£????????\??´??§????????´?????????????????? '1', '2', ..., '9' ??¨???????????\???????????£??¨??¬??? 1, 2,
 *         ..., N ????????????????????£????????\??´??????????????? 1
 *         ???????????????????????????????????????????????????????????°??§???????????¨???????¨?????????????????????????????????¨???????????????????£??????????????????¨???????¨???????????????????
 * 
 *         ?????? ?????????????????????????£??????????????????§??????????????????????????????????????¨?????´??°??? 1 ?????§???????????????
 * 
 *         ??\????????? ??\?????? 1 3 3 1 S.. ... ..1 ????????? 1 4 ??\?????? 2 4 5 2 .X..1 ....X .XX.S
 *         .2.X. ????????? 2 12 ??\?????? 3 10 10 9 .X...X.S.X 6..5X..X1X ...XXXX..X
 *         X..9X...X. 8.X2X..X3X ...XX.X4.. XX....7X.. X..X..XX.. X...X.XX..
 *         ..X....... ????????? 3 91
 *
 */
public class Main{
	
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int H = in.nextInt();
		int W = in.nextInt();
		int N = in.nextInt();
		
		char[][] map = new char[H][W];
		for (int i = 0; i < H; i++) {
			char[] ss = in.next().trim().toCharArray();
			for (int j = 0; j < W; j++) {
				map[i][j] = ss[j];
			}
		}
		System.out.println(solve(map,N));
		in.close();
	}
	
	//????¬????????°????????????????????????????????????????????????????????¢?????????????????????¨BFS????´¢????????\??????????¢???????
	public static int solve(char[][] map, int N){
		int row = map.length;
		int col = map[0].length;
		int[][] factory = new int[N+1][2];
		for (int i = 0; i < row; i++){
			for (int j = 0; j <col; j++){
				if (map[i][j] == 'S'){
					factory[0][0] = i;
					factory[0][1] = j;
				}
				else if (map[i][j] != '.' && map[i][j] != 'X'){
					factory[map[i][j]-'0'][0] = i;
					factory[map[i][j]-'0'][1] = j;
				}
			}
		}
		int step = 0;
		for (int i = 0; i < N; i++){
			step += bfs(map, factory[i][0], factory[i][1], factory[i+1][0], factory[i+1][1]);
		}
		return step;
	}
	
	static int[][] dir = {{-1,0},{1,0},{0,-1},{0,1}};
	private static int bfs(char[][] map, int sx, int sy, int ex, int ey){
		int row = map.length, col = map[0].length;
		int[][] distance = new int[row][col];
		for (int i = 0; i < row; i++){
			Arrays.fill(distance[i], -1);
		}
		Queue<int[]> queue = new LinkedList<>();
		queue.offer(new int[]{sx, sy});
		distance[sx][sy] = 0;
		int step = 1;
		while (!queue.isEmpty()){
			int size = queue.size();
			for (int i = 0; i < size; i++){
				int[] cur = queue.poll();
				for (int[] d : dir){
					int nx = cur[0] + d[0];
					int ny = cur[1] + d[1];
					if (nx >= 0 && nx < row && ny >= 0 && ny < col && map[nx][ny] != 'X' && distance[nx][ny] == -1){
						distance[nx][ny] = step;
						queue.offer(new int[]{nx,ny});
					}
				}
			}
			step++;
		}
		return distance[ex][ey];
	}
	
	
//	static int[][] dir = {{-1,0},{1,0},{0,-1},{0,1}};
//	private static int bfs(char[][] map, int N, int x, int y){
//		int row = map.length, col = map[0].length;
//		int step = 0;
//		int p = 1;
//		int cp = Math.min(p , N);
//		Queue<int[]> queue = new LinkedList<>();
//		queue.offer(new int[]{x,y});
//		while (!queue.isEmpty()){
//			int size = queue.size();
//			boolean noCheese = true;
//			for (int i = 0; i < size; i++){
//				int[] pos = queue.poll();
//				for (int[] d : dir){
//					int nx = pos[0] + d[0];
//					int ny = pos[1] + d[1];
//					if (nx >= 0 && nx < row && ny >= 0 && ny < col && map[nx][ny] != 'X' && map[nx][ny] <= '0'+cp){
//						if (map[nx][ny] != '.'){
//							noCheese = false;
//							map[nx][ny] = 'X';
//							p++;
//							while(!queue.isEmpty()){
//								queue.poll();
//							}
//							queue.offer(new int[]{nx,ny});
//						}else{
//							queue.offer(new int[]{nx,ny});
//						}
//					}
//				}
//				if (!noCheese) break;
//			}
//			step++;
//		}
//		return step;
//	}
	
//	private boolean noCheese(char[][] map){
//		return false;
//	}
}