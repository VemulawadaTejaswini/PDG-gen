Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_3 $$ float gamma = 0 [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_4 $$ boolean annealObjective = true [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_5 $$ double[] convergedScores = new double[n] [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_6 $$ double[] totalLogScores = new double[n] [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_7 $$ boolean[] isConverged = new boolean[n] [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_8 $$ GradientPoint[] initPoints = new GradientPoint[n] [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_9 $$ GradientPoint[] prevInitPoints = new GradientPoint[n] [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_10 $$ GradientPoint[] bestInitPoints = new GradientPoint[n] [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_11 $$ GradientPoint[] prevMinPoints = new GradientPoint[n] [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_12 $$ Random rand = new Random(randomSeed) [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_13 $$ Time time = new Time() [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_14 $$ if (stateFile != null && stateFile.length() > 0) [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_14 $$ if (stateFile != null && stateFile.length() > 0) [FD]
Line_14 $$ if (stateFile != null && stateFile.length() > 0) --> Line_15 $$ time.reset() [CD]
Line_13 $$ Time time = new Time() --> Line_15 $$ time.reset() [FD]
Line_3 $$ float gamma = 0 --> Line_18 $$ gamma = stream.readFloat() [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_18 $$ gamma = stream.readFloat() [FD]
Line_4 $$ boolean annealObjective = true --> Line_19 $$ annealObjective = stream.readBoolean() [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_19 $$ annealObjective = stream.readBoolean() [FD]
Line_5 $$ double[] convergedScores = new double[n] --> Line_20 $$ convergedScores = (double[]) stream.readObject() [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_20 $$ convergedScores = (double[]) stream.readObject() [FD]
Line_6 $$ double[] totalLogScores = new double[n] --> Line_21 $$ totalLogScores = (double[]) stream.readObject() [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_21 $$ totalLogScores = (double[]) stream.readObject() [FD]
Line_7 $$ boolean[] isConverged = new boolean[n] --> Line_22 $$ isConverged = (boolean[]) stream.readObject() [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_22 $$ isConverged = (boolean[]) stream.readObject() [FD]
Line_8 $$ GradientPoint[] initPoints = new GradientPoint[n] --> Line_23 $$ initPoints = (GradientPoint[]) stream.readObject() [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_23 $$ initPoints = (GradientPoint[]) stream.readObject() [FD]
Line_9 $$ GradientPoint[] prevInitPoints = new GradientPoint[n] --> Line_24 $$ prevInitPoints = (GradientPoint[]) stream.readObject() [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_24 $$ prevInitPoints = (GradientPoint[]) stream.readObject() [FD]
Line_10 $$ GradientPoint[] bestInitPoints = new GradientPoint[n] --> Line_25 $$ bestInitPoints = (GradientPoint[]) stream.readObject() [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_25 $$ bestInitPoints = (GradientPoint[]) stream.readObject() [FD]
Line_11 $$ GradientPoint[] prevMinPoints = new GradientPoint[n] --> Line_26 $$ prevMinPoints = (GradientPoint[]) stream.readObject() [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_26 $$ prevMinPoints = (GradientPoint[]) stream.readObject() [FD]
Line_12 $$ Random rand = new Random(randomSeed) --> Line_27 $$ rand = (Random) stream.readObject() [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_27 $$ rand = (Random) stream.readObject() [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_28 $$ int size = stream.readInt() [FD]
Line_28 $$ int size = stream.readInt() --> Line_29 $$ for (int id = 0; id < size; id++) [FD]
Line_29 $$ for (int id = 0; id < size; id++) --> Line_30 $$ Feature feature = FEATURES.getRaw(CONFIG, stream.readUTF(), 0f) [CD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_30 $$ Feature feature = FEATURES.getRaw(CONFIG, stream.readUTF(), 0f) [FD]
Line_29 $$ for (int id = 0; id < size; id++) --> Line_31 $$ if (feature.getId() != id) [CD]
Line_29 $$ for (int id = 0; id < size; id++) --> Line_31 $$ if (feature.getId() != id) [FD]
Line_30 $$ Feature feature = FEATURES.getRaw(CONFIG, stream.readUTF(), 0f) --> Line_31 $$ if (feature.getId() != id) [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_33 $$ evaluation.read(stream) [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_34 $$ stream.close() [FD]
Line_14 $$ if (stateFile != null && stateFile.length() > 0) --> Line_42 $$ final int evaluations = ProjectedEvaluation.CFG_OPT_HISTORY_SIZE.getValue() [CD]
Line_14 $$ if (stateFile != null && stateFile.length() > 0) --> Line_43 $$ final GradientPoint[] randPoints = new GradientPoint[n * evaluations] [CD]
Line_14 $$ if (stateFile != null && stateFile.length() > 0) --> Line_44 $$ for (int i = 0; i < n; i++) [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_44 $$ for (int i = 0; i < n; i++) [FD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_45 $$ evaluation.setParallelId(i) [CD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_45 $$ evaluation.setParallelId(i) [FD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_46 $$ for (int j = 0; j < evaluations; j++) [CD]
Line_42 $$ final int evaluations = ProjectedEvaluation.CFG_OPT_HISTORY_SIZE.getValue() --> Line_46 $$ for (int j = 0; j < evaluations; j++) [FD]
Line_46 $$ for (int j = 0; j < evaluations; j++) --> Line_47 $$ randPoints[i * n + j] = getRandomPoint(rand, randPoints[0], distanceLimit, null) [CD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_47 $$ randPoints[i * n + j] = getRandomPoint(rand, randPoints[0], distanceLimit, null) [FD]
Line_12 $$ Random rand = new Random(randomSeed) --> Line_47 $$ randPoints[i * n + j] = getRandomPoint(rand, randPoints[0], distanceLimit, null) [FD]
Line_27 $$ rand = (Random) stream.readObject() --> Line_47 $$ randPoints[i * n + j] = getRandomPoint(rand, randPoints[0], distanceLimit, null) [FD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_47 $$ randPoints[i * n + j] = getRandomPoint(rand, randPoints[0], distanceLimit, null) [FD]
Line_46 $$ for (int j = 0; j < evaluations; j++) --> Line_48 $$ evaluate(references, i + ":" + j) [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_48 $$ evaluate(references, i + ":" + j) [FD]
Line_46 $$ for (int j = 0; j < evaluations; j++) --> Line_49 $$ if (i == 0) [CD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_49 $$ if (i == 0) [FD]
Line_49 $$ if (i == 0) --> Line_50 $$ randPoints[0] = new GradientPoint(evaluation, null) [CD]
Line_49 $$ if (i == 0) --> Line_51 $$ gamma = LogFeatureModel.FEAT_MODEL_GAMMA.getValue() [CD]
Line_3 $$ float gamma = 0 --> Line_51 $$ gamma = LogFeatureModel.FEAT_MODEL_GAMMA.getValue() [FD]
Line_18 $$ gamma = stream.readFloat() --> Line_51 $$ gamma = LogFeatureModel.FEAT_MODEL_GAMMA.getValue() [FD]
Line_14 $$ if (stateFile != null && stateFile.length() > 0) --> Line_56 $$ for (int i = 0; i < randPoints.length; i++) if (randPoints[i] != null) [CD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_56 $$ for (int i = 0; i < randPoints.length; i++) if (randPoints[i] != null) [FD]
Line_14 $$ if (stateFile != null && stateFile.length() > 0) --> Line_57 $$ for (int i = 0; i < n; i++) [CD]
Line_56 $$ for (int i = 0; i < randPoints.length; i++) if (randPoints[i] != null) --> Line_57 $$ for (int i = 0; i < n; i++) [FD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_57 $$ for (int i = 0; i < n; i++) [FD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_57 $$ for (int i = 0; i < n; i++) [FD]
Line_57 $$ for (int i = 0; i < n; i++) --> Line_58 $$ prevInitPoints[i] = null [CD]
Line_57 $$ for (int i = 0; i < n; i++) --> Line_59 $$ initPoints[i] = randPoints[i * n] [CD]
Line_57 $$ for (int i = 0; i < n; i++) --> Line_60 $$ for (int j = 1; j < evaluations; j++) if (randPoints[i * n + j].getScore() < initPoints[i].getScore()) [CD]
Line_57 $$ for (int i = 0; i < n; i++) --> Line_60 $$ for (int j = 1; j < evaluations; j++) if (randPoints[i * n + j].getScore() < initPoints[i].getScore()) [FD]
Line_56 $$ for (int i = 0; i < randPoints.length; i++) if (randPoints[i] != null) --> Line_60 $$ for (int j = 1; j < evaluations; j++) if (randPoints[i * n + j].getScore() < initPoints[i].getScore()) [FD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_60 $$ for (int j = 1; j < evaluations; j++) if (randPoints[i * n + j].getScore() < initPoints[i].getScore()) [FD]
Line_46 $$ for (int j = 0; j < evaluations; j++) --> Line_60 $$ for (int j = 1; j < evaluations; j++) if (randPoints[i * n + j].getScore() < initPoints[i].getScore()) [FD]
Line_42 $$ final int evaluations = ProjectedEvaluation.CFG_OPT_HISTORY_SIZE.getValue() --> Line_60 $$ for (int j = 1; j < evaluations; j++) if (randPoints[i * n + j].getScore() < initPoints[i].getScore()) [FD]
Line_57 $$ for (int i = 0; i < n; i++) --> Line_61 $$ bestInitPoints[i] = initPoints[i] [CD]
Line_57 $$ for (int i = 0; i < n; i++) --> Line_62 $$ convergedScores[i] = Float.MAX_VALUE [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_65 $$ for (int searchCount = 1; ; searchCount++) [CD]
Line_65 $$ for (int searchCount = 1; ; searchCount++) --> Line_66 $$ boolean isFinished = true [CD]
Line_65 $$ for (int searchCount = 1; ; searchCount++) --> Line_67 $$ for (int i = 0; i < n; i++) isFinished = isFinished && isConverged[i] [CD]
Line_57 $$ for (int i = 0; i < n; i++) --> Line_67 $$ for (int i = 0; i < n; i++) isFinished = isFinished && isConverged[i] [FD]
Line_56 $$ for (int i = 0; i < randPoints.length; i++) if (randPoints[i] != null) --> Line_67 $$ for (int i = 0; i < n; i++) isFinished = isFinished && isConverged[i] [FD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_67 $$ for (int i = 0; i < n; i++) isFinished = isFinished && isConverged[i] [FD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_67 $$ for (int i = 0; i < n; i++) isFinished = isFinished && isConverged[i] [FD]
Line_66 $$ boolean isFinished = true --> Line_67 $$ for (int i = 0; i < n; i++) isFinished = isFinished && isConverged[i] [FD]
Line_65 $$ for (int searchCount = 1; ; searchCount++) --> Line_68 $$ if (isFinished) [CD]
Line_68 $$ if (isFinished) --> Line_69 $$ output.println("*** N-best list converged. Modifying annealing schedule. ***") [CD]
Line_68 $$ if (isFinished) --> Line_70 $$ output.println() [CD]
Line_68 $$ if (isFinished) --> Line_71 $$ if (annealObjective) [CD]
Line_71 $$ if (annealObjective) --> Line_73 $$ for (int i = 0; objectiveConverged && i < n; i++) objectiveConverged = isConverged(bestInitPoints[i].getScore(), convergedScores[i], objectiveTolerance, SCORE_EPSILON) [CD]
Line_67 $$ for (int i = 0; i < n; i++) isFinished = isFinished && isConverged[i] --> Line_73 $$ for (int i = 0; objectiveConverged && i < n; i++) objectiveConverged = isConverged(bestInitPoints[i].getScore(), convergedScores[i], objectiveTolerance, SCORE_EPSILON) [FD]
Line_57 $$ for (int i = 0; i < n; i++) --> Line_73 $$ for (int i = 0; objectiveConverged && i < n; i++) objectiveConverged = isConverged(bestInitPoints[i].getScore(), convergedScores[i], objectiveTolerance, SCORE_EPSILON) [FD]
Line_56 $$ for (int i = 0; i < randPoints.length; i++) if (randPoints[i] != null) --> Line_73 $$ for (int i = 0; objectiveConverged && i < n; i++) objectiveConverged = isConverged(bestInitPoints[i].getScore(), convergedScores[i], objectiveTolerance, SCORE_EPSILON) [FD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_73 $$ for (int i = 0; objectiveConverged && i < n; i++) objectiveConverged = isConverged(bestInitPoints[i].getScore(), convergedScores[i], objectiveTolerance, SCORE_EPSILON) [FD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_73 $$ for (int i = 0; objectiveConverged && i < n; i++) objectiveConverged = isConverged(bestInitPoints[i].getScore(), convergedScores[i], objectiveTolerance, SCORE_EPSILON) [FD]
Line_71 $$ if (annealObjective) --> Line_74 $$ annealObjective = false [CD]
Line_4 $$ boolean annealObjective = true --> Line_74 $$ annealObjective = false [FD]
Line_19 $$ annealObjective = stream.readBoolean() --> Line_74 $$ annealObjective = false [FD]
Line_75 $$ if (metric.doAnnealing()) --> Line_76 $$ float weight = metric.getWeight() [CD]
Line_75 $$ if (metric.doAnnealing()) --> Line_77 $$ if (objectiveConverged) [CD]
Line_77 $$ if (objectiveConverged) --> Line_78 $$ annealObjective = true [CD]
Line_74 $$ annealObjective = false --> Line_78 $$ annealObjective = true [FD]
Line_4 $$ boolean annealObjective = true --> Line_78 $$ annealObjective = true [FD]
Line_19 $$ annealObjective = stream.readBoolean() --> Line_78 $$ annealObjective = true [FD]
Line_77 $$ if (objectiveConverged) --> Line_79 $$ metric.setWeight(weight / objectiveAccel) [CD]
Line_68 $$ if (isFinished) --> Line_83 $$ if (!annealObjective) [CD]
Line_74 $$ annealObjective = false --> Line_83 $$ if (!annealObjective) [FD]
Line_78 $$ annealObjective = true --> Line_83 $$ if (!annealObjective) [FD]
Line_4 $$ boolean annealObjective = true --> Line_83 $$ if (!annealObjective) [FD]
Line_19 $$ annealObjective = stream.readBoolean() --> Line_83 $$ if (!annealObjective) [FD]
Line_83 $$ if (!annealObjective) --> Line_84 $$ if (Math.abs(gamma) >= maxGamma) [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_84 $$ if (Math.abs(gamma) >= maxGamma) [FD]
Line_51 $$ gamma = LogFeatureModel.FEAT_MODEL_GAMMA.getValue() --> Line_84 $$ if (Math.abs(gamma) >= maxGamma) [FD]
Line_3 $$ float gamma = 0 --> Line_84 $$ if (Math.abs(gamma) >= maxGamma) [FD]
Line_18 $$ gamma = stream.readFloat() --> Line_84 $$ if (Math.abs(gamma) >= maxGamma) [FD]
Line_84 $$ if (Math.abs(gamma) >= maxGamma) --> Line_86 $$ for (int i = 1; i < n; i++) if (bestInitPoints[i].getScore() < bestPoint.getScore()) [CD]
Line_73 $$ for (int i = 0; objectiveConverged && i < n; i++) objectiveConverged = isConverged(bestInitPoints[i].getScore(), convergedScores[i], objectiveTolerance, SCORE_EPSILON) --> Line_86 $$ for (int i = 1; i < n; i++) if (bestInitPoints[i].getScore() < bestPoint.getScore()) [FD]
Line_67 $$ for (int i = 0; i < n; i++) isFinished = isFinished && isConverged[i] --> Line_86 $$ for (int i = 1; i < n; i++) if (bestInitPoints[i].getScore() < bestPoint.getScore()) [FD]
Line_57 $$ for (int i = 0; i < n; i++) --> Line_86 $$ for (int i = 1; i < n; i++) if (bestInitPoints[i].getScore() < bestPoint.getScore()) [FD]
Line_56 $$ for (int i = 0; i < randPoints.length; i++) if (randPoints[i] != null) --> Line_86 $$ for (int i = 1; i < n; i++) if (bestInitPoints[i].getScore() < bestPoint.getScore()) [FD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_86 $$ for (int i = 1; i < n; i++) if (bestInitPoints[i].getScore() < bestPoint.getScore()) [FD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_86 $$ for (int i = 1; i < n; i++) if (bestInitPoints[i].getScore() < bestPoint.getScore()) [FD]
Line_84 $$ if (Math.abs(gamma) >= maxGamma) --> Line_87 $$ output.format("Best Score: %+.7g%n", bestPoint.getScore()) [CD]
Line_84 $$ if (Math.abs(gamma) >= maxGamma) --> Line_88 $$ output.println() [CD]
Line_83 $$ if (!annealObjective) --> Line_92 $$ gamma *= gammaAccel [CD]
Line_51 $$ gamma = LogFeatureModel.FEAT_MODEL_GAMMA.getValue() --> Line_92 $$ gamma *= gammaAccel [FD]
Line_3 $$ float gamma = 0 --> Line_92 $$ gamma *= gammaAccel [FD]
Line_18 $$ gamma = stream.readFloat() --> Line_92 $$ gamma *= gammaAccel [FD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_92 $$ gamma *= gammaAccel [FD]
Line_83 $$ if (!annealObjective) --> Line_93 $$ if (Math.abs(gamma) + GAMMA_EPSILON >= maxGamma) [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_93 $$ if (Math.abs(gamma) + GAMMA_EPSILON >= maxGamma) [FD]
Line_92 $$ gamma *= gammaAccel --> Line_93 $$ if (Math.abs(gamma) + GAMMA_EPSILON >= maxGamma) [FD]
Line_51 $$ gamma = LogFeatureModel.FEAT_MODEL_GAMMA.getValue() --> Line_93 $$ if (Math.abs(gamma) + GAMMA_EPSILON >= maxGamma) [FD]
Line_3 $$ float gamma = 0 --> Line_93 $$ if (Math.abs(gamma) + GAMMA_EPSILON >= maxGamma) [FD]
Line_18 $$ gamma = stream.readFloat() --> Line_93 $$ if (Math.abs(gamma) + GAMMA_EPSILON >= maxGamma) [FD]
Line_68 $$ if (isFinished) --> Line_95 $$ for (int i = 0; i < n; i++) [CD]
Line_86 $$ for (int i = 1; i < n; i++) if (bestInitPoints[i].getScore() < bestPoint.getScore()) --> Line_95 $$ for (int i = 0; i < n; i++) [FD]
Line_73 $$ for (int i = 0; objectiveConverged && i < n; i++) objectiveConverged = isConverged(bestInitPoints[i].getScore(), convergedScores[i], objectiveTolerance, SCORE_EPSILON) --> Line_95 $$ for (int i = 0; i < n; i++) [FD]
Line_67 $$ for (int i = 0; i < n; i++) isFinished = isFinished && isConverged[i] --> Line_95 $$ for (int i = 0; i < n; i++) [FD]
Line_57 $$ for (int i = 0; i < n; i++) --> Line_95 $$ for (int i = 0; i < n; i++) [FD]
Line_56 $$ for (int i = 0; i < randPoints.length; i++) if (randPoints[i] != null) --> Line_95 $$ for (int i = 0; i < n; i++) [FD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_95 $$ for (int i = 0; i < n; i++) [FD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_95 $$ for (int i = 0; i < n; i++) [FD]
Line_95 $$ for (int i = 0; i < n; i++) --> Line_96 $$ convergedScores[i] = bestInitPoints[i].getScore() [CD]
Line_95 $$ for (int i = 0; i < n; i++) --> Line_97 $$ initPoints[i] = new GradientPoint(evaluation, bestInitPoints[i], gamma, output) [CD]
Line_95 $$ for (int i = 0; i < n; i++) --> Line_98 $$ bestInitPoints[i] = initPoints[i] [CD]
Line_95 $$ for (int i = 0; i < n; i++) --> Line_99 $$ prevInitPoints[i] = null [CD]
Line_95 $$ for (int i = 0; i < n; i++) --> Line_100 $$ prevMinPoints[i] = null [CD]
Line_95 $$ for (int i = 0; i < n; i++) --> Line_101 $$ isConverged[i] = false [CD]
Line_68 $$ if (isFinished) --> Line_103 $$ searchCount = 0 [CD]
Line_65 $$ for (int searchCount = 1; ; searchCount++) --> Line_103 $$ searchCount = 0 [FD]
Line_65 $$ for (int searchCount = 1; ; searchCount++) --> Line_105 $$ for (int i = 0; i < n; i++) [CD]
Line_95 $$ for (int i = 0; i < n; i++) --> Line_105 $$ for (int i = 0; i < n; i++) [FD]
Line_86 $$ for (int i = 1; i < n; i++) if (bestInitPoints[i].getScore() < bestPoint.getScore()) --> Line_105 $$ for (int i = 0; i < n; i++) [FD]
Line_73 $$ for (int i = 0; objectiveConverged && i < n; i++) objectiveConverged = isConverged(bestInitPoints[i].getScore(), convergedScores[i], objectiveTolerance, SCORE_EPSILON) --> Line_105 $$ for (int i = 0; i < n; i++) [FD]
Line_67 $$ for (int i = 0; i < n; i++) isFinished = isFinished && isConverged[i] --> Line_105 $$ for (int i = 0; i < n; i++) [FD]
Line_57 $$ for (int i = 0; i < n; i++) --> Line_105 $$ for (int i = 0; i < n; i++) [FD]
Line_56 $$ for (int i = 0; i < randPoints.length; i++) if (randPoints[i] != null) --> Line_105 $$ for (int i = 0; i < n; i++) [FD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_105 $$ for (int i = 0; i < n; i++) [FD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_105 $$ for (int i = 0; i < n; i++) [FD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_106 $$ if (isConverged[i]) [CD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_106 $$ if (isConverged[i]) [FD]
Line_7 $$ boolean[] isConverged = new boolean[n] --> Line_106 $$ if (isConverged[i]) [FD]
Line_22 $$ isConverged = (boolean[]) stream.readObject() --> Line_106 $$ if (isConverged[i]) [FD]
Line_95 $$ for (int i = 0; i < n; i++) --> Line_106 $$ if (isConverged[i]) [FD]
Line_86 $$ for (int i = 1; i < n; i++) if (bestInitPoints[i].getScore() < bestPoint.getScore()) --> Line_106 $$ if (isConverged[i]) [FD]
Line_73 $$ for (int i = 0; objectiveConverged && i < n; i++) objectiveConverged = isConverged(bestInitPoints[i].getScore(), convergedScores[i], objectiveTolerance, SCORE_EPSILON) --> Line_106 $$ if (isConverged[i]) [FD]
Line_67 $$ for (int i = 0; i < n; i++) isFinished = isFinished && isConverged[i] --> Line_106 $$ if (isConverged[i]) [FD]
Line_57 $$ for (int i = 0; i < n; i++) --> Line_106 $$ if (isConverged[i]) [FD]
Line_56 $$ for (int i = 0; i < randPoints.length; i++) if (randPoints[i] != null) --> Line_106 $$ if (isConverged[i]) [FD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_106 $$ if (isConverged[i]) [FD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_107 $$ output.println("Minimizing point " + i) [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_107 $$ output.println("Minimizing point " + i) [FD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_108 $$ Gradient gradient = initPoints[i].getGradient() [CD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_109 $$ for (int id = 0; id < FEATURES.size(); id++) output.format("GRAD %-65s %-+13.7g%n", FEATURES.getName(id), gradient.get(id)) [CD]
Line_29 $$ for (int id = 0; id < size; id++) --> Line_109 $$ for (int id = 0; id < FEATURES.size(); id++) output.format("GRAD %-65s %-+13.7g%n", FEATURES.getName(id), gradient.get(id)) [FD]
Line_108 $$ Gradient gradient = initPoints[i].getGradient() --> Line_109 $$ for (int id = 0; id < FEATURES.size(); id++) output.format("GRAD %-65s %-+13.7g%n", FEATURES.getName(id), gradient.get(id)) [FD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_110 $$ output.println() [CD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_111 $$ time.reset() [CD]
Line_13 $$ Time time = new Time() --> Line_111 $$ time.reset() [FD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_112 $$ GradientPoint minPoint = minimize(initPoints[i], prevInitPoints[i], bestInitPoints[i], scoreTolerance, paramTolerance, distanceLimit, randomLimit, rand) [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_112 $$ GradientPoint minPoint = minimize(initPoints[i], prevInitPoints[i], bestInitPoints[i], scoreTolerance, paramTolerance, distanceLimit, randomLimit, rand) [FD]
Line_12 $$ Random rand = new Random(randomSeed) --> Line_112 $$ GradientPoint minPoint = minimize(initPoints[i], prevInitPoints[i], bestInitPoints[i], scoreTolerance, paramTolerance, distanceLimit, randomLimit, rand) [FD]
Line_27 $$ rand = (Random) stream.readObject() --> Line_112 $$ GradientPoint minPoint = minimize(initPoints[i], prevInitPoints[i], bestInitPoints[i], scoreTolerance, paramTolerance, distanceLimit, randomLimit, rand) [FD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_113 $$ final float[] weights = minPoint.getWeights() [CD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_114 $$ for (int j = 0; j < weights.length; j++) output.format("PARM %-65s %-+13.7g%n", FEATURES.getName(j), weights[j]) [CD]
Line_60 $$ for (int j = 1; j < evaluations; j++) if (randPoints[i * n + j].getScore() < initPoints[i].getScore()) --> Line_114 $$ for (int j = 0; j < weights.length; j++) output.format("PARM %-65s %-+13.7g%n", FEATURES.getName(j), weights[j]) [FD]
Line_46 $$ for (int j = 0; j < evaluations; j++) --> Line_114 $$ for (int j = 0; j < weights.length; j++) output.format("PARM %-65s %-+13.7g%n", FEATURES.getName(j), weights[j]) [FD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_115 $$ output.println() [CD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_116 $$ output.format("Minimum Score: %+.7g (average distance of %.2f)%n", minPoint.getScore(), minPoint.getAverageDistance()) [CD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_117 $$ output.println() [CD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_118 $$ output.println("# Minimized gradient (" + time + ")") [CD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_119 $$ output.println() [CD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_120 $$ output.flush() [CD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_121 $$ isConverged[i] = weights == initPoints[i].getWeights() [CD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_122 $$ prevInitPoints[i] = initPoints[i] [CD]
Line_65 $$ for (int searchCount = 1; ; searchCount++) --> Line_126 $$ for (int i = 0; i < n; i++) [CD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_126 $$ for (int i = 0; i < n; i++) [FD]
Line_95 $$ for (int i = 0; i < n; i++) --> Line_126 $$ for (int i = 0; i < n; i++) [FD]
Line_86 $$ for (int i = 1; i < n; i++) if (bestInitPoints[i].getScore() < bestPoint.getScore()) --> Line_126 $$ for (int i = 0; i < n; i++) [FD]
Line_73 $$ for (int i = 0; objectiveConverged && i < n; i++) objectiveConverged = isConverged(bestInitPoints[i].getScore(), convergedScores[i], objectiveTolerance, SCORE_EPSILON) --> Line_126 $$ for (int i = 0; i < n; i++) [FD]
Line_67 $$ for (int i = 0; i < n; i++) isFinished = isFinished && isConverged[i] --> Line_126 $$ for (int i = 0; i < n; i++) [FD]
Line_57 $$ for (int i = 0; i < n; i++) --> Line_126 $$ for (int i = 0; i < n; i++) [FD]
Line_56 $$ for (int i = 0; i < randPoints.length; i++) if (randPoints[i] != null) --> Line_126 $$ for (int i = 0; i < n; i++) [FD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_126 $$ for (int i = 0; i < n; i++) [FD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_126 $$ for (int i = 0; i < n; i++) [FD]
Line_126 $$ for (int i = 0; i < n; i++) --> Line_127 $$ if (isConverged[i]) [CD]
Line_126 $$ for (int i = 0; i < n; i++) --> Line_127 $$ if (isConverged[i]) [FD]
Line_7 $$ boolean[] isConverged = new boolean[n] --> Line_127 $$ if (isConverged[i]) [FD]
Line_22 $$ isConverged = (boolean[]) stream.readObject() --> Line_127 $$ if (isConverged[i]) [FD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_127 $$ if (isConverged[i]) [FD]
Line_95 $$ for (int i = 0; i < n; i++) --> Line_127 $$ if (isConverged[i]) [FD]
Line_86 $$ for (int i = 1; i < n; i++) if (bestInitPoints[i].getScore() < bestPoint.getScore()) --> Line_127 $$ if (isConverged[i]) [FD]
Line_73 $$ for (int i = 0; objectiveConverged && i < n; i++) objectiveConverged = isConverged(bestInitPoints[i].getScore(), convergedScores[i], objectiveTolerance, SCORE_EPSILON) --> Line_127 $$ if (isConverged[i]) [FD]
Line_67 $$ for (int i = 0; i < n; i++) isFinished = isFinished && isConverged[i] --> Line_127 $$ if (isConverged[i]) [FD]
Line_57 $$ for (int i = 0; i < n; i++) --> Line_127 $$ if (isConverged[i]) [FD]
Line_56 $$ for (int i = 0; i < randPoints.length; i++) if (randPoints[i] != null) --> Line_127 $$ if (isConverged[i]) [FD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_127 $$ if (isConverged[i]) [FD]
Line_126 $$ for (int i = 0; i < n; i++) --> Line_128 $$ isConverged[i] = isConvergedScore("minimum", prevMinPoints[i], prevInitPoints[i], scoreTolerance) && isConvergedWeights(prevMinPoints[i], prevInitPoints[i], paramTolerance) [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_128 $$ isConverged[i] = isConvergedScore("minimum", prevMinPoints[i], prevInitPoints[i], scoreTolerance) && isConvergedWeights(prevMinPoints[i], prevInitPoints[i], paramTolerance) [FD]
Line_126 $$ for (int i = 0; i < n; i++) --> Line_129 $$ prevMinPoints[i].setWeightsAndRescore(evaluation) [CD]
Line_126 $$ for (int i = 0; i < n; i++) --> Line_130 $$ evaluation.setParallelId(i) [CD]
Line_126 $$ for (int i = 0; i < n; i++) --> Line_130 $$ evaluation.setParallelId(i) [FD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_130 $$ evaluation.setParallelId(i) [FD]
Line_95 $$ for (int i = 0; i < n; i++) --> Line_130 $$ evaluation.setParallelId(i) [FD]
Line_86 $$ for (int i = 1; i < n; i++) if (bestInitPoints[i].getScore() < bestPoint.getScore()) --> Line_130 $$ evaluation.setParallelId(i) [FD]
Line_73 $$ for (int i = 0; objectiveConverged && i < n; i++) objectiveConverged = isConverged(bestInitPoints[i].getScore(), convergedScores[i], objectiveTolerance, SCORE_EPSILON) --> Line_130 $$ evaluation.setParallelId(i) [FD]
Line_67 $$ for (int i = 0; i < n; i++) isFinished = isFinished && isConverged[i] --> Line_130 $$ evaluation.setParallelId(i) [FD]
Line_57 $$ for (int i = 0; i < n; i++) --> Line_130 $$ evaluation.setParallelId(i) [FD]
Line_56 $$ for (int i = 0; i < randPoints.length; i++) if (randPoints[i] != null) --> Line_130 $$ evaluation.setParallelId(i) [FD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_130 $$ evaluation.setParallelId(i) [FD]
Line_126 $$ for (int i = 0; i < n; i++) --> Line_131 $$ evaluate(references, Integer.toString(i)) [CD]
Line_126 $$ for (int i = 0; i < n; i++) --> Line_131 $$ evaluate(references, Integer.toString(i)) [FD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_131 $$ evaluate(references, Integer.toString(i)) [FD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_131 $$ evaluate(references, Integer.toString(i)) [FD]
Line_95 $$ for (int i = 0; i < n; i++) --> Line_131 $$ evaluate(references, Integer.toString(i)) [FD]
Line_86 $$ for (int i = 1; i < n; i++) if (bestInitPoints[i].getScore() < bestPoint.getScore()) --> Line_131 $$ evaluate(references, Integer.toString(i)) [FD]
Line_73 $$ for (int i = 0; objectiveConverged && i < n; i++) objectiveConverged = isConverged(bestInitPoints[i].getScore(), convergedScores[i], objectiveTolerance, SCORE_EPSILON) --> Line_131 $$ evaluate(references, Integer.toString(i)) [FD]
Line_67 $$ for (int i = 0; i < n; i++) isFinished = isFinished && isConverged[i] --> Line_131 $$ evaluate(references, Integer.toString(i)) [FD]
Line_57 $$ for (int i = 0; i < n; i++) --> Line_131 $$ evaluate(references, Integer.toString(i)) [FD]
Line_56 $$ for (int i = 0; i < randPoints.length; i++) if (randPoints[i] != null) --> Line_131 $$ evaluate(references, Integer.toString(i)) [FD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_131 $$ evaluate(references, Integer.toString(i)) [FD]
Line_65 $$ for (int searchCount = 1; ; searchCount++) --> Line_134 $$ prunePoints.addAll(Arrays.asList(bestInitPoints)) [CD]
Line_10 $$ GradientPoint[] bestInitPoints = new GradientPoint[n] --> Line_134 $$ prunePoints.addAll(Arrays.asList(bestInitPoints)) [FD]
Line_25 $$ bestInitPoints = (GradientPoint[]) stream.readObject() --> Line_134 $$ prunePoints.addAll(Arrays.asList(bestInitPoints)) [FD]
Line_65 $$ for (int searchCount = 1; ; searchCount++) --> Line_135 $$ prunePoints.addAll(Arrays.asList(prevInitPoints)) [CD]
Line_9 $$ GradientPoint[] prevInitPoints = new GradientPoint[n] --> Line_135 $$ prunePoints.addAll(Arrays.asList(prevInitPoints)) [FD]
Line_24 $$ prevInitPoints = (GradientPoint[]) stream.readObject() --> Line_135 $$ prunePoints.addAll(Arrays.asList(prevInitPoints)) [FD]
Line_65 $$ for (int searchCount = 1; ; searchCount++) --> Line_136 $$ prunePoints.addAll(Arrays.asList(initPoints)) [CD]
Line_8 $$ GradientPoint[] initPoints = new GradientPoint[n] --> Line_136 $$ prunePoints.addAll(Arrays.asList(initPoints)) [FD]
Line_23 $$ initPoints = (GradientPoint[]) stream.readObject() --> Line_136 $$ prunePoints.addAll(Arrays.asList(initPoints)) [FD]
Line_65 $$ for (int searchCount = 1; ; searchCount++) --> Line_137 $$ evaluation.prune(prunePoints, maxNbest, output) [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_137 $$ evaluation.prune(prunePoints, maxNbest, output) [FD]
Line_65 $$ for (int searchCount = 1; ; searchCount++) --> Line_138 $$ for (int i = 0; i < n; i++) [CD]
Line_126 $$ for (int i = 0; i < n; i++) --> Line_138 $$ for (int i = 0; i < n; i++) [FD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_138 $$ for (int i = 0; i < n; i++) [FD]
Line_95 $$ for (int i = 0; i < n; i++) --> Line_138 $$ for (int i = 0; i < n; i++) [FD]
Line_86 $$ for (int i = 1; i < n; i++) if (bestInitPoints[i].getScore() < bestPoint.getScore()) --> Line_138 $$ for (int i = 0; i < n; i++) [FD]
Line_73 $$ for (int i = 0; objectiveConverged && i < n; i++) objectiveConverged = isConverged(bestInitPoints[i].getScore(), convergedScores[i], objectiveTolerance, SCORE_EPSILON) --> Line_138 $$ for (int i = 0; i < n; i++) [FD]
Line_67 $$ for (int i = 0; i < n; i++) isFinished = isFinished && isConverged[i] --> Line_138 $$ for (int i = 0; i < n; i++) [FD]
Line_57 $$ for (int i = 0; i < n; i++) --> Line_138 $$ for (int i = 0; i < n; i++) [FD]
Line_56 $$ for (int i = 0; i < randPoints.length; i++) if (randPoints[i] != null) --> Line_138 $$ for (int i = 0; i < n; i++) [FD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_138 $$ for (int i = 0; i < n; i++) [FD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_138 $$ for (int i = 0; i < n; i++) [FD]
Line_138 $$ for (int i = 0; i < n; i++) --> Line_139 $$ final boolean bestIsPrev = bestInitPoints[i] == prevInitPoints[i] [CD]
Line_138 $$ for (int i = 0; i < n; i++) --> Line_140 $$ final boolean bestIsInit = bestInitPoints[i] == initPoints[i] [CD]
Line_138 $$ for (int i = 0; i < n; i++) --> Line_141 $$ bestInitPoints[i] = new GradientPoint(evaluation, bestInitPoints[i], bestIsInit ? output : null) [CD]
Line_138 $$ for (int i = 0; i < n; i++) --> Line_142 $$ prevInitPoints[i] = bestInitPoints[i] [CD]
Line_138 $$ for (int i = 0; i < n; i++) --> Line_143 $$ initPoints[i] = bestInitPoints[i] [CD]
Line_138 $$ for (int i = 0; i < n; i++) --> Line_144 $$ if (!bestIsPrev && prevInitPoints[i] != null) [CD]
Line_139 $$ final boolean bestIsPrev = bestInitPoints[i] == prevInitPoints[i] --> Line_144 $$ if (!bestIsPrev && prevInitPoints[i] != null) [FD]
Line_144 $$ if (!bestIsPrev && prevInitPoints[i] != null) --> Line_145 $$ prevInitPoints[i] = new GradientPoint(evaluation, prevInitPoints[i], null) [CD]
Line_144 $$ if (!bestIsPrev && prevInitPoints[i] != null) --> Line_146 $$ if (prevInitPoints[i].getScore() <= bestInitPoints[i].getScore()) [CD]
Line_138 $$ for (int i = 0; i < n; i++) --> Line_148 $$ if (!bestIsInit) [CD]
Line_140 $$ final boolean bestIsInit = bestInitPoints[i] == initPoints[i] --> Line_148 $$ if (!bestIsInit) [FD]
Line_148 $$ if (!bestIsInit) --> Line_149 $$ initPoints[i] = new GradientPoint(evaluation, initPoints[i], output) [CD]
Line_148 $$ if (!bestIsInit) --> Line_150 $$ if (initPoints[i].getScore() <= bestInitPoints[i].getScore()) [CD]
Line_65 $$ for (int searchCount = 1; ; searchCount++) --> Line_153 $$ for (int i = 0; i < n; i++) if (isConverged[i]) [CD]
Line_138 $$ for (int i = 0; i < n; i++) --> Line_153 $$ for (int i = 0; i < n; i++) if (isConverged[i]) [FD]
Line_126 $$ for (int i = 0; i < n; i++) --> Line_153 $$ for (int i = 0; i < n; i++) if (isConverged[i]) [FD]
Line_105 $$ for (int i = 0; i < n; i++) --> Line_153 $$ for (int i = 0; i < n; i++) if (isConverged[i]) [FD]
Line_95 $$ for (int i = 0; i < n; i++) --> Line_153 $$ for (int i = 0; i < n; i++) if (isConverged[i]) [FD]
Line_86 $$ for (int i = 1; i < n; i++) if (bestInitPoints[i].getScore() < bestPoint.getScore()) --> Line_153 $$ for (int i = 0; i < n; i++) if (isConverged[i]) [FD]
Line_73 $$ for (int i = 0; objectiveConverged && i < n; i++) objectiveConverged = isConverged(bestInitPoints[i].getScore(), convergedScores[i], objectiveTolerance, SCORE_EPSILON) --> Line_153 $$ for (int i = 0; i < n; i++) if (isConverged[i]) [FD]
Line_67 $$ for (int i = 0; i < n; i++) isFinished = isFinished && isConverged[i] --> Line_153 $$ for (int i = 0; i < n; i++) if (isConverged[i]) [FD]
Line_57 $$ for (int i = 0; i < n; i++) --> Line_153 $$ for (int i = 0; i < n; i++) if (isConverged[i]) [FD]
Line_56 $$ for (int i = 0; i < randPoints.length; i++) if (randPoints[i] != null) --> Line_153 $$ for (int i = 0; i < n; i++) if (isConverged[i]) [FD]
Line_44 $$ for (int i = 0; i < n; i++) --> Line_153 $$ for (int i = 0; i < n; i++) if (isConverged[i]) [FD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_153 $$ for (int i = 0; i < n; i++) if (isConverged[i]) [FD]
Line_7 $$ boolean[] isConverged = new boolean[n] --> Line_153 $$ for (int i = 0; i < n; i++) if (isConverged[i]) [FD]
Line_22 $$ isConverged = (boolean[]) stream.readObject() --> Line_153 $$ for (int i = 0; i < n; i++) if (isConverged[i]) [FD]
Line_153 $$ for (int i = 0; i < n; i++) if (isConverged[i]) --> Line_154 $$ output.println("# Convergence failed: no previous minimum is defined") [CD]
Line_153 $$ for (int i = 0; i < n; i++) if (isConverged[i]) --> Line_155 $$ output.println() [CD]
Line_153 $$ for (int i = 0; i < n; i++) if (isConverged[i]) --> Line_156 $$ isConverged[i] = false [CD]
Line_153 $$ for (int i = 0; i < n; i++) if (isConverged[i]) --> Line_158 $$ isConverged[i] = isConvergedScore("best known", bestInitPoints[i], initPoints[i], scoreTolerance) && isConvergedScore("previous minimum", prevMinPoints[i], initPoints[i], scoreTolerance) [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_158 $$ isConverged[i] = isConvergedScore("best known", bestInitPoints[i], initPoints[i], scoreTolerance) && isConvergedScore("previous minimum", prevMinPoints[i], initPoints[i], scoreTolerance) [FD]
Line_65 $$ for (int searchCount = 1; ; searchCount++) --> Line_160 $$ if (stateFile != null) [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_160 $$ if (stateFile != null) [FD]
Line_160 $$ if (stateFile != null) --> Line_161 $$ time.reset() [CD]
Line_13 $$ Time time = new Time() --> Line_161 $$ time.reset() [FD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_163 $$ File dir = stateFile.getCanonicalFile().getParentFile() [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_166 $$ stream.writeFloat(gamma) [FD]
Line_92 $$ gamma *= gammaAccel --> Line_166 $$ stream.writeFloat(gamma) [FD]
Line_93 $$ if (Math.abs(gamma) + GAMMA_EPSILON >= maxGamma) --> Line_166 $$ stream.writeFloat(gamma) [FD]
Line_51 $$ gamma = LogFeatureModel.FEAT_MODEL_GAMMA.getValue() --> Line_166 $$ stream.writeFloat(gamma) [FD]
Line_3 $$ float gamma = 0 --> Line_166 $$ stream.writeFloat(gamma) [FD]
Line_18 $$ gamma = stream.readFloat() --> Line_166 $$ stream.writeFloat(gamma) [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_167 $$ stream.writeBoolean(annealObjective) [FD]
Line_74 $$ annealObjective = false --> Line_167 $$ stream.writeBoolean(annealObjective) [FD]
Line_78 $$ annealObjective = true --> Line_167 $$ stream.writeBoolean(annealObjective) [FD]
Line_4 $$ boolean annealObjective = true --> Line_167 $$ stream.writeBoolean(annealObjective) [FD]
Line_19 $$ annealObjective = stream.readBoolean() --> Line_167 $$ stream.writeBoolean(annealObjective) [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_168 $$ stream.writeObject(convergedScores) [FD]
Line_5 $$ double[] convergedScores = new double[n] --> Line_168 $$ stream.writeObject(convergedScores) [FD]
Line_20 $$ convergedScores = (double[]) stream.readObject() --> Line_168 $$ stream.writeObject(convergedScores) [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_169 $$ stream.writeObject(totalLogScores) [FD]
Line_6 $$ double[] totalLogScores = new double[n] --> Line_169 $$ stream.writeObject(totalLogScores) [FD]
Line_21 $$ totalLogScores = (double[]) stream.readObject() --> Line_169 $$ stream.writeObject(totalLogScores) [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_170 $$ stream.writeObject(isConverged) [FD]
Line_7 $$ boolean[] isConverged = new boolean[n] --> Line_170 $$ stream.writeObject(isConverged) [FD]
Line_22 $$ isConverged = (boolean[]) stream.readObject() --> Line_170 $$ stream.writeObject(isConverged) [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_171 $$ stream.writeObject(initPoints) [FD]
Line_8 $$ GradientPoint[] initPoints = new GradientPoint[n] --> Line_171 $$ stream.writeObject(initPoints) [FD]
Line_23 $$ initPoints = (GradientPoint[]) stream.readObject() --> Line_171 $$ stream.writeObject(initPoints) [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_172 $$ stream.writeObject(prevInitPoints) [FD]
Line_9 $$ GradientPoint[] prevInitPoints = new GradientPoint[n] --> Line_172 $$ stream.writeObject(prevInitPoints) [FD]
Line_24 $$ prevInitPoints = (GradientPoint[]) stream.readObject() --> Line_172 $$ stream.writeObject(prevInitPoints) [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_173 $$ stream.writeObject(bestInitPoints) [FD]
Line_10 $$ GradientPoint[] bestInitPoints = new GradientPoint[n] --> Line_173 $$ stream.writeObject(bestInitPoints) [FD]
Line_25 $$ bestInitPoints = (GradientPoint[]) stream.readObject() --> Line_173 $$ stream.writeObject(bestInitPoints) [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_174 $$ stream.writeObject(prevMinPoints) [FD]
Line_11 $$ GradientPoint[] prevMinPoints = new GradientPoint[n] --> Line_174 $$ stream.writeObject(prevMinPoints) [FD]
Line_26 $$ prevMinPoints = (GradientPoint[]) stream.readObject() --> Line_174 $$ stream.writeObject(prevMinPoints) [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_175 $$ stream.writeObject(rand) [FD]
Line_12 $$ Random rand = new Random(randomSeed) --> Line_175 $$ stream.writeObject(rand) [FD]
Line_27 $$ rand = (Random) stream.readObject() --> Line_175 $$ stream.writeObject(rand) [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_176 $$ stream.writeInt(FEATURES.size()) [FD]
Line_109 $$ for (int id = 0; id < FEATURES.size(); id++) output.format("GRAD %-65s %-+13.7g%n", FEATURES.getName(id), gradient.get(id)) --> Line_177 $$ for (int id = 0; id < FEATURES.size(); id++) stream.writeUTF(FEATURES.getName(id)) [FD]
Line_29 $$ for (int id = 0; id < size; id++) --> Line_177 $$ for (int id = 0; id < FEATURES.size(); id++) stream.writeUTF(FEATURES.getName(id)) [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_177 $$ for (int id = 0; id < FEATURES.size(); id++) stream.writeUTF(FEATURES.getName(id)) [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_178 $$ evaluation.write(stream) [FD]
Line_17 $$ ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)) --> Line_179 $$ stream.close() [FD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_180 $$ if (!temp.renameTo(stateFile)) [FD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_200 $$ if (stateFile != null && !keepState) [CD]
Line_2 $$ private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) --> Line_200 $$ if (stateFile != null && !keepState) [FD]
Line_103 $$ searchCount = 0 --> Line_65 $$ for (int searchCount = 1; ; searchCount++) [FD]
Line_92 $$ gamma *= gammaAccel --> Line_84 $$ if (Math.abs(gamma) >= maxGamma) [FD]
Line_93 $$ if (Math.abs(gamma) + GAMMA_EPSILON >= maxGamma) --> Line_84 $$ if (Math.abs(gamma) >= maxGamma) [FD]
