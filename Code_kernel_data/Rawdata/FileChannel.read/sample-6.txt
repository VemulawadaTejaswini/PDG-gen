
  
CodeKernel
  
     h3{color:#800; font-family: "Courier New", Courier, monospace; font-size: 20pt}
  



 Instance 0







   
  
   
    
Class30.read(FileChannel fc,SymbolTable symbols){
        final ByteBuffer buffer = ByteBuffer.allocate((int) fc.size());
        fc.read(buffer);
        buffer.flip();
        root.read(buffer, symbols);
}
    
   
  
   







 Instance 1







   
  
   
    
Class450.writeLastUpdated(File touchfile,String key,String error)#5{
                    ByteBuffer buffer = ByteBuffer.allocate( (int) channel.size() );
                    channel.read( buffer );
                    buffer.flip();
                    ByteArrayInputStream stream = new ByteArrayInputStream( buffer.array() );
                    props.load( stream );
}
    
   
  
   







 Instance 2







   
  
   
    
Class540.main(String[] args)#0{
      File f = new File(args[0]);
      FileInputStream inStream = new FileInputStream(f);
      FileChannel fc = inStream.getChannel();
      ByteBuffer frame = ByteBuffer.allocate((int)fc.size());
      fc.read(frame);
      frame.flip();
      dec.decodeFrame(frame);
}
    
   
  
   







 Instance 3







   
  
   
    
Class530.testAppendMessages_toOffset()#4{
        assertEquals(this.messageStore.nameFromOffset(offset), logs[0].getName());
        final FileChannel channel = new RandomAccessFile(logs[0], "rw").getChannel();
            final ByteBuffer buf = ByteBuffer.allocate((int) channel.size());
            while (buf.hasRemaining()) {
                channel.read(buf);
            }
            buf.flip();
            final DecodedMessage decodedMessage1 = MessageUtils.decodeMessage(this.topic, buf.array(), 0);
                    MessageUtils.decodeMessage(this.topic, buf.array(), decodedMessage1.newOffset);
}
    
   
  
   







 Instance 4







   
  
   
    
Class160.assertMessages(final long id1,final long id2)#1{
        assertEquals(this.messageStore.nameFromOffset(0), logs[0].getName());
        final FileChannel channel = new RandomAccessFile(logs[0], "rw").getChannel();
            final ByteBuffer buf = ByteBuffer.allocate((int) channel.size());
            while (buf.hasRemaining()) {
                channel.read(buf);
            }
            buf.flip();
            final DecodedMessage decodedMessage1 = MessageUtils.decodeMessage(this.topic, buf.array(), 0);
                    MessageUtils.decodeMessage(this.topic, buf.array(), decodedMessage1.newOffset);
}
    
   
  
   







 Instance 5







   
  
   
    
Class460.dump(FileChannel fc)#0{
        int sz = (int)fc.size();
        ByteBuffer bb = ByteBuffer.allocate(sz);
        fc.position(0);
        if (fc.read(bb) != sz)
            throw new IOException("Incomplete read");
        bb.flip();
        while (bb.hasRemaining() && (n < 32)) {
            byte b = bb.get();
            if (b == prev) {
                r++;
                continue;
            }
            if (r > 0) {
                int c = prev & 0xff;
                if (c < 0x10)
                    out.print('0');
                out.print(Integer.toHexString(c));
                if (r > 1) {
                    out.print("[");
                    out.print(r);
                    out.print("]");
                }
                n++;
            }
            prev = b;
            r = 1;
        }
}
    
   
  
   







 Instance 6







   
  
   
    
Class320.fileDigest(File file)#0{
        FileChannel channel = new FileInputStream(file).getChannel();
        ByteBuffer buffer = ByteBuffer.allocate((int) channel.size());
        channel.read(buffer);
        return new BigInteger(1,digest.digest(buffer.array()));
}
    
   
  
   







 Instance 7







   
  
   
    
Class180.testThroughLogBuffer()#2{
        ByteBuffer readInMe = ByteBuffer.allocate( 4 ); // One integers
        dup.read( readInMe );
        readInMe.flip();
        assertEquals( 1, readInMe.getInt() );
        readInMe.flip();
}
    
   
  
   







 Instance 8







   
  
   
    
Class30.ID3v1Tag(RandomAccessFile file,String loggingFilename)#1{
        fc = file.getChannel();
        fc.position(file.length() - TAG_LENGTH);
        byteBuffer = ByteBuffer.allocate(TAG_LENGTH);
        fc.read(byteBuffer);
        byteBuffer.flip();
        read(byteBuffer);
}
    
   
  
   







 Instance 9







   
  
   
    
Class10.readFileToBuffer(File file,boolean allocateDirect)#0{
            ByteBuffer buffer = allocateDirect ? ByteBuffer.allocateDirect(size) : ByteBuffer.allocate(size);
            for (int count = 0; count >= 0 && buffer.hasRemaining(); )
            {
                count = fc.read(buffer);
            }
            buffer.flip();
}
    
   
  
   





