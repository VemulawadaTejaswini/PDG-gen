Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_30 $$ scoping = Scopes.makeInjectable(Scoping.forAnnotation(scopeAnnotation), this, errors.withSource(rawType))[ FD ]
Line_11 $$ ImplementedBy implementedBy = rawType.getAnnotation(ImplementedBy.class)-->Line_14 $$ return createImplementedByBinding(key, scoping, implementedBy, errors)[ FD ]
Line_16 $$ ProvidedBy providedBy = rawType.getAnnotation(ProvidedBy.class)-->Line_17 $$ if (providedBy != null) [ FD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_14 $$ return createImplementedByBinding(key, scoping, implementedBy, errors)[ FD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_28 $$ Class<? extends Annotation> scopeAnnotation = findScopeAnnotation(errors, rawType)[ FD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_11 $$ ImplementedBy implementedBy = rawType.getAnnotation(ImplementedBy.class)[ CD ]
Line_3 $$ Class<?> rawType = key.getTypeLiteral().getRawType()-->Line_21 $$ if (Modifier.isAbstract(rawType.getModifiers())) [ FD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_19 $$ return createProvidedByBinding(key, scoping, providedBy, errors)[ FD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_21 $$ if (Modifier.isAbstract(rawType.getModifiers())) [ CD ]
Line_27 $$ if (!scoping.isExplicitlyScoped()) -->Line_28 $$ Class<? extends Annotation> scopeAnnotation = findScopeAnnotation(errors, rawType)[ CD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_33 $$ return ConstructorBindingImpl.create(this, key, source, scoping)[ FD ]
Line_3 $$ Class<?> rawType = key.getTypeLiteral().getRawType()-->Line_16 $$ ProvidedBy providedBy = rawType.getAnnotation(ProvidedBy.class)[ FD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_24 $$ if (Classes.isInnerClass(rawType)) [ CD ]
Line_3 $$ Class<?> rawType = key.getTypeLiteral().getRawType()-->Line_28 $$ Class<? extends Annotation> scopeAnnotation = findScopeAnnotation(errors, rawType)[ FD ]
Line_30 $$ scoping = Scopes.makeInjectable(Scoping.forAnnotation(scopeAnnotation), this, errors.withSource(rawType))-->Line_33 $$ return ConstructorBindingImpl.create(this, key, source, scoping)[ FD ]
Line_3 $$ Class<?> rawType = key.getTypeLiteral().getRawType()-->Line_18 $$ Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors)[ FD ]
Line_17 $$ if (providedBy != null) -->Line_19 $$ return createProvidedByBinding(key, scoping, providedBy, errors)[ CD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_27 $$ if (!scoping.isExplicitlyScoped()) [ FD ]
Line_7 $$ if (rawType == TypeLiteral.class) -->Line_9 $$ return binding[ CD ]
Line_3 $$ Class<?> rawType = key.getTypeLiteral().getRawType()-->Line_13 $$ Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors)[ FD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_5 $$ throw errors.missingImplementation(key).toException()[ FD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_25 $$ throw errors.cannotInjectInnerClass(rawType).toException()[ FD ]
Line_12 $$ if (implementedBy != null) -->Line_14 $$ return createImplementedByBinding(key, scoping, implementedBy, errors)[ CD ]
Line_3 $$ Class<?> rawType = key.getTypeLiteral().getRawType()-->Line_25 $$ throw errors.cannotInjectInnerClass(rawType).toException()[ FD ]
Line_3 $$ Class<?> rawType = key.getTypeLiteral().getRawType()-->Line_11 $$ ImplementedBy implementedBy = rawType.getAnnotation(ImplementedBy.class)[ FD ]
Line_28 $$ Class<? extends Annotation> scopeAnnotation = findScopeAnnotation(errors, rawType)-->Line_29 $$ if (scopeAnnotation != null) [ FD ]
Line_29 $$ if (scopeAnnotation != null) -->Line_30 $$ scoping = Scopes.makeInjectable(Scoping.forAnnotation(scopeAnnotation), this, errors.withSource(rawType))[ CD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_33 $$ return ConstructorBindingImpl.create(this, key, source, scoping)[ CD ]
Line_16 $$ ProvidedBy providedBy = rawType.getAnnotation(ProvidedBy.class)-->Line_19 $$ return createProvidedByBinding(key, scoping, providedBy, errors)[ FD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_8 $$ BindingImpl<T> binding = (BindingImpl<T>) createTypeLiteralBinding((Key<TypeLiteral<Object>>) key, errors)[ FD ]
Line_12 $$ if (implementedBy != null) -->Line_13 $$ Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors)[ CD ]
Line_7 $$ if (rawType == TypeLiteral.class) -->Line_8 $$ BindingImpl<T> binding = (BindingImpl<T>) createTypeLiteralBinding((Key<TypeLiteral<Object>>) key, errors)[ CD ]
Line_3 $$ Class<?> rawType = key.getTypeLiteral().getRawType()-->Line_30 $$ scoping = Scopes.makeInjectable(Scoping.forAnnotation(scopeAnnotation), this, errors.withSource(rawType))[ FD ]
Line_11 $$ ImplementedBy implementedBy = rawType.getAnnotation(ImplementedBy.class)-->Line_12 $$ if (implementedBy != null) [ FD ]
Line_27 $$ if (!scoping.isExplicitlyScoped()) -->Line_29 $$ if (scopeAnnotation != null) [ CD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_13 $$ Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors)[ FD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_4 $$ if (rawType.isArray() || rawType.isEnum()) [ CD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_16 $$ ProvidedBy providedBy = rawType.getAnnotation(ProvidedBy.class)[ CD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_3 $$ Class<?> rawType = key.getTypeLiteral().getRawType()[ CD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_3 $$ Class<?> rawType = key.getTypeLiteral().getRawType()[ FD ]
Line_17 $$ if (providedBy != null) -->Line_18 $$ Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors)[ CD ]
Line_28 $$ Class<? extends Annotation> scopeAnnotation = findScopeAnnotation(errors, rawType)-->Line_30 $$ scoping = Scopes.makeInjectable(Scoping.forAnnotation(scopeAnnotation), this, errors.withSource(rawType))[ FD ]
Line_3 $$ Class<?> rawType = key.getTypeLiteral().getRawType()-->Line_24 $$ if (Classes.isInnerClass(rawType)) [ FD ]
Line_3 $$ Class<?> rawType = key.getTypeLiteral().getRawType()-->Line_4 $$ if (rawType.isArray() || rawType.isEnum()) [ FD ]
Line_3 $$ Class<?> rawType = key.getTypeLiteral().getRawType()-->Line_7 $$ if (rawType == TypeLiteral.class) [ FD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_12 $$ if (implementedBy != null) [ CD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_27 $$ if (!scoping.isExplicitlyScoped()) [ CD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_18 $$ Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors)[ FD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_7 $$ if (rawType == TypeLiteral.class) [ CD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_22 $$ throw errors.missingImplementation(key).toException()[ FD ]
Line_2 $$ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException -->Line_17 $$ if (providedBy != null) [ CD ]
