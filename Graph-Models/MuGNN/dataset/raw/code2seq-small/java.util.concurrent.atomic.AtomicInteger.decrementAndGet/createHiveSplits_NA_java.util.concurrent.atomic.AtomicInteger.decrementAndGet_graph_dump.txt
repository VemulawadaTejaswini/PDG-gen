Line_13 $$ creatingInitialSplits = true-->Line_21 $$ if (remainingInitialSplits.decrementAndGet() < 0 && creatingInitialSplits) [ FD ]
Line_6 $$ for (BlockLocation blockLocation : blockLocations) -->Line_31 $$ builder.add(new HiveSplit(connectorId, table.getDbName(), table.getTableName(), partitionName, path, blockLocation.getOffset() + chunkOffset, chunkLength, schema, partitionKeys, addresses, forceLocalScheduling, effectivePredicate))[ FD ]
Line_3 $$ ImmutableList.Builder<HiveSplit> builder = ImmutableList.builder()-->Line_31 $$ builder.add(new HiveSplit(connectorId, table.getDbName(), table.getTableName(), partitionName, path, blockLocation.getOffset() + chunkOffset, chunkLength, schema, partitionKeys, addresses, forceLocalScheduling, effectivePredicate))[ FD ]
Line_11 $$ if (remainingInitialSplits.get() > 0) -->Line_12 $$ maxBytes = maxInitialSplitSize.toBytes()[ CD ]
Line_22 $$ creatingInitialSplits = false-->Line_21 $$ if (remainingInitialSplits.decrementAndGet() < 0 && creatingInitialSplits) [ FD ]
Line_2 $$ private List<HiveSplit> createHiveSplits(String partitionName, String path, BlockLocation[] blockLocations, long start, long length, Properties schema, List<HivePartitionKey> partitionKeys, boolean splittable, ConnectorSession session, TupleDomain<HiveColumnHandle> effectivePredicate) throws IOException -->Line_4 $$ boolean forceLocalScheduling = HiveSessionProperties.isForceLocalScheduling(session)[ FD ]
Line_11 $$ if (remainingInitialSplits.get() > 0) -->Line_13 $$ creatingInitialSplits = true[ CD ]
Line_21 $$ if (remainingInitialSplits.decrementAndGet() < 0 && creatingInitialSplits) -->Line_26 $$ chunks = Math.max(1, (int) (remainingLength / maxBytes))[ CD ]
Line_6 $$ for (BlockLocation blockLocation : blockLocations) -->Line_34 $$ checkState(chunkOffset == blockLocation.getLength(), "Error splitting blocks")[ FD ]
Line_5 $$ if (splittable) -->Line_42 $$ builder.add(new HiveSplit(connectorId, table.getDbName(), table.getTableName(), partitionName, path, start, length, schema, partitionKeys, addresses, forceLocalScheduling, effectivePredicate))[ CD ]
Line_21 $$ if (remainingInitialSplits.decrementAndGet() < 0 && creatingInitialSplits) -->Line_22 $$ creatingInitialSplits = false[ CD ]
Line_13 $$ creatingInitialSplits = true-->Line_22 $$ creatingInitialSplits = false[ FD ]
Line_2 $$ private List<HiveSplit> createHiveSplits(String partitionName, String path, BlockLocation[] blockLocations, long start, long length, Properties schema, List<HivePartitionKey> partitionKeys, boolean splittable, ConnectorSession session, TupleDomain<HiveColumnHandle> effectivePredicate) throws IOException -->Line_44 $$ return builder.build()[ CD ]
Line_3 $$ ImmutableList.Builder<HiveSplit> builder = ImmutableList.builder()-->Line_42 $$ builder.add(new HiveSplit(connectorId, table.getDbName(), table.getTableName(), partitionName, path, start, length, schema, partitionKeys, addresses, forceLocalScheduling, effectivePredicate))[ FD ]
Line_10 $$ boolean creatingInitialSplits = false-->Line_22 $$ creatingInitialSplits = false[ FD ]
Line_20 $$ while (chunkOffset < blockLocation.getLength()) -->Line_32 $$ chunkOffset += chunkLength[ CD ]
Line_5 $$ if (splittable) -->Line_39 $$ if (blockLocations.length > 0) [ CD ]
Line_32 $$ chunkOffset += chunkLength-->Line_20 $$ while (chunkOffset < blockLocation.getLength()) [ FD ]
Line_20 $$ while (chunkOffset < blockLocation.getLength()) -->Line_21 $$ if (remainingInitialSplits.decrementAndGet() < 0 && creatingInitialSplits) [ CD ]
Line_20 $$ while (chunkOffset < blockLocation.getLength()) -->Line_31 $$ builder.add(new HiveSplit(connectorId, table.getDbName(), table.getTableName(), partitionName, path, blockLocation.getOffset() + chunkOffset, chunkLength, schema, partitionKeys, addresses, forceLocalScheduling, effectivePredicate))[ CD ]
Line_2 $$ private List<HiveSplit> createHiveSplits(String partitionName, String path, BlockLocation[] blockLocations, long start, long length, Properties schema, List<HivePartitionKey> partitionKeys, boolean splittable, ConnectorSession session, TupleDomain<HiveColumnHandle> effectivePredicate) throws IOException -->Line_3 $$ ImmutableList.Builder<HiveSplit> builder = ImmutableList.builder()[ CD ]
Line_6 $$ for (BlockLocation blockLocation : blockLocations) -->Line_20 $$ while (chunkOffset < blockLocation.getLength()) [ FD ]
Line_9 $$ long maxBytes = maxSplitSize.toBytes()-->Line_12 $$ maxBytes = maxInitialSplitSize.toBytes()[ FD ]
Line_39 $$ if (blockLocations.length > 0) -->Line_40 $$ addresses = toHostAddress(blockLocations[0].getHosts())[ CD ]
Line_10 $$ boolean creatingInitialSplits = false-->Line_13 $$ creatingInitialSplits = true[ FD ]
Line_6 $$ for (BlockLocation blockLocation : blockLocations) -->Line_25 $$ long remainingLength = blockLocation.getLength() - chunkOffset[ FD ]
Line_21 $$ if (remainingInitialSplits.decrementAndGet() < 0 && creatingInitialSplits) -->Line_25 $$ long remainingLength = blockLocation.getLength() - chunkOffset[ CD ]
Line_21 $$ if (remainingInitialSplits.decrementAndGet() < 0 && creatingInitialSplits) -->Line_27 $$ targetChunkSize = (long) Math.ceil(remainingLength * 1.0 / chunks)[ CD ]
Line_2 $$ private List<HiveSplit> createHiveSplits(String partitionName, String path, BlockLocation[] blockLocations, long start, long length, Properties schema, List<HivePartitionKey> partitionKeys, boolean splittable, ConnectorSession session, TupleDomain<HiveColumnHandle> effectivePredicate) throws IOException -->Line_5 $$ if (splittable) [ CD ]
Line_3 $$ ImmutableList.Builder<HiveSplit> builder = ImmutableList.builder()-->Line_44 $$ return builder.build()[ FD ]
Line_2 $$ private List<HiveSplit> createHiveSplits(String partitionName, String path, BlockLocation[] blockLocations, long start, long length, Properties schema, List<HivePartitionKey> partitionKeys, boolean splittable, ConnectorSession session, TupleDomain<HiveColumnHandle> effectivePredicate) throws IOException -->Line_4 $$ boolean forceLocalScheduling = HiveSessionProperties.isForceLocalScheduling(session)[ CD ]
Line_19 $$ long chunkOffset = 0-->Line_20 $$ while (chunkOffset < blockLocation.getLength()) [ FD ]
Line_10 $$ boolean creatingInitialSplits = false-->Line_21 $$ if (remainingInitialSplits.decrementAndGet() < 0 && creatingInitialSplits) [ FD ]
Line_19 $$ long chunkOffset = 0-->Line_32 $$ chunkOffset += chunkLength[ FD ]
