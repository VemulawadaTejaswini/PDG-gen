Line_15 $$ return new PeekableIterator<T>() -->Line_25 $$ if (modCount != modCountBefore)[ CD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_92 $$ IntervalNode<T> parent = root.getParent()[ FD ]
Line_8 $$ if (firstOverlap == null) -->Line_10 $$ return PeekableIterator.EMPTY[ CD ]
Line_5 $$ final int startOffset = rangeInterval.getStartOffset()-->Line_81 $$ if (startOffset <= rightMaxEnd) [ FD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_75 $$ int myMaxEnd = maxEndOf(root, deltaUpToRootExclusive)[ CD ]
Line_81 $$ if (startOffset <= rightMaxEnd) -->Line_87 $$ deltaUpToRootExclusive = rightDelta - right.delta[ CD ]
Line_87 $$ deltaUpToRootExclusive = rightDelta - right.delta-->Line_97 $$ deltaUpToRootExclusive -= parent.delta[ FD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_23 $$ if (currentNode == null)[ CD ]
Line_93 $$ if (parent == null)-->Line_94 $$ return null[ CD ]
Line_78 $$ IntervalNode<T> right = root.getRight()-->Line_84 $$ right = right.getLeft()[ FD ]
Line_81 $$ if (startOffset <= rightMaxEnd) -->Line_88 $$ return right[ CD ]
Line_81 $$ if (startOffset <= rightMaxEnd) -->Line_83 $$ while (right.getLeft() != null && startOffset <= maxEndOf(right.getLeft(), rightDelta)) [ CD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_70 $$ l.readLock().unlock()[ CD ]
Line_78 $$ IntervalNode<T> right = root.getRight()-->Line_83 $$ while (right.getLeft() != null && startOffset <= maxEndOf(right.getLeft(), rightDelta)) [ FD ]
Line_35 $$ while (true) -->Line_36 $$ currentNode = nextNode(currentNode)[ CD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_74 $$ int delta = deltaUpToRootExclusive + root.delta[ CD ]
Line_2 $$ private PeekableIterator<T> overlappingIterator(@NotNull final TextRangeInterval rangeInterval) -->Line_6 $$ final int endOffset = rangeInterval.getEndOffset()[ FD ]
Line_79 $$ if (right != null) -->Line_81 $$ if (startOffset <= rightMaxEnd) [ CD ]
Line_28 $$ T t = currentNode.intervals.get(indexInCurrentList++).get()-->Line_29 $$ if (t != null) [ FD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_21 $$ if (current != null)[ CD ]
Line_29 $$ if (t != null) -->Line_31 $$ return true[ CD ]
Line_91 $$ while (true) -->Line_92 $$ IntervalNode<T> parent = root.getParent()[ CD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_55 $$ if (!hasNext())[ CD ]
Line_34 $$ indexInCurrentList = 0-->Line_42 $$ indexInCurrentList = 0[ FD ]
Line_6 $$ final int endOffset = rangeInterval.getEndOffset()-->Line_95 $$ if (parent.intervalStart() + deltaUpToRootExclusive > endOffset)[ FD ]
Line_45 $$ if (t != null) -->Line_47 $$ return true[ CD ]
Line_2 $$ private PeekableIterator<T> overlappingIterator(@NotNull final TextRangeInterval rangeInterval) -->Line_5 $$ final int startOffset = rangeInterval.getStartOffset()[ FD ]
Line_21 $$ if (current != null)-->Line_22 $$ return true[ CD ]
Line_81 $$ if (startOffset <= rightMaxEnd) -->Line_82 $$ int rightDelta = delta + right.delta[ CD ]
Line_35 $$ while (true) -->Line_40 $$ if (overlaps(currentNode, rangeInterval, deltaUpToRootExclusive)) [ CD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_75 $$ int myMaxEnd = maxEndOf(root, deltaUpToRootExclusive)[ FD ]
Line_7 $$ final IntervalNode<T> firstOverlap = findMinOverlappingWith(getRoot(), rangeInterval, modCount, 0)-->Line_12 $$ final int firstOverlapDelta = firstOverlap.computeDeltaUpToRoot()[ FD ]
Line_91 $$ while (true) -->Line_93 $$ if (parent == null)[ CD ]
Line_91 $$ while (true) -->Line_98 $$ if (parent.getLeft() == root) [ CD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_34 $$ indexInCurrentList = 0[ CD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_91 $$ while (true) [ CD ]
Line_42 $$ indexInCurrentList = 0-->Line_50 $$ indexInCurrentList = 0[ FD ]
Line_37 $$ if (currentNode == null) -->Line_38 $$ return false[ CD ]
Line_83 $$ while (right.getLeft() != null && startOffset <= maxEndOf(right.getLeft(), rightDelta)) -->Line_85 $$ rightDelta += right.delta[ CD ]
Line_92 $$ IntervalNode<T> parent = root.getParent()-->Line_98 $$ if (parent.getLeft() == root) [ FD ]
Line_83 $$ while (right.getLeft() != null && startOffset <= maxEndOf(right.getLeft(), rightDelta)) -->Line_84 $$ right = right.getLeft()[ CD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_64 $$ return current[ CD ]
Line_76 $$ if (startOffset > myMaxEnd)-->Line_77 $$ return null[ CD ]
Line_42 $$ indexInCurrentList = 0-->Line_44 $$ T t = currentNode.intervals.get(indexInCurrentList++).get()[ FD ]
Line_80 $$ int rightMaxEnd = maxEndOf(right, delta)-->Line_81 $$ if (startOffset <= rightMaxEnd) [ FD ]
Line_2 $$ private PeekableIterator<T> overlappingIterator(@NotNull final TextRangeInterval rangeInterval) -->Line_3 $$ l.readLock().lock()[ CD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_78 $$ IntervalNode<T> right = root.getRight()[ FD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_57 $$ T t = current[ CD ]
Line_27 $$ while (indexInCurrentList != currentNode.intervals.size()) -->Line_28 $$ T t = currentNode.intervals.get(indexInCurrentList++).get()[ CD ]
Line_92 $$ IntervalNode<T> parent = root.getParent()-->Line_95 $$ if (parent.intervalStart() + deltaUpToRootExclusive > endOffset)[ FD ]
Line_43 $$ while (indexInCurrentList != currentNode.intervals.size()) -->Line_44 $$ T t = currentNode.intervals.get(indexInCurrentList++).get()[ CD ]
Line_27 $$ while (indexInCurrentList != currentNode.intervals.size()) -->Line_29 $$ if (t != null) [ CD ]
Line_8 $$ if (firstOverlap == null) -->Line_9 $$ l.readLock().unlock()[ CD ]
Line_40 $$ if (overlaps(currentNode, rangeInterval, deltaUpToRootExclusive)) -->Line_50 $$ indexInCurrentList = 0[ CD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_35 $$ while (true) [ CD ]
Line_82 $$ int rightDelta = delta + right.delta-->Line_85 $$ rightDelta += right.delta[ FD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_98 $$ if (parent.getLeft() == root) [ FD ]
Line_7 $$ final IntervalNode<T> firstOverlap = findMinOverlappingWith(getRoot(), rangeInterval, modCount, 0)-->Line_8 $$ if (firstOverlap == null) [ FD ]
Line_23 $$ if (currentNode == null)-->Line_24 $$ return false[ CD ]
Line_75 $$ int myMaxEnd = maxEndOf(root, deltaUpToRootExclusive)-->Line_76 $$ if (startOffset > myMaxEnd)[ FD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_79 $$ if (right != null) [ CD ]
Line_98 $$ if (parent.getLeft() == root) -->Line_99 $$ return parent[ CD ]
Line_2 $$ private PeekableIterator<T> overlappingIterator(@NotNull final TextRangeInterval rangeInterval) -->Line_7 $$ final IntervalNode<T> firstOverlap = findMinOverlappingWith(getRoot(), rangeInterval, modCount, 0)[ FD ]
Line_34 $$ indexInCurrentList = 0-->Line_43 $$ while (indexInCurrentList != currentNode.intervals.size()) [ FD ]
Line_40 $$ if (overlaps(currentNode, rangeInterval, deltaUpToRootExclusive)) -->Line_43 $$ while (indexInCurrentList != currentNode.intervals.size()) [ CD ]
Line_78 $$ IntervalNode<T> right = root.getRight()-->Line_79 $$ if (right != null) [ FD ]
Line_85 $$ rightDelta += right.delta-->Line_87 $$ deltaUpToRootExclusive = rightDelta - right.delta[ FD ]
Line_85 $$ rightDelta += right.delta-->Line_83 $$ while (right.getLeft() != null && startOffset <= maxEndOf(right.getLeft(), rightDelta)) [ FD ]
Line_34 $$ indexInCurrentList = 0-->Line_50 $$ indexInCurrentList = 0[ FD ]
Line_2 $$ private PeekableIterator<T> overlappingIterator(@NotNull final TextRangeInterval rangeInterval) -->Line_40 $$ if (overlaps(currentNode, rangeInterval, deltaUpToRootExclusive)) [ FD ]
Line_5 $$ final int startOffset = rangeInterval.getStartOffset()-->Line_76 $$ if (startOffset > myMaxEnd)[ FD ]
Line_78 $$ IntervalNode<T> right = root.getRight()-->Line_80 $$ int rightMaxEnd = maxEndOf(right, delta)[ FD ]
Line_42 $$ indexInCurrentList = 0-->Line_43 $$ while (indexInCurrentList != currentNode.intervals.size()) [ FD ]
Line_44 $$ T t = currentNode.intervals.get(indexInCurrentList++).get()-->Line_45 $$ if (t != null) [ FD ]
Line_40 $$ if (overlaps(currentNode, rangeInterval, deltaUpToRootExclusive)) -->Line_42 $$ indexInCurrentList = 0[ CD ]
Line_91 $$ while (true) -->Line_95 $$ if (parent.intervalStart() + deltaUpToRootExclusive > endOffset)[ CD ]
Line_84 $$ right = right.getLeft()-->Line_83 $$ while (right.getLeft() != null && startOffset <= maxEndOf(right.getLeft(), rightDelta)) [ FD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_27 $$ while (indexInCurrentList != currentNode.intervals.size()) [ CD ]
Line_82 $$ int rightDelta = delta + right.delta-->Line_87 $$ deltaUpToRootExclusive = rightDelta - right.delta[ FD ]
Line_7 $$ final IntervalNode<T> firstOverlap = findMinOverlappingWith(getRoot(), rangeInterval, modCount, 0)-->Line_13 $$ final int firstOverlapStart = firstOverlap.intervalStart() + firstOverlapDelta[ FD ]
Line_74 $$ int delta = deltaUpToRootExclusive + root.delta-->Line_80 $$ int rightMaxEnd = maxEndOf(right, delta)[ FD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_73 $$ assert root.isValid() : root[ FD ]
Line_92 $$ IntervalNode<T> parent = root.getParent()-->Line_93 $$ if (parent == null)[ FD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_76 $$ if (startOffset > myMaxEnd)[ CD ]
Line_14 $$ final int modCountBefore = modCount-->Line_25 $$ if (modCount != modCountBefore)[ FD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_59 $$ return t[ CD ]
Line_91 $$ while (true) -->Line_97 $$ deltaUpToRootExclusive -= parent.delta[ CD ]
Line_34 $$ indexInCurrentList = 0-->Line_44 $$ T t = currentNode.intervals.get(indexInCurrentList++).get()[ FD ]
Line_43 $$ while (indexInCurrentList != currentNode.intervals.size()) -->Line_45 $$ if (t != null) [ CD ]
Line_95 $$ if (parent.intervalStart() + deltaUpToRootExclusive > endOffset)-->Line_96 $$ return null[ CD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_62 $$ if (!hasNext())[ CD ]
Line_15 $$ return new PeekableIterator<T>() -->Line_78 $$ IntervalNode<T> right = root.getRight()[ CD ]
Line_79 $$ if (right != null) -->Line_80 $$ int rightMaxEnd = maxEndOf(right, delta)[ CD ]
Line_35 $$ while (true) -->Line_37 $$ if (currentNode == null) [ CD ]
Line_28 $$ T t = currentNode.intervals.get(indexInCurrentList++).get()-->Line_45 $$ if (t != null) [ FD ]
Line_82 $$ int rightDelta = delta + right.delta-->Line_83 $$ while (right.getLeft() != null && startOffset <= maxEndOf(right.getLeft(), rightDelta)) [ FD ]
