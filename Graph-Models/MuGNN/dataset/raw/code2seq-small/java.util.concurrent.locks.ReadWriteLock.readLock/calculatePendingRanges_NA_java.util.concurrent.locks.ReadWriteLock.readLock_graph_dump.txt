Line_18 $$ Set<InetAddress> currentEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right, metadata))-->Line_20 $$ newPendingRanges.putAll(range, Sets.difference(newEndpoints, currentEndpoints))[ FD ]
Line_13 $$ TokenMetadata allLeftMetadata = cloneAfterAllLeft()-->Line_26 $$ for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint)) newPendingRanges.put(range, endpoint)[ FD ]
Line_2 $$ public void calculatePendingRanges(AbstractReplicationStrategy strategy, String keyspaceName) -->Line_32 $$ for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint)) [ FD ]
Line_22 $$ Multimap<InetAddress, Token> bootstrapAddresses = bootstrapTokens.inverse()-->Line_23 $$ for (InetAddress endpoint : bootstrapAddresses.keySet()) [ FD ]
Line_13 $$ TokenMetadata allLeftMetadata = cloneAfterAllLeft()-->Line_32 $$ for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint)) [ FD ]
Line_2 $$ public void calculatePendingRanges(AbstractReplicationStrategy strategy, String keyspaceName) -->Line_3 $$ lock.readLock().lock()[ CD ]
Line_6 $$ if (bootstrapTokens.isEmpty() && leavingEndpoints.isEmpty() && movingEndpoints.isEmpty()) -->Line_7 $$ if (logger.isTraceEnabled())[ CD ]
Line_2 $$ public void calculatePendingRanges(AbstractReplicationStrategy strategy, String keyspaceName) -->Line_37 $$ pendingRanges.put(keyspaceName, newPendingRanges)[ FD ]
Line_19 $$ Set<InetAddress> newEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right, allLeftMetadata))-->Line_20 $$ newPendingRanges.putAll(range, Sets.difference(newEndpoints, currentEndpoints))[ FD ]
Line_14 $$ Set<Range<Token>> affectedRanges = new HashSet<Range<Token>>()-->Line_15 $$ affectedRanges.addAll(addressRanges.get(endpoint))[ FD ]
Line_38 $$ if (logger.isTraceEnabled())-->Line_39 $$ logger.trace("Pending ranges:\n[ CD ]
Line_15 $$ for (InetAddress endpoint : leavingEndpoints) affectedRanges.addAll(addressRanges.get(endpoint))-->Line_31 $$ allLeftMetadata.updateNormalToken(moving.left, endpoint)[ FD ]
Line_2 $$ public void calculatePendingRanges(AbstractReplicationStrategy strategy, String keyspaceName) -->Line_8 $$ logger.trace("No bootstrapping, leaving or moving nodes -> empty pending ranges for [ FD ]
Line_2 $$ public void calculatePendingRanges(AbstractReplicationStrategy strategy, String keyspaceName) -->Line_26 $$ for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint)) newPendingRanges.put(range, endpoint)[ FD ]
Line_2 $$ public void calculatePendingRanges(AbstractReplicationStrategy strategy, String keyspaceName) -->Line_9 $$ pendingRanges.put(keyspaceName, newPendingRanges)[ FD ]
Line_15 $$ for (InetAddress endpoint : leavingEndpoints) affectedRanges.addAll(addressRanges.get(endpoint))-->Line_24 $$ Collection<Token> tokens = bootstrapAddresses.get(endpoint)[ FD ]
Line_5 $$ Multimap<Range<Token>, InetAddress> newPendingRanges = HashMultimap.create()-->Line_37 $$ pendingRanges.put(keyspaceName, newPendingRanges)[ FD ]
Line_2 $$ public void calculatePendingRanges(AbstractReplicationStrategy strategy, String keyspaceName) -->Line_12 $$ Multimap<InetAddress, Range<Token>> addressRanges = strategy.getAddressRanges()[ FD ]
Line_12 $$ Multimap<InetAddress, Range<Token>> addressRanges = strategy.getAddressRanges()-->Line_15 $$ affectedRanges.addAll(addressRanges.get(endpoint))[ FD ]
Line_5 $$ Multimap<Range<Token>, InetAddress> newPendingRanges = HashMultimap.create()-->Line_20 $$ newPendingRanges.putAll(range, Sets.difference(newEndpoints, currentEndpoints))[ FD ]
Line_13 $$ TokenMetadata allLeftMetadata = cloneAfterAllLeft()-->Line_19 $$ Set<InetAddress> newEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right, allLeftMetadata))[ FD ]
Line_16 $$ TokenMetadata metadata = cloneOnlyTokenMap()-->Line_18 $$ Set<InetAddress> currentEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right, metadata))[ FD ]
Line_6 $$ if (bootstrapTokens.isEmpty() && leavingEndpoints.isEmpty() && movingEndpoints.isEmpty()) -->Line_9 $$ pendingRanges.put(keyspaceName, newPendingRanges)[ CD ]
Line_15 $$ for (InetAddress endpoint : leavingEndpoints) affectedRanges.addAll(addressRanges.get(endpoint))-->Line_33 $$ newPendingRanges.put(range, endpoint)[ FD ]
Line_15 $$ for (InetAddress endpoint : leavingEndpoints) affectedRanges.addAll(addressRanges.get(endpoint))-->Line_27 $$ allLeftMetadata.removeEndpoint(endpoint)[ FD ]
Line_2 $$ public void calculatePendingRanges(AbstractReplicationStrategy strategy, String keyspaceName) -->Line_18 $$ Set<InetAddress> currentEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right, metadata))[ FD ]
Line_17 $$ for (Range<Token> range : affectedRanges) -->Line_33 $$ newPendingRanges.put(range, endpoint)[ FD ]
Line_2 $$ public void calculatePendingRanges(AbstractReplicationStrategy strategy, String keyspaceName) -->Line_19 $$ Set<InetAddress> newEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right, allLeftMetadata))[ FD ]
Line_7 $$ if (logger.isTraceEnabled())-->Line_8 $$ logger.trace("No bootstrapping, leaving or moving nodes -> empty pending ranges for [ CD ]
Line_13 $$ TokenMetadata allLeftMetadata = cloneAfterAllLeft()-->Line_27 $$ allLeftMetadata.removeEndpoint(endpoint)[ FD ]
Line_22 $$ Multimap<InetAddress, Token> bootstrapAddresses = bootstrapTokens.inverse()-->Line_24 $$ Collection<Token> tokens = bootstrapAddresses.get(endpoint)[ FD ]
Line_5 $$ Multimap<Range<Token>, InetAddress> newPendingRanges = HashMultimap.create()-->Line_9 $$ pendingRanges.put(keyspaceName, newPendingRanges)[ FD ]
Line_17 $$ for (Range<Token> range : affectedRanges) -->Line_26 $$ newPendingRanges.put(range, endpoint)[ FD ]
Line_5 $$ Multimap<Range<Token>, InetAddress> newPendingRanges = HashMultimap.create()-->Line_33 $$ newPendingRanges.put(range, endpoint)[ FD ]
Line_13 $$ TokenMetadata allLeftMetadata = cloneAfterAllLeft()-->Line_25 $$ allLeftMetadata.updateNormalTokens(tokens, endpoint)[ FD ]
Line_24 $$ Collection<Token> tokens = bootstrapAddresses.get(endpoint)-->Line_25 $$ allLeftMetadata.updateNormalTokens(tokens, endpoint)[ FD ]
Line_15 $$ for (InetAddress endpoint : leavingEndpoints) affectedRanges.addAll(addressRanges.get(endpoint))-->Line_35 $$ allLeftMetadata.removeEndpoint(endpoint)[ FD ]
Line_15 $$ for (InetAddress endpoint : leavingEndpoints) affectedRanges.addAll(addressRanges.get(endpoint))-->Line_26 $$ for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint)) newPendingRanges.put(range, endpoint)[ FD ]
Line_13 $$ TokenMetadata allLeftMetadata = cloneAfterAllLeft()-->Line_31 $$ allLeftMetadata.updateNormalToken(moving.left, endpoint)[ FD ]
Line_13 $$ TokenMetadata allLeftMetadata = cloneAfterAllLeft()-->Line_35 $$ allLeftMetadata.removeEndpoint(endpoint)[ FD ]
Line_6 $$ if (bootstrapTokens.isEmpty() && leavingEndpoints.isEmpty() && movingEndpoints.isEmpty()) -->Line_10 $$ return[ CD ]
Line_15 $$ for (InetAddress endpoint : leavingEndpoints) affectedRanges.addAll(addressRanges.get(endpoint))-->Line_32 $$ for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint)) [ FD ]
Line_5 $$ Multimap<Range<Token>, InetAddress> newPendingRanges = HashMultimap.create()-->Line_26 $$ newPendingRanges.put(range, endpoint)[ FD ]
Line_15 $$ for (InetAddress endpoint : leavingEndpoints) affectedRanges.addAll(addressRanges.get(endpoint))-->Line_25 $$ allLeftMetadata.updateNormalTokens(tokens, endpoint)[ FD ]
Line_17 $$ for (Range<Token> range : affectedRanges) -->Line_20 $$ newPendingRanges.putAll(range, Sets.difference(newEndpoints, currentEndpoints))[ FD ]
Line_15 $$ for (InetAddress endpoint : leavingEndpoints) affectedRanges.addAll(addressRanges.get(endpoint))-->Line_26 $$ newPendingRanges.put(range, endpoint)[ FD ]
