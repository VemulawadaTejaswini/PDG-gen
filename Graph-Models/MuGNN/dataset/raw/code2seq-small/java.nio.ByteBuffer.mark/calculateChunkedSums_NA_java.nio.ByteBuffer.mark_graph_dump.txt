Line_28 $$ while (data.remaining() > 0) -->Line_30 $$ data.get(buf, 0, n)[ CD ]
Line_20 $$ if (NativeCrc32.isAvailable()) -->Line_22 $$ return[ CD ]
Line_28 $$ while (data.remaining() > 0) -->Line_29 $$ int n = Math.min(data.remaining(), bytesPerChecksum)[ CD ]
Line_16 $$ if (data.hasArray() && checksums.hasArray()) -->Line_18 $$ return[ CD ]
Line_28 $$ while (data.remaining() > 0) -->Line_31 $$ summer.reset()[ CD ]
Line_20 $$ if (NativeCrc32.isAvailable()) -->Line_21 $$ NativeCrc32.calculateChunkedSums(bytesPerChecksum, type.id, checksums, data)[ CD ]
Line_29 $$ int n = Math.min(data.remaining(), bytesPerChecksum)-->Line_32 $$ summer.update(buf, 0, n)[ FD ]
Line_16 $$ if (data.hasArray() && checksums.hasArray()) -->Line_17 $$ calculateChunkedSums(data.array(), data.arrayOffset() + data.position(), data.remaining(), checksums.array(), checksums.arrayOffset() + checksums.position())[ CD ]
Line_27 $$ byte[] buf = new byte[bytesPerChecksum]-->Line_30 $$ data.get(buf, 0, n)[ FD ]
Line_28 $$ while (data.remaining() > 0) -->Line_32 $$ summer.update(buf, 0, n)[ CD ]
Line_14 $$ if (type.size == 0)-->Line_15 $$ return[ CD ]
Line_27 $$ byte[] buf = new byte[bytesPerChecksum]-->Line_32 $$ summer.update(buf, 0, n)[ FD ]
Line_28 $$ while (data.remaining() > 0) -->Line_33 $$ checksums.putInt((int) summer.getValue())[ CD ]
Line_29 $$ int n = Math.min(data.remaining(), bytesPerChecksum)-->Line_30 $$ data.get(buf, 0, n)[ FD ]
