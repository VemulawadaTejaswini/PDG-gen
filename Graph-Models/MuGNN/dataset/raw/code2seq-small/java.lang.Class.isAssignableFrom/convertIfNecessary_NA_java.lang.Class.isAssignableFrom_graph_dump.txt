Line_52 $$ if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) -->Line_71 $$ convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)[ CD ]
Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)-->Line_31 $$ if (convertedValue != null) [ FD ]
Line_40 $$ convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_52 $$ if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) [ FD ]
Line_25 $$ editor = findDefaultEditor(requiredType)-->Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)[ FD ]
Line_43 $$ convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_51 $$ return (T) convertedValue.toString()[ FD ]
Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)-->Line_46 $$ if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) [ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_71 $$ convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)[ FD ]
Line_87 $$ if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) -->Line_88 $$ return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)[ CD ]
Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_98 $$ msg.append(": PropertyEditor [").append(editor.getClass().getName()).append("] returned inappropriate value of type [").append(ClassUtils.getDescriptiveType(convertedValue)).append("]")[ FD ]
Line_71 $$ convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)-->Line_98 $$ msg.append(": PropertyEditor [").append(editor.getClass().getName()).append("] returned inappropriate value of type [").append(ClassUtils.getDescriptiveType(convertedValue)).append("]")[ FD ]
Line_48 $$ standardConversion = true-->Line_107 $$ if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) [ FD ]
Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_82 $$ if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) [ FD ]
Line_52 $$ if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) -->Line_72 $$ standardConversion = true[ CD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_25 $$ editor = findDefaultEditor(requiredType)[ FD ]
Line_67 $$ String trimmedValue = ((String) convertedValue).trim()-->Line_71 $$ convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)[ FD ]
Line_82 $$ if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) -->Line_83 $$ if (conversionAttemptEx != null) [ CD ]
Line_82 $$ if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) -->Line_91 $$ StringBuilder msg = new StringBuilder()[ CD ]
Line_12 $$ conversionAttemptEx = ex-->Line_110 $$ logger.debug("Original ConversionService attempt failed - ignored since " + "PropertyEditor based conversion eventually succeeded", conversionAttemptEx)[ FD ]
Line_68 $$ if (requiredType.isEnum() && "".equals(trimmedValue)) -->Line_69 $$ return null[ CD ]
Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_52 $$ if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) [ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_53 $$ if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) [ FD ]
Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)-->Line_79 $$ convertedValue = javaUtilOptionalEmpty[ FD ]
Line_29 $$ boolean standardConversion = false-->Line_41 $$ standardConversion = true[ FD ]
Line_82 $$ if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) -->Line_93 $$ msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")[ CD ]
Line_91 $$ StringBuilder msg = new StringBuilder()-->Line_101 $$ msg.append(": no matching editors or conversion strategy found")[ FD ]
Line_5 $$ ConversionService conversionService = this.propertyEditorRegistry.getConversionService()-->Line_85 $$ if (conversionService != null) [ FD ]
Line_6 $$ if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) -->Line_8 $$ if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) [ CD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_5 $$ ConversionService conversionService = this.propertyEditorRegistry.getConversionService()[ CD ]
Line_16 $$ Object convertedValue = newValue-->Line_38 $$ return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())[ FD ]
Line_43 $$ convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_82 $$ if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) [ FD ]
Line_50 $$ if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) -->Line_52 $$ if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) [ CD ]
Line_83 $$ if (conversionAttemptEx != null) -->Line_85 $$ if (conversionService != null) [ CD ]
Line_82 $$ if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) -->Line_92 $$ msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))[ CD ]
Line_85 $$ if (conversionService != null) -->Line_86 $$ TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)[ CD ]
Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_47 $$ convertedValue = Array.get(convertedValue, 0)[ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_35 $$ if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) [ FD ]
Line_43 $$ convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_56 $$ return BeanUtils.instantiateClass(strCtor, convertedValue)[ FD ]
Line_91 $$ StringBuilder msg = new StringBuilder()-->Line_98 $$ msg.append(": PropertyEditor [").append(editor.getClass().getName()).append("] returned inappropriate value of type [").append(ClassUtils.getDescriptiveType(convertedValue)).append("]")[ FD ]
Line_25 $$ editor = findDefaultEditor(requiredType)-->Line_98 $$ msg.append(": PropertyEditor [").append(editor.getClass().getName()).append("] returned inappropriate value of type [").append(ClassUtils.getDescriptiveType(convertedValue)).append("]")[ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_106 $$ if (conversionAttemptEx != null) [ CD ]
Line_41 $$ standardConversion = true-->Line_107 $$ if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) [ FD ]
Line_5 $$ ConversionService conversionService = this.propertyEditorRegistry.getConversionService()-->Line_88 $$ return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)[ FD ]
Line_17 $$ if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) -->Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)[ CD ]
Line_25 $$ editor = findDefaultEditor(requiredType)-->Line_97 $$ if (editor != null) [ FD ]
Line_52 $$ if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) -->Line_73 $$ if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) [ CD ]
Line_30 $$ if (requiredType != null) -->Line_82 $$ if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) [ CD ]
Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_71 $$ convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)[ FD ]
Line_71 $$ convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)-->Line_74 $$ convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType)[ FD ]
Line_43 $$ convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_98 $$ msg.append(": PropertyEditor [").append(editor.getClass().getName()).append("] returned inappropriate value of type [").append(ClassUtils.getDescriptiveType(convertedValue)).append("]")[ FD ]
Line_16 $$ Object convertedValue = newValue-->Line_46 $$ if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) [ FD ]
Line_6 $$ if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) -->Line_7 $$ TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)[ CD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_86 $$ TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)[ FD ]
Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)-->Line_40 $$ convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)[ FD ]
Line_40 $$ convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_47 $$ convertedValue = Array.get(convertedValue, 0)[ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_87 $$ if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) [ FD ]
Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)-->Line_51 $$ return (T) convertedValue.toString()[ FD ]
Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_47 $$ convertedValue = Array.get(convertedValue, 0)[ FD ]
Line_31 $$ if (convertedValue != null) -->Line_32 $$ if (Object.class == requiredType) [ CD ]
Line_16 $$ Object convertedValue = newValue-->Line_42 $$ if (convertedValue instanceof Map) [ FD ]
Line_40 $$ convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_51 $$ return (T) convertedValue.toString()[ FD ]
Line_16 $$ Object convertedValue = newValue-->Line_98 $$ msg.append(": PropertyEditor [").append(editor.getClass().getName()).append("] returned inappropriate value of type [").append(ClassUtils.getDescriptiveType(convertedValue)).append("]")[ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_7 $$ TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)[ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_17 $$ if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) [ CD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)[ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_93 $$ msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")[ FD ]
Line_52 $$ if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) -->Line_67 $$ String trimmedValue = ((String) convertedValue).trim()[ CD ]
Line_62 $$ if (logger.isDebugEnabled()) -->Line_63 $$ logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)[ CD ]
Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_38 $$ return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())[ FD ]
Line_40 $$ convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_43 $$ convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)[ FD ]
Line_40 $$ convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_74 $$ convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType)[ FD ]
Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_82 $$ if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) [ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_94 $$ if (propertyName != null) [ FD ]
Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_46 $$ if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) [ FD ]
Line_39 $$ if (convertedValue instanceof Collection) -->Line_41 $$ standardConversion = true[ CD ]
Line_4 $$ ConversionFailedException conversionAttemptEx = null-->Line_12 $$ conversionAttemptEx = ex[ FD ]
Line_31 $$ if (convertedValue != null) -->Line_46 $$ if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) [ CD ]
Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)-->Line_47 $$ convertedValue = Array.get(convertedValue, 0)[ FD ]
Line_46 $$ if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) -->Line_48 $$ standardConversion = true[ CD ]
Line_29 $$ boolean standardConversion = false-->Line_48 $$ standardConversion = true[ FD ]
Line_40 $$ convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_71 $$ convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)[ FD ]
Line_78 $$ if (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) -->Line_79 $$ convertedValue = javaUtilOptionalEmpty[ CD ]
Line_40 $$ convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_46 $$ if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) [ FD ]
Line_16 $$ Object convertedValue = newValue-->Line_40 $$ convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)[ FD ]
Line_16 $$ Object convertedValue = newValue-->Line_52 $$ if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) [ FD ]
Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_50 $$ if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) [ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_52 $$ if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) [ FD ]
Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)-->Line_71 $$ convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)[ FD ]
Line_71 $$ convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)-->Line_82 $$ if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) [ FD ]
Line_16 $$ Object convertedValue = newValue-->Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)[ FD ]
Line_7 $$ TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)-->Line_10 $$ return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)[ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_34 $$ if (requiredType.isArray()) [ FD ]
Line_41 $$ standardConversion = true-->Line_48 $$ standardConversion = true[ FD ]
Line_42 $$ if (convertedValue instanceof Map) -->Line_43 $$ convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)[ CD ]
Line_91 $$ StringBuilder msg = new StringBuilder()-->Line_99 $$ throw new IllegalArgumentException(msg.toString())[ FD ]
Line_16 $$ Object convertedValue = newValue-->Line_56 $$ return BeanUtils.instantiateClass(strCtor, convertedValue)[ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_59 $$ logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)[ FD ]
Line_73 $$ if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) -->Line_75 $$ standardConversion = true[ CD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_8 $$ if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) [ FD ]
Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)-->Line_38 $$ return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())[ FD ]
Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_51 $$ return (T) convertedValue.toString()[ FD ]
Line_32 $$ if (Object.class == requiredType) -->Line_34 $$ if (requiredType.isArray()) [ CD ]
Line_16 $$ Object convertedValue = newValue-->Line_50 $$ if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) [ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_32 $$ if (Object.class == requiredType) [ FD ]
Line_91 $$ StringBuilder msg = new StringBuilder()-->Line_102 $$ throw new IllegalStateException(msg.toString())[ FD ]
Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)-->Line_52 $$ if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) [ FD ]
Line_91 $$ StringBuilder msg = new StringBuilder()-->Line_92 $$ msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))[ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_43 $$ convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)[ FD ]
Line_47 $$ convertedValue = Array.get(convertedValue, 0)-->Line_50 $$ if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) [ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_78 $$ if (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) [ FD ]
Line_4 $$ ConversionFailedException conversionAttemptEx = null-->Line_106 $$ if (conversionAttemptEx != null) [ FD ]
Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_46 $$ if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) [ FD ]
Line_16 $$ Object convertedValue = newValue-->Line_79 $$ convertedValue = javaUtilOptionalEmpty[ FD ]
Line_42 $$ if (convertedValue instanceof Map) -->Line_44 $$ standardConversion = true[ CD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_30 $$ if (requiredType != null) [ CD ]
Line_17 $$ if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) -->Line_24 $$ if (editor == null) [ CD ]
Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)-->Line_56 $$ return BeanUtils.instantiateClass(strCtor, convertedValue)[ FD ]
Line_16 $$ Object convertedValue = newValue-->Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)[ FD ]
Line_47 $$ convertedValue = Array.get(convertedValue, 0)-->Line_56 $$ return BeanUtils.instantiateClass(strCtor, convertedValue)[ FD ]
Line_4 $$ ConversionFailedException conversionAttemptEx = null-->Line_110 $$ logger.debug("Original ConversionService attempt failed - ignored since " + "PropertyEditor based conversion eventually succeeded", conversionAttemptEx)[ FD ]
Line_32 $$ if (Object.class == requiredType) -->Line_33 $$ return (T) convertedValue[ CD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_88 $$ return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)[ FD ]
Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_38 $$ return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())[ FD ]
Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_51 $$ return (T) convertedValue.toString()[ FD ]
Line_40 $$ convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_42 $$ if (convertedValue instanceof Map) [ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_3 $$ PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)[ CD ]
Line_44 $$ standardConversion = true-->Line_48 $$ standardConversion = true[ FD ]
Line_18 $$ if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) -->Line_19 $$ TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()[ CD ]
Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_40 $$ convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)[ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_40 $$ convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)[ FD ]
Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)[ FD ]
Line_16 $$ Object convertedValue = newValue-->Line_74 $$ convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType)[ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_38 $$ return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())[ FD ]
Line_7 $$ TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)-->Line_8 $$ if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) [ FD ]
Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_74 $$ convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType)[ FD ]
Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_40 $$ convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)[ FD ]
Line_106 $$ if (conversionAttemptEx != null) -->Line_107 $$ if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) [ CD ]
Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_52 $$ if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) [ FD ]
Line_43 $$ convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_52 $$ if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) [ FD ]
Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_56 $$ return BeanUtils.instantiateClass(strCtor, convertedValue)[ FD ]
Line_3 $$ PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)-->Line_25 $$ editor = findDefaultEditor(requiredType)[ FD ]
Line_12 $$ conversionAttemptEx = ex-->Line_83 $$ if (conversionAttemptEx != null) [ FD ]
Line_39 $$ if (convertedValue instanceof Collection) -->Line_40 $$ convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)[ CD ]
Line_43 $$ convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_47 $$ convertedValue = Array.get(convertedValue, 0)[ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_30 $$ if (requiredType != null) [ FD ]
Line_16 $$ Object convertedValue = newValue-->Line_43 $$ convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)[ FD ]
Line_72 $$ standardConversion = true-->Line_107 $$ if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) [ FD ]
Line_97 $$ if (editor != null) -->Line_98 $$ msg.append(": PropertyEditor [").append(editor.getClass().getName()).append("] returned inappropriate value of type [").append(ClassUtils.getDescriptiveType(convertedValue)).append("]")[ CD ]
Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_43 $$ convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)[ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_18 $$ if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) [ FD ]
Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_79 $$ convertedValue = javaUtilOptionalEmpty[ FD ]
Line_47 $$ convertedValue = Array.get(convertedValue, 0)-->Line_98 $$ msg.append(": PropertyEditor [").append(editor.getClass().getName()).append("] returned inappropriate value of type [").append(ClassUtils.getDescriptiveType(convertedValue)).append("]")[ FD ]
Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_98 $$ msg.append(": PropertyEditor [").append(editor.getClass().getName()).append("] returned inappropriate value of type [").append(ClassUtils.getDescriptiveType(convertedValue)).append("]")[ FD ]
Line_82 $$ if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) -->Line_94 $$ if (propertyName != null) [ CD ]
Line_91 $$ StringBuilder msg = new StringBuilder()-->Line_95 $$ msg.append(" for property '").append(propertyName).append("'")[ FD ]
Line_52 $$ if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) -->Line_53 $$ if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) [ CD ]
Line_35 $$ if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) -->Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)[ CD ]
Line_47 $$ convertedValue = Array.get(convertedValue, 0)-->Line_51 $$ return (T) convertedValue.toString()[ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_16 $$ Object convertedValue = newValue[ CD ]
Line_43 $$ convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_79 $$ convertedValue = javaUtilOptionalEmpty[ FD ]
Line_40 $$ convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_79 $$ convertedValue = javaUtilOptionalEmpty[ FD ]
Line_5 $$ ConversionService conversionService = this.propertyEditorRegistry.getConversionService()-->Line_87 $$ if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) [ FD ]
Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)-->Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)[ FD ]
Line_43 $$ convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_71 $$ convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)[ FD ]
Line_71 $$ convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)-->Line_79 $$ convertedValue = javaUtilOptionalEmpty[ FD ]
Line_4 $$ ConversionFailedException conversionAttemptEx = null-->Line_83 $$ if (conversionAttemptEx != null) [ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_6 $$ if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) [ CD ]
Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_79 $$ convertedValue = javaUtilOptionalEmpty[ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_112 $$ return (T) convertedValue[ CD ]
Line_47 $$ convertedValue = Array.get(convertedValue, 0)-->Line_79 $$ convertedValue = javaUtilOptionalEmpty[ FD ]
Line_17 $$ if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) -->Line_18 $$ if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) [ CD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_55 $$ Constructor<T> strCtor = requiredType.getConstructor(String.class)[ FD ]
Line_29 $$ boolean standardConversion = false-->Line_44 $$ standardConversion = true[ FD ]
Line_7 $$ TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)-->Line_87 $$ if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) [ FD ]
Line_16 $$ Object convertedValue = newValue-->Line_39 $$ if (convertedValue instanceof Collection) [ FD ]
Line_55 $$ Constructor<T> strCtor = requiredType.getConstructor(String.class)-->Line_56 $$ return BeanUtils.instantiateClass(strCtor, convertedValue)[ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_17 $$ if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) [ FD ]
Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)-->Line_39 $$ if (convertedValue instanceof Collection) [ FD ]
Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)-->Line_50 $$ if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) [ FD ]
Line_44 $$ standardConversion = true-->Line_72 $$ standardConversion = true[ FD ]
Line_24 $$ if (editor == null) -->Line_25 $$ editor = findDefaultEditor(requiredType)[ CD ]
Line_47 $$ convertedValue = Array.get(convertedValue, 0)-->Line_74 $$ convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType)[ FD ]
Line_31 $$ if (convertedValue != null) -->Line_50 $$ if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) [ CD ]
Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_42 $$ if (convertedValue instanceof Map) [ FD ]
Line_16 $$ Object convertedValue = newValue-->Line_82 $$ if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) [ FD ]
Line_40 $$ convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_82 $$ if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) [ FD ]
Line_40 $$ convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_98 $$ msg.append(": PropertyEditor [").append(editor.getClass().getName()).append("] returned inappropriate value of type [").append(ClassUtils.getDescriptiveType(convertedValue)).append("]")[ FD ]
Line_16 $$ Object convertedValue = newValue-->Line_51 $$ return (T) convertedValue.toString()[ FD ]
Line_16 $$ Object convertedValue = newValue-->Line_71 $$ convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)[ FD ]
Line_29 $$ boolean standardConversion = false-->Line_75 $$ standardConversion = true[ FD ]
Line_31 $$ if (convertedValue != null) -->Line_78 $$ if (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) [ CD ]
Line_97 $$ if (editor != null) -->Line_101 $$ msg.append(": no matching editors or conversion strategy found")[ CD ]
Line_34 $$ if (requiredType.isArray()) -->Line_39 $$ if (convertedValue instanceof Collection) [ CD ]
Line_3 $$ PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)-->Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)[ FD ]
Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)-->Line_74 $$ convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType)[ FD ]
Line_48 $$ standardConversion = true-->Line_75 $$ standardConversion = true[ FD ]
Line_7 $$ TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)-->Line_88 $$ return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)[ FD ]
Line_48 $$ standardConversion = true-->Line_72 $$ standardConversion = true[ FD ]
Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_74 $$ convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType)[ FD ]
Line_3 $$ PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)-->Line_97 $$ if (editor != null) [ FD ]
Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)-->Line_82 $$ if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) [ FD ]
Line_79 $$ convertedValue = javaUtilOptionalEmpty-->Line_98 $$ msg.append(": PropertyEditor [").append(editor.getClass().getName()).append("] returned inappropriate value of type [").append(ClassUtils.getDescriptiveType(convertedValue)).append("]")[ FD ]
Line_74 $$ convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType)-->Line_82 $$ if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) [ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_10 $$ return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)[ FD ]
Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_31 $$ if (convertedValue != null) [ FD ]
Line_20 $$ if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) -->Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)[ CD ]
Line_3 $$ PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)-->Line_24 $$ if (editor == null) [ FD ]
Line_43 $$ convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_74 $$ convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType)[ FD ]
Line_16 $$ Object convertedValue = newValue-->Line_47 $$ convertedValue = Array.get(convertedValue, 0)[ FD ]
Line_58 $$ if (logger.isTraceEnabled()) -->Line_59 $$ logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)[ CD ]
Line_41 $$ standardConversion = true-->Line_72 $$ standardConversion = true[ FD ]
Line_72 $$ standardConversion = true-->Line_75 $$ standardConversion = true[ FD ]
Line_47 $$ convertedValue = Array.get(convertedValue, 0)-->Line_82 $$ if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) [ FD ]
Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)-->Line_98 $$ msg.append(": PropertyEditor [").append(editor.getClass().getName()).append("] returned inappropriate value of type [").append(ClassUtils.getDescriptiveType(convertedValue)).append("]")[ FD ]
Line_73 $$ if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) -->Line_74 $$ convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType)[ CD ]
Line_74 $$ convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType)-->Line_98 $$ msg.append(": PropertyEditor [").append(editor.getClass().getName()).append("] returned inappropriate value of type [").append(ClassUtils.getDescriptiveType(convertedValue)).append("]")[ FD ]
Line_16 $$ Object convertedValue = newValue-->Line_17 $$ if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) [ FD ]
Line_40 $$ convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_50 $$ if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) [ FD ]
Line_41 $$ standardConversion = true-->Line_75 $$ standardConversion = true[ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_95 $$ msg.append(" for property '").append(propertyName).append("'")[ FD ]
Line_82 $$ if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) -->Line_97 $$ if (editor != null) [ CD ]
Line_106 $$ if (conversionAttemptEx != null) -->Line_110 $$ logger.debug("Original ConversionService attempt failed - ignored since " + "PropertyEditor based conversion eventually succeeded", conversionAttemptEx)[ CD ]
Line_34 $$ if (requiredType.isArray()) -->Line_38 $$ return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())[ CD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_3 $$ PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)[ FD ]
Line_34 $$ if (requiredType.isArray()) -->Line_35 $$ if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) [ CD ]
Line_91 $$ StringBuilder msg = new StringBuilder()-->Line_93 $$ msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")[ FD ]
Line_75 $$ standardConversion = true-->Line_107 $$ if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) [ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_82 $$ if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) [ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_29 $$ boolean standardConversion = false[ CD ]
Line_39 $$ if (convertedValue instanceof Collection) -->Line_42 $$ if (convertedValue instanceof Map) [ CD ]
Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)-->Line_42 $$ if (convertedValue instanceof Map) [ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_68 $$ if (requiredType.isEnum() && "".equals(trimmedValue)) [ FD ]
Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_43 $$ convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)[ FD ]
Line_27 $$ convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)-->Line_43 $$ convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)[ FD ]
Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_71 $$ convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)[ FD ]
Line_44 $$ standardConversion = true-->Line_107 $$ if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) [ FD ]
Line_29 $$ boolean standardConversion = false-->Line_72 $$ standardConversion = true[ FD ]
Line_5 $$ ConversionService conversionService = this.propertyEditorRegistry.getConversionService()-->Line_8 $$ if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) [ FD ]
Line_29 $$ boolean standardConversion = false-->Line_107 $$ if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) [ FD ]
Line_16 $$ Object convertedValue = newValue-->Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)[ FD ]
Line_47 $$ convertedValue = Array.get(convertedValue, 0)-->Line_71 $$ convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)[ FD ]
Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_56 $$ return BeanUtils.instantiateClass(strCtor, convertedValue)[ FD ]
Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_39 $$ if (convertedValue instanceof Collection) [ FD ]
Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_42 $$ if (convertedValue instanceof Map) [ FD ]
Line_94 $$ if (propertyName != null) -->Line_95 $$ msg.append(" for property '").append(propertyName).append("'")[ CD ]
Line_18 $$ if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) -->Line_20 $$ if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) [ CD ]
Line_19 $$ TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()-->Line_20 $$ if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) [ FD ]
Line_79 $$ convertedValue = javaUtilOptionalEmpty-->Line_82 $$ if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) [ FD ]
Line_46 $$ if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) -->Line_47 $$ convertedValue = Array.get(convertedValue, 0)[ CD ]
Line_44 $$ standardConversion = true-->Line_75 $$ standardConversion = true[ FD ]
Line_43 $$ convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_50 $$ if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) [ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_4 $$ ConversionFailedException conversionAttemptEx = null[ CD ]
Line_16 $$ Object convertedValue = newValue-->Line_31 $$ if (convertedValue != null) [ FD ]
Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_39 $$ if (convertedValue instanceof Collection) [ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_63 $$ logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)[ FD ]
Line_67 $$ String trimmedValue = ((String) convertedValue).trim()-->Line_68 $$ if (requiredType.isEnum() && "".equals(trimmedValue)) [ FD ]
Line_85 $$ if (conversionService != null) -->Line_87 $$ if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) [ CD ]
Line_5 $$ ConversionService conversionService = this.propertyEditorRegistry.getConversionService()-->Line_10 $$ return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)[ FD ]
Line_52 $$ if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) -->Line_68 $$ if (requiredType.isEnum() && "".equals(trimmedValue)) [ CD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_73 $$ if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) [ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_92 $$ msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))[ FD ]
Line_3 $$ PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)-->Line_98 $$ msg.append(": PropertyEditor [").append(editor.getClass().getName()).append("] returned inappropriate value of type [").append(ClassUtils.getDescriptiveType(convertedValue)).append("]")[ FD ]
Line_12 $$ conversionAttemptEx = ex-->Line_106 $$ if (conversionAttemptEx != null) [ FD ]
Line_74 $$ convertedValue = NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class<Number>) requiredType)-->Line_79 $$ convertedValue = javaUtilOptionalEmpty[ FD ]
Line_21 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)[ FD ]
Line_50 $$ if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) -->Line_51 $$ return (T) convertedValue.toString()[ CD ]
Line_47 $$ convertedValue = Array.get(convertedValue, 0)-->Line_52 $$ if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) [ FD ]
Line_40 $$ convertedValue = convertToTypedCollection((Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_56 $$ return BeanUtils.instantiateClass(strCtor, convertedValue)[ FD ]
Line_2 $$ public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException -->Line_19 $$ TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()[ FD ]
Line_36 $$ convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)-->Line_50 $$ if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) [ FD ]
Line_30 $$ if (requiredType != null) -->Line_31 $$ if (convertedValue != null) [ CD ]
Line_41 $$ standardConversion = true-->Line_44 $$ standardConversion = true[ FD ]
Line_43 $$ convertedValue = convertToTypedMap((Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)-->Line_46 $$ if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) [ FD ]
