Line_6 $$ Path file = new Path(dir, "testbinary.seq")-->Line_48 $$ SequenceFileInputFormat.addInputPath(job, file)[ FD ]
Line_2 $$ public void testBinary() throws IOException -->Line_18 $$ SequenceFileAsBinaryOutputFormat.setSequenceFileOutputValueClass(job, DoubleWritable.class)[ CD ]
Line_2 $$ public void testBinary() throws IOException -->Line_19 $$ SequenceFileAsBinaryOutputFormat.setCompressOutput(job, true)[ CD ]
Line_3 $$ JobConf job = new JobConf()-->Line_17 $$ SequenceFileAsBinaryOutputFormat.setSequenceFileOutputKeyClass(job, IntWritable.class)[ FD ]
Line_7 $$ Random r = new Random()-->Line_30 $$ iwritable = new IntWritable(r.nextInt())[ FD ]
Line_2 $$ public void testBinary() throws IOException -->Line_27 $$ LOG.info("Creating data by SequenceFileAsBinaryOutputFormat")[ CD ]
Line_29 $$ for (int i = 0; i < RECORDS; ++i) -->Line_31 $$ iwritable.write(outbuf)[ CD ]
Line_3 $$ JobConf job = new JobConf()-->Line_48 $$ SequenceFileInputFormat.addInputPath(job, file)[ FD ]
Line_54 $$ double sourceDouble-->Line_57 $$ sourceDouble = r.nextDouble()[ FD ]
Line_3 $$ JobConf job = new JobConf()-->Line_23 $$ RecordWriter<BytesWritable, BytesWritable> writer = new SequenceFileAsBinaryOutputFormat().getRecordWriter(fs, job, file.toString(), Reporter.NULL)[ FD ]
Line_26 $$ DataOutputBuffer outbuf = new DataOutputBuffer()-->Line_32 $$ bkey.set(outbuf.getData(), 0, outbuf.getLength())[ FD ]
Line_2 $$ public void testBinary() throws IOException -->Line_6 $$ Path file = new Path(dir, "testbinary.seq")[ CD ]
Line_23 $$ RecordWriter<BytesWritable, BytesWritable> writer = new SequenceFileAsBinaryOutputFormat().getRecordWriter(fs, job, file.toString(), Reporter.NULL)-->Line_38 $$ writer.write(bkey, bval)[ FD ]
Line_4 $$ FileSystem fs = FileSystem.getLocal(job)-->Line_11 $$ if (!fs.mkdirs(dir)) [ FD ]
Line_8 $$ long seed = r.nextLong()-->Line_9 $$ r.setSeed(seed)[ FD ]
Line_2 $$ public void testBinary() throws IOException -->Line_3 $$ JobConf job = new JobConf()[ CD ]
Line_55 $$ while (reader.next(iwritable, dwritable)) -->Line_59 $$ assertTrue("Vals don't match: " + "*" + dwritable.get() + ":" + sourceDouble + "*", Double.compare(dwritable.get(), sourceDouble) == 0)[ CD ]
Line_3 $$ JobConf job = new JobConf()-->Line_19 $$ SequenceFileAsBinaryOutputFormat.setCompressOutput(job, true)[ FD ]
Line_26 $$ DataOutputBuffer outbuf = new DataOutputBuffer()-->Line_35 $$ dwritable.write(outbuf)[ FD ]
Line_2 $$ public void testBinary() throws IOException -->Line_45 $$ r.setSeed(seed)[ CD ]
Line_7 $$ Random r = new Random()-->Line_45 $$ r.setSeed(seed)[ FD ]
Line_11 $$ if (!fs.mkdirs(dir)) -->Line_12 $$ fail("Failed to create output directory")[ CD ]
Line_2 $$ public void testBinary() throws IOException -->Line_66 $$ assertEquals("Some records not found", RECORDS, count)[ CD ]
Line_50 $$ for (InputSplit split : iformat.getSplits(job, NUM_SPLITS)) -->Line_51 $$ RecordReader<IntWritable, DoubleWritable> reader = iformat.getRecordReader(split, job, Reporter.NULL)[ FD ]
Line_5 $$ Path dir = new Path(new Path(new Path(System.getProperty("test.build.data", ".")), FileOutputCommitter.TEMP_DIR_NAME), "_" + attempt)-->Line_15 $$ FileOutputFormat.setOutputPath(job, dir.getParent().getParent())[ FD ]
Line_2 $$ public void testBinary() throws IOException -->Line_15 $$ FileOutputFormat.setOutputPath(job, dir.getParent().getParent())[ CD ]
Line_2 $$ public void testBinary() throws IOException -->Line_26 $$ DataOutputBuffer outbuf = new DataOutputBuffer()[ CD ]
Line_24 $$ IntWritable iwritable = new IntWritable()-->Line_30 $$ iwritable = new IntWritable(r.nextInt())[ FD ]
Line_6 $$ Path file = new Path(dir, "testbinary.seq")-->Line_23 $$ RecordWriter<BytesWritable, BytesWritable> writer = new SequenceFileAsBinaryOutputFormat().getRecordWriter(fs, job, file.toString(), Reporter.NULL)[ FD ]
Line_51 $$ RecordReader<IntWritable, DoubleWritable> reader = iformat.getRecordReader(split, job, Reporter.NULL)-->Line_63 $$ reader.close()[ FD ]
Line_2 $$ public void testBinary() throws IOException -->Line_17 $$ SequenceFileAsBinaryOutputFormat.setSequenceFileOutputKeyClass(job, IntWritable.class)[ CD ]
Line_2 $$ public void testBinary() throws IOException -->Line_43 $$ InputFormat<IntWritable, DoubleWritable> iformat = new SequenceFileInputFormat<IntWritable, DoubleWritable>()[ CD ]
Line_2 $$ public void testBinary() throws IOException -->Line_16 $$ FileOutputFormat.setWorkOutputPath(job, dir)[ CD ]
Line_55 $$ while (reader.next(iwritable, dwritable)) -->Line_56 $$ sourceInt = r.nextInt()[ CD ]
Line_21 $$ BytesWritable bkey = new BytesWritable()-->Line_32 $$ bkey.set(outbuf.getData(), 0, outbuf.getLength())[ FD ]
Line_2 $$ public void testBinary() throws IOException -->Line_44 $$ int count = 0[ CD ]
Line_2 $$ public void testBinary() throws IOException -->Line_5 $$ Path dir = new Path(new Path(new Path(System.getProperty("test.build.data", ".")), FileOutputCommitter.TEMP_DIR_NAME), "_" + attempt)[ CD ]
Line_26 $$ DataOutputBuffer outbuf = new DataOutputBuffer()-->Line_31 $$ iwritable.write(outbuf)[ FD ]
Line_24 $$ IntWritable iwritable = new IntWritable()-->Line_58 $$ assertEquals("Keys don't match: " + "*" + iwritable.get() + ":" + sourceInt + "*", sourceInt, iwritable.get())[ FD ]
Line_7 $$ Random r = new Random()-->Line_56 $$ sourceInt = r.nextInt()[ FD ]
Line_3 $$ JobConf job = new JobConf()-->Line_15 $$ FileOutputFormat.setOutputPath(job, dir.getParent().getParent())[ FD ]
Line_2 $$ public void testBinary() throws IOException -->Line_4 $$ FileSystem fs = FileSystem.getLocal(job)[ CD ]
Line_22 $$ BytesWritable bval = new BytesWritable()-->Line_38 $$ writer.write(bkey, bval)[ FD ]
Line_2 $$ public void testBinary() throws IOException -->Line_10 $$ fs.delete(dir, true)[ CD ]
Line_44 $$ int count = 0-->Line_60 $$ ++count[ FD ]
Line_2 $$ public void testBinary() throws IOException -->Line_11 $$ if (!fs.mkdirs(dir)) [ CD ]
Line_55 $$ while (reader.next(iwritable, dwritable)) -->Line_58 $$ assertEquals("Keys don't match: " + "*" + iwritable.get() + ":" + sourceInt + "*", sourceInt, iwritable.get())[ CD ]
Line_5 $$ Path dir = new Path(new Path(new Path(System.getProperty("test.build.data", ".")), FileOutputCommitter.TEMP_DIR_NAME), "_" + attempt)-->Line_10 $$ fs.delete(dir, true)[ FD ]
Line_3 $$ JobConf job = new JobConf()-->Line_4 $$ FileSystem fs = FileSystem.getLocal(job)[ FD ]
Line_34 $$ dwritable = new DoubleWritable(r.nextDouble())-->Line_35 $$ dwritable.write(outbuf)[ FD ]
Line_8 $$ long seed = r.nextLong()-->Line_45 $$ r.setSeed(seed)[ FD ]
Line_30 $$ iwritable = new IntWritable(r.nextInt())-->Line_31 $$ iwritable.write(outbuf)[ FD ]
Line_26 $$ DataOutputBuffer outbuf = new DataOutputBuffer()-->Line_33 $$ outbuf.reset()[ FD ]
Line_2 $$ public void testBinary() throws IOException -->Line_22 $$ BytesWritable bval = new BytesWritable()[ CD ]
Line_2 $$ public void testBinary() throws IOException -->Line_49 $$ LOG.info("Reading data by SequenceFileInputFormat")[ CD ]
Line_3 $$ JobConf job = new JobConf()-->Line_16 $$ FileOutputFormat.setWorkOutputPath(job, dir)[ FD ]
Line_2 $$ public void testBinary() throws IOException -->Line_47 $$ final int NUM_SPLITS = 3[ CD ]
Line_2 $$ public void testBinary() throws IOException -->Line_21 $$ BytesWritable bkey = new BytesWritable()[ CD ]
Line_43 $$ InputFormat<IntWritable, DoubleWritable> iformat = new SequenceFileInputFormat<IntWritable, DoubleWritable>()-->Line_51 $$ RecordReader<IntWritable, DoubleWritable> reader = iformat.getRecordReader(split, job, Reporter.NULL)[ FD ]
Line_2 $$ public void testBinary() throws IOException -->Line_25 $$ DoubleWritable dwritable = new DoubleWritable()[ CD ]
Line_26 $$ DataOutputBuffer outbuf = new DataOutputBuffer()-->Line_37 $$ outbuf.reset()[ FD ]
Line_2 $$ public void testBinary() throws IOException -->Line_14 $$ job.set(JobContext.TASK_ATTEMPT_ID, attempt)[ CD ]
Line_3 $$ JobConf job = new JobConf()-->Line_50 $$ for (InputSplit split : iformat.getSplits(job, NUM_SPLITS)) [ FD ]
Line_3 $$ JobConf job = new JobConf()-->Line_51 $$ RecordReader<IntWritable, DoubleWritable> reader = iformat.getRecordReader(split, job, Reporter.NULL)[ FD ]
Line_29 $$ for (int i = 0; i < RECORDS; ++i) -->Line_38 $$ writer.write(bkey, bval)[ CD ]
Line_34 $$ dwritable = new DoubleWritable(r.nextDouble())-->Line_55 $$ while (reader.next(iwritable, dwritable)) [ FD ]
Line_3 $$ JobConf job = new JobConf()-->Line_14 $$ job.set(JobContext.TASK_ATTEMPT_ID, attempt)[ FD ]
Line_7 $$ Random r = new Random()-->Line_8 $$ long seed = r.nextLong()[ FD ]
Line_3 $$ JobConf job = new JobConf()-->Line_20 $$ SequenceFileAsBinaryOutputFormat.setOutputCompressionType(job, CompressionType.BLOCK)[ FD ]
Line_29 $$ for (int i = 0; i < RECORDS; ++i) -->Line_33 $$ outbuf.reset()[ CD ]
Line_51 $$ RecordReader<IntWritable, DoubleWritable> reader = iformat.getRecordReader(split, job, Reporter.NULL)-->Line_55 $$ while (reader.next(iwritable, dwritable)) [ FD ]
Line_57 $$ sourceDouble = r.nextDouble()-->Line_59 $$ assertTrue("Vals don't match: " + "*" + dwritable.get() + ":" + sourceDouble + "*", Double.compare(dwritable.get(), sourceDouble) == 0)[ FD ]
Line_29 $$ for (int i = 0; i < RECORDS; ++i) -->Line_32 $$ bkey.set(outbuf.getData(), 0, outbuf.getLength())[ CD ]
Line_24 $$ IntWritable iwritable = new IntWritable()-->Line_55 $$ while (reader.next(iwritable, dwritable)) [ FD ]
Line_34 $$ dwritable = new DoubleWritable(r.nextDouble())-->Line_59 $$ assertTrue("Vals don't match: " + "*" + dwritable.get() + ":" + sourceDouble + "*", Double.compare(dwritable.get(), sourceDouble) == 0)[ FD ]
Line_4 $$ FileSystem fs = FileSystem.getLocal(job)-->Line_23 $$ RecordWriter<BytesWritable, BytesWritable> writer = new SequenceFileAsBinaryOutputFormat().getRecordWriter(fs, job, file.toString(), Reporter.NULL)[ FD ]
Line_30 $$ iwritable = new IntWritable(r.nextInt())-->Line_58 $$ assertEquals("Keys don't match: " + "*" + iwritable.get() + ":" + sourceInt + "*", sourceInt, iwritable.get())[ FD ]
Line_7 $$ Random r = new Random()-->Line_9 $$ r.setSeed(seed)[ FD ]
Line_2 $$ public void testBinary() throws IOException -->Line_7 $$ Random r = new Random()[ CD ]
Line_23 $$ RecordWriter<BytesWritable, BytesWritable> writer = new SequenceFileAsBinaryOutputFormat().getRecordWriter(fs, job, file.toString(), Reporter.NULL)-->Line_41 $$ writer.close(Reporter.NULL)[ FD ]
Line_5 $$ Path dir = new Path(new Path(new Path(System.getProperty("test.build.data", ".")), FileOutputCommitter.TEMP_DIR_NAME), "_" + attempt)-->Line_11 $$ if (!fs.mkdirs(dir)) [ FD ]
Line_22 $$ BytesWritable bval = new BytesWritable()-->Line_36 $$ bval.set(outbuf.getData(), 0, outbuf.getLength())[ FD ]
Line_55 $$ while (reader.next(iwritable, dwritable)) -->Line_60 $$ ++count[ CD ]
Line_7 $$ Random r = new Random()-->Line_34 $$ dwritable = new DoubleWritable(r.nextDouble())[ FD ]
Line_47 $$ final int NUM_SPLITS = 3-->Line_50 $$ for (InputSplit split : iformat.getSplits(job, NUM_SPLITS)) [ FD ]
Line_29 $$ for (int i = 0; i < RECORDS; ++i) -->Line_34 $$ dwritable = new DoubleWritable(r.nextDouble())[ CD ]
Line_54 $$ double sourceDouble-->Line_59 $$ assertTrue("Vals don't match: " + "*" + dwritable.get() + ":" + sourceDouble + "*", Double.compare(dwritable.get(), sourceDouble) == 0)[ FD ]
Line_4 $$ FileSystem fs = FileSystem.getLocal(job)-->Line_10 $$ fs.delete(dir, true)[ FD ]
Line_2 $$ public void testBinary() throws IOException -->Line_48 $$ SequenceFileInputFormat.addInputPath(job, file)[ CD ]
Line_2 $$ public void testBinary() throws IOException -->Line_8 $$ long seed = r.nextLong()[ CD ]
Line_53 $$ int sourceInt-->Line_58 $$ assertEquals("Keys don't match: " + "*" + iwritable.get() + ":" + sourceInt + "*", sourceInt, iwritable.get())[ FD ]
Line_21 $$ BytesWritable bkey = new BytesWritable()-->Line_38 $$ writer.write(bkey, bval)[ FD ]
Line_43 $$ InputFormat<IntWritable, DoubleWritable> iformat = new SequenceFileInputFormat<IntWritable, DoubleWritable>()-->Line_50 $$ for (InputSplit split : iformat.getSplits(job, NUM_SPLITS)) [ FD ]
Line_3 $$ JobConf job = new JobConf()-->Line_18 $$ SequenceFileAsBinaryOutputFormat.setSequenceFileOutputValueClass(job, DoubleWritable.class)[ FD ]
Line_56 $$ sourceInt = r.nextInt()-->Line_58 $$ assertEquals("Keys don't match: " + "*" + iwritable.get() + ":" + sourceInt + "*", sourceInt, iwritable.get())[ FD ]
Line_55 $$ while (reader.next(iwritable, dwritable)) -->Line_57 $$ sourceDouble = r.nextDouble()[ CD ]
Line_7 $$ Random r = new Random()-->Line_57 $$ sourceDouble = r.nextDouble()[ FD ]
Line_30 $$ iwritable = new IntWritable(r.nextInt())-->Line_55 $$ while (reader.next(iwritable, dwritable)) [ FD ]
Line_24 $$ IntWritable iwritable = new IntWritable()-->Line_31 $$ iwritable.write(outbuf)[ FD ]
Line_25 $$ DoubleWritable dwritable = new DoubleWritable()-->Line_34 $$ dwritable = new DoubleWritable(r.nextDouble())[ FD ]
Line_29 $$ for (int i = 0; i < RECORDS; ++i) -->Line_36 $$ bval.set(outbuf.getData(), 0, outbuf.getLength())[ CD ]
Line_2 $$ public void testBinary() throws IOException -->Line_23 $$ RecordWriter<BytesWritable, BytesWritable> writer = new SequenceFileAsBinaryOutputFormat().getRecordWriter(fs, job, file.toString(), Reporter.NULL)[ CD ]
Line_29 $$ for (int i = 0; i < RECORDS; ++i) -->Line_37 $$ outbuf.reset()[ CD ]
Line_2 $$ public void testBinary() throws IOException -->Line_20 $$ SequenceFileAsBinaryOutputFormat.setOutputCompressionType(job, CompressionType.BLOCK)[ CD ]
Line_2 $$ public void testBinary() throws IOException -->Line_9 $$ r.setSeed(seed)[ CD ]
Line_44 $$ int count = 0-->Line_66 $$ assertEquals("Some records not found", RECORDS, count)[ FD ]
Line_29 $$ for (int i = 0; i < RECORDS; ++i) -->Line_30 $$ iwritable = new IntWritable(r.nextInt())[ CD ]
Line_53 $$ int sourceInt-->Line_56 $$ sourceInt = r.nextInt()[ FD ]
Line_2 $$ public void testBinary() throws IOException -->Line_24 $$ IntWritable iwritable = new IntWritable()[ CD ]
Line_25 $$ DoubleWritable dwritable = new DoubleWritable()-->Line_59 $$ assertTrue("Vals don't match: " + "*" + dwritable.get() + ":" + sourceDouble + "*", Double.compare(dwritable.get(), sourceDouble) == 0)[ FD ]
Line_26 $$ DataOutputBuffer outbuf = new DataOutputBuffer()-->Line_36 $$ bval.set(outbuf.getData(), 0, outbuf.getLength())[ FD ]
Line_25 $$ DoubleWritable dwritable = new DoubleWritable()-->Line_55 $$ while (reader.next(iwritable, dwritable)) [ FD ]
Line_2 $$ public void testBinary() throws IOException -->Line_46 $$ DataInputBuffer buf = new DataInputBuffer()[ CD ]
Line_5 $$ Path dir = new Path(new Path(new Path(System.getProperty("test.build.data", ".")), FileOutputCommitter.TEMP_DIR_NAME), "_" + attempt)-->Line_16 $$ FileOutputFormat.setWorkOutputPath(job, dir)[ FD ]
Line_25 $$ DoubleWritable dwritable = new DoubleWritable()-->Line_35 $$ dwritable.write(outbuf)[ FD ]
Line_29 $$ for (int i = 0; i < RECORDS; ++i) -->Line_35 $$ dwritable.write(outbuf)[ CD ]
