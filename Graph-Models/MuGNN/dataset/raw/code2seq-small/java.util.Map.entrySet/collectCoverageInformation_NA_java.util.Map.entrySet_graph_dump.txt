Line_26 $$ for (int i = 0; i < childCoverageInfo.length; i++) -->Line_33 $$ parentDir.totalMethodCount += coverageInfo.totalMethodCount[ CD ]
Line_47 $$ final Boolean isInSource = DumbService.getInstance(myProject).runReadActionInSmartMode(new Computable<Boolean>() -->Line_49 $$ if (myProject.isDisposed())[ CD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_60 $$ final ModuleFileIndex fileIndex = ModuleRootManager.getInstance(module).getFileIndex()[ FD ]
Line_111 $$ if (isTestHierarchy) -->Line_114 $$ annotator.annotateSourceDirectory(dir.sourceRoot, dir, module)[ CD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_23 $$ final String childPackageVMName = packageVMName.length() > 0 ? packageVMName + "/" + childName : childName[ FD ]
Line_47 $$ final Boolean isInSource = DumbService.getInstance(myProject).runReadActionInSmartMode(new Computable<Boolean>() -->Line_60 $$ final ModuleFileIndex fileIndex = ModuleRootManager.getInstance(module).getFileIndex()[ CD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_19 $$ Map<String, ClassCoverageInfo> toplevelClassCoverage = new HashMap<String, ClassCoverageInfo>()[ CD ]
Line_24 $$ final DirCoverageInfo[] childCoverageInfo = collectCoverageInformation(child, packageCoverageMap, flattenPackageCoverageMap, projectInfo, childPackageVMName, annotator, module, trackTestFolders, isTestHierarchy)-->Line_25 $$ if (childCoverageInfo != null) [ FD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_93 $$ collectClassCoverageInformation(child, psiClassRef.get(), coverageInfoForClass, projectInfo, toplevelClassCoverage, classFqVMName.replace("/", "."), classCoverageKey)[ FD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_108 $$ PackageCoverageInfo packageCoverageInfo = getOrCreateCoverageInfo(packageCoverageMap, packageVMName)[ FD ]
Line_42 $$ final Ref<VirtualFile> containingFileRef = new Ref<VirtualFile>()-->Line_56 $$ if (containingFileRef.isNull()) [ FD ]
Line_92 $$ if (coverageInfoForClass != null) -->Line_93 $$ collectClassCoverageInformation(child, psiClassRef.get(), coverageInfoForClass, projectInfo, toplevelClassCoverage, classFqVMName.replace("/", "."), classCoverageKey)[ CD ]
Line_20 $$ for (File child : children) -->Line_38 $$ if (isClassFile(child)) [ FD ]
Line_6 $$ for (SourceFolder folder : contentEntry.getSourceFolders(isTestHierarchy ? JavaSourceRootType.TEST_SOURCE : JavaSourceRootType.SOURCE)) -->Line_7 $$ final VirtualFile file = folder.getFile()[ FD ]
Line_26 $$ for (int i = 0; i < childCoverageInfo.length; i++) -->Line_28 $$ final DirCoverageInfo parentDir = dirs.get(i)[ CD ]
Line_49 $$ if (myProject.isDisposed())-->Line_50 $$ return null[ CD ]
Line_38 $$ if (isClassFile(child)) -->Line_80 $$ if (isInSource != null && isInSource.booleanValue()) [ CD ]
Line_5 $$ for (ContentEntry contentEntry : contentEntries) -->Line_6 $$ for (SourceFolder folder : contentEntry.getSourceFolders(isTestHierarchy ? JavaSourceRootType.TEST_SOURCE : JavaSourceRootType.SOURCE)) [ FD ]
Line_26 $$ for (int i = 0; i < childCoverageInfo.length; i++) -->Line_32 $$ parentDir.coveredLineCount += coverageInfo.coveredLineCount[ CD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_40 $$ final String classFqVMName = packageVMName.length() > 0 ? packageVMName + "/" + childName : childName[ FD ]
Line_20 $$ for (File child : children) -->Line_93 $$ collectClassCoverageInformation(child, psiClassRef.get(), coverageInfoForClass, projectInfo, toplevelClassCoverage, classFqVMName.replace("/", "."), classCoverageKey)[ FD ]
Line_27 $$ DirCoverageInfo coverageInfo = childCoverageInfo[i]-->Line_101 $$ annotator.annotateClass(toplevelClassName, coverageInfo)[ FD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_103 $$ PackageCoverageInfo flattenPackageCoverageInfo = getOrCreateCoverageInfo(flattenPackageCoverageMap, packageVMName)[ CD ]
Line_20 $$ for (File child : children) -->Line_39 $$ final String childName = getClassName(child)[ FD ]
Line_26 $$ for (int i = 0; i < childCoverageInfo.length; i++) -->Line_34 $$ parentDir.coveredMethodCount += coverageInfo.coveredMethodCount[ CD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_112 $$ annotator.annotateTestDirectory(dir.sourceRoot, dir, module)[ FD ]
Line_42 $$ final Ref<VirtualFile> containingFileRef = new Ref<VirtualFile>()-->Line_55 $$ containingFileRef.set(aClass.getNavigationElement().getContainingFile().getVirtualFile())[ FD ]
Line_25 $$ if (childCoverageInfo != null) -->Line_26 $$ for (int i = 0; i < childCoverageInfo.length; i++) [ CD ]
Line_19 $$ Map<String, ClassCoverageInfo> toplevelClassCoverage = new HashMap<String, ClassCoverageInfo>()-->Line_104 $$ for (Map.Entry<String, ClassCoverageInfo> entry : toplevelClassCoverage.entrySet()) [ FD ]
Line_7 $$ final VirtualFile file = folder.getFile()-->Line_11 $$ final VirtualFile relativeSrcRoot = file.findFileByRelativePath(StringUtil.trimStart(packageVMName, prefix))[ FD ]
Line_17 $$ if (children == null)-->Line_18 $$ return null[ CD ]
Line_38 $$ if (isClassFile(child)) -->Line_47 $$ final Boolean isInSource = DumbService.getInstance(myProject).runReadActionInSmartMode(new Computable<Boolean>() [ CD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_11 $$ final VirtualFile relativeSrcRoot = file.findFileByRelativePath(StringUtil.trimStart(packageVMName, prefix))[ FD ]
Line_16 $$ final File[] children = packageOutputRoot.listFiles()-->Line_17 $$ if (children == null)[ FD ]
Line_21 $$ if (child.isDirectory()) -->Line_38 $$ if (isClassFile(child)) [ CD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_16 $$ final File[] children = packageOutputRoot.listFiles()[ FD ]
Line_19 $$ Map<String, ClassCoverageInfo> toplevelClassCoverage = new HashMap<String, ClassCoverageInfo>()-->Line_93 $$ collectClassCoverageInformation(child, psiClassRef.get(), coverageInfoForClass, projectInfo, toplevelClassCoverage, classFqVMName.replace("/", "."), classCoverageKey)[ FD ]
Line_43 $$ final Ref<PsiClass> psiClassRef = new Ref<PsiClass>()-->Line_54 $$ psiClassRef.set(aClass)[ FD ]
Line_38 $$ if (isClassFile(child)) -->Line_45 $$ if (suitesBundle == null)[ CD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_17 $$ if (children == null)[ CD ]
Line_20 $$ for (File child : children) -->Line_24 $$ final DirCoverageInfo[] childCoverageInfo = collectCoverageInformation(child, packageCoverageMap, flattenPackageCoverageMap, projectInfo, childPackageVMName, annotator, module, trackTestFolders, isTestHierarchy)[ FD ]
Line_26 $$ for (int i = 0; i < childCoverageInfo.length; i++) -->Line_27 $$ DirCoverageInfo coverageInfo = childCoverageInfo[i][ CD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_103 $$ PackageCoverageInfo flattenPackageCoverageInfo = getOrCreateCoverageInfo(flattenPackageCoverageMap, packageVMName)[ FD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_4 $$ final ContentEntry[] contentEntries = ModuleRootManager.getInstance(module).getContentEntries()[ CD ]
Line_26 $$ for (int i = 0; i < childCoverageInfo.length; i++) -->Line_29 $$ parentDir.totalClassCount += coverageInfo.totalClassCount[ CD ]
Line_56 $$ if (containingFileRef.isNull()) -->Line_58 $$ return null[ CD ]
Line_111 $$ if (isTestHierarchy) -->Line_112 $$ annotator.annotateTestDirectory(dir.sourceRoot, dir, module)[ CD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_24 $$ final DirCoverageInfo[] childCoverageInfo = collectCoverageInformation(child, packageCoverageMap, flattenPackageCoverageMap, projectInfo, childPackageVMName, annotator, module, trackTestFolders, isTestHierarchy)[ FD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_114 $$ annotator.annotateSourceDirectory(dir.sourceRoot, dir, module)[ FD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_4 $$ final ContentEntry[] contentEntries = ModuleRootManager.getInstance(module).getContentEntries()[ FD ]
Line_38 $$ if (isClassFile(child)) -->Line_65 $$ String classCoverageKey = classFqVMName.replace('/', '.')[ CD ]
Line_47 $$ final Boolean isInSource = DumbService.getInstance(myProject).runReadActionInSmartMode(new Computable<Boolean>() -->Line_56 $$ if (containingFileRef.isNull()) [ CD ]
Line_40 $$ final String classFqVMName = packageVMName.length() > 0 ? packageVMName + "/" + childName : childName-->Line_93 $$ collectClassCoverageInformation(child, psiClassRef.get(), coverageInfoForClass, projectInfo, toplevelClassCoverage, classFqVMName.replace("/", "."), classCoverageKey)[ FD ]
Line_51 $$ final PsiClass aClass = JavaPsiFacade.getInstance(myManager.getProject()).findClass(toplevelClassSrcFQName, GlobalSearchScope.moduleScope(module))-->Line_54 $$ psiClassRef.set(aClass)[ FD ]
Line_20 $$ for (File child : children) -->Line_21 $$ if (child.isDirectory()) [ FD ]
Line_44 $$ final CoverageSuitesBundle suitesBundle = myCoverageManager.getCurrentSuitesBundle()-->Line_45 $$ if (suitesBundle == null)[ FD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_3 $$ final List<DirCoverageInfo> dirs = new ArrayList<DirCoverageInfo>()[ CD ]
Line_10 $$ final String prefix = folder.getPackagePrefix().replaceAll("\\.", "/")-->Line_11 $$ final VirtualFile relativeSrcRoot = file.findFileByRelativePath(StringUtil.trimStart(packageVMName, prefix))[ FD ]
Line_26 $$ for (int i = 0; i < childCoverageInfo.length; i++) -->Line_30 $$ parentDir.coveredClassCount += coverageInfo.coveredClassCount[ CD ]
Line_44 $$ final CoverageSuitesBundle suitesBundle = myCoverageManager.getCurrentSuitesBundle()-->Line_73 $$ if (extension.keepCoverageInfoForClassWithoutSource(suitesBundle, child)) [ FD ]
Line_21 $$ if (child.isDirectory()) -->Line_24 $$ final DirCoverageInfo[] childCoverageInfo = collectCoverageInformation(child, packageCoverageMap, flattenPackageCoverageMap, projectInfo, childPackageVMName, annotator, module, trackTestFolders, isTestHierarchy)[ CD ]
Line_44 $$ final CoverageSuitesBundle suitesBundle = myCoverageManager.getCurrentSuitesBundle()-->Line_69 $$ if (extension.ignoreCoverageForClass(suitesBundle, child)) [ FD ]
Line_47 $$ final Boolean isInSource = DumbService.getInstance(myProject).runReadActionInSmartMode(new Computable<Boolean>() -->Line_54 $$ psiClassRef.set(aClass)[ CD ]
Line_56 $$ if (containingFileRef.isNull()) -->Line_57 $$ LOG.info("No virtual file found for: " + aClass)[ CD ]
Line_47 $$ final Boolean isInSource = DumbService.getInstance(myProject).runReadActionInSmartMode(new Computable<Boolean>() -->Line_55 $$ containingFileRef.set(aClass.getNavigationElement().getContainingFile().getVirtualFile())[ CD ]
Line_38 $$ if (isClassFile(child)) -->Line_40 $$ final String classFqVMName = packageVMName.length() > 0 ? packageVMName + "/" + childName : childName[ CD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_118 $$ return dirs.toArray(new DirCoverageInfo[dirs.size()])[ CD ]
Line_60 $$ final ModuleFileIndex fileIndex = ModuleRootManager.getInstance(module).getFileIndex()-->Line_61 $$ return fileIndex.isUnderSourceRootOfType(containingFileRef.get(), JavaModuleSourceRootTypes.SOURCES) && (trackTestFolders || !fileIndex.isInTestSourceContent(containingFileRef.get()))[ FD ]
Line_40 $$ final String classFqVMName = packageVMName.length() > 0 ? packageVMName + "/" + childName : childName-->Line_65 $$ String classCoverageKey = classFqVMName.replace('/', '.')[ FD ]
Line_6 $$ for (SourceFolder folder : contentEntry.getSourceFolders(isTestHierarchy ? JavaSourceRootType.TEST_SOURCE : JavaSourceRootType.SOURCE)) -->Line_10 $$ final String prefix = folder.getPackagePrefix().replaceAll("\\.", "/")[ FD ]
Line_41 $$ final String toplevelClassSrcFQName = getSourceToplevelFQName(classFqVMName)-->Line_51 $$ final PsiClass aClass = JavaPsiFacade.getInstance(myManager.getProject()).findClass(toplevelClassSrcFQName, GlobalSearchScope.moduleScope(module))[ FD ]
Line_52 $$ if (aClass == null || !aClass.isValid())-->Line_53 $$ return Boolean.FALSE[ CD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_15 $$ final PackageCoverageInfo classWithoutSourceCoverageInfo = new PackageCoverageInfo()[ CD ]
Line_47 $$ final Boolean isInSource = DumbService.getInstance(myProject).runReadActionInSmartMode(new Computable<Boolean>() -->Line_52 $$ if (aClass == null || !aClass.isValid())[ CD ]
Line_38 $$ if (isClassFile(child)) -->Line_41 $$ final String toplevelClassSrcFQName = getSourceToplevelFQName(classFqVMName)[ CD ]
Line_21 $$ if (child.isDirectory()) -->Line_23 $$ final String childPackageVMName = packageVMName.length() > 0 ? packageVMName + "/" + childName : childName[ CD ]
Line_47 $$ final Boolean isInSource = DumbService.getInstance(myProject).runReadActionInSmartMode(new Computable<Boolean>() -->Line_61 $$ return fileIndex.isUnderSourceRootOfType(containingFileRef.get(), JavaModuleSourceRootTypes.SOURCES) && (trackTestFolders || !fileIndex.isInTestSourceContent(containingFileRef.get()))[ CD ]
Line_38 $$ if (isClassFile(child)) -->Line_77 $$ if (ignoreClass) [ CD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_108 $$ PackageCoverageInfo packageCoverageInfo = getOrCreateCoverageInfo(packageCoverageMap, packageVMName)[ CD ]
Line_38 $$ if (isClassFile(child)) -->Line_39 $$ final String childName = getClassName(child)[ CD ]
Line_20 $$ for (File child : children) -->Line_69 $$ if (extension.ignoreCoverageForClass(suitesBundle, child)) [ FD ]
Line_26 $$ for (int i = 0; i < childCoverageInfo.length; i++) -->Line_31 $$ parentDir.totalLineCount += coverageInfo.totalLineCount[ CD ]
Line_21 $$ if (child.isDirectory()) -->Line_25 $$ if (childCoverageInfo != null) [ CD ]
Line_3 $$ final List<DirCoverageInfo> dirs = new ArrayList<DirCoverageInfo>()-->Line_118 $$ return dirs.toArray(new DirCoverageInfo[dirs.size()])[ FD ]
Line_40 $$ final String classFqVMName = packageVMName.length() > 0 ? packageVMName + "/" + childName : childName-->Line_41 $$ final String toplevelClassSrcFQName = getSourceToplevelFQName(classFqVMName)[ FD ]
Line_26 $$ for (int i = 0; i < childCoverageInfo.length; i++) -->Line_28 $$ final DirCoverageInfo parentDir = dirs.get(i)[ FD ]
Line_47 $$ final Boolean isInSource = DumbService.getInstance(myProject).runReadActionInSmartMode(new Computable<Boolean>() -->Line_51 $$ final PsiClass aClass = JavaPsiFacade.getInstance(myManager.getProject()).findClass(toplevelClassSrcFQName, GlobalSearchScope.moduleScope(module))[ CD ]
Line_27 $$ DirCoverageInfo coverageInfo = childCoverageInfo[i]-->Line_106 $$ flattenPackageCoverageInfo.append(coverageInfo)[ FD ]
Line_20 $$ for (File child : children) -->Line_22 $$ final String childName = child.getName()[ FD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_16 $$ final File[] children = packageOutputRoot.listFiles()[ CD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_101 $$ annotator.annotateClass(toplevelClassName, coverageInfo)[ FD ]
Line_51 $$ final PsiClass aClass = JavaPsiFacade.getInstance(myManager.getProject()).findClass(toplevelClassSrcFQName, GlobalSearchScope.moduleScope(module))-->Line_52 $$ if (aClass == null || !aClass.isValid())[ FD ]
Line_42 $$ final Ref<VirtualFile> containingFileRef = new Ref<VirtualFile>()-->Line_82 $$ if (dirCoverageInfo.sourceRoot != null && VfsUtil.isAncestor(dirCoverageInfo.sourceRoot, containingFileRef.get(), false)) [ FD ]
Line_3 $$ final List<DirCoverageInfo> dirs = new ArrayList<DirCoverageInfo>()-->Line_12 $$ dirs.add(new DirCoverageInfo(relativeSrcRoot))[ FD ]
Line_23 $$ final String childPackageVMName = packageVMName.length() > 0 ? packageVMName + "/" + childName : childName-->Line_24 $$ final DirCoverageInfo[] childCoverageInfo = collectCoverageInformation(child, packageCoverageMap, flattenPackageCoverageMap, projectInfo, childPackageVMName, annotator, module, trackTestFolders, isTestHierarchy)[ FD ]
Line_19 $$ Map<String, ClassCoverageInfo> toplevelClassCoverage = new HashMap<String, ClassCoverageInfo>()-->Line_98 $$ for (Map.Entry<String, ClassCoverageInfo> entry : toplevelClassCoverage.entrySet()) [ FD ]
Line_38 $$ if (isClassFile(child)) -->Line_43 $$ final Ref<PsiClass> psiClassRef = new Ref<PsiClass>()[ CD ]
Line_51 $$ final PsiClass aClass = JavaPsiFacade.getInstance(myManager.getProject()).findClass(toplevelClassSrcFQName, GlobalSearchScope.moduleScope(module))-->Line_55 $$ containingFileRef.set(aClass.getNavigationElement().getContainingFile().getVirtualFile())[ FD ]
Line_43 $$ final Ref<PsiClass> psiClassRef = new Ref<PsiClass>()-->Line_93 $$ collectClassCoverageInformation(child, psiClassRef.get(), coverageInfoForClass, projectInfo, toplevelClassCoverage, classFqVMName.replace("/", "."), classCoverageKey)[ FD ]
Line_42 $$ final Ref<VirtualFile> containingFileRef = new Ref<VirtualFile>()-->Line_61 $$ return fileIndex.isUnderSourceRootOfType(containingFileRef.get(), JavaModuleSourceRootTypes.SOURCES) && (trackTestFolders || !fileIndex.isInTestSourceContent(containingFileRef.get()))[ FD ]
Line_3 $$ final List<DirCoverageInfo> dirs = new ArrayList<DirCoverageInfo>()-->Line_28 $$ final DirCoverageInfo parentDir = dirs.get(i)[ FD ]
Line_21 $$ if (child.isDirectory()) -->Line_22 $$ final String childName = child.getName()[ CD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_51 $$ final PsiClass aClass = JavaPsiFacade.getInstance(myManager.getProject()).findClass(toplevelClassSrcFQName, GlobalSearchScope.moduleScope(module))[ FD ]
Line_7 $$ final VirtualFile file = folder.getFile()-->Line_8 $$ if (file == null)[ FD ]
Line_2 $$ private DirCoverageInfo[] collectCoverageInformation(final File packageOutputRoot, final Map<String, PackageCoverageInfo> packageCoverageMap, Map<String, PackageCoverageInfo> flattenPackageCoverageMap, final ProjectData projectInfo, final String packageVMName, final Annotator annotator, final Module module, final boolean trackTestFolders, final boolean isTestHierarchy) -->Line_117 $$ packageCoverageInfo.append(classWithoutSourceCoverageInfo)[ CD ]
Line_47 $$ final Boolean isInSource = DumbService.getInstance(myProject).runReadActionInSmartMode(new Computable<Boolean>() -->Line_80 $$ if (isInSource != null && isInSource.booleanValue()) [ FD ]
Line_38 $$ if (isClassFile(child)) -->Line_92 $$ if (coverageInfoForClass != null) [ CD ]
Line_38 $$ if (isClassFile(child)) -->Line_89 $$ if (coverageInfoForClass == null && keepWithoutSource) [ CD ]
Line_15 $$ final PackageCoverageInfo classWithoutSourceCoverageInfo = new PackageCoverageInfo()-->Line_117 $$ packageCoverageInfo.append(classWithoutSourceCoverageInfo)[ FD ]
Line_38 $$ if (isClassFile(child)) -->Line_42 $$ final Ref<VirtualFile> containingFileRef = new Ref<VirtualFile>()[ CD ]
Line_38 $$ if (isClassFile(child)) -->Line_44 $$ final CoverageSuitesBundle suitesBundle = myCoverageManager.getCurrentSuitesBundle()[ CD ]
Line_20 $$ for (File child : children) -->Line_73 $$ if (extension.keepCoverageInfoForClassWithoutSource(suitesBundle, child)) [ FD ]
