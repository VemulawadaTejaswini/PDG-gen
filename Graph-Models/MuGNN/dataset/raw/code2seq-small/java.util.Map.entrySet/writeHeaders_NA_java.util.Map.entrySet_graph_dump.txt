Line_27 $$ if (command.requiresContentLength()) -->Line_31 $$ output.write(LF)[ CD ]
Line_2 $$ private void writeHeaders(StompCommand command, Map<String, Object> headers, byte[] payload, DataOutputStream output) throws IOException -->Line_13 $$ if (command.requiresContentLength() && "content-length".equals(entry.getKey())) [ FD ]
Line_2 $$ private void writeHeaders(StompCommand command, Map<String, Object> headers, byte[] payload, DataOutputStream output) throws IOException -->Line_3 $$ Map<String, List<String>> nativeHeaders = (Map<String, List<String>>) headers.get(NativeMessageHeaderAccessor.NATIVE_HEADERS)[ CD ]
Line_20 $$ for (String value : values) -->Line_23 $$ output.write(encodeHeaderString(value, shouldEscape))[ FD ]
Line_2 $$ private void writeHeaders(StompCommand command, Map<String, Object> headers, byte[] payload, DataOutputStream output) throws IOException -->Line_24 $$ output.write(LF)[ FD ]
Line_2 $$ private void writeHeaders(StompCommand command, Map<String, Object> headers, byte[] payload, DataOutputStream output) throws IOException -->Line_21 $$ output.write(key)[ FD ]
Line_27 $$ if (command.requiresContentLength()) -->Line_30 $$ output.write(Integer.toString(contentLength).getBytes(StompDecoder.UTF8_CHARSET))[ CD ]
Line_2 $$ private void writeHeaders(StompCommand command, Map<String, Object> headers, byte[] payload, DataOutputStream output) throws IOException -->Line_27 $$ if (command.requiresContentLength()) [ FD ]
Line_2 $$ private void writeHeaders(StompCommand command, Map<String, Object> headers, byte[] payload, DataOutputStream output) throws IOException -->Line_29 $$ output.write("content-length:".getBytes(StompDecoder.UTF8_CHARSET))[ FD ]
Line_2 $$ private void writeHeaders(StompCommand command, Map<String, Object> headers, byte[] payload, DataOutputStream output) throws IOException -->Line_22 $$ output.write(COLON)[ FD ]
Line_2 $$ private void writeHeaders(StompCommand command, Map<String, Object> headers, byte[] payload, DataOutputStream output) throws IOException -->Line_23 $$ output.write(encodeHeaderString(value, shouldEscape))[ FD ]
Line_10 $$ boolean shouldEscape = (command != StompCommand.CONNECT && command != StompCommand.CONNECTED)-->Line_12 $$ byte[] key = encodeHeaderString(entry.getKey(), shouldEscape)[ FD ]
Line_11 $$ for (Entry<String, List<String>> entry : nativeHeaders.entrySet()) -->Line_12 $$ byte[] key = encodeHeaderString(entry.getKey(), shouldEscape)[ FD ]
Line_17 $$ if (StompCommand.CONNECT.equals(command) && StompHeaderAccessor.STOMP_PASSCODE_HEADER.equals(entry.getKey())) -->Line_18 $$ values = Arrays.asList(StompHeaderAccessor.getPasscode(headers))[ CD ]
Line_12 $$ byte[] key = encodeHeaderString(entry.getKey(), shouldEscape)-->Line_21 $$ output.write(key)[ FD ]
Line_2 $$ private void writeHeaders(StompCommand command, Map<String, Object> headers, byte[] payload, DataOutputStream output) throws IOException -->Line_31 $$ output.write(LF)[ FD ]
Line_2 $$ private void writeHeaders(StompCommand command, Map<String, Object> headers, byte[] payload, DataOutputStream output) throws IOException -->Line_3 $$ Map<String, List<String>> nativeHeaders = (Map<String, List<String>>) headers.get(NativeMessageHeaderAccessor.NATIVE_HEADERS)[ FD ]
Line_3 $$ Map<String, List<String>> nativeHeaders = (Map<String, List<String>>) headers.get(NativeMessageHeaderAccessor.NATIVE_HEADERS)-->Line_11 $$ for (Entry<String, List<String>> entry : nativeHeaders.entrySet()) [ FD ]
Line_11 $$ for (Entry<String, List<String>> entry : nativeHeaders.entrySet()) -->Line_13 $$ if (command.requiresContentLength() && "content-length".equals(entry.getKey())) [ FD ]
Line_28 $$ int contentLength = payload.length-->Line_30 $$ output.write(Integer.toString(contentLength).getBytes(StompDecoder.UTF8_CHARSET))[ FD ]
Line_2 $$ private void writeHeaders(StompCommand command, Map<String, Object> headers, byte[] payload, DataOutputStream output) throws IOException -->Line_18 $$ values = Arrays.asList(StompHeaderAccessor.getPasscode(headers))[ FD ]
Line_7 $$ if (nativeHeaders == null) -->Line_8 $$ return[ CD ]
Line_10 $$ boolean shouldEscape = (command != StompCommand.CONNECT && command != StompCommand.CONNECTED)-->Line_23 $$ output.write(encodeHeaderString(value, shouldEscape))[ FD ]
Line_11 $$ for (Entry<String, List<String>> entry : nativeHeaders.entrySet()) -->Line_16 $$ List<String> values = entry.getValue()[ FD ]
Line_2 $$ private void writeHeaders(StompCommand command, Map<String, Object> headers, byte[] payload, DataOutputStream output) throws IOException -->Line_7 $$ if (nativeHeaders == null) [ CD ]
Line_4 $$ if (logger.isTraceEnabled()) -->Line_5 $$ logger.trace("Encoding STOMP " + command + ", headers=" + nativeHeaders)[ CD ]
Line_2 $$ private void writeHeaders(StompCommand command, Map<String, Object> headers, byte[] payload, DataOutputStream output) throws IOException -->Line_27 $$ if (command.requiresContentLength()) [ CD ]
Line_16 $$ List<String> values = entry.getValue()-->Line_18 $$ values = Arrays.asList(StompHeaderAccessor.getPasscode(headers))[ FD ]
Line_27 $$ if (command.requiresContentLength()) -->Line_28 $$ int contentLength = payload.length[ CD ]
Line_2 $$ private void writeHeaders(StompCommand command, Map<String, Object> headers, byte[] payload, DataOutputStream output) throws IOException -->Line_10 $$ boolean shouldEscape = (command != StompCommand.CONNECT && command != StompCommand.CONNECTED)[ CD ]
Line_2 $$ private void writeHeaders(StompCommand command, Map<String, Object> headers, byte[] payload, DataOutputStream output) throws IOException -->Line_4 $$ if (logger.isTraceEnabled()) [ CD ]
Line_11 $$ for (Entry<String, List<String>> entry : nativeHeaders.entrySet()) -->Line_17 $$ if (StompCommand.CONNECT.equals(command) && StompHeaderAccessor.STOMP_PASSCODE_HEADER.equals(entry.getKey())) [ FD ]
Line_27 $$ if (command.requiresContentLength()) -->Line_29 $$ output.write("content-length:".getBytes(StompDecoder.UTF8_CHARSET))[ CD ]
Line_3 $$ Map<String, List<String>> nativeHeaders = (Map<String, List<String>>) headers.get(NativeMessageHeaderAccessor.NATIVE_HEADERS)-->Line_7 $$ if (nativeHeaders == null) [ FD ]
Line_2 $$ private void writeHeaders(StompCommand command, Map<String, Object> headers, byte[] payload, DataOutputStream output) throws IOException -->Line_17 $$ if (StompCommand.CONNECT.equals(command) && StompHeaderAccessor.STOMP_PASSCODE_HEADER.equals(entry.getKey())) [ FD ]
Line_2 $$ private void writeHeaders(StompCommand command, Map<String, Object> headers, byte[] payload, DataOutputStream output) throws IOException -->Line_30 $$ output.write(Integer.toString(contentLength).getBytes(StompDecoder.UTF8_CHARSET))[ FD ]
