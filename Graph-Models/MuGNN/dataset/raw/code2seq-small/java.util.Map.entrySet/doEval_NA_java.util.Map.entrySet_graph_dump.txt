Line_15 $$ for (Map.Entry<String, Object> entry : inputObjects.entrySet()) -->Line_17 $$ Object inputObject = entry.getValue()[ FD ]
Line_18 $$ if (!inputName.startsWith(StringPool.DOLLAR)) -->Line_19 $$ inputName = StringPool.DOLLAR + inputName[ CD ]
Line_6 $$ org.jruby.embed.ScriptingContainer scriptingContainer = _scriptingContainer.getWrappedScriptingContainer()-->Line_24 $$ scriptingContainer.runScriptlet(new FileInputStream(scriptFile), scriptFile.toString())[ FD ]
Line_2 $$ protected Map<String, Object> doEval(Set<String> allowedClasses, Map<String, Object> inputObjects, Set<String> outputNames, File scriptFile, String script, ClassLoader... classLoaders) throws ScriptingException -->Line_12 $$ rubyInstanceConfig.setLoader(getAggregateClassLoader(classLoaders))[ FD ]
Line_2 $$ protected Map<String, Object> doEval(Set<String> allowedClasses, Map<String, Object> inputObjects, Set<String> outputNames, File scriptFile, String script, ClassLoader... classLoaders) throws ScriptingException -->Line_6 $$ org.jruby.embed.ScriptingContainer scriptingContainer = _scriptingContainer.getWrappedScriptingContainer()[ CD ]
Line_16 $$ String inputName = entry.getKey()-->Line_19 $$ inputName = StringPool.DOLLAR + inputName[ FD ]
Line_16 $$ String inputName = entry.getKey()-->Line_18 $$ if (!inputName.startsWith(StringPool.DOLLAR)) [ FD ]
Line_17 $$ Object inputObject = entry.getValue()-->Line_21 $$ scriptingContainer.put(inputName, inputObject)[ FD ]
Line_2 $$ protected Map<String, Object> doEval(Set<String> allowedClasses, Map<String, Object> inputObjects, Set<String> outputNames, File scriptFile, String script, ClassLoader... classLoaders) throws ScriptingException -->Line_3 $$ if (allowedClasses != null) [ FD ]
Line_2 $$ protected Map<String, Object> doEval(Set<String> allowedClasses, Map<String, Object> inputObjects, Set<String> outputNames, File scriptFile, String script, ClassLoader... classLoaders) throws ScriptingException -->Line_24 $$ scriptingContainer.runScriptlet(new FileInputStream(scriptFile), scriptFile.toString())[ FD ]
Line_11 $$ if (ArrayUtil.isNotEmpty(classLoaders)) -->Line_12 $$ rubyInstanceConfig.setLoader(getAggregateClassLoader(classLoaders))[ CD ]
Line_23 $$ if (scriptFile != null) -->Line_24 $$ scriptingContainer.runScriptlet(new FileInputStream(scriptFile), scriptFile.toString())[ CD ]
Line_28 $$ if (outputNames == null) -->Line_29 $$ return null[ CD ]
Line_2 $$ protected Map<String, Object> doEval(Set<String> allowedClasses, Map<String, Object> inputObjects, Set<String> outputNames, File scriptFile, String script, ClassLoader... classLoaders) throws ScriptingException -->Line_11 $$ if (ArrayUtil.isNotEmpty(classLoaders)) [ FD ]
Line_2 $$ protected Map<String, Object> doEval(Set<String> allowedClasses, Map<String, Object> inputObjects, Set<String> outputNames, File scriptFile, String script, ClassLoader... classLoaders) throws ScriptingException -->Line_26 $$ _scriptingContainer.runScriptlet(script)[ FD ]
Line_9 $$ RubyInstanceConfig rubyInstanceConfig = localContextProvider.getRubyInstanceConfig()-->Line_12 $$ rubyInstanceConfig.setLoader(getAggregateClassLoader(classLoaders))[ FD ]
Line_8 $$ LocalContextProvider localContextProvider = scriptingContainer.getProvider()-->Line_9 $$ RubyInstanceConfig rubyInstanceConfig = localContextProvider.getRubyInstanceConfig()[ FD ]
Line_9 $$ RubyInstanceConfig rubyInstanceConfig = localContextProvider.getRubyInstanceConfig()-->Line_14 $$ rubyInstanceConfig.setLoadPaths(_loadPaths)[ FD ]
Line_15 $$ for (Map.Entry<String, Object> entry : inputObjects.entrySet()) -->Line_16 $$ String inputName = entry.getKey()[ FD ]
Line_2 $$ protected Map<String, Object> doEval(Set<String> allowedClasses, Map<String, Object> inputObjects, Set<String> outputNames, File scriptFile, String script, ClassLoader... classLoaders) throws ScriptingException -->Line_15 $$ for (Map.Entry<String, Object> entry : inputObjects.entrySet()) [ FD ]
Line_6 $$ org.jruby.embed.ScriptingContainer scriptingContainer = _scriptingContainer.getWrappedScriptingContainer()-->Line_21 $$ scriptingContainer.put(inputName, inputObject)[ FD ]
Line_23 $$ if (scriptFile != null) -->Line_26 $$ _scriptingContainer.runScriptlet(script)[ CD ]
Line_6 $$ org.jruby.embed.ScriptingContainer scriptingContainer = _scriptingContainer.getWrappedScriptingContainer()-->Line_33 $$ outputObjects.put(outputName, scriptingContainer.get(outputName))[ FD ]
Line_32 $$ for (String outputName : outputNames) -->Line_33 $$ outputObjects.put(outputName, scriptingContainer.get(outputName))[ FD ]
Line_6 $$ org.jruby.embed.ScriptingContainer scriptingContainer = _scriptingContainer.getWrappedScriptingContainer()-->Line_8 $$ LocalContextProvider localContextProvider = scriptingContainer.getProvider()[ FD ]
Line_2 $$ protected Map<String, Object> doEval(Set<String> allowedClasses, Map<String, Object> inputObjects, Set<String> outputNames, File scriptFile, String script, ClassLoader... classLoaders) throws ScriptingException -->Line_28 $$ if (outputNames == null) [ FD ]
Line_2 $$ protected Map<String, Object> doEval(Set<String> allowedClasses, Map<String, Object> inputObjects, Set<String> outputNames, File scriptFile, String script, ClassLoader... classLoaders) throws ScriptingException -->Line_23 $$ if (scriptFile != null) [ FD ]
Line_2 $$ protected Map<String, Object> doEval(Set<String> allowedClasses, Map<String, Object> inputObjects, Set<String> outputNames, File scriptFile, String script, ClassLoader... classLoaders) throws ScriptingException -->Line_3 $$ if (allowedClasses != null) [ CD ]
Line_19 $$ inputName = StringPool.DOLLAR + inputName-->Line_21 $$ scriptingContainer.put(inputName, inputObject)[ FD ]
Line_16 $$ String inputName = entry.getKey()-->Line_21 $$ scriptingContainer.put(inputName, inputObject)[ FD ]
Line_9 $$ RubyInstanceConfig rubyInstanceConfig = localContextProvider.getRubyInstanceConfig()-->Line_10 $$ rubyInstanceConfig.setCurrentDirectory(_basePath)[ FD ]
Line_31 $$ Map<String, Object> outputObjects = new HashMap()-->Line_33 $$ outputObjects.put(outputName, scriptingContainer.get(outputName))[ FD ]
