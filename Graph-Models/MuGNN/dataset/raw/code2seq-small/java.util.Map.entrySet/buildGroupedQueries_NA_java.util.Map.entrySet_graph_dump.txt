Line_2 $$ public List<Query> buildGroupedQueries(MultiMatchQueryBuilder.Type type, Map<String, Float> fieldNames, Object value, String minimumShouldMatch) throws IOException -->Line_39 $$ Query q = parseGroup(type.matchQueryType(), fieldAndFieldType.field, 1f, value, minimumShouldMatch)[ FD ]
Line_23 $$ Query q = parseGroup(type.matchQueryType(), tuple.v1(), tuple.v2(), value, minimumShouldMatch)-->Line_25 $$ queries.add(q)[ FD ]
Line_21 $$ List<Query> queries = new ArrayList()-->Line_44 $$ return queries.isEmpty() ? null : queries[ FD ]
Line_7 $$ MappedFieldType fieldType = context.fieldMapper(name)-->Line_8 $$ if (fieldType != null) [ FD ]
Line_9 $$ Analyzer actualAnalyzer = getAnalyzer(fieldType)-->Line_16 $$ groups.get(actualAnalyzer).add(new FieldAndFieldType(name, fieldType, boost))[ FD ]
Line_2 $$ public List<Query> buildGroupedQueries(MultiMatchQueryBuilder.Type type, Map<String, Float> fieldNames, Object value, String minimumShouldMatch) throws IOException -->Line_23 $$ Query q = parseGroup(type.matchQueryType(), tuple.v1(), tuple.v2(), value, minimumShouldMatch)[ FD ]
Line_24 $$ if (q != null) -->Line_25 $$ queries.add(q)[ CD ]
Line_29 $$ if (group.size() > 1) -->Line_31 $$ int i = 0[ CD ]
Line_8 $$ if (fieldType != null) -->Line_18 $$ missing.add(new Tuple(name, entry.getValue()))[ CD ]
Line_7 $$ MappedFieldType fieldType = context.fieldMapper(name)-->Line_10 $$ name = fieldType.name()[ FD ]
Line_6 $$ String name = entry.getKey()-->Line_10 $$ name = fieldType.name()[ FD ]
Line_4 $$ List<Tuple<String, Float>> missing = new ArrayList()-->Line_18 $$ missing.add(new Tuple(name, entry.getValue()))[ FD ]
Line_32 $$ for (FieldAndFieldType fieldAndFieldType : group) -->Line_33 $$ blendedFields[i++] = fieldAndFieldType[ FD ]
Line_2 $$ public List<Query> buildGroupedQueries(MultiMatchQueryBuilder.Type type, Map<String, Float> fieldNames, Object value, String minimumShouldMatch) throws IOException -->Line_21 $$ List<Query> queries = new ArrayList()[ CD ]
Line_23 $$ Query q = parseGroup(type.matchQueryType(), tuple.v1(), tuple.v2(), value, minimumShouldMatch)-->Line_24 $$ if (q != null) [ FD ]
Line_6 $$ String name = entry.getKey()-->Line_7 $$ MappedFieldType fieldType = context.fieldMapper(name)[ FD ]
Line_3 $$ Map<Analyzer, List<FieldAndFieldType>> groups = new HashMap()-->Line_11 $$ if (!groups.containsKey(actualAnalyzer)) [ FD ]
Line_5 $$ for (Map.Entry<String, Float> entry : fieldNames.entrySet()) -->Line_6 $$ String name = entry.getKey()[ FD ]
Line_14 $$ Float boost = entry.getValue()-->Line_15 $$ boost = boost == null ? Float.valueOf(1.0f) : boost[ FD ]
Line_9 $$ Analyzer actualAnalyzer = getAnalyzer(fieldType)-->Line_11 $$ if (!groups.containsKey(actualAnalyzer)) [ FD ]
Line_21 $$ List<Query> queries = new ArrayList()-->Line_41 $$ queries.add(q)[ FD ]
Line_5 $$ for (Map.Entry<String, Float> entry : fieldNames.entrySet()) -->Line_14 $$ Float boost = entry.getValue()[ FD ]
Line_9 $$ Analyzer actualAnalyzer = getAnalyzer(fieldType)-->Line_12 $$ groups.put(actualAnalyzer, new ArrayList())[ FD ]
Line_28 $$ for (List<FieldAndFieldType> group : groups.values()) -->Line_38 $$ final FieldAndFieldType fieldAndFieldType = group.get(0)[ FD ]
Line_2 $$ public List<Query> buildGroupedQueries(MultiMatchQueryBuilder.Type type, Map<String, Float> fieldNames, Object value, String minimumShouldMatch) throws IOException -->Line_4 $$ List<Tuple<String, Float>> missing = new ArrayList()[ CD ]
Line_8 $$ if (fieldType != null) -->Line_11 $$ if (!groups.containsKey(actualAnalyzer)) [ CD ]
Line_8 $$ if (fieldType != null) -->Line_16 $$ groups.get(actualAnalyzer).add(new FieldAndFieldType(name, fieldType, boost))[ CD ]
Line_23 $$ Query q = parseGroup(type.matchQueryType(), tuple.v1(), tuple.v2(), value, minimumShouldMatch)-->Line_41 $$ queries.add(q)[ FD ]
Line_3 $$ Map<Analyzer, List<FieldAndFieldType>> groups = new HashMap()-->Line_12 $$ groups.put(actualAnalyzer, new ArrayList())[ FD ]
Line_40 $$ if (q != null) -->Line_41 $$ queries.add(q)[ CD ]
Line_2 $$ public List<Query> buildGroupedQueries(MultiMatchQueryBuilder.Type type, Map<String, Float> fieldNames, Object value, String minimumShouldMatch) throws IOException -->Line_44 $$ return queries.isEmpty() ? null : queries[ CD ]
Line_8 $$ if (fieldType != null) -->Line_15 $$ boost = boost == null ? Float.valueOf(1.0f) : boost[ CD ]
Line_23 $$ Query q = parseGroup(type.matchQueryType(), tuple.v1(), tuple.v2(), value, minimumShouldMatch)-->Line_40 $$ if (q != null) [ FD ]
Line_3 $$ Map<Analyzer, List<FieldAndFieldType>> groups = new HashMap()-->Line_16 $$ groups.get(actualAnalyzer).add(new FieldAndFieldType(name, fieldType, boost))[ FD ]
Line_28 $$ for (List<FieldAndFieldType> group : groups.values()) -->Line_30 $$ blendedFields = new FieldAndFieldType[group.size()][ FD ]
Line_8 $$ if (fieldType != null) -->Line_9 $$ Analyzer actualAnalyzer = getAnalyzer(fieldType)[ CD ]
Line_2 $$ public List<Query> buildGroupedQueries(MultiMatchQueryBuilder.Type type, Map<String, Float> fieldNames, Object value, String minimumShouldMatch) throws IOException -->Line_5 $$ for (Map.Entry<String, Float> entry : fieldNames.entrySet()) [ FD ]
Line_8 $$ if (fieldType != null) -->Line_14 $$ Float boost = entry.getValue()[ CD ]
Line_22 $$ for (Tuple<String, Float> tuple : missing) -->Line_23 $$ Query q = parseGroup(type.matchQueryType(), tuple.v1(), tuple.v2(), value, minimumShouldMatch)[ FD ]
Line_3 $$ Map<Analyzer, List<FieldAndFieldType>> groups = new HashMap()-->Line_28 $$ for (List<FieldAndFieldType> group : groups.values()) [ FD ]
Line_31 $$ int i = 0-->Line_33 $$ blendedFields[i++] = fieldAndFieldType[ FD ]
Line_2 $$ public List<Query> buildGroupedQueries(MultiMatchQueryBuilder.Type type, Map<String, Float> fieldNames, Object value, String minimumShouldMatch) throws IOException -->Line_3 $$ Map<Analyzer, List<FieldAndFieldType>> groups = new HashMap()[ CD ]
Line_5 $$ for (Map.Entry<String, Float> entry : fieldNames.entrySet()) -->Line_18 $$ missing.add(new Tuple(name, entry.getValue()))[ FD ]
Line_11 $$ if (!groups.containsKey(actualAnalyzer)) -->Line_12 $$ groups.put(actualAnalyzer, new ArrayList())[ CD ]
Line_21 $$ List<Query> queries = new ArrayList()-->Line_25 $$ queries.add(q)[ FD ]
Line_7 $$ MappedFieldType fieldType = context.fieldMapper(name)-->Line_9 $$ Analyzer actualAnalyzer = getAnalyzer(fieldType)[ FD ]
Line_28 $$ for (List<FieldAndFieldType> group : groups.values()) -->Line_29 $$ if (group.size() > 1) [ FD ]
Line_8 $$ if (fieldType != null) -->Line_10 $$ name = fieldType.name()[ CD ]
