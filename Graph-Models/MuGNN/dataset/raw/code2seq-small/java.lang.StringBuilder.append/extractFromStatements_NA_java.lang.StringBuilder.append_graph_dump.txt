Line_27 $$ final RefactoringEventData beforeData = new RefactoringEventData()-->Line_28 $$ beforeData.addElements(new PsiElement[] [ FD ]
Line_23 $$ CommandProcessor.getInstance().executeCommand(project, new Runnable() -->Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() [ CD ]
Line_60 $$ if (isAsync) -->Line_62 $$ if (fragment.isYieldInside()) [ CD ]
Line_40 $$ if (hasOutputVariables) -->Line_43 $$ builder.append(outputVariables)[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_27 $$ final RefactoringEventData beforeData = new RefactoringEventData()[ CD ]
Line_11 $$ final List<PsiElement> elementsRange = PyPsiUtils.collectElements(statement1, statement2)-->Line_12 $$ if (elementsRange.isEmpty()) [ FD ]
Line_72 $$ callElement = replaceElements(elementsRange, callElement)-->Line_77 $$ setSelectionAndCaret(editor, callElement)[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_10 $$ final boolean isStaticMethod = flags != null && flags.isStaticMethod()[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_36 $$ final List<PsiElement> newMethodElements = new ArrayList<PsiElement>(elementsRange)[ CD ]
Line_65 $$ if (isMethod) -->Line_66 $$ appendSelf(firstElement, builder, isStaticMethod)[ CD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_3 $$ if (!fragment.getOutputVariables().isEmpty() && fragment.isReturnInstructionInside()) [ CD ]
Line_31 $$ final boolean isAsync = fragment.isAsync()-->Line_48 $$ PyFunction generatedMethod = generateMethodFromElements(project, methodName, variableData, newMethodElements, flags, isAsync)[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_29 $$ project.getMessageBus().syncPublisher(RefactoringEventListener.REFACTORING_EVENT_TOPIC).refactoringStarted(getRefactoringId(), beforeData)[ FD ]
Line_30 $$ final StringBuilder builder = new StringBuilder()-->Line_63 $$ builder.append("yield from ")[ FD ]
Line_50 $$ final PsiElement firstElement = elementsRange.get(0)-->Line_66 $$ appendSelf(firstElement, builder, isStaticMethod)[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_50 $$ final PsiElement firstElement = elementsRange.get(0)[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_77 $$ setSelectionAndCaret(editor, callElement)[ CD ]
Line_30 $$ final StringBuilder builder = new StringBuilder()-->Line_33 $$ builder.append("async ")[ FD ]
Line_3 $$ if (!fragment.getOutputVariables().isEmpty() && fragment.isReturnInstructionInside()) -->Line_5 $$ return[ CD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_22 $$ final SimpleDuplicatesFinder finder = new SimpleDuplicatesFinder(statement1, statement2, variableData, fragment.getOutputVariables())[ FD ]
Line_39 $$ final LanguageLevel languageLevel = LanguageLevel.forElement(statement1)-->Line_44 $$ final PyFunction function = generator.createFromText(languageLevel, PyFunction.class, newMethodText)[ FD ]
Line_78 $$ final RefactoringEventData afterData = new RefactoringEventData()-->Line_80 $$ project.getMessageBus().syncPublisher(RefactoringEventListener.REFACTORING_EVENT_TOPIC).refactoringDone(getRefactoringId(), afterData)[ FD ]
Line_71 $$ PsiElement callElement = function.getStatementList().getStatements()[0]-->Line_77 $$ setSelectionAndCaret(editor, callElement)[ FD ]
Line_8 $$ final PyUtil.MethodFlags flags = function == null ? null : PyUtil.MethodFlags.of(function)-->Line_48 $$ PyFunction generatedMethod = generateMethodFromElements(project, methodName, variableData, newMethodElements, flags, isAsync)[ FD ]
Line_10 $$ final boolean isStaticMethod = flags != null && flags.isStaticMethod()-->Line_66 $$ appendSelf(firstElement, builder, isStaticMethod)[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_38 $$ final PyElementGenerator generator = PyElementGenerator.getInstance(project)[ CD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_52 $$ processParameters(project, generatedMethod, variableData, isMethod, isClassMethod, isStaticMethod)[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_8 $$ final PyUtil.MethodFlags flags = function == null ? null : PyUtil.MethodFlags.of(function)[ CD ]
Line_44 $$ final PyFunction function = generator.createFromText(languageLevel, PyFunction.class, newMethodText)-->Line_71 $$ PsiElement callElement = function.getStatementList().getStatements()[0][ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_57 $$ if (fragment.isReturnInstructionInside()) [ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_28 $$ beforeData.addElements(new PsiElement[] [ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_72 $$ callElement = replaceElements(elementsRange, callElement)[ CD ]
Line_50 $$ final PsiElement firstElement = elementsRange.get(0)-->Line_51 $$ final boolean isMethod = PyPsiUtils.isMethodContext(firstElement)[ FD ]
Line_27 $$ final RefactoringEventData beforeData = new RefactoringEventData()-->Line_29 $$ project.getMessageBus().syncPublisher(RefactoringEventListener.REFACTORING_EVENT_TOPIC).refactoringStarted(getRefactoringId(), beforeData)[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_32 $$ if (isAsync) [ CD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_17 $$ if (data.first == null || data.second == null) [ CD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_37 $$ final boolean hasOutputVariables = !fragment.getOutputVariables().isEmpty()[ FD ]
Line_44 $$ final PyFunction function = generator.createFromText(languageLevel, PyFunction.class, newMethodText)-->Line_45 $$ final PsiElement returnStatement = function.getStatementList().getStatements()[0][ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_12 $$ if (elementsRange.isEmpty()) [ CD ]
Line_57 $$ if (fragment.isReturnInstructionInside()) -->Line_58 $$ builder.append("return ")[ CD ]
Line_60 $$ if (isAsync) -->Line_61 $$ builder.append("await ")[ CD ]
Line_38 $$ final PyElementGenerator generator = PyElementGenerator.getInstance(project)-->Line_70 $$ final PyFunction function = generator.createFromText(languageLevel, PyFunction.class, builder.toString())[ FD ]
Line_40 $$ if (hasOutputVariables) -->Line_45 $$ final PsiElement returnStatement = function.getStatementList().getStatements()[0][ CD ]
Line_3 $$ if (!fragment.getOutputVariables().isEmpty() && fragment.isReturnInstructionInside()) -->Line_4 $$ CommonRefactoringUtil.showErrorHint(project, editor, PyBundle.message("refactoring.extract.method.error.local.variable.modifications.and.returns"), RefactoringBundle.message("error.title"), "refactoring.extractMethod")[ CD ]
Line_7 $$ final PyFunction function = PsiTreeUtil.getParentOfType(statement1, PyFunction.class)-->Line_45 $$ final PsiElement returnStatement = function.getStatementList().getStatements()[0][ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_16 $$ final Pair<String, AbstractVariableData[]> data = getNameAndVariableData(project, fragment, statement1, isClassMethod, isStaticMethod)[ CD ]
Line_49 $$ generatedMethod = insertGeneratedMethod(statement1, generatedMethod)-->Line_75 $$ processDuplicates(callElement, generatedMethod, finder, editor)[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_7 $$ final PyFunction function = PsiTreeUtil.getParentOfType(statement1, PyFunction.class)[ CD ]
Line_30 $$ final StringBuilder builder = new StringBuilder()-->Line_35 $$ builder.append("def f():\n    ")[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_49 $$ generatedMethod = insertGeneratedMethod(statement1, generatedMethod)[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_65 $$ if (isMethod) [ CD ]
Line_12 $$ if (elementsRange.isEmpty()) -->Line_14 $$ return[ CD ]
Line_36 $$ final List<PsiElement> newMethodElements = new ArrayList<PsiElement>(elementsRange)-->Line_46 $$ newMethodElements.add(returnStatement)[ FD ]
Line_40 $$ if (hasOutputVariables) -->Line_44 $$ final PyFunction function = generator.createFromText(languageLevel, PyFunction.class, newMethodText)[ CD ]
Line_30 $$ final StringBuilder builder = new StringBuilder()-->Line_66 $$ appendSelf(firstElement, builder, isStaticMethod)[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_13 $$ CommonRefactoringUtil.showErrorHint(project, editor, PyBundle.message("refactoring.extract.method.error.empty.fragment"), RefactoringBundle.message("extract.method.title"), "refactoring.extractMethod")[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_73 $$ callElement = CodeInsightUtilCore.forcePsiPostprocessAndRestoreElement(callElement)[ CD ]
Line_11 $$ final List<PsiElement> elementsRange = PyPsiUtils.collectElements(statement1, statement2)-->Line_50 $$ final PsiElement firstElement = elementsRange.get(0)[ FD ]
Line_49 $$ generatedMethod = insertGeneratedMethod(statement1, generatedMethod)-->Line_53 $$ processGlobalWrites(generatedMethod, fragment)[ FD ]
Line_22 $$ final SimpleDuplicatesFinder finder = new SimpleDuplicatesFinder(statement1, statement2, variableData, fragment.getOutputVariables())-->Line_75 $$ processDuplicates(callElement, generatedMethod, finder, editor)[ FD ]
Line_48 $$ PyFunction generatedMethod = generateMethodFromElements(project, methodName, variableData, newMethodElements, flags, isAsync)-->Line_49 $$ generatedMethod = insertGeneratedMethod(statement1, generatedMethod)[ FD ]
Line_30 $$ final StringBuilder builder = new StringBuilder()-->Line_69 $$ builder.append(createCallArgsString(variableData)).append(")")[ FD ]
Line_40 $$ if (hasOutputVariables) -->Line_46 $$ newMethodElements.add(returnStatement)[ CD ]
Line_9 $$ final boolean isClassMethod = flags != null && flags.isClassMethod()-->Line_16 $$ final Pair<String, AbstractVariableData[]> data = getNameAndVariableData(project, fragment, statement1, isClassMethod, isStaticMethod)[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_22 $$ final SimpleDuplicatesFinder finder = new SimpleDuplicatesFinder(statement1, statement2, variableData, fragment.getOutputVariables())[ CD ]
Line_45 $$ final PsiElement returnStatement = function.getStatementList().getStatements()[0]-->Line_46 $$ newMethodElements.add(returnStatement)[ FD ]
Line_72 $$ callElement = replaceElements(elementsRange, callElement)-->Line_74 $$ if (callElement != null) [ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_62 $$ if (fragment.isYieldInside()) [ FD ]
Line_42 $$ String newMethodText = builder + "return " + outputVariables-->Line_44 $$ final PyFunction function = generator.createFromText(languageLevel, PyFunction.class, newMethodText)[ FD ]
Line_71 $$ PsiElement callElement = function.getStatementList().getStatements()[0]-->Line_75 $$ processDuplicates(callElement, generatedMethod, finder, editor)[ FD ]
Line_51 $$ final boolean isMethod = PyPsiUtils.isMethodContext(firstElement)-->Line_52 $$ processParameters(project, generatedMethod, variableData, isMethod, isClassMethod, isStaticMethod)[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_23 $$ CommandProcessor.getInstance().executeCommand(project, new Runnable() [ FD ]
Line_41 $$ final String outputVariables = StringUtil.join(fragment.getOutputVariables(), ", ")-->Line_43 $$ builder.append(outputVariables)[ FD ]
Line_36 $$ final List<PsiElement> newMethodElements = new ArrayList<PsiElement>(elementsRange)-->Line_48 $$ PyFunction generatedMethod = generateMethodFromElements(project, methodName, variableData, newMethodElements, flags, isAsync)[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_41 $$ final String outputVariables = StringUtil.join(fragment.getOutputVariables(), ", ")[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_35 $$ builder.append("def f():\n    ")[ CD ]
Line_49 $$ generatedMethod = insertGeneratedMethod(statement1, generatedMethod)-->Line_54 $$ processNonlocalWrites(generatedMethod, fragment)[ FD ]
Line_30 $$ final StringBuilder builder = new StringBuilder()-->Line_56 $$ builder.append(" = ")[ FD ]
Line_49 $$ generatedMethod = insertGeneratedMethod(statement1, generatedMethod)-->Line_52 $$ processParameters(project, generatedMethod, variableData, isMethod, isClassMethod, isStaticMethod)[ FD ]
Line_55 $$ if (hasOutputVariables) -->Line_56 $$ builder.append(" = ")[ CD ]
Line_39 $$ final LanguageLevel languageLevel = LanguageLevel.forElement(statement1)-->Line_70 $$ final PyFunction function = generator.createFromText(languageLevel, PyFunction.class, builder.toString())[ FD ]
Line_21 $$ final AbstractVariableData[] variableData = data.second-->Line_52 $$ processParameters(project, generatedMethod, variableData, isMethod, isClassMethod, isStaticMethod)[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_71 $$ PsiElement callElement = function.getStatementList().getStatements()[0][ CD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_4 $$ CommonRefactoringUtil.showErrorHint(project, editor, PyBundle.message("refactoring.extract.method.error.local.variable.modifications.and.returns"), RefactoringBundle.message("error.title"), "refactoring.extractMethod")[ FD ]
Line_48 $$ PyFunction generatedMethod = generateMethodFromElements(project, methodName, variableData, newMethodElements, flags, isAsync)-->Line_54 $$ processNonlocalWrites(generatedMethod, fragment)[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_53 $$ processGlobalWrites(generatedMethod, fragment)[ FD ]
Line_7 $$ final PyFunction function = PsiTreeUtil.getParentOfType(statement1, PyFunction.class)-->Line_71 $$ PsiElement callElement = function.getStatementList().getStatements()[0][ FD ]
Line_40 $$ if (hasOutputVariables) -->Line_42 $$ String newMethodText = builder + "return " + outputVariables[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_78 $$ final RefactoringEventData afterData = new RefactoringEventData()[ CD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_80 $$ project.getMessageBus().syncPublisher(RefactoringEventListener.REFACTORING_EVENT_TOPIC).refactoringDone(getRefactoringId(), afterData)[ FD ]
Line_9 $$ final boolean isClassMethod = flags != null && flags.isClassMethod()-->Line_52 $$ processParameters(project, generatedMethod, variableData, isMethod, isClassMethod, isStaticMethod)[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_11 $$ final List<PsiElement> elementsRange = PyPsiUtils.collectElements(statement1, statement2)[ CD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_23 $$ CommandProcessor.getInstance().executeCommand(project, new Runnable() [ CD ]
Line_71 $$ PsiElement callElement = function.getStatementList().getStatements()[0]-->Line_74 $$ if (callElement != null) [ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_48 $$ PyFunction generatedMethod = generateMethodFromElements(project, methodName, variableData, newMethodElements, flags, isAsync)[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_70 $$ final PyFunction function = generator.createFromText(languageLevel, PyFunction.class, builder.toString())[ CD ]
Line_48 $$ PyFunction generatedMethod = generateMethodFromElements(project, methodName, variableData, newMethodElements, flags, isAsync)-->Line_75 $$ processDuplicates(callElement, generatedMethod, finder, editor)[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_75 $$ processDuplicates(callElement, generatedMethod, finder, editor)[ FD ]
Line_55 $$ if (hasOutputVariables) -->Line_57 $$ if (fragment.isReturnInstructionInside()) [ CD ]
Line_20 $$ final String methodName = data.first-->Line_68 $$ builder.append(methodName).append("(")[ FD ]
Line_71 $$ PsiElement callElement = function.getStatementList().getStatements()[0]-->Line_72 $$ callElement = replaceElements(elementsRange, callElement)[ FD ]
Line_30 $$ final StringBuilder builder = new StringBuilder()-->Line_58 $$ builder.append("return ")[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_68 $$ builder.append(methodName).append("(")[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_60 $$ if (isAsync) [ CD ]
Line_11 $$ final List<PsiElement> elementsRange = PyPsiUtils.collectElements(statement1, statement2)-->Line_72 $$ callElement = replaceElements(elementsRange, callElement)[ FD ]
Line_30 $$ final StringBuilder builder = new StringBuilder()-->Line_43 $$ builder.append(outputVariables)[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_3 $$ if (!fragment.getOutputVariables().isEmpty() && fragment.isReturnInstructionInside()) [ FD ]
Line_48 $$ PyFunction generatedMethod = generateMethodFromElements(project, methodName, variableData, newMethodElements, flags, isAsync)-->Line_53 $$ processGlobalWrites(generatedMethod, fragment)[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_31 $$ final boolean isAsync = fragment.isAsync()[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_39 $$ final LanguageLevel languageLevel = LanguageLevel.forElement(statement1)[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_54 $$ processNonlocalWrites(generatedMethod, fragment)[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_80 $$ project.getMessageBus().syncPublisher(RefactoringEventListener.REFACTORING_EVENT_TOPIC).refactoringDone(getRefactoringId(), afterData)[ CD ]
Line_48 $$ PyFunction generatedMethod = generateMethodFromElements(project, methodName, variableData, newMethodElements, flags, isAsync)-->Line_79 $$ afterData.addElement(generatedMethod)[ FD ]
Line_38 $$ final PyElementGenerator generator = PyElementGenerator.getInstance(project)-->Line_44 $$ final PyFunction function = generator.createFromText(languageLevel, PyFunction.class, newMethodText)[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_9 $$ final boolean isClassMethod = flags != null && flags.isClassMethod()[ CD ]
Line_8 $$ final PyUtil.MethodFlags flags = function == null ? null : PyUtil.MethodFlags.of(function)-->Line_9 $$ final boolean isClassMethod = flags != null && flags.isClassMethod()[ FD ]
Line_72 $$ callElement = replaceElements(elementsRange, callElement)-->Line_73 $$ callElement = CodeInsightUtilCore.forcePsiPostprocessAndRestoreElement(callElement)[ FD ]
Line_49 $$ generatedMethod = insertGeneratedMethod(statement1, generatedMethod)-->Line_79 $$ afterData.addElement(generatedMethod)[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_54 $$ processNonlocalWrites(generatedMethod, fragment)[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_40 $$ if (hasOutputVariables) [ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_29 $$ project.getMessageBus().syncPublisher(RefactoringEventListener.REFACTORING_EVENT_TOPIC).refactoringStarted(getRefactoringId(), beforeData)[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_31 $$ final boolean isAsync = fragment.isAsync()[ CD ]
Line_48 $$ PyFunction generatedMethod = generateMethodFromElements(project, methodName, variableData, newMethodElements, flags, isAsync)-->Line_52 $$ processParameters(project, generatedMethod, variableData, isMethod, isClassMethod, isStaticMethod)[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_37 $$ final boolean hasOutputVariables = !fragment.getOutputVariables().isEmpty()[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_52 $$ processParameters(project, generatedMethod, variableData, isMethod, isClassMethod, isStaticMethod)[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_74 $$ if (callElement != null) [ CD ]
Line_74 $$ if (callElement != null) -->Line_75 $$ processDuplicates(callElement, generatedMethod, finder, editor)[ CD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_21 $$ final AbstractVariableData[] variableData = data.second[ CD ]
Line_73 $$ callElement = CodeInsightUtilCore.forcePsiPostprocessAndRestoreElement(callElement)-->Line_77 $$ setSelectionAndCaret(editor, callElement)[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_30 $$ final StringBuilder builder = new StringBuilder()[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_69 $$ builder.append(createCallArgsString(variableData)).append(")")[ CD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_16 $$ final Pair<String, AbstractVariableData[]> data = getNameAndVariableData(project, fragment, statement1, isClassMethod, isStaticMethod)[ FD ]
Line_12 $$ if (elementsRange.isEmpty()) -->Line_13 $$ CommonRefactoringUtil.showErrorHint(project, editor, PyBundle.message("refactoring.extract.method.error.empty.fragment"), RefactoringBundle.message("extract.method.title"), "refactoring.extractMethod")[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_53 $$ processGlobalWrites(generatedMethod, fragment)[ CD ]
Line_40 $$ if (hasOutputVariables) -->Line_41 $$ final String outputVariables = StringUtil.join(fragment.getOutputVariables(), ", ")[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_48 $$ PyFunction generatedMethod = generateMethodFromElements(project, methodName, variableData, newMethodElements, flags, isAsync)[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_55 $$ if (hasOutputVariables) [ CD ]
Line_71 $$ PsiElement callElement = function.getStatementList().getStatements()[0]-->Line_73 $$ callElement = CodeInsightUtilCore.forcePsiPostprocessAndRestoreElement(callElement)[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_38 $$ final PyElementGenerator generator = PyElementGenerator.getInstance(project)[ FD ]
Line_21 $$ final AbstractVariableData[] variableData = data.second-->Line_48 $$ PyFunction generatedMethod = generateMethodFromElements(project, methodName, variableData, newMethodElements, flags, isAsync)[ FD ]
Line_30 $$ final StringBuilder builder = new StringBuilder()-->Line_68 $$ builder.append(methodName).append("(")[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_77 $$ setSelectionAndCaret(editor, callElement)[ FD ]
Line_8 $$ final PyUtil.MethodFlags flags = function == null ? null : PyUtil.MethodFlags.of(function)-->Line_10 $$ final boolean isStaticMethod = flags != null && flags.isStaticMethod()[ FD ]
Line_73 $$ callElement = CodeInsightUtilCore.forcePsiPostprocessAndRestoreElement(callElement)-->Line_75 $$ processDuplicates(callElement, generatedMethod, finder, editor)[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_11 $$ final List<PsiElement> elementsRange = PyPsiUtils.collectElements(statement1, statement2)[ FD ]
Line_30 $$ final StringBuilder builder = new StringBuilder()-->Line_70 $$ final PyFunction function = generator.createFromText(languageLevel, PyFunction.class, builder.toString())[ FD ]
Line_62 $$ if (fragment.isYieldInside()) -->Line_63 $$ builder.append("yield from ")[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_79 $$ afterData.addElement(generatedMethod)[ CD ]
Line_32 $$ if (isAsync) -->Line_33 $$ builder.append("async ")[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_39 $$ final LanguageLevel languageLevel = LanguageLevel.forElement(statement1)[ CD ]
Line_73 $$ callElement = CodeInsightUtilCore.forcePsiPostprocessAndRestoreElement(callElement)-->Line_74 $$ if (callElement != null) [ FD ]
Line_21 $$ final AbstractVariableData[] variableData = data.second-->Line_69 $$ builder.append(createCallArgsString(variableData)).append(")")[ FD ]
Line_17 $$ if (data.first == null || data.second == null) -->Line_18 $$ return[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_49 $$ generatedMethod = insertGeneratedMethod(statement1, generatedMethod)[ CD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_20 $$ final String methodName = data.first[ CD ]
Line_10 $$ final boolean isStaticMethod = flags != null && flags.isStaticMethod()-->Line_52 $$ processParameters(project, generatedMethod, variableData, isMethod, isClassMethod, isStaticMethod)[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_51 $$ final boolean isMethod = PyPsiUtils.isMethodContext(firstElement)[ CD ]
Line_72 $$ callElement = replaceElements(elementsRange, callElement)-->Line_75 $$ processDuplicates(callElement, generatedMethod, finder, editor)[ FD ]
Line_20 $$ final String methodName = data.first-->Line_48 $$ PyFunction generatedMethod = generateMethodFromElements(project, methodName, variableData, newMethodElements, flags, isAsync)[ FD ]
Line_2 $$ public static void extractFromStatements(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement statement1, @NotNull final PsiElement statement2) -->Line_7 $$ final PyFunction function = PsiTreeUtil.getParentOfType(statement1, PyFunction.class)[ FD ]
Line_10 $$ final boolean isStaticMethod = flags != null && flags.isStaticMethod()-->Line_16 $$ final Pair<String, AbstractVariableData[]> data = getNameAndVariableData(project, fragment, statement1, isClassMethod, isStaticMethod)[ FD ]
Line_78 $$ final RefactoringEventData afterData = new RefactoringEventData()-->Line_79 $$ afterData.addElement(generatedMethod)[ FD ]
Line_7 $$ final PyFunction function = PsiTreeUtil.getParentOfType(statement1, PyFunction.class)-->Line_8 $$ final PyUtil.MethodFlags flags = function == null ? null : PyUtil.MethodFlags.of(function)[ FD ]
Line_30 $$ final StringBuilder builder = new StringBuilder()-->Line_61 $$ builder.append("await ")[ FD ]
