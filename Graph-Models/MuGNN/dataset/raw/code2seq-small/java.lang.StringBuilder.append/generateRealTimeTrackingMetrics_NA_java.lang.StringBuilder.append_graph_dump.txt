Line_57 $$ double timecost = handleOperTimecostHistogramMap.containsKey(e) ? handleOperTimecostHistogramMap.get(e).getSnapshot().getMean() / 1000000 : 0-->Line_58 $$ handleOperTimecostMap.put(e, timecost)[ FD ]
Line_53 $$ String key = "sampler.scheduler.operation.handle." + e + ".timecost"-->Line_71 $$ queueAllocatedVCoresCounterMap.put(queue, metrics.getCounters().get(key))[ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_7 $$ if (jvmMaxMemoryGauge == null && metrics.getGauges().containsKey("variable.jvm.max.memory")) [ CD ]
Line_53 $$ String key = "sampler.scheduler.operation.handle." + e + ".timecost"-->Line_70 $$ if (!queueAllocatedVCoresCounterMap.containsKey(queue) && metrics.getCounters().containsKey(key)) [ FD ]
Line_40 $$ availableMemoryGB = availableMemoryGauge == null ? 0 : Double.parseDouble(availableMemoryGauge.getValue().toString()) / 1024-->Line_78 $$ sb.append("\"time\":").append(System.currentTimeMillis()).append(",\"jvm.free.memory\":").append(jvmFreeMemoryGB).append(",\"jvm.max.memory\":").append(jvmMaxMemoryGB).append(",\"jvm.total.memory\":").append(jvmTotalMemoryGB).append(",\"running.applications\":").append(numRunningApps).append(",\"running.containers\":").append(numRunningContainers).append(",\"cluster.allocated.memory\":").append(allocatedMemoryGB).append(",\"cluster.allocated.vcores\":").append(allocatedVCoresGB).append(",\"cluster.available.memory\":").append(availableMemoryGB).append(",\"cluster.available.vcores\":").append(availableVCoresGB)[ FD ]
Line_10 $$ if (jvmTotalMemoryGauge == null && metrics.getGauges().containsKey("variable.jvm.total.memory")) -->Line_11 $$ jvmTotalMemoryGauge = metrics.getGauges().get("variable.jvm.total.memory")[ CD ]
Line_49 $$ allocateTimecost = allocateTimecostHistogram == null ? 0.0 : allocateTimecostHistogram.getSnapshot().getMean() / 1000000-->Line_83 $$ sb.append(",\"scheduler.allocate.timecost\":").append(allocateTimecost)[ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_60 $$ Map<String, Double> queueAllocatedMemoryMap = new HashMap<String, Double>()[ CD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_23 $$ numRunningApps = numRunningAppsGauge == null ? "0" : numRunningAppsGauge.getValue().toString()[ CD ]
Line_52 $$ for (SchedulerEventType e : SchedulerEventType.values()) -->Line_58 $$ handleOperTimecostMap.put(e, timecost)[ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_77 $$ sb.append("[ CD ]
Line_42 $$ double allocateTimecost, handleTimecost-->Line_84 $$ sb.append(",\"scheduler.handle.timecost\":").append(handleTimecost)[ FD ]
Line_25 $$ double allocatedMemoryGB, allocatedVCoresGB, availableMemoryGB, availableVCoresGB-->Line_41 $$ availableVCoresGB = availableVCoresGauge == null ? 0 : Double.parseDouble(availableVCoresGauge.getValue().toString())[ FD ]
Line_62 $$ for (String queue : wrapper.getQueueSet()) -->Line_74 $$ queueAllocatedVCoresMap.put(queue, queueAllocatedVCores)[ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_17 $$ if (numRunningAppsGauge == null && metrics.getGauges().containsKey("variable.running.application")) [ CD ]
Line_53 $$ String key = "sampler.scheduler.operation.handle." + e + ".timecost"-->Line_65 $$ queueAllocatedMemoryCounterMap.put(queue, metrics.getCounters().get(key))[ FD ]
Line_4 $$ if (jvmFreeMemoryGauge == null && metrics.getGauges().containsKey("variable.jvm.free.memory")) -->Line_5 $$ jvmFreeMemoryGauge = metrics.getGauges().get("variable.jvm.free.memory")[ CD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_3 $$ double jvmFreeMemoryGB, jvmMaxMemoryGB, jvmTotalMemoryGB[ CD ]
Line_62 $$ for (String queue : wrapper.getQueueSet()) -->Line_67 $$ double queueAllocatedMemoryGB = queueAllocatedMemoryCounterMap.containsKey(queue) ? queueAllocatedMemoryCounterMap.get(queue).getCount() / 1024.0 : 0[ FD ]
Line_76 $$ StringBuilder sb = new StringBuilder()-->Line_88 $$ sb.append("}")[ FD ]
Line_39 $$ allocatedVCoresGB = allocatedVCoresGauge == null ? 0 : Double.parseDouble(allocatedVCoresGauge.getValue().toString())-->Line_78 $$ sb.append("\"time\":").append(System.currentTimeMillis()).append(",\"jvm.free.memory\":").append(jvmFreeMemoryGB).append(",\"jvm.max.memory\":").append(jvmMaxMemoryGB).append(",\"jvm.total.memory\":").append(jvmTotalMemoryGB).append(",\"running.applications\":").append(numRunningApps).append(",\"running.containers\":").append(numRunningContainers).append(",\"cluster.allocated.memory\":").append(allocatedMemoryGB).append(",\"cluster.allocated.vcores\":").append(allocatedVCoresGB).append(",\"cluster.available.memory\":").append(availableMemoryGB).append(",\"cluster.available.vcores\":").append(availableVCoresGB)[ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_35 $$ if (availableVCoresGauge == null && metrics.getGauges().containsKey("variable.cluster.available.vcores")) [ CD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_39 $$ allocatedVCoresGB = allocatedVCoresGauge == null ? 0 : Double.parseDouble(allocatedVCoresGauge.getValue().toString())[ CD ]
Line_69 $$ key = "counter.queue." + queue + ".allocated.cores"-->Line_70 $$ if (!queueAllocatedVCoresCounterMap.containsKey(queue) && metrics.getCounters().containsKey(key)) [ FD ]
Line_16 $$ String numRunningApps, numRunningContainers-->Line_78 $$ sb.append("\"time\":").append(System.currentTimeMillis()).append(",\"jvm.free.memory\":").append(jvmFreeMemoryGB).append(",\"jvm.max.memory\":").append(jvmMaxMemoryGB).append(",\"jvm.total.memory\":").append(jvmTotalMemoryGB).append(",\"running.applications\":").append(numRunningApps).append(",\"running.containers\":").append(numRunningContainers).append(",\"cluster.allocated.memory\":").append(allocatedMemoryGB).append(",\"cluster.allocated.vcores\":").append(allocatedVCoresGB).append(",\"cluster.available.memory\":").append(availableMemoryGB).append(",\"cluster.available.vcores\":").append(availableVCoresGB)[ FD ]
Line_23 $$ numRunningApps = numRunningAppsGauge == null ? "0" : numRunningAppsGauge.getValue().toString()-->Line_78 $$ sb.append("\"time\":").append(System.currentTimeMillis()).append(",\"jvm.free.memory\":").append(jvmFreeMemoryGB).append(",\"jvm.max.memory\":").append(jvmMaxMemoryGB).append(",\"jvm.total.memory\":").append(jvmTotalMemoryGB).append(",\"running.applications\":").append(numRunningApps).append(",\"running.containers\":").append(numRunningContainers).append(",\"cluster.allocated.memory\":").append(allocatedMemoryGB).append(",\"cluster.allocated.vcores\":").append(allocatedVCoresGB).append(",\"cluster.available.memory\":").append(availableMemoryGB).append(",\"cluster.available.vcores\":").append(availableVCoresGB)[ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_40 $$ availableMemoryGB = availableMemoryGauge == null ? 0 : Double.parseDouble(availableMemoryGauge.getValue().toString()) / 1024[ CD ]
Line_53 $$ String key = "sampler.scheduler.operation.handle." + e + ".timecost"-->Line_69 $$ key = "counter.queue." + queue + ".allocated.cores"[ FD ]
Line_52 $$ for (SchedulerEventType e : SchedulerEventType.values()) -->Line_54 $$ if (!handleOperTimecostHistogramMap.containsKey(e) && metrics.getHistograms().containsKey(key)) [ FD ]
Line_76 $$ StringBuilder sb = new StringBuilder()-->Line_78 $$ sb.append("\"time\":").append(System.currentTimeMillis()).append(",\"jvm.free.memory\":").append(jvmFreeMemoryGB).append(",\"jvm.max.memory\":").append(jvmMaxMemoryGB).append(",\"jvm.total.memory\":").append(jvmTotalMemoryGB).append(",\"running.applications\":").append(numRunningApps).append(",\"running.containers\":").append(numRunningContainers).append(",\"cluster.allocated.memory\":").append(allocatedMemoryGB).append(",\"cluster.allocated.vcores\":").append(allocatedVCoresGB).append(",\"cluster.available.memory\":").append(availableMemoryGB).append(",\"cluster.available.vcores\":").append(availableVCoresGB)[ FD ]
Line_61 $$ Map<String, Long> queueAllocatedVCoresMap = new HashMap<String, Long>()-->Line_81 $$ sb.append(",\"queue.").append(queue).append(".allocated.vcores\":").append(queueAllocatedVCoresMap.get(queue))[ FD ]
Line_62 $$ for (String queue : wrapper.getQueueSet()) -->Line_80 $$ sb.append(",\"queue.").append(queue).append(".allocated.memory\":").append(queueAllocatedMemoryMap.get(queue))[ FD ]
Line_62 $$ for (String queue : wrapper.getQueueSet()) -->Line_65 $$ queueAllocatedMemoryCounterMap.put(queue, metrics.getCounters().get(key))[ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_20 $$ if (numRunningContainersGauge == null && metrics.getGauges().containsKey("variable.running.container")) [ CD ]
Line_7 $$ if (jvmMaxMemoryGauge == null && metrics.getGauges().containsKey("variable.jvm.max.memory")) -->Line_8 $$ jvmMaxMemoryGauge = metrics.getGauges().get("variable.jvm.max.memory")[ CD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_78 $$ sb.append("\"time\":").append(System.currentTimeMillis()).append(",\"jvm.free.memory\":").append(jvmFreeMemoryGB).append(",\"jvm.max.memory\":").append(jvmMaxMemoryGB).append(",\"jvm.total.memory\":").append(jvmTotalMemoryGB).append(",\"running.applications\":").append(numRunningApps).append(",\"running.containers\":").append(numRunningContainers).append(",\"cluster.allocated.memory\":").append(allocatedMemoryGB).append(",\"cluster.allocated.vcores\":").append(allocatedVCoresGB).append(",\"cluster.available.memory\":").append(availableMemoryGB).append(",\"cluster.available.vcores\":").append(availableVCoresGB)[ CD ]
Line_62 $$ for (String queue : wrapper.getQueueSet()) -->Line_81 $$ sb.append(",\"queue.").append(queue).append(".allocated.vcores\":").append(queueAllocatedVCoresMap.get(queue))[ FD ]
Line_46 $$ if (handleTimecostHistogram == null && metrics.getHistograms().containsKey("sampler.scheduler.operation.handle.timecost")) -->Line_47 $$ handleTimecostHistogram = metrics.getHistograms().get("sampler.scheduler.operation.handle.timecost")[ CD ]
Line_76 $$ StringBuilder sb = new StringBuilder()-->Line_77 $$ sb.append("[ FD ]
Line_25 $$ double allocatedMemoryGB, allocatedVCoresGB, availableMemoryGB, availableVCoresGB-->Line_78 $$ sb.append("\"time\":").append(System.currentTimeMillis()).append(",\"jvm.free.memory\":").append(jvmFreeMemoryGB).append(",\"jvm.max.memory\":").append(jvmMaxMemoryGB).append(",\"jvm.total.memory\":").append(jvmTotalMemoryGB).append(",\"running.applications\":").append(numRunningApps).append(",\"running.containers\":").append(numRunningContainers).append(",\"cluster.allocated.memory\":").append(allocatedMemoryGB).append(",\"cluster.allocated.vcores\":").append(allocatedVCoresGB).append(",\"cluster.available.memory\":").append(availableMemoryGB).append(",\"cluster.available.vcores\":").append(availableVCoresGB)[ FD ]
Line_62 $$ for (String queue : wrapper.getQueueSet()) -->Line_64 $$ if (!queueAllocatedMemoryCounterMap.containsKey(queue) && metrics.getCounters().containsKey(key)) [ FD ]
Line_62 $$ for (String queue : wrapper.getQueueSet()) -->Line_68 $$ queueAllocatedMemoryMap.put(queue, queueAllocatedMemoryGB)[ FD ]
Line_64 $$ if (!queueAllocatedMemoryCounterMap.containsKey(queue) && metrics.getCounters().containsKey(key)) -->Line_65 $$ queueAllocatedMemoryCounterMap.put(queue, metrics.getCounters().get(key))[ CD ]
Line_24 $$ numRunningContainers = numRunningContainersGauge == null ? "0" : numRunningContainersGauge.getValue().toString()-->Line_78 $$ sb.append("\"time\":").append(System.currentTimeMillis()).append(",\"jvm.free.memory\":").append(jvmFreeMemoryGB).append(",\"jvm.max.memory\":").append(jvmMaxMemoryGB).append(",\"jvm.total.memory\":").append(jvmTotalMemoryGB).append(",\"running.applications\":").append(numRunningApps).append(",\"running.containers\":").append(numRunningContainers).append(",\"cluster.allocated.memory\":").append(allocatedMemoryGB).append(",\"cluster.allocated.vcores\":").append(allocatedVCoresGB).append(",\"cluster.available.memory\":").append(availableMemoryGB).append(",\"cluster.available.vcores\":").append(availableVCoresGB)[ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_51 $$ Map<SchedulerEventType, Double> handleOperTimecostMap = new HashMap<SchedulerEventType, Double>()[ CD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_46 $$ if (handleTimecostHistogram == null && metrics.getHistograms().containsKey("sampler.scheduler.operation.handle.timecost")) [ CD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_42 $$ double allocateTimecost, handleTimecost[ CD ]
Line_15 $$ jvmTotalMemoryGB = jvmTotalMemoryGauge == null ? 0 : Double.parseDouble(jvmTotalMemoryGauge.getValue().toString()) / 1024 / 1024 / 1024-->Line_78 $$ sb.append("\"time\":").append(System.currentTimeMillis()).append(",\"jvm.free.memory\":").append(jvmFreeMemoryGB).append(",\"jvm.max.memory\":").append(jvmMaxMemoryGB).append(",\"jvm.total.memory\":").append(jvmTotalMemoryGB).append(",\"running.applications\":").append(numRunningApps).append(",\"running.containers\":").append(numRunningContainers).append(",\"cluster.allocated.memory\":").append(allocatedMemoryGB).append(",\"cluster.allocated.vcores\":").append(allocatedVCoresGB).append(",\"cluster.available.memory\":").append(availableMemoryGB).append(",\"cluster.available.vcores\":").append(availableVCoresGB)[ FD ]
Line_52 $$ for (SchedulerEventType e : SchedulerEventType.values()) -->Line_57 $$ double timecost = handleOperTimecostHistogramMap.containsKey(e) ? handleOperTimecostHistogramMap.get(e).getSnapshot().getMean() / 1000000 : 0[ FD ]
Line_25 $$ double allocatedMemoryGB, allocatedVCoresGB, availableMemoryGB, availableVCoresGB-->Line_39 $$ allocatedVCoresGB = allocatedVCoresGauge == null ? 0 : Double.parseDouble(allocatedVCoresGauge.getValue().toString())[ FD ]
Line_16 $$ String numRunningApps, numRunningContainers-->Line_24 $$ numRunningContainers = numRunningContainersGauge == null ? "0" : numRunningContainersGauge.getValue().toString()[ FD ]
Line_13 $$ jvmFreeMemoryGB = jvmFreeMemoryGauge == null ? 0 : Double.parseDouble(jvmFreeMemoryGauge.getValue().toString()) / 1024 / 1024 / 1024-->Line_78 $$ sb.append("\"time\":").append(System.currentTimeMillis()).append(",\"jvm.free.memory\":").append(jvmFreeMemoryGB).append(",\"jvm.max.memory\":").append(jvmMaxMemoryGB).append(",\"jvm.total.memory\":").append(jvmTotalMemoryGB).append(",\"running.applications\":").append(numRunningApps).append(",\"running.containers\":").append(numRunningContainers).append(",\"cluster.allocated.memory\":").append(allocatedMemoryGB).append(",\"cluster.allocated.vcores\":").append(allocatedVCoresGB).append(",\"cluster.available.memory\":").append(availableMemoryGB).append(",\"cluster.available.vcores\":").append(availableVCoresGB)[ FD ]
Line_3 $$ double jvmFreeMemoryGB, jvmMaxMemoryGB, jvmTotalMemoryGB-->Line_13 $$ jvmFreeMemoryGB = jvmFreeMemoryGauge == null ? 0 : Double.parseDouble(jvmFreeMemoryGauge.getValue().toString()) / 1024 / 1024 / 1024[ FD ]
Line_3 $$ double jvmFreeMemoryGB, jvmMaxMemoryGB, jvmTotalMemoryGB-->Line_15 $$ jvmTotalMemoryGB = jvmTotalMemoryGauge == null ? 0 : Double.parseDouble(jvmTotalMemoryGauge.getValue().toString()) / 1024 / 1024 / 1024[ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_76 $$ StringBuilder sb = new StringBuilder()[ CD ]
Line_60 $$ Map<String, Double> queueAllocatedMemoryMap = new HashMap<String, Double>()-->Line_80 $$ sb.append(",\"queue.").append(queue).append(".allocated.memory\":").append(queueAllocatedMemoryMap.get(queue))[ FD ]
Line_52 $$ for (SchedulerEventType e : SchedulerEventType.values()) -->Line_86 $$ sb.append(",\"scheduler.handle-").append(e).append(".timecost\":").append(handleOperTimecostMap.get(e))[ FD ]
Line_43 $$ if (allocateTimecostHistogram == null && metrics.getHistograms().containsKey("sampler.scheduler.operation.allocate.timecost")) -->Line_44 $$ allocateTimecostHistogram = metrics.getHistograms().get("sampler.scheduler.operation.allocate.timecost")[ CD ]
Line_3 $$ double jvmFreeMemoryGB, jvmMaxMemoryGB, jvmTotalMemoryGB-->Line_14 $$ jvmMaxMemoryGB = jvmMaxMemoryGauge == null ? 0 : Double.parseDouble(jvmMaxMemoryGauge.getValue().toString()) / 1024 / 1024 / 1024[ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_26 $$ if (allocatedMemoryGauge == null && metrics.getGauges().containsKey("variable.cluster.allocated.memory")) [ CD ]
Line_76 $$ StringBuilder sb = new StringBuilder()-->Line_84 $$ sb.append(",\"scheduler.handle.timecost\":").append(handleTimecost)[ FD ]
Line_42 $$ double allocateTimecost, handleTimecost-->Line_49 $$ allocateTimecost = allocateTimecostHistogram == null ? 0.0 : allocateTimecostHistogram.getSnapshot().getMean() / 1000000[ FD ]
Line_29 $$ if (allocatedVCoresGauge == null && metrics.getGauges().containsKey("variable.cluster.allocated.vcores")) -->Line_30 $$ allocatedVCoresGauge = metrics.getGauges().get("variable.cluster.allocated.vcores")[ CD ]
Line_25 $$ double allocatedMemoryGB, allocatedVCoresGB, availableMemoryGB, availableVCoresGB-->Line_38 $$ allocatedMemoryGB = allocatedMemoryGauge == null ? 0 : Double.parseDouble(allocatedMemoryGauge.getValue().toString()) / 1024[ FD ]
Line_51 $$ Map<SchedulerEventType, Double> handleOperTimecostMap = new HashMap<SchedulerEventType, Double>()-->Line_86 $$ sb.append(",\"scheduler.handle-").append(e).append(".timecost\":").append(handleOperTimecostMap.get(e))[ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_25 $$ double allocatedMemoryGB, allocatedVCoresGB, availableMemoryGB, availableVCoresGB[ CD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_14 $$ jvmMaxMemoryGB = jvmMaxMemoryGauge == null ? 0 : Double.parseDouble(jvmMaxMemoryGauge.getValue().toString()) / 1024 / 1024 / 1024[ CD ]
Line_38 $$ allocatedMemoryGB = allocatedMemoryGauge == null ? 0 : Double.parseDouble(allocatedMemoryGauge.getValue().toString()) / 1024-->Line_78 $$ sb.append("\"time\":").append(System.currentTimeMillis()).append(",\"jvm.free.memory\":").append(jvmFreeMemoryGB).append(",\"jvm.max.memory\":").append(jvmMaxMemoryGB).append(",\"jvm.total.memory\":").append(jvmTotalMemoryGB).append(",\"running.applications\":").append(numRunningApps).append(",\"running.containers\":").append(numRunningContainers).append(",\"cluster.allocated.memory\":").append(allocatedMemoryGB).append(",\"cluster.allocated.vcores\":").append(allocatedVCoresGB).append(",\"cluster.available.memory\":").append(availableMemoryGB).append(",\"cluster.available.vcores\":").append(availableVCoresGB)[ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_24 $$ numRunningContainers = numRunningContainersGauge == null ? "0" : numRunningContainersGauge.getValue().toString()[ CD ]
Line_41 $$ availableVCoresGB = availableVCoresGauge == null ? 0 : Double.parseDouble(availableVCoresGauge.getValue().toString())-->Line_78 $$ sb.append("\"time\":").append(System.currentTimeMillis()).append(",\"jvm.free.memory\":").append(jvmFreeMemoryGB).append(",\"jvm.max.memory\":").append(jvmMaxMemoryGB).append(",\"jvm.total.memory\":").append(jvmTotalMemoryGB).append(",\"running.applications\":").append(numRunningApps).append(",\"running.containers\":").append(numRunningContainers).append(",\"cluster.allocated.memory\":").append(allocatedMemoryGB).append(",\"cluster.allocated.vcores\":").append(allocatedVCoresGB).append(",\"cluster.available.memory\":").append(availableMemoryGB).append(",\"cluster.available.vcores\":").append(availableVCoresGB)[ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_89 $$ return sb.toString()[ CD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_10 $$ if (jvmTotalMemoryGauge == null && metrics.getGauges().containsKey("variable.jvm.total.memory")) [ CD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_43 $$ if (allocateTimecostHistogram == null && metrics.getHistograms().containsKey("sampler.scheduler.operation.allocate.timecost")) [ CD ]
Line_76 $$ StringBuilder sb = new StringBuilder()-->Line_83 $$ sb.append(",\"scheduler.allocate.timecost\":").append(allocateTimecost)[ FD ]
Line_14 $$ jvmMaxMemoryGB = jvmMaxMemoryGauge == null ? 0 : Double.parseDouble(jvmMaxMemoryGauge.getValue().toString()) / 1024 / 1024 / 1024-->Line_78 $$ sb.append("\"time\":").append(System.currentTimeMillis()).append(",\"jvm.free.memory\":").append(jvmFreeMemoryGB).append(",\"jvm.max.memory\":").append(jvmMaxMemoryGB).append(",\"jvm.total.memory\":").append(jvmTotalMemoryGB).append(",\"running.applications\":").append(numRunningApps).append(",\"running.containers\":").append(numRunningContainers).append(",\"cluster.allocated.memory\":").append(allocatedMemoryGB).append(",\"cluster.allocated.vcores\":").append(allocatedVCoresGB).append(",\"cluster.available.memory\":").append(availableMemoryGB).append(",\"cluster.available.vcores\":").append(availableVCoresGB)[ FD ]
Line_53 $$ String key = "sampler.scheduler.operation.handle." + e + ".timecost"-->Line_55 $$ handleOperTimecostHistogramMap.put(e, metrics.getHistograms().get(key))[ FD ]
Line_53 $$ String key = "sampler.scheduler.operation.handle." + e + ".timecost"-->Line_54 $$ if (!handleOperTimecostHistogramMap.containsKey(e) && metrics.getHistograms().containsKey(key)) [ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_88 $$ sb.append("}")[ CD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_84 $$ sb.append(",\"scheduler.handle.timecost\":").append(handleTimecost)[ CD ]
Line_51 $$ Map<SchedulerEventType, Double> handleOperTimecostMap = new HashMap<SchedulerEventType, Double>()-->Line_58 $$ handleOperTimecostMap.put(e, timecost)[ FD ]
Line_70 $$ if (!queueAllocatedVCoresCounterMap.containsKey(queue) && metrics.getCounters().containsKey(key)) -->Line_71 $$ queueAllocatedVCoresCounterMap.put(queue, metrics.getCounters().get(key))[ CD ]
Line_52 $$ for (SchedulerEventType e : SchedulerEventType.values()) -->Line_55 $$ handleOperTimecostHistogramMap.put(e, metrics.getHistograms().get(key))[ FD ]
Line_53 $$ String key = "sampler.scheduler.operation.handle." + e + ".timecost"-->Line_64 $$ if (!queueAllocatedMemoryCounterMap.containsKey(queue) && metrics.getCounters().containsKey(key)) [ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_16 $$ String numRunningApps, numRunningContainers[ CD ]
Line_42 $$ double allocateTimecost, handleTimecost-->Line_50 $$ handleTimecost = handleTimecostHistogram == null ? 0.0 : handleTimecostHistogram.getSnapshot().getMean() / 1000000[ FD ]
Line_76 $$ StringBuilder sb = new StringBuilder()-->Line_89 $$ return sb.toString()[ FD ]
Line_32 $$ if (availableMemoryGauge == null && metrics.getGauges().containsKey("variable.cluster.available.memory")) -->Line_33 $$ availableMemoryGauge = metrics.getGauges().get("variable.cluster.available.memory")[ CD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_29 $$ if (allocatedVCoresGauge == null && metrics.getGauges().containsKey("variable.cluster.allocated.vcores")) [ CD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_49 $$ allocateTimecost = allocateTimecostHistogram == null ? 0.0 : allocateTimecostHistogram.getSnapshot().getMean() / 1000000[ CD ]
Line_54 $$ if (!handleOperTimecostHistogramMap.containsKey(e) && metrics.getHistograms().containsKey(key)) -->Line_55 $$ handleOperTimecostHistogramMap.put(e, metrics.getHistograms().get(key))[ CD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_41 $$ availableVCoresGB = availableVCoresGauge == null ? 0 : Double.parseDouble(availableVCoresGauge.getValue().toString())[ CD ]
Line_76 $$ StringBuilder sb = new StringBuilder()-->Line_80 $$ sb.append(",\"queue.").append(queue).append(".allocated.memory\":").append(queueAllocatedMemoryMap.get(queue))[ FD ]
Line_73 $$ long queueAllocatedVCores = queueAllocatedVCoresCounterMap.containsKey(queue) ? queueAllocatedVCoresCounterMap.get(queue).getCount() : 0-->Line_74 $$ queueAllocatedVCoresMap.put(queue, queueAllocatedVCores)[ FD ]
Line_42 $$ double allocateTimecost, handleTimecost-->Line_83 $$ sb.append(",\"scheduler.allocate.timecost\":").append(allocateTimecost)[ FD ]
Line_62 $$ for (String queue : wrapper.getQueueSet()) -->Line_70 $$ if (!queueAllocatedVCoresCounterMap.containsKey(queue) && metrics.getCounters().containsKey(key)) [ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_15 $$ jvmTotalMemoryGB = jvmTotalMemoryGauge == null ? 0 : Double.parseDouble(jvmTotalMemoryGauge.getValue().toString()) / 1024 / 1024 / 1024[ CD ]
Line_69 $$ key = "counter.queue." + queue + ".allocated.cores"-->Line_71 $$ queueAllocatedVCoresCounterMap.put(queue, metrics.getCounters().get(key))[ FD ]
Line_50 $$ handleTimecost = handleTimecostHistogram == null ? 0.0 : handleTimecostHistogram.getSnapshot().getMean() / 1000000-->Line_84 $$ sb.append(",\"scheduler.handle.timecost\":").append(handleTimecost)[ FD ]
Line_35 $$ if (availableVCoresGauge == null && metrics.getGauges().containsKey("variable.cluster.available.vcores")) -->Line_36 $$ availableVCoresGauge = metrics.getGauges().get("variable.cluster.available.vcores")[ CD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_38 $$ allocatedMemoryGB = allocatedMemoryGauge == null ? 0 : Double.parseDouble(allocatedMemoryGauge.getValue().toString()) / 1024[ CD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_4 $$ if (jvmFreeMemoryGauge == null && metrics.getGauges().containsKey("variable.jvm.free.memory")) [ CD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_50 $$ handleTimecost = handleTimecostHistogram == null ? 0.0 : handleTimecostHistogram.getSnapshot().getMean() / 1000000[ CD ]
Line_62 $$ for (String queue : wrapper.getQueueSet()) -->Line_71 $$ queueAllocatedVCoresCounterMap.put(queue, metrics.getCounters().get(key))[ FD ]
Line_26 $$ if (allocatedMemoryGauge == null && metrics.getGauges().containsKey("variable.cluster.allocated.memory")) -->Line_27 $$ allocatedMemoryGauge = metrics.getGauges().get("variable.cluster.allocated.memory")[ CD ]
Line_67 $$ double queueAllocatedMemoryGB = queueAllocatedMemoryCounterMap.containsKey(queue) ? queueAllocatedMemoryCounterMap.get(queue).getCount() / 1024.0 : 0-->Line_68 $$ queueAllocatedMemoryMap.put(queue, queueAllocatedMemoryGB)[ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_83 $$ sb.append(",\"scheduler.allocate.timecost\":").append(allocateTimecost)[ CD ]
Line_76 $$ StringBuilder sb = new StringBuilder()-->Line_86 $$ sb.append(",\"scheduler.handle-").append(e).append(".timecost\":").append(handleOperTimecostMap.get(e))[ FD ]
Line_60 $$ Map<String, Double> queueAllocatedMemoryMap = new HashMap<String, Double>()-->Line_68 $$ queueAllocatedMemoryMap.put(queue, queueAllocatedMemoryGB)[ FD ]
Line_76 $$ StringBuilder sb = new StringBuilder()-->Line_81 $$ sb.append(",\"queue.").append(queue).append(".allocated.vcores\":").append(queueAllocatedVCoresMap.get(queue))[ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_61 $$ Map<String, Long> queueAllocatedVCoresMap = new HashMap<String, Long>()[ CD ]
Line_3 $$ double jvmFreeMemoryGB, jvmMaxMemoryGB, jvmTotalMemoryGB-->Line_78 $$ sb.append("\"time\":").append(System.currentTimeMillis()).append(",\"jvm.free.memory\":").append(jvmFreeMemoryGB).append(",\"jvm.max.memory\":").append(jvmMaxMemoryGB).append(",\"jvm.total.memory\":").append(jvmTotalMemoryGB).append(",\"running.applications\":").append(numRunningApps).append(",\"running.containers\":").append(numRunningContainers).append(",\"cluster.allocated.memory\":").append(allocatedMemoryGB).append(",\"cluster.allocated.vcores\":").append(allocatedVCoresGB).append(",\"cluster.available.memory\":").append(availableMemoryGB).append(",\"cluster.available.vcores\":").append(availableVCoresGB)[ FD ]
Line_16 $$ String numRunningApps, numRunningContainers-->Line_23 $$ numRunningApps = numRunningAppsGauge == null ? "0" : numRunningAppsGauge.getValue().toString()[ FD ]
Line_17 $$ if (numRunningAppsGauge == null && metrics.getGauges().containsKey("variable.running.application")) -->Line_18 $$ numRunningAppsGauge = metrics.getGauges().get("variable.running.application")[ CD ]
Line_61 $$ Map<String, Long> queueAllocatedVCoresMap = new HashMap<String, Long>()-->Line_74 $$ queueAllocatedVCoresMap.put(queue, queueAllocatedVCores)[ FD ]
Line_25 $$ double allocatedMemoryGB, allocatedVCoresGB, availableMemoryGB, availableVCoresGB-->Line_40 $$ availableMemoryGB = availableMemoryGauge == null ? 0 : Double.parseDouble(availableMemoryGauge.getValue().toString()) / 1024[ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_32 $$ if (availableMemoryGauge == null && metrics.getGauges().containsKey("variable.cluster.available.memory")) [ CD ]
Line_62 $$ for (String queue : wrapper.getQueueSet()) -->Line_73 $$ long queueAllocatedVCores = queueAllocatedVCoresCounterMap.containsKey(queue) ? queueAllocatedVCoresCounterMap.get(queue).getCount() : 0[ FD ]
Line_2 $$ public String generateRealTimeTrackingMetrics() -->Line_13 $$ jvmFreeMemoryGB = jvmFreeMemoryGauge == null ? 0 : Double.parseDouble(jvmFreeMemoryGauge.getValue().toString()) / 1024 / 1024 / 1024[ CD ]
Line_20 $$ if (numRunningContainersGauge == null && metrics.getGauges().containsKey("variable.running.container")) -->Line_21 $$ numRunningContainersGauge = metrics.getGauges().get("variable.running.container")[ CD ]
