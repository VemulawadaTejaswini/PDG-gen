Line_8 $$ psiClass = resolveResult.getElement()-->Line_44 $$ found = psiClass.findMethodBySignature(pattern, true)[ FD ]
Line_55 $$ returnType = signature.getReturnType()-->Line_57 $$ TypeWriter.writeType(builder, returnType, operand)[ FD ]
Line_3 $$ final PsiType type = typeElement.getType()-->Line_15 $$ TypeWriter.writeTypeForNew(builder, type, operand)[ FD ]
Line_62 $$ if (param == allParameters.length) -->Line_66 $$ final ExpressionGenerator expressionGenerator = new ExpressionGenerator(builder, extended)[ CD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_47 $$ ModifierListGenerator.writeModifiers(builder, found.getModifierList(), ModifierListGenerator.JAVA_MODIFIERS_WITHOUT_ABSTRACT)[ FD ]
Line_51 $$ PsiType returnType-->Line_55 $$ returnType = signature.getReturnType()[ FD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_68 $$ builder.append(";\n}\n")[ FD ]
Line_26 $$ List<GrParameter> actual = new ArrayList<GrParameter>(Arrays.asList(allParameters))-->Line_39 $$ final GrParameter[] parameters = actual.toArray(new GrParameter[actual.size()])[ FD ]
Line_42 $$ PsiMethod found = null-->Line_44 $$ found = psiClass.findMethodBySignature(pattern, true)[ FD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_58 $$ builder.append(' ').append(name)[ FD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_59 $$ GenerationUtil.writeParameterList(builder, parameters, new GeneratorClassNameProvider(), context)[ CD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_35 $$ if (param < allParameters.length) [ FD ]
Line_46 $$ if (found != null) -->Line_47 $$ ModifierListGenerator.writeModifiers(builder, found.getModifierList(), ModifierListGenerator.JAVA_MODIFIERS_WITHOUT_ABSTRACT)[ CD ]
Line_11 $$ psiClass = null-->Line_43 $$ if (psiClass != null) [ FD ]
Line_39 $$ final GrParameter[] parameters = actual.toArray(new GrParameter[actual.size()])-->Line_59 $$ GenerationUtil.writeParameterList(builder, parameters, new GeneratorClassNameProvider(), context)[ FD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_61 $$ extended.setInAnonymousContext(true)[ CD ]
Line_12 $$ substitutor = PsiSubstitutor.EMPTY-->Line_53 $$ returnType = substitutor.substitute(context.typeProvider.getReturnType(found))[ FD ]
Line_26 $$ List<GrParameter> actual = new ArrayList<GrParameter>(Arrays.asList(allParameters))-->Line_33 $$ if (param < allParameters.length && !actual.get(param).isOptional())[ FD ]
Line_19 $$ for (GrNamedArgument arg : operand.getNamedArguments()) -->Line_21 $$ final GrExpression expression = arg.getExpression()[ FD ]
Line_19 $$ for (GrNamedArgument arg : operand.getNamedArguments()) -->Line_20 $$ final String name = arg.getLabelName()[ FD ]
Line_51 $$ PsiType returnType-->Line_53 $$ returnType = substitutor.substitute(context.typeProvider.getReturnType(found))[ FD ]
Line_20 $$ final String name = arg.getLabelName()-->Line_67 $$ GenerationUtil.invokeMethodByName(caller, name, args, GrNamedArgument.EMPTY_ARRAY, GrClosableBlock.EMPTY_ARRAY, expressionGenerator, arg)[ FD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_40 $$ final GrClosureSignature signature = GrClosureSignatureUtil.createSignature(parameters, clReturnType)[ CD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_17 $$ final GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(operand.getProject())[ CD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_19 $$ for (GrNamedArgument arg : operand.getNamedArguments()) [ FD ]
Line_40 $$ final GrClosureSignature signature = GrClosureSignatureUtil.createSignature(parameters, clReturnType)-->Line_41 $$ final GrMethod pattern = factory.createMethodFromSignature(name, signature)[ FD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_3 $$ final PsiType type = typeElement.getType()[ FD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_36 $$ final GrParameter opt = actual.remove(param)[ FD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_33 $$ if (param < allParameters.length && !actual.get(param).isOptional())[ FD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_5 $$ final PsiSubstitutor substitutor[ CD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_72 $$ builder.append("}")[ FD ]
Line_39 $$ final GrParameter[] parameters = actual.toArray(new GrParameter[actual.size()])-->Line_40 $$ final GrClosureSignature signature = GrClosureSignatureUtil.createSignature(parameters, clReturnType)[ FD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_16 $$ builder.append("() [ FD ]
Line_6 $$ if (type instanceof PsiClassType) -->Line_12 $$ substitutor = PsiSubstitutor.EMPTY[ CD ]
Line_44 $$ found = psiClass.findMethodBySignature(pattern, true)-->Line_47 $$ ModifierListGenerator.writeModifiers(builder, found.getModifierList(), ModifierListGenerator.JAVA_MODIFIERS_WITHOUT_ABSTRACT)[ FD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_4 $$ final PsiClass psiClass[ CD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_52 $$ if (found != null) [ CD ]
Line_20 $$ final String name = arg.getLabelName()-->Line_58 $$ builder.append(' ').append(name)[ FD ]
Line_62 $$ if (param == allParameters.length) -->Line_63 $$ new CodeBlockGenerator(builder, extended).generateCodeBlock((GrCodeBlock) expression, false)[ CD ]
Line_6 $$ if (type instanceof PsiClassType) -->Line_11 $$ psiClass = null[ CD ]
Line_9 $$ substitutor = resolveResult.getSubstitutor()-->Line_12 $$ substitutor = PsiSubstitutor.EMPTY[ FD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_43 $$ if (psiClass != null) [ CD ]
Line_27 $$ final PsiType clReturnType = context.typeProvider.getReturnType(closure)-->Line_40 $$ final GrClosureSignature signature = GrClosureSignatureUtil.createSignature(parameters, clReturnType)[ FD ]
Line_4 $$ final PsiClass psiClass-->Line_8 $$ psiClass = resolveResult.getElement()[ FD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_33 $$ if (param < allParameters.length && !actual.get(param).isOptional())[ CD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_59 $$ GenerationUtil.writeParameterList(builder, parameters, new GeneratorClassNameProvider(), context)[ FD ]
Line_42 $$ PsiMethod found = null-->Line_46 $$ if (found != null) [ FD ]
Line_26 $$ List<GrParameter> actual = new ArrayList<GrParameter>(Arrays.asList(allParameters))-->Line_36 $$ final GrParameter opt = actual.remove(param)[ FD ]
Line_36 $$ final GrParameter opt = actual.remove(param)-->Line_37 $$ args[param] = opt.getInitializerGroovy()[ FD ]
Line_8 $$ psiClass = resolveResult.getElement()-->Line_11 $$ psiClass = null[ FD ]
Line_42 $$ PsiMethod found = null-->Line_47 $$ ModifierListGenerator.writeModifiers(builder, found.getModifierList(), ModifierListGenerator.JAVA_MODIFIERS_WITHOUT_ABSTRACT)[ FD ]
Line_18 $$ final GrExpression caller = factory.createExpressionFromText("this")-->Line_67 $$ GenerationUtil.invokeMethodByName(caller, name, args, GrNamedArgument.EMPTY_ARRAY, GrClosableBlock.EMPTY_ARRAY, expressionGenerator, arg)[ FD ]
Line_53 $$ returnType = substitutor.substitute(context.typeProvider.getReturnType(found))-->Line_55 $$ returnType = signature.getReturnType()[ FD ]
Line_4 $$ final PsiClass psiClass-->Line_44 $$ found = psiClass.findMethodBySignature(pattern, true)[ FD ]
Line_44 $$ found = psiClass.findMethodBySignature(pattern, true)-->Line_52 $$ if (found != null) [ FD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_16 $$ builder.append("() [ CD ]
Line_19 $$ for (GrNamedArgument arg : operand.getNamedArguments()) -->Line_67 $$ GenerationUtil.invokeMethodByName(caller, name, args, GrNamedArgument.EMPTY_ARRAY, GrClosableBlock.EMPTY_ARRAY, expressionGenerator, arg)[ FD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_65 $$ builder.append("[ FD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_72 $$ builder.append("}")[ CD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_18 $$ final GrExpression caller = factory.createExpressionFromText("this")[ CD ]
Line_4 $$ final PsiClass psiClass-->Line_11 $$ psiClass = null[ FD ]
Line_17 $$ final GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(operand.getProject())-->Line_30 $$ args[i] = factory.createExpressionFromText(allParameters[i].getName())[ FD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_35 $$ if (param < allParameters.length) [ CD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_62 $$ if (param == allParameters.length) [ FD ]
Line_5 $$ final PsiSubstitutor substitutor-->Line_53 $$ returnType = substitutor.substitute(context.typeProvider.getReturnType(found))[ FD ]
Line_44 $$ found = psiClass.findMethodBySignature(pattern, true)-->Line_53 $$ returnType = substitutor.substitute(context.typeProvider.getReturnType(found))[ FD ]
Line_60 $$ final ExpressionContext extended = context.extend()-->Line_61 $$ extended.setInAnonymousContext(true)[ FD ]
Line_3 $$ final PsiType type = typeElement.getType()-->Line_6 $$ if (type instanceof PsiClassType) [ FD ]
Line_53 $$ returnType = substitutor.substitute(context.typeProvider.getReturnType(found))-->Line_57 $$ TypeWriter.writeType(builder, returnType, operand)[ FD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_3 $$ final PsiType type = typeElement.getType()[ CD ]
Line_20 $$ final String name = arg.getLabelName()-->Line_41 $$ final GrMethod pattern = factory.createMethodFromSignature(name, signature)[ FD ]
Line_62 $$ if (param == allParameters.length) -->Line_65 $$ builder.append("[ CD ]
Line_62 $$ if (param == allParameters.length) -->Line_68 $$ builder.append(";\n}\n")[ CD ]
Line_66 $$ final ExpressionGenerator expressionGenerator = new ExpressionGenerator(builder, extended)-->Line_67 $$ GenerationUtil.invokeMethodByName(caller, name, args, GrNamedArgument.EMPTY_ARRAY, GrClosableBlock.EMPTY_ARRAY, expressionGenerator, arg)[ FD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_60 $$ final ExpressionContext extended = context.extend()[ CD ]
Line_52 $$ if (found != null) -->Line_55 $$ returnType = signature.getReturnType()[ CD ]
Line_44 $$ found = psiClass.findMethodBySignature(pattern, true)-->Line_46 $$ if (found != null) [ FD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_51 $$ PsiType returnType[ CD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_57 $$ TypeWriter.writeType(builder, returnType, operand)[ FD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_15 $$ TypeWriter.writeTypeForNew(builder, type, operand)[ FD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_41 $$ final GrMethod pattern = factory.createMethodFromSignature(name, signature)[ CD ]
Line_40 $$ final GrClosureSignature signature = GrClosureSignatureUtil.createSignature(parameters, clReturnType)-->Line_55 $$ returnType = signature.getReturnType()[ FD ]
Line_7 $$ final PsiClassType.ClassResolveResult resolveResult = ((PsiClassType) type).resolveGenerics()-->Line_8 $$ psiClass = resolveResult.getElement()[ FD ]
Line_6 $$ if (type instanceof PsiClassType) -->Line_9 $$ substitutor = resolveResult.getSubstitutor()[ CD ]
Line_35 $$ if (param < allParameters.length) -->Line_36 $$ final GrParameter opt = actual.remove(param)[ CD ]
Line_43 $$ if (psiClass != null) -->Line_44 $$ found = psiClass.findMethodBySignature(pattern, true)[ CD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_14 $$ builder.append("new ")[ CD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_46 $$ if (found != null) [ CD ]
Line_11 $$ psiClass = null-->Line_44 $$ found = psiClass.findMethodBySignature(pattern, true)[ FD ]
Line_5 $$ final PsiSubstitutor substitutor-->Line_12 $$ substitutor = PsiSubstitutor.EMPTY[ FD ]
Line_17 $$ final GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(operand.getProject())-->Line_18 $$ final GrExpression caller = factory.createExpressionFromText("this")[ FD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_17 $$ final GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(operand.getProject())[ FD ]
Line_5 $$ final PsiSubstitutor substitutor-->Line_9 $$ substitutor = resolveResult.getSubstitutor()[ FD ]
Line_29 $$ for (int i = 0; i < allParameters.length; i++) -->Line_30 $$ args[i] = factory.createExpressionFromText(allParameters[i].getName())[ CD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_42 $$ PsiMethod found = null[ CD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_6 $$ if (type instanceof PsiClassType) [ CD ]
Line_62 $$ if (param == allParameters.length) -->Line_67 $$ GenerationUtil.invokeMethodByName(caller, name, args, GrNamedArgument.EMPTY_ARRAY, GrClosableBlock.EMPTY_ARRAY, expressionGenerator, arg)[ CD ]
Line_8 $$ psiClass = resolveResult.getElement()-->Line_43 $$ if (psiClass != null) [ FD ]
Line_28 $$ GrExpression[] args = new GrExpression[allParameters.length]-->Line_67 $$ GenerationUtil.invokeMethodByName(caller, name, args, GrNamedArgument.EMPTY_ARRAY, GrClosableBlock.EMPTY_ARRAY, expressionGenerator, arg)[ FD ]
Line_25 $$ final GrParameter[] allParameters = closure.getAllParameters()-->Line_26 $$ List<GrParameter> actual = new ArrayList<GrParameter>(Arrays.asList(allParameters))[ FD ]
Line_46 $$ if (found != null) -->Line_49 $$ builder.append("public ")[ CD ]
Line_35 $$ if (param < allParameters.length) -->Line_37 $$ args[param] = opt.getInitializerGroovy()[ CD ]
Line_41 $$ final GrMethod pattern = factory.createMethodFromSignature(name, signature)-->Line_44 $$ found = psiClass.findMethodBySignature(pattern, true)[ FD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_60 $$ final ExpressionContext extended = context.extend()[ FD ]
Line_6 $$ if (type instanceof PsiClassType) -->Line_7 $$ final PsiClassType.ClassResolveResult resolveResult = ((PsiClassType) type).resolveGenerics()[ CD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_15 $$ TypeWriter.writeTypeForNew(builder, type, operand)[ CD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_39 $$ final GrParameter[] parameters = actual.toArray(new GrParameter[actual.size()])[ CD ]
Line_42 $$ PsiMethod found = null-->Line_53 $$ returnType = substitutor.substitute(context.typeProvider.getReturnType(found))[ FD ]
Line_9 $$ substitutor = resolveResult.getSubstitutor()-->Line_53 $$ returnType = substitutor.substitute(context.typeProvider.getReturnType(found))[ FD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_14 $$ builder.append("new ")[ FD ]
Line_4 $$ final PsiClass psiClass-->Line_43 $$ if (psiClass != null) [ FD ]
Line_51 $$ PsiType returnType-->Line_57 $$ TypeWriter.writeType(builder, returnType, operand)[ FD ]
Line_2 $$ static void writeAnonymousMap(GrListOrMap operand, GrTypeElement typeElement, final StringBuilder builder, ExpressionContext context) -->Line_49 $$ builder.append("public ")[ FD ]
Line_24 $$ final GrClosableBlock closure = (GrClosableBlock) expression-->Line_25 $$ final GrParameter[] allParameters = closure.getAllParameters()[ FD ]
Line_17 $$ final GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(operand.getProject())-->Line_41 $$ final GrMethod pattern = factory.createMethodFromSignature(name, signature)[ FD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_62 $$ if (param == allParameters.length) [ CD ]
Line_42 $$ PsiMethod found = null-->Line_52 $$ if (found != null) [ FD ]
Line_7 $$ final PsiClassType.ClassResolveResult resolveResult = ((PsiClassType) type).resolveGenerics()-->Line_9 $$ substitutor = resolveResult.getSubstitutor()[ FD ]
Line_6 $$ if (type instanceof PsiClassType) -->Line_8 $$ psiClass = resolveResult.getElement()[ CD ]
Line_24 $$ final GrClosableBlock closure = (GrClosableBlock) expression-->Line_27 $$ final PsiType clReturnType = context.typeProvider.getReturnType(closure)[ FD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_58 $$ builder.append(' ').append(name)[ CD ]
Line_32 $$ for (int param = allParameters.length; param >= 0; param--) -->Line_57 $$ TypeWriter.writeType(builder, returnType, operand)[ CD ]
Line_52 $$ if (found != null) -->Line_53 $$ returnType = substitutor.substitute(context.typeProvider.getReturnType(found))[ CD ]
