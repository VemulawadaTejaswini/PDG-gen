Line_30 $$ if (!candidates.isEmpty()) -->Line_39 $$ if (myDebugS.isDebugEnabled()) [ CD ]
Line_13 $$ final Set<File> candidates = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_21 $$ candidates.removeAll(newSources)[ FD ]
Line_12 $$ if (!c.isLocal() && !c.isAnonymous() && isEmpty(c.getOuterClassName())) -->Line_15 $$ if (currentlyMapped != null) [ CD ]
Line_14 $$ final Collection<File> currentlyMapped = myClassToSourceFile.get(c.name)-->Line_15 $$ if (currentlyMapped != null) [ FD ]
Line_13 $$ final Set<File> candidates = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_36 $$ candidates.addAll(newSources)[ FD ]
Line_2 $$ private void processAddedClasses(final DiffState state, File srcFile) -->Line_4 $$ if (addedClasses.isEmpty()) [ CD ]
Line_24 $$ for (final File candidate : candidates) -->Line_26 $$ nonExistentOrOutOfScope.add(candidate)[ FD ]
Line_23 $$ final Set<File> nonExistentOrOutOfScope = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_38 $$ candidates.removeAll(nonExistentOrOutOfScope)[ FD ]
Line_13 $$ final Set<File> candidates = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_38 $$ candidates.removeAll(nonExistentOrOutOfScope)[ FD ]
Line_19 $$ final Collection<File> newSources = myDelta.myClassToSourceFile.get(c.name)-->Line_36 $$ candidates.addAll(newSources)[ FD ]
Line_14 $$ final Collection<File> currentlyMapped = myClassToSourceFile.get(c.name)-->Line_16 $$ candidates.addAll(currentlyMapped)[ FD ]
Line_2 $$ private void processAddedClasses(final DiffState state, File srcFile) -->Line_8 $$ if (!myEasyMode && myFilter != null) [ CD ]
Line_60 $$ final TIntHashSet toAffect = new TIntHashSet()-->Line_64 $$ toAffect.addAll(classes.toArray())[ FD ]
Line_11 $$ for (ClassRepr c : addedClasses) -->Line_62 $$ final TIntHashSet classes = myShortClassNameIndex.get(myContext.get(c.getShortName()))[ FD ]
Line_19 $$ final Collection<File> newSources = myDelta.myClassToSourceFile.get(c.name)-->Line_20 $$ if (newSources != null) [ FD ]
Line_66 $$ toAffect.forEach(new TIntProcedure() -->Line_68 $$ final TIntHashSet depClasses = myClassToClassDependency.get(qName)[ FD ]
Line_13 $$ final Set<File> candidates = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_47 $$ myAffectedFiles.addAll(candidates)[ FD ]
Line_19 $$ final Collection<File> newSources = myDelta.myClassToSourceFile.get(c.name)-->Line_35 $$ if (newSources != null) [ FD ]
Line_30 $$ if (!candidates.isEmpty()) -->Line_35 $$ if (newSources != null) [ CD ]
Line_40 $$ final StringBuilder msg = new StringBuilder()-->Line_43 $$ msg.append(file.getPath()).append("; ")[ FD ]
Line_11 $$ for (ClassRepr c : addedClasses) -->Line_55 $$ myDelta.addAddedClass(c)[ FD ]
Line_59 $$ if (!myEasyMode && !c.isAnonymous() && !c.isLocal()) -->Line_62 $$ final TIntHashSet classes = myShortClassNameIndex.get(myContext.get(c.getShortName()))[ CD ]
Line_40 $$ final StringBuilder msg = new StringBuilder()-->Line_41 $$ msg.append("Possibly duplicated classes; Scheduling for recompilation sources: ")[ FD ]
Line_13 $$ final Set<File> candidates = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_33 $$ candidates.addAll(currentlyMapped)[ FD ]
Line_12 $$ if (!c.isLocal() && !c.isAnonymous() && isEmpty(c.getOuterClassName())) -->Line_29 $$ candidates.removeAll(nonExistentOrOutOfScope)[ CD ]
Line_30 $$ if (!candidates.isEmpty()) -->Line_32 $$ if (currentlyMapped != null) [ CD ]
Line_32 $$ if (currentlyMapped != null) -->Line_33 $$ candidates.addAll(currentlyMapped)[ CD ]
Line_60 $$ final TIntHashSet toAffect = new TIntHashSet()-->Line_61 $$ toAffect.add(c.name)[ FD ]
Line_2 $$ private void processAddedClasses(final DiffState state, File srcFile) -->Line_7 $$ debug("Processing added classes:")[ CD ]
Line_2 $$ private void processAddedClasses(final DiffState state, File srcFile) -->Line_3 $$ final Collection<ClassRepr> addedClasses = state.myClassDiff.added()[ CD ]
Line_2 $$ private void processAddedClasses(final DiffState state, File srcFile) -->Line_77 $$ debug("End of added classes processing.")[ CD ]
Line_59 $$ if (!myEasyMode && !c.isAnonymous() && !c.isLocal()) -->Line_63 $$ if (classes != null) [ CD ]
Line_12 $$ if (!c.isLocal() && !c.isAnonymous() && isEmpty(c.getOuterClassName())) -->Line_20 $$ if (newSources != null) [ CD ]
Line_39 $$ if (myDebugS.isDebugEnabled()) -->Line_45 $$ debug(msg.toString())[ CD ]
Line_15 $$ if (currentlyMapped != null) -->Line_16 $$ candidates.addAll(currentlyMapped)[ CD ]
Line_23 $$ final Set<File> nonExistentOrOutOfScope = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_29 $$ candidates.removeAll(nonExistentOrOutOfScope)[ FD ]
Line_66 $$ toAffect.forEach(new TIntProcedure() -->Line_69 $$ if (depClasses != null) [ CD ]
Line_11 $$ for (ClassRepr c : addedClasses) -->Line_56 $$ for (final int sup : c.getSupers()) [ FD ]
Line_13 $$ final Set<File> candidates = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_29 $$ candidates.removeAll(nonExistentOrOutOfScope)[ FD ]
Line_56 $$ for (final int sup : c.getSupers()) -->Line_57 $$ myDelta.registerAddedSuperClass(c.name, sup)[ FD ]
Line_12 $$ if (!c.isLocal() && !c.isAnonymous() && isEmpty(c.getOuterClassName())) -->Line_23 $$ final Set<File> nonExistentOrOutOfScope = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)[ CD ]
Line_13 $$ final Set<File> candidates = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_16 $$ candidates.addAll(currentlyMapped)[ FD ]
Line_39 $$ if (myDebugS.isDebugEnabled()) -->Line_41 $$ msg.append("Possibly duplicated classes; Scheduling for recompilation sources: ")[ CD ]
Line_30 $$ if (!candidates.isEmpty()) -->Line_31 $$ candidates.clear()[ CD ]
Line_13 $$ final Set<File> candidates = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_18 $$ candidates.removeAll(myCompiledFiles)[ FD ]
Line_11 $$ for (ClassRepr c : addedClasses) -->Line_12 $$ if (!c.isLocal() && !c.isAnonymous() && isEmpty(c.getOuterClassName())) [ FD ]
Line_59 $$ if (!myEasyMode && !c.isAnonymous() && !c.isLocal()) -->Line_60 $$ final TIntHashSet toAffect = new TIntHashSet()[ CD ]
Line_30 $$ if (!candidates.isEmpty()) -->Line_38 $$ candidates.removeAll(nonExistentOrOutOfScope)[ CD ]
Line_25 $$ if (!candidate.exists() || !myFilter.belongsToCurrentTargetChunk(candidate)) -->Line_26 $$ nonExistentOrOutOfScope.add(candidate)[ CD ]
Line_19 $$ final Collection<File> newSources = myDelta.myClassToSourceFile.get(c.name)-->Line_21 $$ candidates.removeAll(newSources)[ FD ]
Line_14 $$ final Collection<File> currentlyMapped = myClassToSourceFile.get(c.name)-->Line_33 $$ candidates.addAll(currentlyMapped)[ FD ]
Line_60 $$ final TIntHashSet toAffect = new TIntHashSet()-->Line_66 $$ toAffect.forEach(new TIntProcedure() [ FD ]
Line_23 $$ final Set<File> nonExistentOrOutOfScope = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_26 $$ nonExistentOrOutOfScope.add(candidate)[ FD ]
Line_62 $$ final TIntHashSet classes = myShortClassNameIndex.get(myContext.get(c.getShortName()))-->Line_64 $$ toAffect.addAll(classes.toArray())[ FD ]
Line_3 $$ final Collection<ClassRepr> addedClasses = state.myClassDiff.added()-->Line_4 $$ if (addedClasses.isEmpty()) [ FD ]
Line_68 $$ final TIntHashSet depClasses = myClassToClassDependency.get(qName)-->Line_69 $$ if (depClasses != null) [ FD ]
Line_12 $$ if (!c.isLocal() && !c.isAnonymous() && isEmpty(c.getOuterClassName())) -->Line_19 $$ final Collection<File> newSources = myDelta.myClassToSourceFile.get(c.name)[ CD ]
Line_13 $$ final Set<File> candidates = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_30 $$ if (!candidates.isEmpty()) [ FD ]
Line_12 $$ if (!c.isLocal() && !c.isAnonymous() && isEmpty(c.getOuterClassName())) -->Line_13 $$ final Set<File> candidates = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)[ CD ]
Line_12 $$ if (!c.isLocal() && !c.isAnonymous() && isEmpty(c.getOuterClassName())) -->Line_30 $$ if (!candidates.isEmpty()) [ CD ]
Line_59 $$ if (!myEasyMode && !c.isAnonymous() && !c.isLocal()) -->Line_66 $$ toAffect.forEach(new TIntProcedure() [ CD ]
Line_20 $$ if (newSources != null) -->Line_21 $$ candidates.removeAll(newSources)[ CD ]
Line_30 $$ if (!candidates.isEmpty()) -->Line_48 $$ return[ CD ]
Line_68 $$ final TIntHashSet depClasses = myClassToClassDependency.get(qName)-->Line_70 $$ affectCorrespondingSourceFiles(depClasses)[ FD ]
Line_12 $$ if (!c.isLocal() && !c.isAnonymous() && isEmpty(c.getOuterClassName())) -->Line_18 $$ candidates.removeAll(myCompiledFiles)[ CD ]
Line_62 $$ final TIntHashSet classes = myShortClassNameIndex.get(myContext.get(c.getShortName()))-->Line_63 $$ if (classes != null) [ FD ]
Line_66 $$ toAffect.forEach(new TIntProcedure() -->Line_72 $$ return true[ CD ]
Line_4 $$ if (addedClasses.isEmpty()) -->Line_5 $$ return[ CD ]
Line_59 $$ if (!myEasyMode && !c.isAnonymous() && !c.isLocal()) -->Line_61 $$ toAffect.add(c.name)[ CD ]
Line_30 $$ if (!candidates.isEmpty()) -->Line_47 $$ myAffectedFiles.addAll(candidates)[ CD ]
Line_42 $$ for (File file : candidates) -->Line_43 $$ msg.append(file.getPath()).append("; ")[ FD ]
Line_14 $$ final Collection<File> currentlyMapped = myClassToSourceFile.get(c.name)-->Line_32 $$ if (currentlyMapped != null) [ FD ]
Line_39 $$ if (myDebugS.isDebugEnabled()) -->Line_40 $$ final StringBuilder msg = new StringBuilder()[ CD ]
Line_40 $$ final StringBuilder msg = new StringBuilder()-->Line_45 $$ debug(msg.toString())[ FD ]
Line_69 $$ if (depClasses != null) -->Line_70 $$ affectCorrespondingSourceFiles(depClasses)[ CD ]
Line_13 $$ final Set<File> candidates = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_31 $$ candidates.clear()[ FD ]
Line_66 $$ toAffect.forEach(new TIntProcedure() -->Line_68 $$ final TIntHashSet depClasses = myClassToClassDependency.get(qName)[ CD ]
Line_35 $$ if (newSources != null) -->Line_36 $$ candidates.addAll(newSources)[ CD ]
Line_63 $$ if (classes != null) -->Line_64 $$ toAffect.addAll(classes.toArray())[ CD ]
Line_24 $$ for (final File candidate : candidates) -->Line_25 $$ if (!candidate.exists() || !myFilter.belongsToCurrentTargetChunk(candidate)) [ FD ]
Line_11 $$ for (ClassRepr c : addedClasses) -->Line_59 $$ if (!myEasyMode && !c.isAnonymous() && !c.isLocal()) [ FD ]
Line_12 $$ if (!c.isLocal() && !c.isAnonymous() && isEmpty(c.getOuterClassName())) -->Line_14 $$ final Collection<File> currentlyMapped = myClassToSourceFile.get(c.name)[ CD ]
