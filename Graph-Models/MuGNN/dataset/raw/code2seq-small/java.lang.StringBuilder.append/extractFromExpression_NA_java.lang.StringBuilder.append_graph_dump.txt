Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_13 $$ final boolean isClassMethod = flags != null && flags.isClassMethod()[ CD ]
Line_39 $$ if (fragment.isYieldInside()) -->Line_40 $$ builder.append("yield from ")[ CD ]
Line_3 $$ if (!fragment.getOutputVariables().isEmpty()) -->Line_5 $$ return[ CD ]
Line_16 $$ if (data.first == null || data.second == null) -->Line_17 $$ return[ CD ]
Line_23 $$ CommandProcessor.getInstance().executeCommand(project, new Runnable() -->Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() [ CD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_21 $$ final SimpleDuplicatesFinder finder = new SimpleDuplicatesFinder(expression, expression, variableData, fragment.getOutputVariables())[ CD ]
Line_7 $$ if (fragment.isReturnInstructionInside()) -->Line_9 $$ return[ CD ]
Line_50 $$ final PyFunction function = generator.createFromText(LanguageLevel.forElement(expression), PyFunction.class, builder.toString())-->Line_51 $$ final PyElement generated = function.getStatementList().getStatements()[0][ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_50 $$ final PyFunction function = generator.createFromText(LanguageLevel.forElement(expression), PyFunction.class, builder.toString())[ CD ]
Line_32 $$ final StringBuilder builder = new StringBuilder()-->Line_50 $$ final PyFunction function = generator.createFromText(LanguageLevel.forElement(expression), PyFunction.class, builder.toString())[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_15 $$ final Pair<String, AbstractVariableData[]> data = getNameAndVariableData(project, fragment, expression, isClassMethod, isStaticMethod)[ FD ]
Line_54 $$ callElement = ((PyReturnStatement) generated).getExpression()-->Line_64 $$ setSelectionAndCaret(editor, callElement)[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_20 $$ final AbstractVariableData[] variableData = data.second[ CD ]
Line_12 $$ final PyUtil.MethodFlags flags = function == null ? null : PyUtil.MethodFlags.of(function)-->Line_28 $$ PyFunction generatedMethod = generateMethodFromExpression(project, methodName, variableData, expression, flags, isAsync)[ FD ]
Line_19 $$ final String methodName = data.first-->Line_47 $$ builder.append(methodName)[ FD ]
Line_59 $$ callElement = PyReplaceExpressionUtil.replaceExpression(expression, callElement)-->Line_61 $$ if (callElement != null) [ FD ]
Line_28 $$ PyFunction generatedMethod = generateMethodFromExpression(project, methodName, variableData, expression, flags, isAsync)-->Line_31 $$ processParameters(project, generatedMethod, variableData, isMethod, isClassMethod, isStaticMethod)[ FD ]
Line_29 $$ generatedMethod = insertGeneratedMethod(expression, generatedMethod)-->Line_62 $$ processDuplicates(callElement, generatedMethod, finder, editor)[ FD ]
Line_32 $$ final StringBuilder builder = new StringBuilder()-->Line_40 $$ builder.append("yield from ")[ FD ]
Line_22 $$ if (fragment.getOutputVariables().isEmpty()) -->Line_23 $$ CommandProcessor.getInstance().executeCommand(project, new Runnable() [ CD ]
Line_20 $$ final AbstractVariableData[] variableData = data.second-->Line_31 $$ processParameters(project, generatedMethod, variableData, isMethod, isClassMethod, isStaticMethod)[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_3 $$ if (!fragment.getOutputVariables().isEmpty()) [ FD ]
Line_54 $$ callElement = ((PyReturnStatement) generated).getExpression()-->Line_59 $$ callElement = PyReplaceExpressionUtil.replaceExpression(expression, callElement)[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_7 $$ if (fragment.isReturnInstructionInside()) [ CD ]
Line_49 $$ final PyElementGenerator generator = PyElementGenerator.getInstance(project)-->Line_50 $$ final PyFunction function = generator.createFromText(LanguageLevel.forElement(expression), PyFunction.class, builder.toString())[ FD ]
Line_37 $$ if (isAsync) -->Line_39 $$ if (fragment.isYieldInside()) [ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_47 $$ builder.append(methodName)[ CD ]
Line_32 $$ final StringBuilder builder = new StringBuilder()-->Line_42 $$ builder.append("return ")[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_61 $$ if (callElement != null) [ CD ]
Line_14 $$ final boolean isStaticMethod = flags != null && flags.isClassMethod()-->Line_45 $$ appendSelf(expression, builder, isStaticMethod)[ FD ]
Line_7 $$ if (fragment.isReturnInstructionInside()) -->Line_8 $$ CommonRefactoringUtil.showErrorHint(project, editor, PyBundle.message("refactoring.extract.method.error.returns"), RefactoringBundle.message("error.title"), "refactoring.extractMethod")[ CD ]
Line_32 $$ final StringBuilder builder = new StringBuilder()-->Line_38 $$ builder.append("await ")[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_45 $$ appendSelf(expression, builder, isStaticMethod)[ FD ]
Line_37 $$ if (isAsync) -->Line_38 $$ builder.append("await ")[ CD ]
Line_20 $$ final AbstractVariableData[] variableData = data.second-->Line_28 $$ PyFunction generatedMethod = generateMethodFromExpression(project, methodName, variableData, expression, flags, isAsync)[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_31 $$ processParameters(project, generatedMethod, variableData, isMethod, isClassMethod, isStaticMethod)[ FD ]
Line_3 $$ if (!fragment.getOutputVariables().isEmpty()) -->Line_4 $$ CommonRefactoringUtil.showErrorHint(project, editor, PyBundle.message("refactoring.extract.method.error.local.variable.modifications"), RefactoringBundle.message("error.title"), "refactoring.extractMethod")[ CD ]
Line_13 $$ final boolean isClassMethod = flags != null && flags.isClassMethod()-->Line_15 $$ final Pair<String, AbstractVariableData[]> data = getNameAndVariableData(project, fragment, expression, isClassMethod, isStaticMethod)[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_19 $$ final String methodName = data.first[ CD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_21 $$ final SimpleDuplicatesFinder finder = new SimpleDuplicatesFinder(expression, expression, variableData, fragment.getOutputVariables())[ FD ]
Line_52 $$ PsiElement callElement = null-->Line_56 $$ callElement = ((PyExpressionStatement) generated).getExpression()[ FD ]
Line_29 $$ generatedMethod = insertGeneratedMethod(expression, generatedMethod)-->Line_31 $$ processParameters(project, generatedMethod, variableData, isMethod, isClassMethod, isStaticMethod)[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_29 $$ generatedMethod = insertGeneratedMethod(expression, generatedMethod)[ FD ]
Line_44 $$ if (isMethod) -->Line_45 $$ appendSelf(expression, builder, isStaticMethod)[ CD ]
Line_52 $$ PsiElement callElement = null-->Line_62 $$ processDuplicates(callElement, generatedMethod, finder, editor)[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_62 $$ processDuplicates(callElement, generatedMethod, finder, editor)[ FD ]
Line_32 $$ final StringBuilder builder = new StringBuilder()-->Line_36 $$ builder.append("def f():\n    ")[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_11 $$ final PyFunction function = PsiTreeUtil.getParentOfType(expression, PyFunction.class)[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_31 $$ processParameters(project, generatedMethod, variableData, isMethod, isClassMethod, isStaticMethod)[ CD ]
Line_27 $$ final boolean isAsync = fragment.isAsync()-->Line_28 $$ PyFunction generatedMethod = generateMethodFromExpression(project, methodName, variableData, expression, flags, isAsync)[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_33 $$ if (isAsync) [ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_64 $$ setSelectionAndCaret(editor, callElement)[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_36 $$ builder.append("def f():\n    ")[ CD ]
Line_51 $$ final PyElement generated = function.getStatementList().getStatements()[0]-->Line_53 $$ if (generated instanceof PyReturnStatement) [ FD ]
Line_58 $$ if (callElement != null) -->Line_59 $$ callElement = PyReplaceExpressionUtil.replaceExpression(expression, callElement)[ CD ]
Line_54 $$ callElement = ((PyReturnStatement) generated).getExpression()-->Line_61 $$ if (callElement != null) [ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_16 $$ if (data.first == null || data.second == null) [ CD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_30 $$ final boolean isMethod = PyPsiUtils.isMethodContext(expression)[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_29 $$ generatedMethod = insertGeneratedMethod(expression, generatedMethod)[ CD ]
Line_33 $$ if (isAsync) -->Line_34 $$ builder.append("async ")[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_58 $$ if (callElement != null) [ CD ]
Line_56 $$ callElement = ((PyExpressionStatement) generated).getExpression()-->Line_61 $$ if (callElement != null) [ FD ]
Line_59 $$ callElement = PyReplaceExpressionUtil.replaceExpression(expression, callElement)-->Line_62 $$ processDuplicates(callElement, generatedMethod, finder, editor)[ FD ]
Line_21 $$ final SimpleDuplicatesFinder finder = new SimpleDuplicatesFinder(expression, expression, variableData, fragment.getOutputVariables())-->Line_62 $$ processDuplicates(callElement, generatedMethod, finder, editor)[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_14 $$ final boolean isStaticMethod = flags != null && flags.isClassMethod()[ CD ]
Line_11 $$ final PyFunction function = PsiTreeUtil.getParentOfType(expression, PyFunction.class)-->Line_12 $$ final PyUtil.MethodFlags flags = function == null ? null : PyUtil.MethodFlags.of(function)[ FD ]
Line_53 $$ if (generated instanceof PyReturnStatement) -->Line_55 $$ if (generated instanceof PyExpressionStatement) [ CD ]
Line_12 $$ final PyUtil.MethodFlags flags = function == null ? null : PyUtil.MethodFlags.of(function)-->Line_14 $$ final boolean isStaticMethod = flags != null && flags.isClassMethod()[ FD ]
Line_11 $$ final PyFunction function = PsiTreeUtil.getParentOfType(expression, PyFunction.class)-->Line_51 $$ final PyElement generated = function.getStatementList().getStatements()[0][ FD ]
Line_54 $$ callElement = ((PyReturnStatement) generated).getExpression()-->Line_56 $$ callElement = ((PyExpressionStatement) generated).getExpression()[ FD ]
Line_32 $$ final StringBuilder builder = new StringBuilder()-->Line_34 $$ builder.append("async ")[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_15 $$ final Pair<String, AbstractVariableData[]> data = getNameAndVariableData(project, fragment, expression, isClassMethod, isStaticMethod)[ CD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_23 $$ CommandProcessor.getInstance().executeCommand(project, new Runnable() [ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_30 $$ final boolean isMethod = PyPsiUtils.isMethodContext(expression)[ CD ]
Line_52 $$ PsiElement callElement = null-->Line_58 $$ if (callElement != null) [ FD ]
Line_20 $$ final AbstractVariableData[] variableData = data.second-->Line_48 $$ builder.append("(").append(createCallArgsString(variableData)).append(")")[ FD ]
Line_55 $$ if (generated instanceof PyExpressionStatement) -->Line_56 $$ callElement = ((PyExpressionStatement) generated).getExpression()[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_32 $$ final StringBuilder builder = new StringBuilder()[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_27 $$ final boolean isAsync = fragment.isAsync()[ CD ]
Line_14 $$ final boolean isStaticMethod = flags != null && flags.isClassMethod()-->Line_15 $$ final Pair<String, AbstractVariableData[]> data = getNameAndVariableData(project, fragment, expression, isClassMethod, isStaticMethod)[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_8 $$ CommonRefactoringUtil.showErrorHint(project, editor, PyBundle.message("refactoring.extract.method.error.returns"), RefactoringBundle.message("error.title"), "refactoring.extractMethod")[ FD ]
Line_52 $$ PsiElement callElement = null-->Line_61 $$ if (callElement != null) [ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_53 $$ if (generated instanceof PyReturnStatement) [ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_37 $$ if (isAsync) [ CD ]
Line_14 $$ final boolean isStaticMethod = flags != null && flags.isClassMethod()-->Line_31 $$ processParameters(project, generatedMethod, variableData, isMethod, isClassMethod, isStaticMethod)[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_12 $$ final PyUtil.MethodFlags flags = function == null ? null : PyUtil.MethodFlags.of(function)[ CD ]
Line_32 $$ final StringBuilder builder = new StringBuilder()-->Line_48 $$ builder.append("(").append(createCallArgsString(variableData)).append(")")[ FD ]
Line_56 $$ callElement = ((PyExpressionStatement) generated).getExpression()-->Line_58 $$ if (callElement != null) [ FD ]
Line_61 $$ if (callElement != null) -->Line_62 $$ processDuplicates(callElement, generatedMethod, finder, editor)[ CD ]
Line_32 $$ final StringBuilder builder = new StringBuilder()-->Line_45 $$ appendSelf(expression, builder, isStaticMethod)[ FD ]
Line_52 $$ PsiElement callElement = null-->Line_64 $$ setSelectionAndCaret(editor, callElement)[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_11 $$ final PyFunction function = PsiTreeUtil.getParentOfType(expression, PyFunction.class)[ FD ]
Line_30 $$ final boolean isMethod = PyPsiUtils.isMethodContext(expression)-->Line_31 $$ processParameters(project, generatedMethod, variableData, isMethod, isClassMethod, isStaticMethod)[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_22 $$ if (fragment.getOutputVariables().isEmpty()) [ CD ]
Line_51 $$ final PyElement generated = function.getStatementList().getStatements()[0]-->Line_55 $$ if (generated instanceof PyExpressionStatement) [ FD ]
Line_54 $$ callElement = ((PyReturnStatement) generated).getExpression()-->Line_62 $$ processDuplicates(callElement, generatedMethod, finder, editor)[ FD ]
Line_56 $$ callElement = ((PyExpressionStatement) generated).getExpression()-->Line_59 $$ callElement = PyReplaceExpressionUtil.replaceExpression(expression, callElement)[ FD ]
Line_13 $$ final boolean isClassMethod = flags != null && flags.isClassMethod()-->Line_31 $$ processParameters(project, generatedMethod, variableData, isMethod, isClassMethod, isStaticMethod)[ FD ]
Line_12 $$ final PyUtil.MethodFlags flags = function == null ? null : PyUtil.MethodFlags.of(function)-->Line_13 $$ final boolean isClassMethod = flags != null && flags.isClassMethod()[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_4 $$ CommonRefactoringUtil.showErrorHint(project, editor, PyBundle.message("refactoring.extract.method.error.local.variable.modifications"), RefactoringBundle.message("error.title"), "refactoring.extractMethod")[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_51 $$ final PyElement generated = function.getStatementList().getStatements()[0][ CD ]
Line_56 $$ callElement = ((PyExpressionStatement) generated).getExpression()-->Line_62 $$ processDuplicates(callElement, generatedMethod, finder, editor)[ FD ]
Line_32 $$ final StringBuilder builder = new StringBuilder()-->Line_47 $$ builder.append(methodName)[ FD ]
Line_54 $$ callElement = ((PyReturnStatement) generated).getExpression()-->Line_58 $$ if (callElement != null) [ FD ]
Line_19 $$ final String methodName = data.first-->Line_28 $$ PyFunction generatedMethod = generateMethodFromExpression(project, methodName, variableData, expression, flags, isAsync)[ FD ]
Line_28 $$ PyFunction generatedMethod = generateMethodFromExpression(project, methodName, variableData, expression, flags, isAsync)-->Line_62 $$ processDuplicates(callElement, generatedMethod, finder, editor)[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_39 $$ if (fragment.isYieldInside()) [ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_59 $$ callElement = PyReplaceExpressionUtil.replaceExpression(expression, callElement)[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_49 $$ final PyElementGenerator generator = PyElementGenerator.getInstance(project)[ CD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_7 $$ if (fragment.isReturnInstructionInside()) [ FD ]
Line_56 $$ callElement = ((PyExpressionStatement) generated).getExpression()-->Line_64 $$ setSelectionAndCaret(editor, callElement)[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_28 $$ PyFunction generatedMethod = generateMethodFromExpression(project, methodName, variableData, expression, flags, isAsync)[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_27 $$ final boolean isAsync = fragment.isAsync()[ FD ]
Line_52 $$ PsiElement callElement = null-->Line_59 $$ callElement = PyReplaceExpressionUtil.replaceExpression(expression, callElement)[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_22 $$ if (fragment.getOutputVariables().isEmpty()) [ FD ]
Line_59 $$ callElement = PyReplaceExpressionUtil.replaceExpression(expression, callElement)-->Line_64 $$ setSelectionAndCaret(editor, callElement)[ FD ]
Line_53 $$ if (generated instanceof PyReturnStatement) -->Line_54 $$ callElement = ((PyReturnStatement) generated).getExpression()[ CD ]
Line_28 $$ PyFunction generatedMethod = generateMethodFromExpression(project, methodName, variableData, expression, flags, isAsync)-->Line_29 $$ generatedMethod = insertGeneratedMethod(expression, generatedMethod)[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_3 $$ if (!fragment.getOutputVariables().isEmpty()) [ CD ]
Line_52 $$ PsiElement callElement = null-->Line_54 $$ callElement = ((PyReturnStatement) generated).getExpression()[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_64 $$ setSelectionAndCaret(editor, callElement)[ FD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_49 $$ final PyElementGenerator generator = PyElementGenerator.getInstance(project)[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_52 $$ PsiElement callElement = null[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_48 $$ builder.append("(").append(createCallArgsString(variableData)).append(")")[ CD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_44 $$ if (isMethod) [ CD ]
Line_2 $$ public static void extractFromExpression(@NotNull final Project project, @NotNull final Editor editor, @NotNull final PyCodeFragment fragment, @NotNull final PsiElement expression) -->Line_50 $$ final PyFunction function = generator.createFromText(LanguageLevel.forElement(expression), PyFunction.class, builder.toString())[ FD ]
Line_25 $$ ApplicationManager.getApplication().runWriteAction(new Runnable() -->Line_28 $$ PyFunction generatedMethod = generateMethodFromExpression(project, methodName, variableData, expression, flags, isAsync)[ CD ]
Line_39 $$ if (fragment.isYieldInside()) -->Line_42 $$ builder.append("return ")[ CD ]
