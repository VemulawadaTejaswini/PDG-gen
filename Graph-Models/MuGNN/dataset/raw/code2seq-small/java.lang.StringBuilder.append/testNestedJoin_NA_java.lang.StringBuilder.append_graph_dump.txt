Line_27 $$ StringBuilder sb = new StringBuilder()-->Line_35 $$ sb.append(CompositeInputFormat.compose(Fake_IF.class, "foobar"))[ FD ]
Line_29 $$ for (int i = 0; i < SOURCES; ++i) -->Line_37 $$ for (int i = 0; i < SOURCES; ++i) [ FD ]
Line_58 $$ SequenceFile.Reader r = new SequenceFile.Reader(cluster.getFileSystem(), outlist[0].getPath(), job)-->Line_60 $$ while (r.next(k, v)) [ FD ]
Line_5 $$ JobConf job = new JobConf()-->Line_49 $$ job.setReducerClass(IdentityReducer.class)[ FD ]
Line_5 $$ JobConf job = new JobConf()-->Line_45 $$ FileOutputFormat.setOutputPath(job, outf)[ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_27 $$ StringBuilder sb = new StringBuilder()[ CD ]
Line_10 $$ for (int j = 0; j < ITEMS; ++j) -->Line_20 $$ for (int j = 0; j < ITEMS; ++j) [ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_56 $$ assertEquals(1, outlist.length)[ CD ]
Line_17 $$ for (int i = 0; i < SOURCES; ++i) -->Line_24 $$ out[i].close()[ CD ]
Line_5 $$ JobConf job = new JobConf()-->Line_51 $$ job.setOutputKeyClass(IntWritable.class)[ FD ]
Line_6 $$ Path base = cluster.getFileSystem().makeQualified(new Path("/nested"))-->Line_79 $$ base.getFileSystem(job).delete(base, true)[ FD ]
Line_27 $$ StringBuilder sb = new StringBuilder()-->Line_38 $$ sb.append(CompositeInputFormat.compose(SequenceFileInputFormat.class, src[i].toString()))[ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_36 $$ sb.append(",")[ CD ]
Line_60 $$ while (r.next(k, v)) -->Line_71 $$ if (chk) [ CD ]
Line_18 $$ IntWritable v = new IntWritable()-->Line_72 $$ assertTrue(v.has(0))[ FD ]
Line_20 $$ for (int j = 0; j < ITEMS; ++j) -->Line_21 $$ k.set(source[i][j])[ CD ]
Line_59 $$ TupleWritable v = new TupleWritable()-->Line_62 $$ assertFalse(((TupleWritable) v.get(1)).has(SOURCES + 1))[ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_28 $$ sb.append("outer(inner(")[ CD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_37 $$ for (int i = 0; i < SOURCES; ++i) [ CD ]
Line_59 $$ TupleWritable v = new TupleWritable()-->Line_73 $$ assertTrue(((TupleWritable) v.get(0)).has(i))[ FD ]
Line_65 $$ for (int i = 2; i < SOURCES + 2; ++i) -->Line_73 $$ for (int i = 0; i < SOURCES; ++i) assertTrue(((TupleWritable) v.get(0)).has(i))[ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_45 $$ FileOutputFormat.setOutputPath(job, outf)[ CD ]
Line_18 $$ IntWritable v = new IntWritable()-->Line_67 $$ assertEquals(i - 2, ((IntWritable) ((TupleWritable) v.get(1)).get((i - 1))).get())[ FD ]
Line_66 $$ if ((ki % i) == 0 && ki <= i * ITEMS) -->Line_69 $$ chk = false[ CD ]
Line_37 $$ for (int i = 0; i < SOURCES; ++i) -->Line_39 $$ sb.append(",")[ CD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_44 $$ Path outf = new Path(base, "out")[ CD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_3 $$ final int SOURCES = 3[ CD ]
Line_59 $$ TupleWritable v = new TupleWritable()-->Line_60 $$ while (r.next(k, v)) [ FD ]
Line_5 $$ JobConf job = new JobConf()-->Line_15 $$ SequenceFile.Writer[] out = createWriters(base, job, SOURCES, src)[ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_59 $$ TupleWritable v = new TupleWritable()[ CD ]
Line_37 $$ for (int i = 0; i < SOURCES; ++i) -->Line_38 $$ sb.append(CompositeInputFormat.compose(SequenceFileInputFormat.class, src[i].toString()))[ CD ]
Line_14 $$ Path[] src = new Path[SOURCES]-->Line_15 $$ SequenceFile.Writer[] out = createWriters(base, job, SOURCES, src)[ FD ]
Line_63 $$ boolean chk = true-->Line_69 $$ chk = false[ FD ]
Line_18 $$ IntWritable v = new IntWritable()-->Line_73 $$ assertTrue(((TupleWritable) v.get(0)).has(i))[ FD ]
Line_8 $$ for (int i = 0; i < SOURCES; ++i) -->Line_10 $$ for (int j = 0; j < ITEMS; ++j) [ CD ]
Line_5 $$ JobConf job = new JobConf()-->Line_46 $$ Fake_IF.setKeyClass(job, IntWritable.class)[ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_78 $$ r.close()[ CD ]
Line_37 $$ for (int i = 0; i < SOURCES; ++i) -->Line_73 $$ for (int i = 0; i < SOURCES; ++i) assertTrue(((TupleWritable) v.get(0)).has(i))[ FD ]
Line_18 $$ IntWritable v = new IntWritable()-->Line_60 $$ while (r.next(k, v)) [ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_48 $$ job.setMapperClass(IdentityMapper.class)[ CD ]
Line_27 $$ StringBuilder sb = new StringBuilder()-->Line_42 $$ job.set("mapreduce.join.expr", sb.toString())[ FD ]
Line_5 $$ JobConf job = new JobConf()-->Line_48 $$ job.setMapperClass(IdentityMapper.class)[ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_8 $$ for (int i = 0; i < SOURCES; ++i) [ CD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_50 $$ job.setNumReduceTasks(0)[ CD ]
Line_29 $$ for (int i = 0; i < SOURCES; ++i) -->Line_65 $$ for (int i = 2; i < SOURCES + 2; ++i) [ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_35 $$ sb.append(CompositeInputFormat.compose(Fake_IF.class, "foobar"))[ CD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_54 $$ JobClient.runJob(job)[ CD ]
Line_16 $$ IntWritable k = new IntWritable()-->Line_64 $$ int ki = k.get()[ FD ]
Line_3 $$ final int SOURCES = 3-->Line_73 $$ for (int i = 0; i < SOURCES; ++i) assertTrue(((TupleWritable) v.get(0)).has(i))[ FD ]
Line_37 $$ for (int i = 0; i < SOURCES; ++i) -->Line_65 $$ for (int i = 2; i < SOURCES + 2; ++i) [ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_34 $$ sb.append("),outer(")[ CD ]
Line_44 $$ Path outf = new Path(base, "out")-->Line_45 $$ FileOutputFormat.setOutputPath(job, outf)[ FD ]
Line_71 $$ if (chk) -->Line_73 $$ for (int i = 0; i < SOURCES; ++i) assertTrue(((TupleWritable) v.get(0)).has(i))[ CD ]
Line_5 $$ JobConf job = new JobConf()-->Line_53 $$ job.setOutputFormat(SequenceFileOutputFormat.class)[ FD ]
Line_27 $$ StringBuilder sb = new StringBuilder()-->Line_39 $$ sb.append(",")[ FD ]
Line_4 $$ final int ITEMS = (SOURCES + 1) * (SOURCES + 1)-->Line_20 $$ for (int j = 0; j < ITEMS; ++j) [ FD ]
Line_27 $$ StringBuilder sb = new StringBuilder()-->Line_36 $$ sb.append(",")[ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_51 $$ job.setOutputKeyClass(IntWritable.class)[ CD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_58 $$ SequenceFile.Reader r = new SequenceFile.Reader(cluster.getFileSystem(), outlist[0].getPath(), job)[ CD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_5 $$ JobConf job = new JobConf()[ CD ]
Line_3 $$ final int SOURCES = 3-->Line_8 $$ for (int i = 0; i < SOURCES; ++i) [ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_42 $$ job.set("mapreduce.join.expr", sb.toString())[ CD ]
Line_27 $$ StringBuilder sb = new StringBuilder()-->Line_28 $$ sb.append("outer(inner(")[ FD ]
Line_17 $$ for (int i = 0; i < SOURCES; ++i) -->Line_19 $$ v.set(i)[ FD ]
Line_5 $$ JobConf job = new JobConf()-->Line_43 $$ job.setInputFormat(CompositeInputFormat.class)[ FD ]
Line_27 $$ StringBuilder sb = new StringBuilder()-->Line_32 $$ sb.append(",")[ FD ]
Line_8 $$ for (int i = 0; i < SOURCES; ++i) -->Line_73 $$ for (int i = 0; i < SOURCES; ++i) assertTrue(((TupleWritable) v.get(0)).has(i))[ FD ]
Line_5 $$ JobConf job = new JobConf()-->Line_52 $$ job.setOutputValueClass(TupleWritable.class)[ FD ]
Line_16 $$ IntWritable k = new IntWritable()-->Line_60 $$ while (r.next(k, v)) [ FD ]
Line_8 $$ for (int i = 0; i < SOURCES; ++i) -->Line_73 $$ assertTrue(((TupleWritable) v.get(0)).has(i))[ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_60 $$ while (r.next(k, v)) [ CD ]
Line_59 $$ TupleWritable v = new TupleWritable()-->Line_75 $$ assertFalse(v.has(0))[ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_55 $$ FileStatus[] outlist = cluster.getFileSystem().listStatus(outf, new Utils.OutputFileUtils.OutputFilesFilter())[ CD ]
Line_29 $$ for (int i = 0; i < SOURCES; ++i) -->Line_30 $$ sb.append(CompositeInputFormat.compose(SequenceFileInputFormat.class, src[i].toString()))[ CD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_29 $$ for (int i = 0; i < SOURCES; ++i) [ CD ]
Line_29 $$ for (int i = 0; i < SOURCES; ++i) -->Line_73 $$ for (int i = 0; i < SOURCES; ++i) assertTrue(((TupleWritable) v.get(0)).has(i))[ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_47 $$ Fake_IF.setValClass(job, IntWritable.class)[ CD ]
Line_18 $$ IntWritable v = new IntWritable()-->Line_19 $$ v.set(i)[ FD ]
Line_8 $$ for (int i = 0; i < SOURCES; ++i) -->Line_29 $$ for (int i = 0; i < SOURCES; ++i) [ FD ]
Line_27 $$ StringBuilder sb = new StringBuilder()-->Line_34 $$ sb.append("),outer(")[ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_49 $$ job.setReducerClass(IdentityReducer.class)[ CD ]
Line_5 $$ JobConf job = new JobConf()-->Line_47 $$ Fake_IF.setValClass(job, IntWritable.class)[ FD ]
Line_8 $$ for (int i = 0; i < SOURCES; ++i) -->Line_17 $$ for (int i = 0; i < SOURCES; ++i) [ FD ]
Line_17 $$ for (int i = 0; i < SOURCES; ++i) -->Line_73 $$ assertTrue(((TupleWritable) v.get(0)).has(i))[ FD ]
Line_17 $$ for (int i = 0; i < SOURCES; ++i) -->Line_19 $$ v.set(i)[ CD ]
Line_10 $$ for (int j = 0; j < ITEMS; ++j) -->Line_11 $$ source[i][j] = (i + 2) * (j + 1)[ CD ]
Line_31 $$ if (i + 1 != SOURCES)-->Line_32 $$ sb.append(",")[ CD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_16 $$ IntWritable k = new IntWritable()[ CD ]
Line_3 $$ final int SOURCES = 3-->Line_17 $$ for (int i = 0; i < SOURCES; ++i) [ FD ]
Line_17 $$ for (int i = 0; i < SOURCES; ++i) -->Line_29 $$ for (int i = 0; i < SOURCES; ++i) [ FD ]
Line_16 $$ IntWritable k = new IntWritable()-->Line_21 $$ k.set(source[i][j])[ FD ]
Line_27 $$ StringBuilder sb = new StringBuilder()-->Line_41 $$ sb.append(CompositeInputFormat.compose(Fake_IF.class, "raboof") + "))")[ FD ]
Line_65 $$ for (int i = 2; i < SOURCES + 2; ++i) -->Line_73 $$ assertTrue(((TupleWritable) v.get(0)).has(i))[ FD ]
Line_60 $$ while (r.next(k, v)) -->Line_65 $$ for (int i = 2; i < SOURCES + 2; ++i) [ CD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_14 $$ Path[] src = new Path[SOURCES][ CD ]
Line_18 $$ IntWritable v = new IntWritable()-->Line_61 $$ assertFalse(((TupleWritable) v.get(1)).has(0))[ FD ]
Line_18 $$ IntWritable v = new IntWritable()-->Line_62 $$ assertFalse(((TupleWritable) v.get(1)).has(SOURCES + 1))[ FD ]
Line_8 $$ for (int i = 0; i < SOURCES; ++i) -->Line_65 $$ for (int i = 2; i < SOURCES + 2; ++i) [ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_57 $$ assertTrue(0 < outlist[0].getLen())[ CD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_79 $$ base.getFileSystem(job).delete(base, true)[ CD ]
Line_17 $$ for (int i = 0; i < SOURCES; ++i) -->Line_65 $$ for (int i = 2; i < SOURCES + 2; ++i) [ FD ]
Line_71 $$ if (chk) -->Line_75 $$ assertFalse(v.has(0))[ CD ]
Line_20 $$ for (int j = 0; j < ITEMS; ++j) -->Line_22 $$ out[i].append(k, v)[ CD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_41 $$ sb.append(CompositeInputFormat.compose(Fake_IF.class, "raboof") + "))")[ CD ]
Line_17 $$ for (int i = 0; i < SOURCES; ++i) -->Line_18 $$ IntWritable v = new IntWritable()[ CD ]
Line_44 $$ Path outf = new Path(base, "out")-->Line_55 $$ FileStatus[] outlist = cluster.getFileSystem().listStatus(outf, new Utils.OutputFileUtils.OutputFilesFilter())[ FD ]
Line_65 $$ for (int i = 2; i < SOURCES + 2; ++i) -->Line_66 $$ if ((ki % i) == 0 && ki <= i * ITEMS) [ CD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_15 $$ SequenceFile.Writer[] out = createWriters(base, job, SOURCES, src)[ CD ]
Line_3 $$ final int SOURCES = 3-->Line_15 $$ SequenceFile.Writer[] out = createWriters(base, job, SOURCES, src)[ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_4 $$ final int ITEMS = (SOURCES + 1) * (SOURCES + 1)[ CD ]
Line_3 $$ final int SOURCES = 3-->Line_29 $$ for (int i = 0; i < SOURCES; ++i) [ FD ]
Line_60 $$ while (r.next(k, v)) -->Line_63 $$ boolean chk = true[ CD ]
Line_6 $$ Path base = cluster.getFileSystem().makeQualified(new Path("/nested"))-->Line_15 $$ SequenceFile.Writer[] out = createWriters(base, job, SOURCES, src)[ FD ]
Line_66 $$ if ((ki % i) == 0 && ki <= i * ITEMS) -->Line_67 $$ assertEquals(i - 2, ((IntWritable) ((TupleWritable) v.get(1)).get((i - 1))).get())[ CD ]
Line_60 $$ while (r.next(k, v)) -->Line_62 $$ assertFalse(((TupleWritable) v.get(1)).has(SOURCES + 1))[ CD ]
Line_71 $$ if (chk) -->Line_72 $$ assertTrue(v.has(0))[ CD ]
Line_18 $$ IntWritable v = new IntWritable()-->Line_75 $$ assertFalse(v.has(0))[ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_17 $$ for (int i = 0; i < SOURCES; ++i) [ CD ]
Line_8 $$ for (int i = 0; i < SOURCES; ++i) -->Line_37 $$ for (int i = 0; i < SOURCES; ++i) [ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_7 $$ int[][] source = new int[SOURCES][][ CD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_53 $$ job.setOutputFormat(SequenceFileOutputFormat.class)[ CD ]
Line_18 $$ IntWritable v = new IntWritable()-->Line_22 $$ out[i].append(k, v)[ FD ]
Line_29 $$ for (int i = 0; i < SOURCES; ++i) -->Line_31 $$ if (i + 1 != SOURCES)[ CD ]
Line_5 $$ JobConf job = new JobConf()-->Line_79 $$ base.getFileSystem(job).delete(base, true)[ FD ]
Line_59 $$ TupleWritable v = new TupleWritable()-->Line_72 $$ assertTrue(v.has(0))[ FD ]
Line_27 $$ StringBuilder sb = new StringBuilder()-->Line_30 $$ sb.append(CompositeInputFormat.compose(SequenceFileInputFormat.class, src[i].toString()))[ FD ]
Line_17 $$ for (int i = 0; i < SOURCES; ++i) -->Line_73 $$ for (int i = 0; i < SOURCES; ++i) assertTrue(((TupleWritable) v.get(0)).has(i))[ FD ]
Line_8 $$ for (int i = 0; i < SOURCES; ++i) -->Line_19 $$ v.set(i)[ FD ]
Line_60 $$ while (r.next(k, v)) -->Line_64 $$ int ki = k.get()[ CD ]
Line_37 $$ for (int i = 0; i < SOURCES; ++i) -->Line_73 $$ assertTrue(((TupleWritable) v.get(0)).has(i))[ FD ]
Line_8 $$ for (int i = 0; i < SOURCES; ++i) -->Line_9 $$ source[i] = new int[ITEMS][ CD ]
Line_58 $$ SequenceFile.Reader r = new SequenceFile.Reader(cluster.getFileSystem(), outlist[0].getPath(), job)-->Line_78 $$ r.close()[ FD ]
Line_17 $$ for (int i = 0; i < SOURCES; ++i) -->Line_37 $$ for (int i = 0; i < SOURCES; ++i) [ FD ]
Line_15 $$ SequenceFile.Writer[] out = createWriters(base, job, SOURCES, src)-->Line_26 $$ out = null[ FD ]
Line_59 $$ TupleWritable v = new TupleWritable()-->Line_67 $$ assertEquals(i - 2, ((IntWritable) ((TupleWritable) v.get(1)).get((i - 1))).get())[ FD ]
Line_3 $$ final int SOURCES = 3-->Line_37 $$ for (int i = 0; i < SOURCES; ++i) [ FD ]
Line_3 $$ final int SOURCES = 3-->Line_31 $$ if (i + 1 != SOURCES)[ FD ]
Line_5 $$ JobConf job = new JobConf()-->Line_42 $$ job.set("mapreduce.join.expr", sb.toString())[ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_43 $$ job.setInputFormat(CompositeInputFormat.class)[ CD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_6 $$ Path base = cluster.getFileSystem().makeQualified(new Path("/nested"))[ CD ]
Line_16 $$ IntWritable k = new IntWritable()-->Line_22 $$ out[i].append(k, v)[ FD ]
Line_59 $$ TupleWritable v = new TupleWritable()-->Line_61 $$ assertFalse(((TupleWritable) v.get(1)).has(0))[ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_46 $$ Fake_IF.setKeyClass(job, IntWritable.class)[ CD ]
Line_29 $$ for (int i = 0; i < SOURCES; ++i) -->Line_73 $$ assertTrue(((TupleWritable) v.get(0)).has(i))[ FD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_26 $$ out = null[ CD ]
Line_4 $$ final int ITEMS = (SOURCES + 1) * (SOURCES + 1)-->Line_10 $$ for (int j = 0; j < ITEMS; ++j) [ FD ]
Line_60 $$ while (r.next(k, v)) -->Line_61 $$ assertFalse(((TupleWritable) v.get(1)).has(0))[ CD ]
Line_2 $$ public void testNestedJoin() throws Exception -->Line_52 $$ job.setOutputValueClass(TupleWritable.class)[ CD ]
Line_5 $$ JobConf job = new JobConf()-->Line_54 $$ JobClient.runJob(job)[ FD ]
Line_17 $$ for (int i = 0; i < SOURCES; ++i) -->Line_20 $$ for (int j = 0; j < ITEMS; ++j) [ CD ]
Line_5 $$ JobConf job = new JobConf()-->Line_50 $$ job.setNumReduceTasks(0)[ FD ]
