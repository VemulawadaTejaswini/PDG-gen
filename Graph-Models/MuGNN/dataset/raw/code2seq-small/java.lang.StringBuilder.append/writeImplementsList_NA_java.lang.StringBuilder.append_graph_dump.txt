Line_10 $$ for (PsiClassType implementsType : implementsTypes) -->Line_11 $$ if (shouldSkipInImplements(typeDefinition, implementsType)) [ FD ]
Line_2 $$ public void writeImplementsList(StringBuilder text, PsiClass typeDefinition) -->Line_9 $$ text.append(typeDefinition.isInterface() ? "extends " : "implements ")[ FD ]
Line_2 $$ public void writeImplementsList(StringBuilder text, PsiClass typeDefinition) -->Line_4 $$ Collections.addAll(implementsTypes, typeDefinition.getImplementsListTypes())[ FD ]
Line_5 $$ if (implementsTypes.isEmpty())-->Line_6 $$ return[ CD ]
Line_2 $$ public void writeImplementsList(StringBuilder text, PsiClass typeDefinition) -->Line_7 $$ if (implementsTypes.size() == 1 && shouldSkipInImplements(typeDefinition, implementsTypes.iterator().next()))[ FD ]
Line_3 $$ final Collection<PsiClassType> implementsTypes = new LinkedHashSet<PsiClassType>()-->Line_4 $$ Collections.addAll(implementsTypes, typeDefinition.getImplementsListTypes())[ FD ]
Line_2 $$ public void writeImplementsList(StringBuilder text, PsiClass typeDefinition) -->Line_17 $$ if (!implementsTypes.isEmpty())[ CD ]
Line_3 $$ final Collection<PsiClassType> implementsTypes = new LinkedHashSet<PsiClassType>()-->Line_7 $$ if (implementsTypes.size() == 1 && shouldSkipInImplements(typeDefinition, implementsTypes.iterator().next()))[ FD ]
Line_2 $$ public void writeImplementsList(StringBuilder text, PsiClass typeDefinition) -->Line_14 $$ TypeWriter.writeType(text, implementsType, typeDefinition, classNameProvider)[ FD ]
Line_2 $$ public void writeImplementsList(StringBuilder text, PsiClass typeDefinition) -->Line_19 $$ text.append(' ')[ CD ]
Line_2 $$ public void writeImplementsList(StringBuilder text, PsiClass typeDefinition) -->Line_5 $$ if (implementsTypes.isEmpty())[ CD ]
Line_3 $$ final Collection<PsiClassType> implementsTypes = new LinkedHashSet<PsiClassType>()-->Line_17 $$ if (!implementsTypes.isEmpty())[ FD ]
Line_3 $$ final Collection<PsiClassType> implementsTypes = new LinkedHashSet<PsiClassType>()-->Line_5 $$ if (implementsTypes.isEmpty())[ FD ]
Line_2 $$ public void writeImplementsList(StringBuilder text, PsiClass typeDefinition) -->Line_19 $$ text.append(' ')[ FD ]
Line_2 $$ public void writeImplementsList(StringBuilder text, PsiClass typeDefinition) -->Line_18 $$ text.delete(text.length() - 2, text.length())[ FD ]
Line_2 $$ public void writeImplementsList(StringBuilder text, PsiClass typeDefinition) -->Line_3 $$ final Collection<PsiClassType> implementsTypes = new LinkedHashSet<PsiClassType>()[ CD ]
Line_7 $$ if (implementsTypes.size() == 1 && shouldSkipInImplements(typeDefinition, implementsTypes.iterator().next()))-->Line_8 $$ return[ CD ]
Line_2 $$ public void writeImplementsList(StringBuilder text, PsiClass typeDefinition) -->Line_15 $$ text.append(", ")[ FD ]
Line_17 $$ if (!implementsTypes.isEmpty())-->Line_18 $$ text.delete(text.length() - 2, text.length())[ CD ]
Line_2 $$ public void writeImplementsList(StringBuilder text, PsiClass typeDefinition) -->Line_11 $$ if (shouldSkipInImplements(typeDefinition, implementsType)) [ FD ]
Line_10 $$ for (PsiClassType implementsType : implementsTypes) -->Line_14 $$ TypeWriter.writeType(text, implementsType, typeDefinition, classNameProvider)[ FD ]
Line_2 $$ public void writeImplementsList(StringBuilder text, PsiClass typeDefinition) -->Line_7 $$ if (implementsTypes.size() == 1 && shouldSkipInImplements(typeDefinition, implementsTypes.iterator().next()))[ CD ]
Line_2 $$ public void writeImplementsList(StringBuilder text, PsiClass typeDefinition) -->Line_4 $$ Collections.addAll(implementsTypes, typeDefinition.getImplementsListTypes())[ CD ]
Line_2 $$ public void writeImplementsList(StringBuilder text, PsiClass typeDefinition) -->Line_9 $$ text.append(typeDefinition.isInterface() ? "extends " : "implements ")[ CD ]
