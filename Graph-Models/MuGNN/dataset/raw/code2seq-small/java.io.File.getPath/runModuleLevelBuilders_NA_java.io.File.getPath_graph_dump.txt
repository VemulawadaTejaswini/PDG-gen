Line_20 $$ DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder = new DirtyFilesHolderBase<JavaSourceRootDescriptor, ModuleBuildTarget>(context) -->Line_90 $$ final boolean moreToCompile = JavaBuilderUtil.updateMappingsOnRoundCompletion(context, dirtyFilesHolder, chunk)[ FD ]
Line_54 $$ final ModuleLevelBuilder.ExitCode buildResult = builder.build(context, chunk, dirtyFilesHolder, outputConsumer)-->Line_57 $$ if (buildResult == ModuleLevelBuilder.ExitCode.ABORT) [ FD ]
Line_33 $$ final SourceToOutputMapping mapping = context.getProjectDescriptor().dataManager.getSourceToOutputMap(target)-->Line_35 $$ mapping.setOutputs(srcFile.getPath(), Collections.<String>emptyList())[ FD ]
Line_4 $$ for (BuilderCategory category : BuilderCategory.values()) -->Line_5 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) [ FD ]
Line_50 $$ for (ModuleLevelBuilder builder : builders) -->Line_55 $$ storeBuilderStatistics(builder, System.nanoTime() - start, outputConsumer.getNumberOfProcessedSources() - processedSourcesBefore)[ FD ]
Line_40 $$ for (BuilderCategory category : BuilderCategory.values()) -->Line_108 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) [ FD ]
Line_31 $$ final Set<File> files = entry.getValue()-->Line_32 $$ if (!files.isEmpty()) [ FD ]
Line_54 $$ final ModuleLevelBuilder.ExitCode buildResult = builder.build(context, chunk, dirtyFilesHolder, outputConsumer)-->Line_63 $$ if (buildResult == ModuleLevelBuilder.ExitCode.CHUNK_REBUILD_REQUIRED) [ FD ]
Line_29 $$ for (Map.Entry<ModuleBuildTarget, Set<File>> entry : cleanedSources.entrySet()) -->Line_30 $$ final ModuleBuildTarget target = entry.getKey()[ FD ]
Line_50 $$ for (ModuleLevelBuilder builder : builders) -->Line_83 $$ LOG.debug("Builder " + builder.getPresentableName() + " requested second chunk rebuild")[ FD ]
Line_30 $$ final ModuleBuildTarget target = entry.getKey()-->Line_33 $$ final SourceToOutputMapping mapping = context.getProjectDescriptor().dataManager.getSourceToOutputMap(target)[ FD ]
Line_15 $$ ChunkBuildOutputConsumerImpl outputConsumer = new ChunkBuildOutputConsumerImpl(context)-->Line_106 $$ outputConsumer.clear()[ FD ]
Line_64 $$ if (!rebuildFromScratchRequested && !JavaBuilderUtil.isForcedRecompilationAllJavaModules(context)) -->Line_65 $$ LOG.info("Builder " + builder.getPresentableName() + " requested rebuild of module chunk " + chunk.getName())[ CD ]
Line_5 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) -->Line_6 $$ builder.chunkBuildStarted(context, chunk)[ FD ]
Line_29 $$ for (Map.Entry<ModuleBuildTarget, Set<File>> entry : cleanedSources.entrySet()) -->Line_31 $$ final Set<File> files = entry.getValue()[ FD ]
Line_20 $$ DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder = new DirtyFilesHolderBase<JavaSourceRootDescriptor, ModuleBuildTarget>(context) -->Line_54 $$ final ModuleLevelBuilder.ExitCode buildResult = builder.build(context, chunk, dirtyFilesHolder, outputConsumer)[ FD ]
Line_15 $$ ChunkBuildOutputConsumerImpl outputConsumer = new ChunkBuildOutputConsumerImpl(context)-->Line_55 $$ storeBuilderStatistics(builder, System.nanoTime() - start, outputConsumer.getNumberOfProcessedSources() - processedSourcesBefore)[ FD ]
Line_5 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) -->Line_83 $$ LOG.debug("Builder " + builder.getPresentableName() + " requested second chunk rebuild")[ FD ]
Line_17 $$ do -->Line_20 $$ DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder = new DirtyFilesHolderBase<JavaSourceRootDescriptor, ModuleBuildTarget>(context) [ CD ]
Line_17 $$ do -->Line_18 $$ nextPassRequired = false[ CD ]
Line_17 $$ do -->Line_27 $$ if (!JavaBuilderUtil.isForcedRecompilationAllJavaModules(context)) [ CD ]
Line_4 $$ for (BuilderCategory category : BuilderCategory.values()) -->Line_42 $$ if (category == BuilderCategory.CLASS_POST_PROCESSOR) [ FD ]
Line_54 $$ final ModuleLevelBuilder.ExitCode buildResult = builder.build(context, chunk, dirtyFilesHolder, outputConsumer)-->Line_61 $$ if (buildResult == ModuleLevelBuilder.ExitCode.ADDITIONAL_PASS_REQUIRED) [ FD ]
Line_18 $$ nextPassRequired = false-->Line_94 $$ if (nextPassRequired && !rebuildFromScratchRequested) [ FD ]
Line_20 $$ DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder = new DirtyFilesHolderBase<JavaSourceRootDescriptor, ModuleBuildTarget>(context) -->Line_24 $$ FSOperations.processFilesToRecompile(context, chunk, processor)[ FD ]
Line_50 $$ for (ModuleLevelBuilder builder : builders) -->Line_58 $$ throw new StopBuildException("Builder " + builder.getPresentableName() + " requested build stop")[ FD ]
Line_5 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) -->Line_54 $$ final ModuleLevelBuilder.ExitCode buildResult = builder.build(context, chunk, dirtyFilesHolder, outputConsumer)[ FD ]
Line_5 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) -->Line_109 $$ builder.chunkBuildFinished(context, chunk)[ FD ]
Line_41 $$ final List<ModuleLevelBuilder> builders = myBuilderRegistry.getBuilders(category)-->Line_46 $$ if (builders.isEmpty()) [ FD ]
Line_15 $$ ChunkBuildOutputConsumerImpl outputConsumer = new ChunkBuildOutputConsumerImpl(context)-->Line_53 $$ int processedSourcesBefore = outputConsumer.getNumberOfProcessedSources()[ FD ]
Line_27 $$ if (!JavaBuilderUtil.isForcedRecompilationAllJavaModules(context)) -->Line_28 $$ final Map<ModuleBuildTarget, Set<File>> cleanedSources = BuildOperations.cleanOutputsCorrespondingToChangedFiles(context, dirtyFilesHolder)[ CD ]
Line_40 $$ for (BuilderCategory category : BuilderCategory.values()) -->Line_41 $$ final List<ModuleLevelBuilder> builders = myBuilderRegistry.getBuilders(category)[ FD ]
Line_15 $$ ChunkBuildOutputConsumerImpl outputConsumer = new ChunkBuildOutputConsumerImpl(context)-->Line_104 $$ saveInstrumentedClasses(outputConsumer)[ FD ]
Line_5 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) -->Line_65 $$ LOG.info("Builder " + builder.getPresentableName() + " requested rebuild of module chunk " + chunk.getName())[ FD ]
Line_14 $$ boolean nextPassRequired-->Line_94 $$ if (nextPassRequired && !rebuildFromScratchRequested) [ FD ]
Line_15 $$ ChunkBuildOutputConsumerImpl outputConsumer = new ChunkBuildOutputConsumerImpl(context)-->Line_105 $$ outputConsumer.fireFileGeneratedEvents()[ FD ]
Line_5 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) -->Line_58 $$ throw new StopBuildException("Builder " + builder.getPresentableName() + " requested build stop")[ FD ]
Line_28 $$ final Map<ModuleBuildTarget, Set<File>> cleanedSources = BuildOperations.cleanOutputsCorrespondingToChangedFiles(context, dirtyFilesHolder)-->Line_29 $$ for (Map.Entry<ModuleBuildTarget, Set<File>> entry : cleanedSources.entrySet()) [ FD ]
Line_64 $$ if (!rebuildFromScratchRequested && !JavaBuilderUtil.isForcedRecompilationAllJavaModules(context)) -->Line_83 $$ LOG.debug("Builder " + builder.getPresentableName() + " requested second chunk rebuild")[ CD ]
Line_4 $$ for (BuilderCategory category : BuilderCategory.values()) -->Line_108 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) [ FD ]
Line_40 $$ for (BuilderCategory category : BuilderCategory.values()) -->Line_42 $$ if (category == BuilderCategory.CLASS_POST_PROCESSOR) [ FD ]
Line_50 $$ for (ModuleLevelBuilder builder : builders) -->Line_54 $$ final ModuleLevelBuilder.ExitCode buildResult = builder.build(context, chunk, dirtyFilesHolder, outputConsumer)[ FD ]
Line_34 $$ for (File srcFile : files) -->Line_35 $$ mapping.setOutputs(srcFile.getPath(), Collections.<String>emptyList())[ FD ]
Line_50 $$ for (ModuleLevelBuilder builder : builders) -->Line_65 $$ LOG.info("Builder " + builder.getPresentableName() + " requested rebuild of module chunk " + chunk.getName())[ FD ]
Line_15 $$ ChunkBuildOutputConsumerImpl outputConsumer = new ChunkBuildOutputConsumerImpl(context)-->Line_77 $$ outputConsumer.clear()[ FD ]
Line_5 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) -->Line_55 $$ storeBuilderStatistics(builder, System.nanoTime() - start, outputConsumer.getNumberOfProcessedSources() - processedSourcesBefore)[ FD ]
Line_4 $$ for (BuilderCategory category : BuilderCategory.values()) -->Line_41 $$ final List<ModuleLevelBuilder> builders = myBuilderRegistry.getBuilders(category)[ FD ]
Line_63 $$ if (buildResult == ModuleLevelBuilder.ExitCode.CHUNK_REBUILD_REQUIRED) -->Line_64 $$ if (!rebuildFromScratchRequested && !JavaBuilderUtil.isForcedRecompilationAllJavaModules(context)) [ CD ]
Line_50 $$ for (ModuleLevelBuilder builder : builders) -->Line_109 $$ builder.chunkBuildFinished(context, chunk)[ FD ]
Line_15 $$ ChunkBuildOutputConsumerImpl outputConsumer = new ChunkBuildOutputConsumerImpl(context)-->Line_54 $$ final ModuleLevelBuilder.ExitCode buildResult = builder.build(context, chunk, dirtyFilesHolder, outputConsumer)[ FD ]
Line_32 $$ if (!files.isEmpty()) -->Line_33 $$ final SourceToOutputMapping mapping = context.getProjectDescriptor().dataManager.getSourceToOutputMap(target)[ CD ]
Line_17 $$ do -->Line_19 $$ myProjectDescriptor.fsState.beforeNextRoundStart(context, chunk)[ CD ]
Line_61 $$ if (buildResult == ModuleLevelBuilder.ExitCode.ADDITIONAL_PASS_REQUIRED) -->Line_63 $$ if (buildResult == ModuleLevelBuilder.ExitCode.CHUNK_REBUILD_REQUIRED) [ CD ]
Line_20 $$ DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder = new DirtyFilesHolderBase<JavaSourceRootDescriptor, ModuleBuildTarget>(context) -->Line_28 $$ final Map<ModuleBuildTarget, Set<File>> cleanedSources = BuildOperations.cleanOutputsCorrespondingToChangedFiles(context, dirtyFilesHolder)[ FD ]
Line_20 $$ DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder = new DirtyFilesHolderBase<JavaSourceRootDescriptor, ModuleBuildTarget>(context) -->Line_24 $$ FSOperations.processFilesToRecompile(context, chunk, processor)[ CD ]
Line_14 $$ boolean nextPassRequired-->Line_18 $$ nextPassRequired = false[ FD ]
