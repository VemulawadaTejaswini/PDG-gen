Line_14 $$ final RmicCompilerOptions options = getOptions(context)-->Line_19 $$ final Collection<String> cmdLine = createStartupCommand(target, rmicPath, classpathString, options, entry.getValue())[ FD ]
Line_16 $$ for (Map.Entry<ModuleBuildTarget, Collection<ClassItem>> entry : remoteClasses.entrySet()) -->Line_18 $$ final ModuleBuildTarget target = entry.getKey()[ FD ]
Line_31 $$ handler.addProcessListener(new ProcessAdapter() -->Line_35 $$ if (outputType == ProcessOutputTypes.STDOUT) [ CD ]
Line_21 $$ final BaseOSProcessHandler handler = new BaseOSProcessHandler(process, StringUtil.join(cmdLine, " "), null) -->Line_53 $$ final int exitValue = handler.getProcess().exitValue()[ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_3 $$ ExitCode exitCode = ExitCode.NOTHING_DONE[ CD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_82 $$ outputConsumer.registerOutputFile(target, generated, sources)[ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_4 $$ final Collection<File> classpath = ProjectPaths.getCompilationClasspath(chunk, false)[ FD ]
Line_18 $$ final ModuleBuildTarget target = entry.getKey()-->Line_67 $$ final Collection<ClassItem> items = remoteClasses.get(target)[ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_84 $$ context.processMessage(new CompilerMessage(getPresentableName(), e))[ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_12 $$ final String classpathString = buf.toString()[ CD ]
Line_7 $$ if (buf.length() > 0) -->Line_8 $$ buf.append(File.pathSeparator)[ CD ]
Line_31 $$ handler.addProcessListener(new ProcessAdapter() -->Line_38 $$ stdErrParser.append(event.getText())[ FD ]
Line_31 $$ handler.addProcessListener(new ProcessAdapter() -->Line_37 $$ if (outputType == ProcessOutputTypes.STDERR) [ FD ]
Line_78 $$ if (!files.isEmpty()) -->Line_79 $$ final Collection<String> sources = Collections.singleton(item.compiledClass.getSourceFile().getPath())[ CD ]
Line_70 $$ if (children == null) -->Line_75 $$ fsCache.put(item.parentDir, children)[ CD ]
Line_35 $$ if (outputType == ProcessOutputTypes.STDOUT) -->Line_37 $$ if (outputType == ProcessOutputTypes.STDERR) [ CD ]
Line_19 $$ final Collection<String> cmdLine = createStartupCommand(target, rmicPath, classpathString, options, entry.getValue())-->Line_20 $$ final Process process = Runtime.getRuntime().exec(ArrayUtil.toStringArray(cmdLine))[ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_13 $$ final String rmicPath = getPathToRmic(chunk)[ FD ]
Line_5 $$ final StringBuilder buf = new StringBuilder()-->Line_10 $$ buf.append(file.getPath())[ FD ]
Line_19 $$ final Collection<String> cmdLine = createStartupCommand(target, rmicPath, classpathString, options, entry.getValue())-->Line_21 $$ final BaseOSProcessHandler handler = new BaseOSProcessHandler(process, StringUtil.join(cmdLine, " "), null) [ FD ]
Line_21 $$ final BaseOSProcessHandler handler = new BaseOSProcessHandler(process, StringUtil.join(cmdLine, " "), null) -->Line_26 $$ return SharedThreadPool.getInstance().executeOnPooledThread(task)[ CD ]
Line_15 $$ final List<ModuleBuildTarget> targetsProcessed = new ArrayList<ModuleBuildTarget>(remoteClasses.size())-->Line_49 $$ targetsProcessed.add(target)[ FD ]
Line_18 $$ final ModuleBuildTarget target = entry.getKey()-->Line_19 $$ final Collection<String> cmdLine = createStartupCommand(target, rmicPath, classpathString, options, entry.getValue())[ FD ]
Line_37 $$ if (outputType == ProcessOutputTypes.STDERR) -->Line_38 $$ stdErrParser.append(event.getText())[ CD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_90 $$ return exitCode[ CD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_4 $$ final Collection<File> classpath = ProjectPaths.getCompilationClasspath(chunk, false)[ CD ]
Line_13 $$ final String rmicPath = getPathToRmic(chunk)-->Line_19 $$ final Collection<String> cmdLine = createStartupCommand(target, rmicPath, classpathString, options, entry.getValue())[ FD ]
Line_31 $$ handler.addProcessListener(new ProcessAdapter() -->Line_44 $$ super.processTerminated(event)[ CD ]
Line_21 $$ final BaseOSProcessHandler handler = new BaseOSProcessHandler(process, StringUtil.join(cmdLine, " "), null) -->Line_26 $$ return SharedThreadPool.getInstance().executeOnPooledThread(task)[ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_16 $$ for (Map.Entry<ModuleBuildTarget, Collection<ClassItem>> entry : remoteClasses.entrySet()) [ FD ]
Line_35 $$ if (outputType == ProcessOutputTypes.STDOUT) -->Line_36 $$ stdOutParser.append(event.getText())[ CD ]
Line_12 $$ final String classpathString = buf.toString()-->Line_19 $$ final Collection<String> cmdLine = createStartupCommand(target, rmicPath, classpathString, options, entry.getValue())[ FD ]
Line_21 $$ final BaseOSProcessHandler handler = new BaseOSProcessHandler(process, StringUtil.join(cmdLine, " "), null) -->Line_48 $$ handler.waitFor()[ FD ]
Line_18 $$ final ModuleBuildTarget target = entry.getKey()-->Line_49 $$ targetsProcessed.add(target)[ FD ]
Line_50 $$ if (stdErrParser.isErrorsReported() || stdOutParser.isErrorsReported()) -->Line_54 $$ if (exitValue != 0) [ CD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_67 $$ final Collection<ClassItem> items = remoteClasses.get(target)[ FD ]
Line_70 $$ if (children == null) -->Line_71 $$ children = item.parentDir.listFiles()[ CD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_15 $$ final List<ModuleBuildTarget> targetsProcessed = new ArrayList<ModuleBuildTarget>(remoteClasses.size())[ CD ]
Line_18 $$ final ModuleBuildTarget target = entry.getKey()-->Line_82 $$ outputConsumer.registerOutputFile(target, generated, sources)[ FD ]
Line_5 $$ final StringBuilder buf = new StringBuilder()-->Line_12 $$ final String classpathString = buf.toString()[ FD ]
Line_54 $$ if (exitValue != 0) -->Line_55 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, "RMI stub generation failed"))[ CD ]
Line_21 $$ final BaseOSProcessHandler handler = new BaseOSProcessHandler(process, StringUtil.join(cmdLine, " "), null) -->Line_47 $$ handler.startNotify()[ FD ]
Line_31 $$ handler.addProcessListener(new ProcessAdapter() -->Line_44 $$ super.processTerminated(event)[ FD ]
Line_31 $$ handler.addProcessListener(new ProcessAdapter() -->Line_36 $$ stdOutParser.append(event.getText())[ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_14 $$ final RmicCompilerOptions options = getOptions(context)[ CD ]
Line_70 $$ if (children == null) -->Line_72 $$ if (children == null) [ CD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_55 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, "RMI stub generation failed"))[ FD ]
Line_21 $$ final BaseOSProcessHandler handler = new BaseOSProcessHandler(process, StringUtil.join(cmdLine, " "), null) -->Line_31 $$ handler.addProcessListener(new ProcessAdapter() [ FD ]
Line_5 $$ final StringBuilder buf = new StringBuilder()-->Line_7 $$ if (buf.length() > 0) [ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_14 $$ final RmicCompilerOptions options = getOptions(context)[ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_5 $$ final StringBuilder buf = new StringBuilder()[ CD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_15 $$ final List<ModuleBuildTarget> targetsProcessed = new ArrayList<ModuleBuildTarget>(remoteClasses.size())[ FD ]
Line_5 $$ final StringBuilder buf = new StringBuilder()-->Line_8 $$ buf.append(File.pathSeparator)[ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_60 $$ context.processMessage(new CompilerMessage(getPresentableName(), e))[ FD ]
Line_50 $$ if (stdErrParser.isErrorsReported() || stdOutParser.isErrorsReported()) -->Line_53 $$ final int exitValue = handler.getProcess().exitValue()[ CD ]
Line_16 $$ for (Map.Entry<ModuleBuildTarget, Collection<ClassItem>> entry : remoteClasses.entrySet()) -->Line_19 $$ final Collection<String> cmdLine = createStartupCommand(target, rmicPath, classpathString, options, entry.getValue())[ FD ]
Line_31 $$ handler.addProcessListener(new ProcessAdapter() -->Line_35 $$ if (outputType == ProcessOutputTypes.STDOUT) [ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_13 $$ final String rmicPath = getPathToRmic(chunk)[ CD ]
Line_6 $$ for (File file : classpath) -->Line_10 $$ buf.append(file.getPath())[ FD ]
