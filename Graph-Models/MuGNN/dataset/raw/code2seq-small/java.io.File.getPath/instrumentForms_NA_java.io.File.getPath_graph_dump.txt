Line_7 $$ final LwRootContainer rootContainer-->Line_24 $$ final String classToBind = rootContainer.getClassToBind()[ FD ]
Line_6 $$ for (File formFile : forms) -->Line_38 $$ class2form.put(classToBind, formFile)[ FD ]
Line_28 $$ final CompiledClass compiled = findClassFile(outConsumer, classToBind)-->Line_29 $$ if (compiled == null) [ FD ]
Line_6 $$ for (File formFile : forms) -->Line_35 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, formFile.getAbsolutePath() + ": The form is bound to the class " + classToBind + ".\nAnother form " + alreadyProcessedForm.getAbsolutePath() + " is also bound to this class", formFile.getAbsolutePath()))[ FD ]
Line_6 $$ for (File formFile : forms) -->Line_62 $$ message.append(formFile.getAbsolutePath()).append(": ").append(error.getErrorMessage())[ FD ]
Line_4 $$ final Map<String, File> class2form = new HashMap<String, File>()-->Line_33 $$ final File alreadyProcessedForm = class2form.get(classToBind)[ FD ]
Line_6 $$ for (File formFile : forms) -->Line_9 $$ rootContainer = Utils.getRootContainer(formFile.toURI().toURL(), new CompiledClassPropertiesProvider(finder.getLoader()))[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_9 $$ rootContainer = Utils.getRootContainer(formFile.toURI().toURL(), new CompiledClassPropertiesProvider(finder.getLoader()))[ FD ]
Line_57 $$ StringBuilder message = new StringBuilder()-->Line_60 $$ message.append("\n")[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_70 $$ return instrumented[ CD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_53 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, warning.getErrorMessage(), formFile.getAbsolutePath()))[ FD ]
Line_6 $$ for (File formFile : forms) -->Line_14 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, e.getMessage(), formFile.getPath()))[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_18 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, e.getMessage(), formFile.getPath()))[ FD ]
Line_56 $$ if (errors.length > 0) -->Line_64 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, message.toString()))[ CD ]
Line_57 $$ StringBuilder message = new StringBuilder()-->Line_62 $$ message.append(formFile.getAbsolutePath()).append(": ").append(error.getErrorMessage())[ FD ]
Line_43 $$ final ClassReader classReader = new FailSafeClassReader(originalContent.getBuffer(), originalContent.getOffset(), originalContent.getLength())-->Line_44 $$ final int version = ClassProcessingBuilder.getClassFileVersion(classReader)[ FD ]
Line_58 $$ for (final FormErrorInfo error : errors) -->Line_62 $$ message.append(formFile.getAbsolutePath()).append(": ").append(error.getErrorMessage())[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_3 $$ final Map<File, Collection<File>> instrumented = new THashMap<File, Collection<File>>(FileUtil.FILE_HASHING_STRATEGY)[ CD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_41 $$ context.processMessage(new ProgressMessage("Instrumenting forms... [" + chunk.getPresentableShortName() + "]"))[ FD ]
Line_57 $$ StringBuilder message = new StringBuilder()-->Line_64 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, message.toString()))[ FD ]
Line_33 $$ final File alreadyProcessedForm = class2form.get(classToBind)-->Line_35 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, formFile.getAbsolutePath() + ": The form is bound to the class " + classToBind + ".\nAnother form " + alreadyProcessedForm.getAbsolutePath() + " is also bound to this class", formFile.getAbsolutePath()))[ FD ]
Line_42 $$ final BinaryContent originalContent = compiled.getContent()-->Line_43 $$ final ClassReader classReader = new FailSafeClassReader(originalContent.getBuffer(), originalContent.getOffset(), originalContent.getLength())[ FD ]
Line_29 $$ if (compiled == null) -->Line_30 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, "Class to bind does not exist: " + classToBind, formFile.getAbsolutePath()))[ CD ]
Line_59 $$ if (message.length() > 0) -->Line_60 $$ message.append("\n")[ CD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_64 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, message.toString()))[ FD ]
Line_7 $$ final LwRootContainer rootContainer-->Line_9 $$ rootContainer = Utils.getRootContainer(formFile.toURI().toURL(), new CompiledClassPropertiesProvider(finder.getLoader()))[ FD ]
Line_48 $$ if (patchedBytes != null) -->Line_49 $$ compiled.setContent(new BinaryContent(patchedBytes))[ CD ]
Line_24 $$ final String classToBind = rootContainer.getClassToBind()-->Line_33 $$ final File alreadyProcessedForm = class2form.get(classToBind)[ FD ]
Line_6 $$ for (File formFile : forms) -->Line_39 $$ addBinding(compiled.getSourceFile(), formFile, instrumented)[ FD ]
Line_43 $$ final ClassReader classReader = new FailSafeClassReader(originalContent.getBuffer(), originalContent.getOffset(), originalContent.getLength())-->Line_47 $$ final byte[] patchedBytes = codeGenerator.patchClass(classReader)[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_67 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, "Forms instrumentation failed" + e.getMessage(), formFile.getAbsolutePath()))[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_5 $$ final MyNestedFormLoader nestedFormsLoader = new MyNestedFormLoader(chunkSourcePath, ProjectPaths.getOutputPathsWithDependents(chunk))[ FD ]
Line_28 $$ final CompiledClass compiled = findClassFile(outConsumer, classToBind)-->Line_49 $$ compiled.setContent(new BinaryContent(patchedBytes))[ FD ]
Line_46 $$ final AsmCodeGenerator codeGenerator = new AsmCodeGenerator(rootContainer, finder, nestedFormsLoader, false, classWriter)-->Line_55 $$ final FormErrorInfo[] errors = codeGenerator.getErrors()[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_35 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, formFile.getAbsolutePath() + ": The form is bound to the class " + classToBind + ".\nAnother form " + alreadyProcessedForm.getAbsolutePath() + " is also bound to this class", formFile.getAbsolutePath()))[ FD ]
Line_57 $$ StringBuilder message = new StringBuilder()-->Line_59 $$ if (message.length() > 0) [ FD ]
Line_24 $$ final String classToBind = rootContainer.getClassToBind()-->Line_38 $$ class2form.put(classToBind, formFile)[ FD ]
Line_3 $$ final Map<File, Collection<File>> instrumented = new THashMap<File, Collection<File>>(FileUtil.FILE_HASHING_STRATEGY)-->Line_39 $$ addBinding(compiled.getSourceFile(), formFile, instrumented)[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_28 $$ final CompiledClass compiled = findClassFile(outConsumer, classToBind)[ FD ]
Line_33 $$ final File alreadyProcessedForm = class2form.get(classToBind)-->Line_34 $$ if (alreadyProcessedForm != null) [ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_4 $$ final Map<String, File> class2form = new HashMap<String, File>()[ CD ]
Line_4 $$ final Map<String, File> class2form = new HashMap<String, File>()-->Line_38 $$ class2form.put(classToBind, formFile)[ FD ]
Line_24 $$ final String classToBind = rootContainer.getClassToBind()-->Line_25 $$ if (classToBind == null) [ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_30 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, "Class to bind does not exist: " + classToBind, formFile.getAbsolutePath()))[ FD ]
Line_28 $$ final CompiledClass compiled = findClassFile(outConsumer, classToBind)-->Line_42 $$ final BinaryContent originalContent = compiled.getContent()[ FD ]
Line_6 $$ for (File formFile : forms) -->Line_67 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, "Forms instrumentation failed" + e.getMessage(), formFile.getAbsolutePath()))[ FD ]
Line_6 $$ for (File formFile : forms) -->Line_22 $$ throw new ProjectBuildException("Cannot process form file " + formFile.getAbsolutePath(), e)[ FD ]
Line_6 $$ for (File formFile : forms) -->Line_30 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, "Class to bind does not exist: " + classToBind, formFile.getAbsolutePath()))[ FD ]
Line_6 $$ for (File formFile : forms) -->Line_53 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, warning.getErrorMessage(), formFile.getAbsolutePath()))[ FD ]
Line_52 $$ for (final FormErrorInfo warning : warnings) -->Line_53 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, warning.getErrorMessage(), formFile.getAbsolutePath()))[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_14 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, e.getMessage(), formFile.getPath()))[ FD ]
Line_44 $$ final int version = ClassProcessingBuilder.getClassFileVersion(classReader)-->Line_45 $$ final InstrumenterClassWriter classWriter = new InstrumenterClassWriter(classReader, ClassProcessingBuilder.getAsmClassWriterFlags(version), finder)[ FD ]
Line_47 $$ final byte[] patchedBytes = codeGenerator.patchClass(classReader)-->Line_48 $$ if (patchedBytes != null) [ FD ]
Line_46 $$ final AsmCodeGenerator codeGenerator = new AsmCodeGenerator(rootContainer, finder, nestedFormsLoader, false, classWriter)-->Line_51 $$ final FormErrorInfo[] warnings = codeGenerator.getWarnings()[ FD ]
Line_28 $$ final CompiledClass compiled = findClassFile(outConsumer, classToBind)-->Line_39 $$ addBinding(compiled.getSourceFile(), formFile, instrumented)[ FD ]
Line_24 $$ final String classToBind = rootContainer.getClassToBind()-->Line_28 $$ final CompiledClass compiled = findClassFile(outConsumer, classToBind)[ FD ]
Line_56 $$ if (errors.length > 0) -->Line_57 $$ StringBuilder message = new StringBuilder()[ CD ]
Line_34 $$ if (alreadyProcessedForm != null) -->Line_35 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, formFile.getAbsolutePath() + ": The form is bound to the class " + classToBind + ".\nAnother form " + alreadyProcessedForm.getAbsolutePath() + " is also bound to this class", formFile.getAbsolutePath()))[ CD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_5 $$ final MyNestedFormLoader nestedFormsLoader = new MyNestedFormLoader(chunkSourcePath, ProjectPaths.getOutputPathsWithDependents(chunk))[ CD ]
Line_9 $$ rootContainer = Utils.getRootContainer(formFile.toURI().toURL(), new CompiledClassPropertiesProvider(finder.getLoader()))-->Line_24 $$ final String classToBind = rootContainer.getClassToBind()[ FD ]
Line_46 $$ final AsmCodeGenerator codeGenerator = new AsmCodeGenerator(rootContainer, finder, nestedFormsLoader, false, classWriter)-->Line_47 $$ final byte[] patchedBytes = codeGenerator.patchClass(classReader)[ FD ]
Line_6 $$ for (File formFile : forms) -->Line_18 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, e.getMessage(), formFile.getPath()))[ FD ]
