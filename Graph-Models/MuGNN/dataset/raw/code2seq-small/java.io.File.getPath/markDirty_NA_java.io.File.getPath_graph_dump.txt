Line_2 $$ public boolean markDirty(@Nullable CompileContext context, CompilationRound round, File file, final BuildRootDescriptor rd, @Nullable Timestamps tsStorage, boolean saveEventStamp) throws IOException -->Line_26 $$ LOG.debug(rd.getTarget() + ": NOT MARKED DIRTY: " + file.getPath())[ FD ]
Line_16 $$ final long eventStamp = System.currentTimeMillis()-->Line_18 $$ myRegistrationStamps.put(file, eventStamp)[ FD ]
Line_2 $$ public boolean markDirty(@Nullable CompileContext context, CompilationRound round, File file, final BuildRootDescriptor rd, @Nullable Timestamps tsStorage, boolean saveEventStamp) throws IOException -->Line_13 $$ LOG.debug(rd.getTarget() + ": MARKED DIRTY: " + file.getPath())[ FD ]
Line_2 $$ public boolean markDirty(@Nullable CompileContext context, CompilationRound round, File file, final BuildRootDescriptor rd, @Nullable Timestamps tsStorage, boolean saveEventStamp) throws IOException -->Line_18 $$ myRegistrationStamps.put(file, eventStamp)[ FD ]
Line_2 $$ public boolean markDirty(@Nullable CompileContext context, CompilationRound round, File file, final BuildRootDescriptor rd, @Nullable Timestamps tsStorage, boolean saveEventStamp) throws IOException -->Line_4 $$ if (roundDelta != null && isInCurrentContextTargets(context, rd)) [ FD ]
Line_7 $$ final FilesDelta filesDelta = getDelta(rd.getTarget())-->Line_10 $$ final boolean marked = filesDelta.markRecompile(rd, file)[ FD ]
Line_2 $$ public boolean markDirty(@Nullable CompileContext context, CompilationRound round, File file, final BuildRootDescriptor rd, @Nullable Timestamps tsStorage, boolean saveEventStamp) throws IOException -->Line_7 $$ final FilesDelta filesDelta = getDelta(rd.getTarget())[ FD ]
Line_2 $$ public boolean markDirty(@Nullable CompileContext context, CompilationRound round, File file, final BuildRootDescriptor rd, @Nullable Timestamps tsStorage, boolean saveEventStamp) throws IOException -->Line_8 $$ filesDelta.lockData()[ CD ]
Line_2 $$ public boolean markDirty(@Nullable CompileContext context, CompilationRound round, File file, final BuildRootDescriptor rd, @Nullable Timestamps tsStorage, boolean saveEventStamp) throws IOException -->Line_22 $$ tsStorage.removeStamp(file, rd.getTarget())[ FD ]
Line_2 $$ public boolean markDirty(@Nullable CompileContext context, CompilationRound round, File file, final BuildRootDescriptor rd, @Nullable Timestamps tsStorage, boolean saveEventStamp) throws IOException -->Line_4 $$ if (roundDelta != null && isInCurrentContextTargets(context, rd)) [ CD ]
Line_3 $$ final FilesDelta roundDelta = getRoundDelta(round == CompilationRound.NEXT ? NEXT_ROUND_DELTA_KEY : CURRENT_ROUND_DELTA_KEY, context)-->Line_5 $$ roundDelta.markRecompile(rd, file)[ FD ]
Line_21 $$ if (tsStorage != null) -->Line_22 $$ tsStorage.removeStamp(file, rd.getTarget())[ CD ]
Line_7 $$ final FilesDelta filesDelta = getDelta(rd.getTarget())-->Line_8 $$ filesDelta.lockData()[ FD ]
Line_2 $$ public boolean markDirty(@Nullable CompileContext context, CompilationRound round, File file, final BuildRootDescriptor rd, @Nullable Timestamps tsStorage, boolean saveEventStamp) throws IOException -->Line_5 $$ roundDelta.markRecompile(rd, file)[ FD ]
Line_11 $$ if (marked) -->Line_21 $$ if (tsStorage != null) [ CD ]
Line_11 $$ if (marked) -->Line_25 $$ if (LOG.isDebugEnabled()) [ CD ]
Line_7 $$ final FilesDelta filesDelta = getDelta(rd.getTarget())-->Line_31 $$ filesDelta.unlockData()[ FD ]
Line_4 $$ if (roundDelta != null && isInCurrentContextTargets(context, rd)) -->Line_5 $$ roundDelta.markRecompile(rd, file)[ CD ]
Line_25 $$ if (LOG.isDebugEnabled()) -->Line_26 $$ LOG.debug(rd.getTarget() + ": NOT MARKED DIRTY: " + file.getPath())[ CD ]
Line_12 $$ if (LOG.isDebugEnabled()) -->Line_13 $$ LOG.debug(rd.getTarget() + ": MARKED DIRTY: " + file.getPath())[ CD ]
Line_2 $$ public boolean markDirty(@Nullable CompileContext context, CompilationRound round, File file, final BuildRootDescriptor rd, @Nullable Timestamps tsStorage, boolean saveEventStamp) throws IOException -->Line_3 $$ final FilesDelta roundDelta = getRoundDelta(round == CompilationRound.NEXT ? NEXT_ROUND_DELTA_KEY : CURRENT_ROUND_DELTA_KEY, context)[ FD ]
Line_2 $$ public boolean markDirty(@Nullable CompileContext context, CompilationRound round, File file, final BuildRootDescriptor rd, @Nullable Timestamps tsStorage, boolean saveEventStamp) throws IOException -->Line_7 $$ final FilesDelta filesDelta = getDelta(rd.getTarget())[ CD ]
Line_11 $$ if (marked) -->Line_12 $$ if (LOG.isDebugEnabled()) [ CD ]
Line_11 $$ if (marked) -->Line_15 $$ if (saveEventStamp) [ CD ]
Line_2 $$ public boolean markDirty(@Nullable CompileContext context, CompilationRound round, File file, final BuildRootDescriptor rd, @Nullable Timestamps tsStorage, boolean saveEventStamp) throws IOException -->Line_21 $$ if (tsStorage != null) [ FD ]
Line_15 $$ if (saveEventStamp) -->Line_16 $$ final long eventStamp = System.currentTimeMillis()[ CD ]
Line_2 $$ public boolean markDirty(@Nullable CompileContext context, CompilationRound round, File file, final BuildRootDescriptor rd, @Nullable Timestamps tsStorage, boolean saveEventStamp) throws IOException -->Line_10 $$ final boolean marked = filesDelta.markRecompile(rd, file)[ FD ]
Line_2 $$ public boolean markDirty(@Nullable CompileContext context, CompilationRound round, File file, final BuildRootDescriptor rd, @Nullable Timestamps tsStorage, boolean saveEventStamp) throws IOException -->Line_3 $$ final FilesDelta roundDelta = getRoundDelta(round == CompilationRound.NEXT ? NEXT_ROUND_DELTA_KEY : CURRENT_ROUND_DELTA_KEY, context)[ CD ]
