Line_2 $$ private int updateValueId(int keyId, long value, long oldValue, @Nullable Key key, int processingKey) throws IOException -->Line_36 $$ if (newKey && IOStatistics.DEBUG && (requests & IOStatistics.KEYS_FACTOR_MASK) == 0) [ CD ]
Line_2 $$ private int updateValueId(int keyId, long value, long oldValue, @Nullable Key key, int processingKey) throws IOException -->Line_3 $$ if (myDirectlyStoreLongFileOffsetMode) [ CD ]
Line_2 $$ private int updateValueId(int keyId, long value, long oldValue, @Nullable Key key, int processingKey) throws IOException -->Line_18 $$ if ((keyId < myLargeIndexWatermarkId || myLargeIndexWatermarkId == 0) && (newKey || canUseIntAddressForNewRecord(oldValue))) [ FD ]
Line_2 $$ private int updateValueId(int keyId, long value, long oldValue, @Nullable Key key, int processingKey) throws IOException -->Line_4 $$ ((PersistentBTreeEnumerator<Key>) myEnumerator).putNonnegativeValue(((InlineKeyDescriptor<Key>) myKeyDescriptor).fromInt(processingKey), value)[ FD ]
Line_2 $$ private int updateValueId(int keyId, long value, long oldValue, @Nullable Key key, int processingKey) throws IOException -->Line_12 $$ if (canUseIntAddressForNewRecord(value)) [ FD ]
Line_40 $$ long checkRecord = readValueId(keyId)-->Line_41 $$ if (checkRecord != (value & ~USED_LONG_VALUE_MASK)) [ FD ]
Line_39 $$ if (doHardConsistencyChecks) -->Line_40 $$ long checkRecord = readValueId(keyId)[ CD ]
Line_2 $$ private int updateValueId(int keyId, long value, long oldValue, @Nullable Key key, int processingKey) throws IOException -->Line_45 $$ return keyId[ CD ]
Line_12 $$ if (canUseIntAddressForNewRecord(value)) -->Line_18 $$ if ((keyId < myLargeIndexWatermarkId || myLargeIndexWatermarkId == 0) && (newKey || canUseIntAddressForNewRecord(oldValue))) [ CD ]
Line_2 $$ private int updateValueId(int keyId, long value, long oldValue, @Nullable Key key, int processingKey) throws IOException -->Line_21 $$ keyId = myEnumerator.reenumerate(key == null ? myEnumerator.getValue(keyId, processingKey) : key)[ FD ]
Line_18 $$ if ((keyId < myLargeIndexWatermarkId || myLargeIndexWatermarkId == 0) && (newKey || canUseIntAddressForNewRecord(oldValue))) -->Line_23 $$ if (myLargeIndexWatermarkId == 0) [ CD ]
Line_36 $$ if (newKey && IOStatistics.DEBUG && (requests & IOStatistics.KEYS_FACTOR_MASK) == 0) -->Line_37 $$ IOStatistics.dump("small:" + smallKeys + ", large:" + largeKeys + ", transformed:" + transformedKeys + ",@" + getBaseFile().getPath())[ CD ]
Line_11 $$ if (myCanReEnumerate) -->Line_12 $$ if (canUseIntAddressForNewRecord(value)) [ CD ]
Line_29 $$ if (defaultSizeInfo) -->Line_33 $$ if (newKey)[ CD ]
Line_2 $$ private int updateValueId(int keyId, long value, long oldValue, @Nullable Key key, int processingKey) throws IOException -->Line_29 $$ if (defaultSizeInfo) [ CD ]
Line_29 $$ if (defaultSizeInfo) -->Line_30 $$ value |= USED_LONG_VALUE_MASK[ CD ]
Line_2 $$ private int updateValueId(int keyId, long value, long oldValue, @Nullable Key key, int processingKey) throws IOException -->Line_10 $$ boolean defaultSizeInfo = true[ CD ]
Line_29 $$ if (defaultSizeInfo) -->Line_31 $$ myEnumerator.myStorage.putInt(keyId + myParentValueRefOffset, (int) (value >>> 32))[ CD ]
Line_10 $$ boolean defaultSizeInfo = true-->Line_13 $$ defaultSizeInfo = false[ FD ]
Line_29 $$ if (defaultSizeInfo) -->Line_32 $$ myEnumerator.myStorage.putInt(keyId + myParentValueRefOffset + 4, (int) value)[ CD ]
Line_2 $$ private int updateValueId(int keyId, long value, long oldValue, @Nullable Key key, int processingKey) throws IOException -->Line_7 $$ final boolean newKey = oldValue == NULL_ADDR[ CD ]
Line_2 $$ private int updateValueId(int keyId, long value, long oldValue, @Nullable Key key, int processingKey) throws IOException -->Line_40 $$ long checkRecord = readValueId(keyId)[ FD ]
Line_2 $$ private int updateValueId(int keyId, long value, long oldValue, @Nullable Key key, int processingKey) throws IOException -->Line_11 $$ if (myCanReEnumerate) [ CD ]
Line_3 $$ if (myDirectlyStoreLongFileOffsetMode) -->Line_5 $$ return keyId[ CD ]
Line_12 $$ if (canUseIntAddressForNewRecord(value)) -->Line_15 $$ if (newKey)[ CD ]
Line_3 $$ if (myDirectlyStoreLongFileOffsetMode) -->Line_4 $$ ((PersistentBTreeEnumerator<Key>) myEnumerator).putNonnegativeValue(((InlineKeyDescriptor<Key>) myKeyDescriptor).fromInt(processingKey), value)[ CD ]
Line_21 $$ keyId = myEnumerator.reenumerate(key == null ? myEnumerator.getValue(keyId, processingKey) : key)-->Line_40 $$ long checkRecord = readValueId(keyId)[ FD ]
Line_12 $$ if (canUseIntAddressForNewRecord(value)) -->Line_13 $$ defaultSizeInfo = false[ CD ]
Line_12 $$ if (canUseIntAddressForNewRecord(value)) -->Line_14 $$ myEnumerator.myStorage.putInt(keyId + myParentValueRefOffset, -(int) (value + POSITIVE_VALUE_SHIFT))[ CD ]
Line_18 $$ if ((keyId < myLargeIndexWatermarkId || myLargeIndexWatermarkId == 0) && (newKey || canUseIntAddressForNewRecord(oldValue))) -->Line_21 $$ keyId = myEnumerator.reenumerate(key == null ? myEnumerator.getValue(keyId, processingKey) : key)[ CD ]
Line_2 $$ private int updateValueId(int keyId, long value, long oldValue, @Nullable Key key, int processingKey) throws IOException -->Line_8 $$ if (newKey)[ CD ]
Line_39 $$ if (doHardConsistencyChecks) -->Line_41 $$ if (checkRecord != (value & ~USED_LONG_VALUE_MASK)) [ CD ]
Line_2 $$ private int updateValueId(int keyId, long value, long oldValue, @Nullable Key key, int processingKey) throws IOException -->Line_39 $$ if (doHardConsistencyChecks) [ CD ]
Line_2 $$ private int updateValueId(int keyId, long value, long oldValue, @Nullable Key key, int processingKey) throws IOException -->Line_30 $$ value |= USED_LONG_VALUE_MASK[ FD ]
