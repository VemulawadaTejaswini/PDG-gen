Line_2 $$ private static String ensureCorrectOutput(ModuleChunk chunk, GroovycOutputParser.OutputItem item, Map<ModuleBuildTarget, String> generationOutputs, String compilerOutput, @NotNull ModuleBuildTarget srcTarget) throws IOException -->Line_7 $$ LOG.info("No output for " + srcTarget + "; outputs=" + generationOutputs + "; targets = " + chunk.getTargets())[ FD ]
Line_3 $$ if (chunk.getModules().size() > 1 && !srcTarget.equals(chunk.representativeTarget())) -->Line_5 $$ String srcTargetOutput = generationOutputs.get(srcTarget)[ CD ]
Line_4 $$ File output = new File(item.outputPath)-->Line_11 $$ File correctOutput = new File(correctRoot, FileUtil.getRelativePath(new File(compilerOutput), output))[ FD ]
Line_4 $$ File output = new File(item.outputPath)-->Line_12 $$ FileUtil.rename(output, correctOutput)[ FD ]
Line_3 $$ if (chunk.getModules().size() > 1 && !srcTarget.equals(chunk.representativeTarget())) -->Line_13 $$ return correctOutput.getPath()[ CD ]
Line_2 $$ private static String ensureCorrectOutput(ModuleChunk chunk, GroovycOutputParser.OutputItem item, Map<ModuleBuildTarget, String> generationOutputs, String compilerOutput, @NotNull ModuleBuildTarget srcTarget) throws IOException -->Line_3 $$ if (chunk.getModules().size() > 1 && !srcTarget.equals(chunk.representativeTarget())) [ CD ]
Line_2 $$ private static String ensureCorrectOutput(ModuleChunk chunk, GroovycOutputParser.OutputItem item, Map<ModuleBuildTarget, String> generationOutputs, String compilerOutput, @NotNull ModuleBuildTarget srcTarget) throws IOException -->Line_3 $$ if (chunk.getModules().size() > 1 && !srcTarget.equals(chunk.representativeTarget())) [ FD ]
Line_5 $$ String srcTargetOutput = generationOutputs.get(srcTarget)-->Line_6 $$ if (srcTargetOutput == null) [ FD ]
Line_3 $$ if (chunk.getModules().size() > 1 && !srcTarget.equals(chunk.representativeTarget())) -->Line_11 $$ File correctOutput = new File(correctRoot, FileUtil.getRelativePath(new File(compilerOutput), output))[ CD ]
Line_3 $$ if (chunk.getModules().size() > 1 && !srcTarget.equals(chunk.representativeTarget())) -->Line_6 $$ if (srcTargetOutput == null) [ CD ]
Line_3 $$ if (chunk.getModules().size() > 1 && !srcTarget.equals(chunk.representativeTarget())) -->Line_12 $$ FileUtil.rename(output, correctOutput)[ CD ]
Line_2 $$ private static String ensureCorrectOutput(ModuleChunk chunk, GroovycOutputParser.OutputItem item, Map<ModuleBuildTarget, String> generationOutputs, String compilerOutput, @NotNull ModuleBuildTarget srcTarget) throws IOException -->Line_15 $$ return item.outputPath[ CD ]
Line_11 $$ File correctOutput = new File(correctRoot, FileUtil.getRelativePath(new File(compilerOutput), output))-->Line_12 $$ FileUtil.rename(output, correctOutput)[ FD ]
Line_3 $$ if (chunk.getModules().size() > 1 && !srcTarget.equals(chunk.representativeTarget())) -->Line_4 $$ File output = new File(item.outputPath)[ CD ]
Line_3 $$ if (chunk.getModules().size() > 1 && !srcTarget.equals(chunk.representativeTarget())) -->Line_10 $$ File correctRoot = new File(srcTargetOutput)[ CD ]
Line_2 $$ private static String ensureCorrectOutput(ModuleChunk chunk, GroovycOutputParser.OutputItem item, Map<ModuleBuildTarget, String> generationOutputs, String compilerOutput, @NotNull ModuleBuildTarget srcTarget) throws IOException -->Line_5 $$ String srcTargetOutput = generationOutputs.get(srcTarget)[ FD ]
Line_11 $$ File correctOutput = new File(correctRoot, FileUtil.getRelativePath(new File(compilerOutput), output))-->Line_13 $$ return correctOutput.getPath()[ FD ]
Line_6 $$ if (srcTargetOutput == null) -->Line_7 $$ LOG.info("No output for " + srcTarget + "; outputs=" + generationOutputs + "; targets = " + chunk.getTargets())[ CD ]
Line_6 $$ if (srcTargetOutput == null) -->Line_8 $$ return item.outputPath[ CD ]
