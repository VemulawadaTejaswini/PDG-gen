Line_27 $$ for (Map.Entry<File, Collection<BuildTarget<?>>> entry : rootsToDelete.entrySet()) -->Line_57 $$ registerTargetsWithClearedOutput(context, entry.getValue())[ FD ]
Line_4 $$ final Set<File> allSourceRoots = new HashSet<File>()-->Line_21 $$ allSourceRoots.add(rootFile)[ FD ]
Line_7 $$ for (BuildTarget<?> target : allTargets) -->Line_8 $$ if (context.getScope().isAffected(target)) [ FD ]
Line_32 $$ if (JpsPathUtil.isUnder(allSourceRoots, outputRoot)) -->Line_33 $$ okToDelete = false[ CD ]
Line_44 $$ if (okToDelete) -->Line_46 $$ if (children != null) [ CD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_59 $$ context.processMessage(new CompilerMessage("", BuildMessage.Kind.WARNING, "Output path " + outputRoot.getPath() + " intersects with a source root. Only files that were created by build will be cleaned."))[ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_9 $$ final Collection<File> outputs = target.getOutputRoots(context)[ FD ]
Line_3 $$ final MultiMap<File, BuildTarget<?>> rootsToDelete = MultiMap.createSet()-->Line_27 $$ for (Map.Entry<File, Collection<BuildTarget<?>>> entry : rootsToDelete.entrySet()) [ FD ]
Line_18 $$ if (!descriptor.isGenerated()) -->Line_20 $$ if (moduleIndex.isInContent(rootFile) && !moduleIndex.isExcluded(rootFile)) [ CD ]
Line_31 $$ if (!moduleIndex.isExcluded(outputRoot)) -->Line_32 $$ if (JpsPathUtil.isUnder(allSourceRoots, outputRoot)) [ CD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_66 $$ final long cleanStart = System.currentTimeMillis()[ CD ]
Line_8 $$ if (context.getScope().isAffected(target)) -->Line_9 $$ final Collection<File> outputs = target.getOutputRoots(context)[ CD ]
Line_20 $$ if (moduleIndex.isInContent(rootFile) && !moduleIndex.isExcluded(rootFile)) -->Line_21 $$ allSourceRoots.add(rootFile)[ CD ]
Line_30 $$ final File outputRoot = entry.getKey()-->Line_45 $$ final File[] children = outputRoot.listFiles()[ FD ]
Line_30 $$ final File outputRoot = entry.getKey()-->Line_53 $$ if (!outputRoot.delete()) [ FD ]
Line_7 $$ for (BuildTarget<?> target : allTargets) -->Line_17 $$ for (BuildRootDescriptor descriptor : projectDescriptor.getBuildRootIndex().getTargetRoots(target, context)) [ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_6 $$ List<? extends BuildTarget<?>> allTargets = projectDescriptor.getBuildTargetIndex().getAllTargets()[ CD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_3 $$ final MultiMap<File, BuildTarget<?>> rootsToDelete = MultiMap.createSet()[ CD ]
Line_30 $$ final File outputRoot = entry.getKey()-->Line_59 $$ context.processMessage(new CompilerMessage("", BuildMessage.Kind.WARNING, "Output path " + outputRoot.getPath() + " intersects with a source root. Only files that were created by build will be cleaned."))[ FD ]
Line_3 $$ final MultiMap<File, BuildTarget<?>> rootsToDelete = MultiMap.createSet()-->Line_11 $$ rootsToDelete.putValue(file, target)[ FD ]
Line_15 $$ ModuleExcludeIndex moduleIndex = projectDescriptor.getModuleExcludeIndex()-->Line_31 $$ if (!moduleIndex.isExcluded(outputRoot)) [ FD ]
Line_27 $$ for (Map.Entry<File, Collection<BuildTarget<?>>> entry : rootsToDelete.entrySet()) -->Line_60 $$ for (BuildTarget<?> target : entry.getValue()) [ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_26 $$ final List<File> filesToDelete = new ArrayList<File>()[ CD ]
Line_19 $$ File rootFile = descriptor.getRootFile()-->Line_21 $$ allSourceRoots.add(rootFile)[ FD ]
Line_29 $$ boolean okToDelete = true-->Line_33 $$ okToDelete = false[ FD ]
Line_7 $$ for (BuildTarget<?> target : allTargets) -->Line_11 $$ rootsToDelete.putValue(file, target)[ FD ]
Line_44 $$ if (okToDelete) -->Line_45 $$ final File[] children = outputRoot.listFiles()[ CD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_4 $$ final Set<File> allSourceRoots = new HashSet<File>()[ CD ]
Line_48 $$ if (!child.delete()) -->Line_49 $$ filesToDelete.add(child)[ CD ]
Line_7 $$ for (BuildTarget<?> target : allTargets) -->Line_9 $$ final Collection<File> outputs = target.getOutputRoots(context)[ FD ]
Line_17 $$ for (BuildRootDescriptor descriptor : projectDescriptor.getBuildRootIndex().getTargetRoots(target, context)) -->Line_18 $$ if (!descriptor.isGenerated()) [ FD ]
Line_36 $$ for (File srcRoot : allSourceRoots) -->Line_37 $$ if (JpsPathUtil.isUnder(_outRoot, srcRoot)) [ FD ]
Line_32 $$ if (JpsPathUtil.isUnder(allSourceRoots, outputRoot)) -->Line_35 $$ final Set<File> _outRoot = Collections.singleton(outputRoot)[ CD ]
Line_17 $$ for (BuildRootDescriptor descriptor : projectDescriptor.getBuildRootIndex().getTargetRoots(target, context)) -->Line_19 $$ File rootFile = descriptor.getRootFile()[ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_8 $$ if (context.getScope().isAffected(target)) [ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_65 $$ context.processMessage(new ProgressMessage("Cleaning output directories..."))[ CD ]
Line_45 $$ final File[] children = outputRoot.listFiles()-->Line_46 $$ if (children != null) [ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_67 $$ if (SYNC_DELETE) [ CD ]
Line_30 $$ final File outputRoot = entry.getKey()-->Line_54 $$ filesToDelete.add(outputRoot)[ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_28 $$ context.checkCanceled()[ FD ]
Line_44 $$ if (okToDelete) -->Line_57 $$ registerTargetsWithClearedOutput(context, entry.getValue())[ CD ]
Line_26 $$ final List<File> filesToDelete = new ArrayList<File>()-->Line_73 $$ myAsyncTasks.add(FileUtil.asyncDelete(filesToDelete))[ FD ]
Line_67 $$ if (SYNC_DELETE) -->Line_73 $$ myAsyncTasks.add(FileUtil.asyncDelete(filesToDelete))[ CD ]
Line_5 $$ ProjectDescriptor projectDescriptor = context.getProjectDescriptor()-->Line_17 $$ for (BuildRootDescriptor descriptor : projectDescriptor.getBuildRootIndex().getTargetRoots(target, context)) [ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_5 $$ ProjectDescriptor projectDescriptor = context.getProjectDescriptor()[ FD ]
Line_19 $$ File rootFile = descriptor.getRootFile()-->Line_20 $$ if (moduleIndex.isInContent(rootFile) && !moduleIndex.isExcluded(rootFile)) [ FD ]
Line_53 $$ if (!outputRoot.delete()) -->Line_54 $$ filesToDelete.add(outputRoot)[ CD ]
Line_33 $$ okToDelete = false-->Line_38 $$ okToDelete = false[ FD ]
Line_35 $$ final Set<File> _outRoot = Collections.singleton(outputRoot)-->Line_37 $$ if (JpsPathUtil.isUnder(_outRoot, srcRoot)) [ FD ]
Line_30 $$ final File outputRoot = entry.getKey()-->Line_31 $$ if (!moduleIndex.isExcluded(outputRoot)) [ FD ]
Line_30 $$ final File outputRoot = entry.getKey()-->Line_35 $$ final Set<File> _outRoot = Collections.singleton(outputRoot)[ FD ]
Line_46 $$ if (children != null) -->Line_53 $$ if (!outputRoot.delete()) [ CD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_15 $$ ModuleExcludeIndex moduleIndex = projectDescriptor.getModuleExcludeIndex()[ CD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_17 $$ for (BuildRootDescriptor descriptor : projectDescriptor.getBuildRootIndex().getTargetRoots(target, context)) [ FD ]
Line_26 $$ final List<File> filesToDelete = new ArrayList<File>()-->Line_49 $$ filesToDelete.add(child)[ FD ]
Line_29 $$ boolean okToDelete = true-->Line_38 $$ okToDelete = false[ FD ]
Line_5 $$ ProjectDescriptor projectDescriptor = context.getProjectDescriptor()-->Line_15 $$ ModuleExcludeIndex moduleIndex = projectDescriptor.getModuleExcludeIndex()[ FD ]
Line_47 $$ for (File child : children) -->Line_49 $$ filesToDelete.add(child)[ FD ]
Line_30 $$ final File outputRoot = entry.getKey()-->Line_32 $$ if (JpsPathUtil.isUnder(allSourceRoots, outputRoot)) [ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_65 $$ context.processMessage(new ProgressMessage("Cleaning output directories..."))[ FD ]
Line_10 $$ for (File file : outputs) -->Line_11 $$ rootsToDelete.putValue(file, target)[ FD ]
Line_18 $$ if (!descriptor.isGenerated()) -->Line_19 $$ File rootFile = descriptor.getRootFile()[ CD ]
Line_5 $$ ProjectDescriptor projectDescriptor = context.getProjectDescriptor()-->Line_6 $$ List<? extends BuildTarget<?>> allTargets = projectDescriptor.getBuildTargetIndex().getAllTargets()[ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_5 $$ ProjectDescriptor projectDescriptor = context.getProjectDescriptor()[ CD ]
Line_10 $$ for (File file : outputs) -->Line_70 $$ FileUtil.delete(file)[ FD ]
Line_15 $$ ModuleExcludeIndex moduleIndex = projectDescriptor.getModuleExcludeIndex()-->Line_20 $$ if (moduleIndex.isInContent(rootFile) && !moduleIndex.isExcluded(rootFile)) [ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_75 $$ LOG.info("Cleaned output directories in " + (System.currentTimeMillis() - cleanStart))[ CD ]
Line_26 $$ final List<File> filesToDelete = new ArrayList<File>()-->Line_54 $$ filesToDelete.add(outputRoot)[ FD ]
Line_27 $$ for (Map.Entry<File, Collection<BuildTarget<?>>> entry : rootsToDelete.entrySet()) -->Line_30 $$ final File outputRoot = entry.getKey()[ FD ]
Line_4 $$ final Set<File> allSourceRoots = new HashSet<File>()-->Line_32 $$ if (JpsPathUtil.isUnder(allSourceRoots, outputRoot)) [ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_61 $$ clearOutputFilesUninterruptibly(context, target)[ FD ]
Line_7 $$ for (BuildTarget<?> target : allTargets) -->Line_61 $$ clearOutputFilesUninterruptibly(context, target)[ FD ]
Line_44 $$ if (okToDelete) -->Line_59 $$ context.processMessage(new CompilerMessage("", BuildMessage.Kind.WARNING, "Output path " + outputRoot.getPath() + " intersects with a source root. Only files that were created by build will be cleaned."))[ CD ]
Line_47 $$ for (File child : children) -->Line_48 $$ if (!child.delete()) [ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_57 $$ registerTargetsWithClearedOutput(context, entry.getValue())[ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_69 $$ context.checkCanceled()[ FD ]
Line_37 $$ if (JpsPathUtil.isUnder(_outRoot, srcRoot)) -->Line_38 $$ okToDelete = false[ CD ]
