Line_8 $$ if (context.getScope().isAffected(target)) -->Line_9 $$ final Collection<File> outputs = target.getOutputRoots(context)[ CD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_5 $$ ProjectDescriptor projectDescriptor = context.getProjectDescriptor()[ CD ]
Line_10 $$ for (File file : outputs) -->Line_80 $$ FileUtil.delete(file)[ FD ]
Line_33 $$ boolean okToDelete = true-->Line_40 $$ okToDelete = false[ FD ]
Line_51 $$ if (okToDelete) -->Line_54 $$ if (children != null) [ CD ]
Line_20 $$ File rootFile = descriptor.getRootFile()-->Line_24 $$ allSourceRoots.add(rootFile)[ FD ]
Line_43 $$ for (File srcRoot : allSourceRoots) -->Line_44 $$ if (JpsPathUtil.isUnder(_outRoot, srcRoot)) [ FD ]
Line_3 $$ final MultiMap<File, BuildTarget<?>> rootsToDelete = MultiMap.createSet()-->Line_11 $$ rootsToDelete.putValue(file, target)[ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_75 $$ context.processMessage(new ProgressMessage("Cleaning output directories..."))[ CD ]
Line_4 $$ final Set<File> allSourceRoots = new HashSet<File>()-->Line_24 $$ allSourceRoots.add(rootFile)[ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_9 $$ final Collection<File> outputs = target.getOutputRoots(context)[ FD ]
Line_51 $$ if (okToDelete) -->Line_66 $$ registerTargetsWithClearedOutput(context, entry.getValue())[ CD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_71 $$ clearOutputFilesUninterruptibly(context, target)[ FD ]
Line_31 $$ for (Map.Entry<File, Collection<BuildTarget<?>>> entry : rootsToDelete.entrySet()) -->Line_66 $$ registerTargetsWithClearedOutput(context, entry.getValue())[ FD ]
Line_7 $$ for (BuildTarget<?> target : allTargets) -->Line_9 $$ final Collection<File> outputs = target.getOutputRoots(context)[ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_3 $$ final MultiMap<File, BuildTarget<?>> rootsToDelete = MultiMap.createSet()[ CD ]
Line_7 $$ for (BuildTarget<?> target : allTargets) -->Line_17 $$ for (BuildRootDescriptor descriptor : projectDescriptor.getBuildRootIndex().getTargetRoots(target, context)) [ FD ]
Line_3 $$ final MultiMap<File, BuildTarget<?>> rootsToDelete = MultiMap.createSet()-->Line_31 $$ for (Map.Entry<File, Collection<BuildTarget<?>>> entry : rootsToDelete.entrySet()) [ FD ]
Line_40 $$ okToDelete = false-->Line_45 $$ okToDelete = false[ FD ]
Line_7 $$ for (BuildTarget<?> target : allTargets) -->Line_11 $$ rootsToDelete.putValue(file, target)[ FD ]
Line_34 $$ final File outputRoot = entry.getKey()-->Line_68 $$ context.processMessage(new CompilerMessage("", BuildMessage.Kind.WARNING, "Output path " + outputRoot.getPath() + " intersects with a source root. Only files that were created by build will be cleaned."))[ FD ]
Line_55 $$ for (File child : children) -->Line_57 $$ filesToDelete.add(child)[ FD ]
Line_5 $$ ProjectDescriptor projectDescriptor = context.getProjectDescriptor()-->Line_15 $$ ModuleExcludeIndex moduleIndex = projectDescriptor.getModuleExcludeIndex()[ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_75 $$ context.processMessage(new ProgressMessage("Cleaning output directories..."))[ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_77 $$ if (SYNC_DELETE) [ CD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_32 $$ context.checkCanceled()[ FD ]
Line_17 $$ for (BuildRootDescriptor descriptor : projectDescriptor.getBuildRootIndex().getTargetRoots(target, context)) -->Line_20 $$ File rootFile = descriptor.getRootFile()[ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_76 $$ final long cleanStart = System.currentTimeMillis()[ CD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_8 $$ if (context.getScope().isAffected(target)) [ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_6 $$ List<? extends BuildTarget<?>> allTargets = projectDescriptor.getBuildTargetIndex().getAllTargets()[ CD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_85 $$ LOG.info("Cleaned output directories in " + (System.currentTimeMillis() - cleanStart))[ CD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_4 $$ final Set<File> allSourceRoots = new HashSet<File>()[ CD ]
Line_5 $$ ProjectDescriptor projectDescriptor = context.getProjectDescriptor()-->Line_17 $$ for (BuildRootDescriptor descriptor : projectDescriptor.getBuildRootIndex().getTargetRoots(target, context)) [ FD ]
Line_77 $$ if (SYNC_DELETE) -->Line_83 $$ myAsyncTasks.add(FileUtil.asyncDelete(filesToDelete))[ CD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_68 $$ context.processMessage(new CompilerMessage("", BuildMessage.Kind.WARNING, "Output path " + outputRoot.getPath() + " intersects with a source root. Only files that were created by build will be cleaned."))[ FD ]
Line_56 $$ if (!child.delete()) -->Line_57 $$ filesToDelete.add(child)[ CD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_5 $$ ProjectDescriptor projectDescriptor = context.getProjectDescriptor()[ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_15 $$ ModuleExcludeIndex moduleIndex = projectDescriptor.getModuleExcludeIndex()[ CD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_66 $$ registerTargetsWithClearedOutput(context, entry.getValue())[ FD ]
Line_33 $$ boolean okToDelete = true-->Line_45 $$ okToDelete = false[ FD ]
Line_7 $$ for (BuildTarget<?> target : allTargets) -->Line_71 $$ clearOutputFilesUninterruptibly(context, target)[ FD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_79 $$ context.checkCanceled()[ FD ]
Line_34 $$ final File outputRoot = entry.getKey()-->Line_42 $$ final Set<File> _outRoot = Collections.singleton(outputRoot)[ FD ]
Line_42 $$ final Set<File> _outRoot = Collections.singleton(outputRoot)-->Line_44 $$ if (JpsPathUtil.isUnder(_outRoot, srcRoot)) [ FD ]
Line_15 $$ ModuleExcludeIndex moduleIndex = projectDescriptor.getModuleExcludeIndex()-->Line_35 $$ if (!moduleIndex.isExcluded(outputRoot)) [ FD ]
Line_55 $$ for (File child : children) -->Line_56 $$ if (!child.delete()) [ FD ]
Line_34 $$ final File outputRoot = entry.getKey()-->Line_35 $$ if (!moduleIndex.isExcluded(outputRoot)) [ FD ]
Line_44 $$ if (JpsPathUtil.isUnder(_outRoot, srcRoot)) -->Line_45 $$ okToDelete = false[ CD ]
Line_34 $$ final File outputRoot = entry.getKey()-->Line_63 $$ filesToDelete.add(outputRoot)[ FD ]
Line_5 $$ ProjectDescriptor projectDescriptor = context.getProjectDescriptor()-->Line_6 $$ List<? extends BuildTarget<?>> allTargets = projectDescriptor.getBuildTargetIndex().getAllTargets()[ FD ]
Line_10 $$ for (File file : outputs) -->Line_11 $$ rootsToDelete.putValue(file, target)[ FD ]
Line_31 $$ for (Map.Entry<File, Collection<BuildTarget<?>>> entry : rootsToDelete.entrySet()) -->Line_34 $$ final File outputRoot = entry.getKey()[ FD ]
Line_51 $$ if (okToDelete) -->Line_68 $$ context.processMessage(new CompilerMessage("", BuildMessage.Kind.WARNING, "Output path " + outputRoot.getPath() + " intersects with a source root. Only files that were created by build will be cleaned."))[ CD ]
Line_2 $$ private void clearOutputs(CompileContext context) throws ProjectBuildException -->Line_17 $$ for (BuildRootDescriptor descriptor : projectDescriptor.getBuildRootIndex().getTargetRoots(target, context)) [ FD ]
Line_7 $$ for (BuildTarget<?> target : allTargets) -->Line_8 $$ if (context.getScope().isAffected(target)) [ FD ]
