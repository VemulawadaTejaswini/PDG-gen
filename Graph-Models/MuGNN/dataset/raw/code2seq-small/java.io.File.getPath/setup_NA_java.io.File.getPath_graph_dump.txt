Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_11 $$ FileSystem remoteFS = p.getFileSystem(conf)[ FD ]
Line_32 $$ Map<LocalResource, Future<Path>> resourcesToPaths = Maps.newHashMap()-->Line_36 $$ resourcesToPaths.put(resource, future)[ FD ]
Line_48 $$ String pathString = path.toUri().toString()-->Line_53 $$ localArchives.add(pathString)[ FD ]
Line_42 $$ path = resourcesToPaths.get(resource).get()-->Line_48 $$ String pathString = path.toUri().toString()[ FD ]
Line_48 $$ String pathString = path.toUri().toString()-->Line_55 $$ localFiles.add(pathString)[ FD ]
Line_49 $$ String link = entry.getKey()-->Line_51 $$ symlink(workDir, target, link)[ FD ]
Line_33 $$ for (LocalResource resource : localResources.values()) -->Line_54 $$ if (resource.getType() == LocalResourceType.FILE) [ FD ]
Line_11 $$ FileSystem remoteFS = p.getFileSystem(conf)-->Line_12 $$ p = remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(), remoteFS.getWorkingDirectory()))[ FD ]
Line_54 $$ if (resource.getType() == LocalResourceType.FILE) -->Line_56 $$ if (resource.getType() == LocalResourceType.PATTERN) [ CD ]
Line_3 $$ File workDir = new File(System.getProperty("user.dir"))-->Line_51 $$ symlink(workDir, target, link)[ FD ]
Line_33 $$ for (LocalResource resource : localResources.values()) -->Line_56 $$ if (resource.getType() == LocalResourceType.PATTERN) [ FD ]
Line_30 $$ exec = Executors.newCachedThreadPool(tf)-->Line_72 $$ if (exec != null) [ FD ]
Line_8 $$ Path[] archiveClassPaths = DistributedCache.getArchiveClassPaths(conf)-->Line_9 $$ if (archiveClassPaths != null) [ FD ]
Line_52 $$ if (resource.getType() == LocalResourceType.ARCHIVE) -->Line_53 $$ localArchives.add(pathString)[ CD ]
Line_12 $$ p = remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(), remoteFS.getWorkingDirectory()))-->Line_20 $$ p = remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(), remoteFS.getWorkingDirectory()))[ FD ]
Line_27 $$ ExecutorService exec = null-->Line_30 $$ exec = Executors.newCachedThreadPool(tf)[ FD ]
Line_24 $$ LocalDirAllocator localDirAllocator = new LocalDirAllocator(MRConfig.LOCAL_DIR)-->Line_31 $$ Path destPath = localDirAllocator.getLocalPathForWrite(".", conf)[ FD ]
Line_33 $$ for (LocalResource resource : localResources.values()) -->Line_61 $$ resourcePath = ConverterUtils.getPathFromYarnURL(resource.getResource())[ FD ]
Line_40 $$ Path path-->Line_48 $$ String pathString = path.toUri().toString()[ FD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_26 $$ UserGroupInformation ugi = UserGroupInformation.getCurrentUser()[ CD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_77 $$ conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils.arrayToString(localArchives.toArray(new String[localArchives.size()])))[ FD ]
Line_67 $$ if (classpaths.keySet().contains(cp)) -->Line_68 $$ localClasspaths.add(path.toUri().getPath().toString())[ CD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_16 $$ Path[] fileClassPaths = DistributedCache.getFileClassPaths(conf)[ CD ]
Line_35 $$ Future<Path> future = exec.submit(download)-->Line_36 $$ resourcesToPaths.put(resource, future)[ FD ]
Line_33 $$ for (LocalResource resource : localResources.values()) -->Line_57 $$ throw new IllegalArgumentException("Resource type PATTERN is not " + "implemented yet. " + resource.getResource())[ FD ]
Line_76 $$ if (!localArchives.isEmpty()) -->Line_77 $$ conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils.arrayToString(localArchives.toArray(new String[localArchives.size()])))[ CD ]
Line_40 $$ Path path-->Line_65 $$ LOG.info(String.format("Localized %s as %s", resourcePath, path))[ FD ]
Line_7 $$ Map<String, Path> classpaths = new HashMap<String, Path>()-->Line_13 $$ classpaths.put(p.toUri().getPath().toString(), p)[ FD ]
Line_7 $$ Map<String, Path> classpaths = new HashMap<String, Path>()-->Line_21 $$ classpaths.put(p.toUri().getPath().toString(), p)[ FD ]
Line_72 $$ if (exec != null) -->Line_73 $$ exec.shutdown()[ CD ]
Line_38 $$ for (Entry<String, LocalResource> entry : localResources.entrySet()) -->Line_39 $$ LocalResource resource = entry.getValue()[ FD ]
Line_33 $$ for (LocalResource resource : localResources.values()) -->Line_42 $$ path = resourcesToPaths.get(resource).get()[ FD ]
Line_34 $$ Callable<Path> download = new FSDownload(localFSFileContext, ugi, conf, new Path(destPath, Long.toString(uniqueNumberGenerator.incrementAndGet())), resource)-->Line_35 $$ Future<Path> future = exec.submit(download)[ FD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_17 $$ if (fileClassPaths != null) [ CD ]
Line_40 $$ Path path-->Line_50 $$ String target = new File(path.toUri()).getPath()[ FD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_8 $$ Path[] archiveClassPaths = DistributedCache.getArchiveClassPaths(conf)[ FD ]
Line_4 $$ Map<String, LocalResource> localResources = new LinkedHashMap<String, LocalResource>()-->Line_38 $$ for (Entry<String, LocalResource> entry : localResources.entrySet()) [ FD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_76 $$ if (!localArchives.isEmpty()) [ CD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_4 $$ Map<String, LocalResource> localResources = new LinkedHashMap<String, LocalResource>()[ CD ]
Line_40 $$ Path path-->Line_68 $$ localClasspaths.add(path.toUri().getPath().toString())[ FD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_16 $$ Path[] fileClassPaths = DistributedCache.getFileClassPaths(conf)[ FD ]
Line_11 $$ FileSystem remoteFS = p.getFileSystem(conf)-->Line_20 $$ p = remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(), remoteFS.getWorkingDirectory()))[ FD ]
Line_40 $$ Path path-->Line_42 $$ path = resourcesToPaths.get(resource).get()[ FD ]
Line_42 $$ path = resourcesToPaths.get(resource).get()-->Line_50 $$ String target = new File(path.toUri()).getPath()[ FD ]
Line_29 $$ ThreadFactory tf = new ThreadFactoryBuilder().setNameFormat("LocalDistributedCacheManager Downloader #%d").build()-->Line_30 $$ exec = Executors.newCachedThreadPool(tf)[ FD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_80 $$ conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils.arrayToString(localFiles.toArray(new String[localArchives.size()])))[ FD ]
Line_52 $$ if (resource.getType() == LocalResourceType.ARCHIVE) -->Line_54 $$ if (resource.getType() == LocalResourceType.FILE) [ CD ]
Line_33 $$ for (LocalResource resource : localResources.values()) -->Line_52 $$ if (resource.getType() == LocalResourceType.ARCHIVE) [ FD ]
Line_42 $$ path = resourcesToPaths.get(resource).get()-->Line_68 $$ localClasspaths.add(path.toUri().getPath().toString())[ FD ]
Line_50 $$ String target = new File(path.toUri()).getPath()-->Line_51 $$ symlink(workDir, target, link)[ FD ]
Line_10 $$ for (Path p : archiveClassPaths) -->Line_11 $$ FileSystem remoteFS = p.getFileSystem(conf)[ FD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_25 $$ FileContext localFSFileContext = FileContext.getLocalFSFileContext()[ CD ]
Line_66 $$ String cp = resourcePath.toUri().getPath()-->Line_67 $$ if (classpaths.keySet().contains(cp)) [ FD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_24 $$ LocalDirAllocator localDirAllocator = new LocalDirAllocator(MRConfig.LOCAL_DIR)[ CD ]
Line_79 $$ if (!localFiles.isEmpty()) -->Line_80 $$ conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils.arrayToString(localFiles.toArray(new String[localArchives.size()])))[ CD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_5 $$ MRApps.setupDistributedCache(conf, localResources)[ FD ]
Line_10 $$ for (Path p : archiveClassPaths) -->Line_20 $$ p = remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(), remoteFS.getWorkingDirectory()))[ FD ]
Line_32 $$ Map<LocalResource, Future<Path>> resourcesToPaths = Maps.newHashMap()-->Line_42 $$ path = resourcesToPaths.get(resource).get()[ FD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_6 $$ AtomicLong uniqueNumberGenerator = new AtomicLong(System.currentTimeMillis())[ CD ]
Line_61 $$ resourcePath = ConverterUtils.getPathFromYarnURL(resource.getResource())-->Line_66 $$ String cp = resourcePath.toUri().getPath()[ FD ]
Line_30 $$ exec = Executors.newCachedThreadPool(tf)-->Line_35 $$ Future<Path> future = exec.submit(download)[ FD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_5 $$ MRApps.setupDistributedCache(conf, localResources)[ CD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_31 $$ Path destPath = localDirAllocator.getLocalPathForWrite(".", conf)[ FD ]
Line_54 $$ if (resource.getType() == LocalResourceType.FILE) -->Line_55 $$ localFiles.add(pathString)[ CD ]
Line_16 $$ Path[] fileClassPaths = DistributedCache.getFileClassPaths(conf)-->Line_17 $$ if (fileClassPaths != null) [ FD ]
Line_20 $$ p = remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(), remoteFS.getWorkingDirectory()))-->Line_21 $$ classpaths.put(p.toUri().getPath().toString(), p)[ FD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_9 $$ if (archiveClassPaths != null) [ CD ]
Line_4 $$ Map<String, LocalResource> localResources = new LinkedHashMap<String, LocalResource>()-->Line_33 $$ for (LocalResource resource : localResources.values()) [ FD ]
Line_27 $$ ExecutorService exec = null-->Line_35 $$ Future<Path> future = exec.submit(download)[ FD ]
Line_10 $$ for (Path p : archiveClassPaths) -->Line_21 $$ classpaths.put(p.toUri().getPath().toString(), p)[ FD ]
Line_61 $$ resourcePath = ConverterUtils.getPathFromYarnURL(resource.getResource())-->Line_65 $$ LOG.info(String.format("Localized %s as %s", resourcePath, path))[ FD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_3 $$ File workDir = new File(System.getProperty("user.dir"))[ CD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_27 $$ ExecutorService exec = null[ CD ]
Line_33 $$ for (LocalResource resource : localResources.values()) -->Line_36 $$ resourcesToPaths.put(resource, future)[ FD ]
Line_27 $$ ExecutorService exec = null-->Line_73 $$ exec.shutdown()[ FD ]
Line_10 $$ for (Path p : archiveClassPaths) -->Line_12 $$ p = remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(), remoteFS.getWorkingDirectory()))[ FD ]
Line_6 $$ AtomicLong uniqueNumberGenerator = new AtomicLong(System.currentTimeMillis())-->Line_34 $$ Callable<Path> download = new FSDownload(localFSFileContext, ugi, conf, new Path(destPath, Long.toString(uniqueNumberGenerator.incrementAndGet())), resource)[ FD ]
Line_59 $$ Path resourcePath-->Line_66 $$ String cp = resourcePath.toUri().getPath()[ FD ]
Line_10 $$ for (Path p : archiveClassPaths) -->Line_13 $$ classpaths.put(p.toUri().getPath().toString(), p)[ FD ]
Line_7 $$ Map<String, Path> classpaths = new HashMap<String, Path>()-->Line_67 $$ if (classpaths.keySet().contains(cp)) [ FD ]
Line_42 $$ path = resourcesToPaths.get(resource).get()-->Line_65 $$ LOG.info(String.format("Localized %s as %s", resourcePath, path))[ FD ]
Line_10 $$ for (Path p : archiveClassPaths) -->Line_19 $$ FileSystem remoteFS = p.getFileSystem(conf)[ FD ]
Line_4 $$ Map<String, LocalResource> localResources = new LinkedHashMap<String, LocalResource>()-->Line_5 $$ MRApps.setupDistributedCache(conf, localResources)[ FD ]
Line_59 $$ Path resourcePath-->Line_65 $$ LOG.info(String.format("Localized %s as %s", resourcePath, path))[ FD ]
Line_12 $$ p = remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(), remoteFS.getWorkingDirectory()))-->Line_21 $$ classpaths.put(p.toUri().getPath().toString(), p)[ FD ]
Line_59 $$ Path resourcePath-->Line_61 $$ resourcePath = ConverterUtils.getPathFromYarnURL(resource.getResource())[ FD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_8 $$ Path[] archiveClassPaths = DistributedCache.getArchiveClassPaths(conf)[ CD ]
Line_38 $$ for (Entry<String, LocalResource> entry : localResources.entrySet()) -->Line_49 $$ String link = entry.getKey()[ FD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_19 $$ FileSystem remoteFS = p.getFileSystem(conf)[ FD ]
Line_27 $$ ExecutorService exec = null-->Line_72 $$ if (exec != null) [ FD ]
Line_12 $$ p = remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(), remoteFS.getWorkingDirectory()))-->Line_13 $$ classpaths.put(p.toUri().getPath().toString(), p)[ FD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_79 $$ if (!localFiles.isEmpty()) [ CD ]
Line_30 $$ exec = Executors.newCachedThreadPool(tf)-->Line_73 $$ exec.shutdown()[ FD ]
Line_2 $$ public void setup(JobConf conf) throws IOException -->Line_7 $$ Map<String, Path> classpaths = new HashMap<String, Path>()[ CD ]
Line_12 $$ p = remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(), remoteFS.getWorkingDirectory()))-->Line_19 $$ FileSystem remoteFS = p.getFileSystem(conf)[ FD ]
