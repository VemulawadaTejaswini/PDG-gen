Line_15 $$ if (hasSourcesToCompile) -->Line_31 $$ final DiagnosticSink diagnosticSink = new DiagnosticSink(context)[ CD ]
Line_15 $$ if (hasSourcesToCompile) -->Line_25 $$ final BuildRootIndex index = pd.getBuildRootIndex()[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_5 $$ if (!hasSourcesToCompile && !dirtyFilesHolder.hasRemovedFiles()) [ FD ]
Line_19 $$ if (versionInfo != null) -->Line_21 $$ context.processMessage(new CompilerMessage("", BuildMessage.Kind.INFO, versionInfo))[ CD ]
Line_15 $$ if (hasSourcesToCompile) -->Line_35 $$ boolean compiledOk = true[ CD ]
Line_8 $$ final ProjectDescriptor pd = context.getProjectDescriptor()-->Line_25 $$ final BuildRootIndex index = pd.getBuildRootIndex()[ FD ]
Line_15 $$ if (hasSourcesToCompile) -->Line_32 $$ final String chunkName = chunk.getName()[ CD ]
Line_67 $$ if (!compiledOk) -->Line_68 $$ diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.OTHER, "Errors occurred while compiling module '" + chunkName + "'"))[ CD ]
Line_15 $$ if (hasSourcesToCompile) -->Line_34 $$ final int filesCount = files.size()[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_9 $$ JavaBuilderUtil.ensureModuleHasJdk(chunk.representativeTarget().getModule(), context, BUILDER_NAME)[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_8 $$ final ProjectDescriptor pd = context.getProjectDescriptor()[ CD ]
Line_31 $$ final DiagnosticSink diagnosticSink = new DiagnosticSink(context)-->Line_70 $$ throw new StopBuildException("Compilation failed: errors: " + diagnosticSink.getErrorCount() + "; warnings: " + diagnosticSink.getWarningCount())[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_5 $$ if (!hasSourcesToCompile && !dirtyFilesHolder.hasRemovedFiles()) [ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_8 $$ final ProjectDescriptor pd = context.getProjectDescriptor()[ FD ]
Line_38 $$ if (LOG.isDebugEnabled()) -->Line_46 $$ LOG.debug(" platform classpath for " + chunkName + ":")[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_10 $$ final Collection<File> classpath = ProjectPaths.getCompilationClasspath(chunk, false)[ FD ]
Line_31 $$ final DiagnosticSink diagnosticSink = new DiagnosticSink(context)-->Line_63 $$ if (!compiledOk && diagnosticSink.getErrorCount() == 0) [ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_10 $$ final Collection<File> classpath = ProjectPaths.getCompilationClasspath(chunk, false)[ CD ]
Line_15 $$ if (hasSourcesToCompile) -->Line_62 $$ context.checkCanceled()[ CD ]
Line_36 $$ if (filesCount > 0) -->Line_37 $$ LOG.info("Compiling " + filesCount + " java files; module: " + chunkName + (chunk.containsTests() ? " (tests)" : ""))[ CD ]
Line_15 $$ if (hasSourcesToCompile) -->Line_33 $$ context.processMessage(new ProgressMessage("Parsing java... [" + chunk.getPresentableShortName() + "]"))[ CD ]
Line_24 $$ final Set<File> srcPath = new HashSet<File>()-->Line_52 $$ compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink, compilingTool)[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_11 $$ final Collection<File> platformCp = ProjectPaths.getPlatformCompilationClasspath(chunk, false)[ FD ]
Line_15 $$ if (hasSourcesToCompile) -->Line_19 $$ if (versionInfo != null) [ CD ]
Line_15 $$ if (hasSourcesToCompile) -->Line_24 $$ final Set<File> srcPath = new HashSet<File>()[ CD ]
Line_31 $$ final DiagnosticSink diagnosticSink = new DiagnosticSink(context)-->Line_66 $$ if (!Utils.PROCEED_ON_ERROR_KEY.get(context, Boolean.FALSE) && diagnosticSink.getErrorCount() > 0) [ FD ]
Line_5 $$ if (!hasSourcesToCompile && !dirtyFilesHolder.hasRemovedFiles()) -->Line_6 $$ return exitCode[ CD ]
Line_63 $$ if (!compiledOk && diagnosticSink.getErrorCount() == 0) -->Line_64 $$ diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, "Compilation failed: internal java compiler error"))[ CD ]
Line_35 $$ boolean compiledOk = true-->Line_63 $$ if (!compiledOk && diagnosticSink.getErrorCount() == 0) [ FD ]
Line_35 $$ boolean compiledOk = true-->Line_52 $$ compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink, compilingTool)[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_4 $$ final boolean hasSourcesToCompile = !files.isEmpty()[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_37 $$ LOG.info("Compiling " + filesCount + " java files; module: " + chunkName + (chunk.containsTests() ? " (tests)" : ""))[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_57 $$ FSOperations.markDeleted(context, file)[ FD ]
Line_24 $$ final Set<File> srcPath = new HashSet<File>()-->Line_28 $$ srcPath.add(rd.root)[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_4 $$ final boolean hasSourcesToCompile = !files.isEmpty()[ FD ]
Line_15 $$ if (hasSourcesToCompile) -->Line_16 $$ final AtomicReference<String> ref = COMPILER_VERSION_INFO.get(context)[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_26 $$ for (ModuleBuildTarget target : chunk.getTargets()) [ FD ]
Line_4 $$ final boolean hasSourcesToCompile = !files.isEmpty()-->Line_5 $$ if (!hasSourcesToCompile && !dirtyFilesHolder.hasRemovedFiles()) [ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_77 $$ return exitCode[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_21 $$ context.processMessage(new CompilerMessage("", BuildMessage.Kind.INFO, versionInfo))[ FD ]
Line_34 $$ final int filesCount = files.size()-->Line_36 $$ if (filesCount > 0) [ FD ]
Line_35 $$ boolean compiledOk = true-->Line_67 $$ if (!compiledOk) [ FD ]
Line_39 $$ for (File file : files) -->Line_40 $$ LOG.debug("Compiling " + file.getPath())[ FD ]
Line_15 $$ if (hasSourcesToCompile) -->Line_23 $$ exitCode = ExitCode.OK[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_3 $$ ExitCode exitCode = ExitCode.NOTHING_DONE[ CD ]
Line_31 $$ final DiagnosticSink diagnosticSink = new DiagnosticSink(context)-->Line_68 $$ diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.OTHER, "Errors occurred while compiling module '" + chunkName + "'"))[ FD ]
Line_31 $$ final DiagnosticSink diagnosticSink = new DiagnosticSink(context)-->Line_64 $$ diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, "Compilation failed: internal java compiler error"))[ FD ]
Line_15 $$ if (hasSourcesToCompile) -->Line_66 $$ if (!Utils.PROCEED_ON_ERROR_KEY.get(context, Boolean.FALSE) && diagnosticSink.getErrorCount() > 0) [ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_11 $$ final Collection<File> platformCp = ProjectPaths.getPlatformCompilationClasspath(chunk, false)[ CD ]
Line_10 $$ final Collection<File> classpath = ProjectPaths.getCompilationClasspath(chunk, false)-->Line_52 $$ compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink, compilingTool)[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_16 $$ final AtomicReference<String> ref = COMPILER_VERSION_INFO.get(context)[ FD ]
Line_11 $$ final Collection<File> platformCp = ProjectPaths.getPlatformCompilationClasspath(chunk, false)-->Line_52 $$ compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink, compilingTool)[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_52 $$ compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink, compilingTool)[ FD ]
Line_36 $$ if (filesCount > 0) -->Line_38 $$ if (LOG.isDebugEnabled()) [ CD ]
Line_38 $$ if (LOG.isDebugEnabled()) -->Line_42 $$ LOG.debug(" classpath for " + chunkName + ":")[ CD ]
Line_25 $$ final BuildRootIndex index = pd.getBuildRootIndex()-->Line_27 $$ for (JavaSourceRootDescriptor rd : index.getTempTargetRoots(target, context)) [ FD ]
Line_3 $$ ExitCode exitCode = ExitCode.NOTHING_DONE-->Line_23 $$ exitCode = ExitCode.OK[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_9 $$ JavaBuilderUtil.ensureModuleHasJdk(chunk.representativeTarget().getModule(), context, BUILDER_NAME)[ FD ]
Line_39 $$ for (File file : files) -->Line_57 $$ FSOperations.markDeleted(context, file)[ FD ]
Line_26 $$ for (ModuleBuildTarget target : chunk.getTargets()) -->Line_27 $$ for (JavaSourceRootDescriptor rd : index.getTempTargetRoots(target, context)) [ FD ]
Line_31 $$ final DiagnosticSink diagnosticSink = new DiagnosticSink(context)-->Line_52 $$ compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink, compilingTool)[ FD ]
Line_19 $$ if (versionInfo != null) -->Line_20 $$ LOG.info(versionInfo)[ CD ]
Line_56 $$ if (!file.exists()) -->Line_57 $$ FSOperations.markDeleted(context, file)[ CD ]
Line_39 $$ for (File file : files) -->Line_44 $$ LOG.debug("  " + file.getAbsolutePath())[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_75 $$ JavaBuilderUtil.registerSuccessfullyCompiled(context, outputSink.getSuccessfullyCompiled())[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_74 $$ JavaBuilderUtil.registerFilesToCompile(context, files)[ FD ]
Line_52 $$ compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink, compilingTool)-->Line_63 $$ if (!compiledOk && diagnosticSink.getErrorCount() == 0) [ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_34 $$ final int filesCount = files.size()[ FD ]
Line_15 $$ if (hasSourcesToCompile) -->Line_63 $$ if (!compiledOk && diagnosticSink.getErrorCount() == 0) [ CD ]
Line_39 $$ for (File file : files) -->Line_56 $$ if (!file.exists()) [ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_62 $$ context.checkCanceled()[ FD ]
Line_66 $$ if (!Utils.PROCEED_ON_ERROR_KEY.get(context, Boolean.FALSE) && diagnosticSink.getErrorCount() > 0) -->Line_67 $$ if (!compiledOk) [ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_33 $$ context.processMessage(new ProgressMessage("Parsing java... [" + chunk.getPresentableShortName() + "]"))[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_32 $$ final String chunkName = chunk.getName()[ FD ]
Line_52 $$ compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink, compilingTool)-->Line_67 $$ if (!compiledOk) [ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_66 $$ if (!Utils.PROCEED_ON_ERROR_KEY.get(context, Boolean.FALSE) && diagnosticSink.getErrorCount() > 0) [ FD ]
Line_39 $$ for (File file : files) -->Line_48 $$ LOG.debug("  " + file.getAbsolutePath())[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_27 $$ for (JavaSourceRootDescriptor rd : index.getTempTargetRoots(target, context)) [ FD ]
Line_15 $$ if (hasSourcesToCompile) -->Line_36 $$ if (filesCount > 0) [ CD ]
