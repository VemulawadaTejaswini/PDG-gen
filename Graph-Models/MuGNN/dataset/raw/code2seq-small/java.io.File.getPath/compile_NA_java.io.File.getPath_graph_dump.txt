Line_24 $$ for (ModuleBuildTarget target : chunk.getTargets()) -->Line_25 $$ for (JavaSourceRootDescriptor rd : index.getTempTargetRoots(target, context)) [ FD ]
Line_15 $$ final AtomicReference<String> ref = COMPILER_VERSION_INFO.get(context)-->Line_16 $$ final String versionInfo = ref.getAndSet(null)[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_54 $$ FSOperations.markDeleted(context, file)[ FD ]
Line_29 $$ final DiagnosticSink diagnosticSink = new DiagnosticSink(context)-->Line_65 $$ diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.OTHER, "Errors occurred while compiling module '" + chunkName + "'"))[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_9 $$ JavaBuilderUtil.ensureModuleHasJdk(chunk.representativeTarget().getModule(), context, BUILDER_NAME)[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_35 $$ LOG.info("Compiling " + filesCount + " java files; module: " + chunkName + (chunk.containsTests() ? " (tests)" : ""))[ FD ]
Line_33 $$ boolean compiledOk = true-->Line_50 $$ compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink, compilingTool)[ FD ]
Line_16 $$ final String versionInfo = ref.getAndSet(null)-->Line_18 $$ LOG.info(versionInfo)[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_11 $$ final Collection<File> platformCp = ProjectPaths.getPlatformCompilationClasspath(chunk, false)[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_10 $$ final Collection<File> classpath = ProjectPaths.getCompilationClasspath(chunk, false)[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_12 $$ final OutputFilesSink outputSink = new OutputFilesSink(context, outputConsumer, JavaBuilderUtil.getDependenciesRegistrar(context), chunk.getPresentableShortName())[ FD ]
Line_29 $$ final DiagnosticSink diagnosticSink = new DiagnosticSink(context)-->Line_52 $$ for (File file : diagnosticSink.getFilesWithErrors()) [ FD ]
Line_14 $$ if (hasSourcesToCompile) -->Line_34 $$ if (filesCount > 0) [ CD ]
Line_53 $$ if (!file.exists()) -->Line_54 $$ FSOperations.markDeleted(context, file)[ CD ]
Line_14 $$ if (hasSourcesToCompile) -->Line_23 $$ final BuildRootIndex index = pd.getBuildRootIndex()[ CD ]
Line_50 $$ compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink, compilingTool)-->Line_64 $$ if (!compiledOk) [ FD ]
Line_5 $$ if (!hasSourcesToCompile && !dirtyFilesHolder.hasRemovedFiles()) -->Line_6 $$ return exitCode[ CD ]
Line_17 $$ if (versionInfo != null) -->Line_18 $$ LOG.info(versionInfo)[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_72 $$ JavaBuilderUtil.registerSuccessfullyCompiled(context, outputSink.getSuccessfullyCompiled())[ FD ]
Line_14 $$ if (hasSourcesToCompile) -->Line_16 $$ final String versionInfo = ref.getAndSet(null)[ CD ]
Line_14 $$ if (hasSourcesToCompile) -->Line_59 $$ context.checkCanceled()[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_32 $$ final int filesCount = files.size()[ FD ]
Line_63 $$ if (!Utils.PROCEED_ON_ERROR_KEY.get(context, Boolean.FALSE) && diagnosticSink.getErrorCount() > 0) -->Line_64 $$ if (!compiledOk) [ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_63 $$ if (!Utils.PROCEED_ON_ERROR_KEY.get(context, Boolean.FALSE) && diagnosticSink.getErrorCount() > 0) [ FD ]
Line_64 $$ if (!compiledOk) -->Line_65 $$ diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.OTHER, "Errors occurred while compiling module '" + chunkName + "'"))[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_8 $$ final ProjectDescriptor pd = context.getProjectDescriptor()[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_15 $$ final AtomicReference<String> ref = COMPILER_VERSION_INFO.get(context)[ FD ]
Line_22 $$ final Set<File> srcPath = new HashSet<File>()-->Line_26 $$ srcPath.add(rd.root)[ FD ]
Line_17 $$ if (versionInfo != null) -->Line_19 $$ context.processMessage(new CompilerMessage("", BuildMessage.Kind.INFO, versionInfo))[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_4 $$ final boolean hasSourcesToCompile = !files.isEmpty()[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_3 $$ ExitCode exitCode = ExitCode.NOTHING_DONE[ CD ]
Line_22 $$ final Set<File> srcPath = new HashSet<File>()-->Line_50 $$ compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink, compilingTool)[ FD ]
Line_60 $$ if (!compiledOk && diagnosticSink.getErrorCount() == 0) -->Line_61 $$ diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, "Compilation failed: internal java compiler error"))[ CD ]
Line_14 $$ if (hasSourcesToCompile) -->Line_33 $$ boolean compiledOk = true[ CD ]
Line_14 $$ if (hasSourcesToCompile) -->Line_29 $$ final DiagnosticSink diagnosticSink = new DiagnosticSink(context)[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_12 $$ final OutputFilesSink outputSink = new OutputFilesSink(context, outputConsumer, JavaBuilderUtil.getDependenciesRegistrar(context), chunk.getPresentableShortName())[ CD ]
Line_37 $$ for (File file : files) -->Line_42 $$ LOG.debug("  " + file.getAbsolutePath())[ FD ]
Line_33 $$ boolean compiledOk = true-->Line_64 $$ if (!compiledOk) [ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_25 $$ for (JavaSourceRootDescriptor rd : index.getTempTargetRoots(target, context)) [ FD ]
Line_29 $$ final DiagnosticSink diagnosticSink = new DiagnosticSink(context)-->Line_67 $$ throw new StopBuildException("Compilation failed: errors: " + diagnosticSink.getErrorCount() + "; warnings: " + diagnosticSink.getWarningCount())[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_30 $$ final String chunkName = chunk.getName()[ FD ]
Line_4 $$ final boolean hasSourcesToCompile = !files.isEmpty()-->Line_5 $$ if (!hasSourcesToCompile && !dirtyFilesHolder.hasRemovedFiles()) [ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_8 $$ final ProjectDescriptor pd = context.getProjectDescriptor()[ FD ]
Line_32 $$ final int filesCount = files.size()-->Line_34 $$ if (filesCount > 0) [ FD ]
Line_37 $$ for (File file : files) -->Line_38 $$ LOG.debug("Compiling " + file.getPath())[ FD ]
Line_3 $$ ExitCode exitCode = ExitCode.NOTHING_DONE-->Line_21 $$ exitCode = ExitCode.OK[ FD ]
Line_29 $$ final DiagnosticSink diagnosticSink = new DiagnosticSink(context)-->Line_50 $$ compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink, compilingTool)[ FD ]
Line_8 $$ final ProjectDescriptor pd = context.getProjectDescriptor()-->Line_23 $$ final BuildRootIndex index = pd.getBuildRootIndex()[ FD ]
Line_37 $$ for (File file : files) -->Line_46 $$ LOG.debug("  " + file.getAbsolutePath())[ FD ]
Line_14 $$ if (hasSourcesToCompile) -->Line_60 $$ if (!compiledOk && diagnosticSink.getErrorCount() == 0) [ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_11 $$ final Collection<File> platformCp = ProjectPaths.getPlatformCompilationClasspath(chunk, false)[ CD ]
Line_14 $$ if (hasSourcesToCompile) -->Line_22 $$ final Set<File> srcPath = new HashSet<File>()[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_74 $$ return exitCode[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_31 $$ context.processMessage(new ProgressMessage("Parsing java... [" + chunk.getPresentableShortName() + "]"))[ FD ]
Line_50 $$ compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink, compilingTool)-->Line_60 $$ if (!compiledOk && diagnosticSink.getErrorCount() == 0) [ FD ]
Line_36 $$ if (LOG.isDebugEnabled()) -->Line_40 $$ LOG.debug(" classpath for " + chunkName + ":")[ CD ]
Line_16 $$ final String versionInfo = ref.getAndSet(null)-->Line_17 $$ if (versionInfo != null) [ FD ]
Line_37 $$ for (File file : files) -->Line_53 $$ if (!file.exists()) [ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_59 $$ context.checkCanceled()[ FD ]
Line_33 $$ boolean compiledOk = true-->Line_60 $$ if (!compiledOk && diagnosticSink.getErrorCount() == 0) [ FD ]
Line_37 $$ for (File file : files) -->Line_54 $$ FSOperations.markDeleted(context, file)[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_9 $$ JavaBuilderUtil.ensureModuleHasJdk(chunk.representativeTarget().getModule(), context, BUILDER_NAME)[ FD ]
Line_11 $$ final Collection<File> platformCp = ProjectPaths.getPlatformCompilationClasspath(chunk, false)-->Line_50 $$ compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink, compilingTool)[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_5 $$ if (!hasSourcesToCompile && !dirtyFilesHolder.hasRemovedFiles()) [ FD ]
Line_12 $$ final OutputFilesSink outputSink = new OutputFilesSink(context, outputConsumer, JavaBuilderUtil.getDependenciesRegistrar(context), chunk.getPresentableShortName())-->Line_72 $$ JavaBuilderUtil.registerSuccessfullyCompiled(context, outputSink.getSuccessfullyCompiled())[ FD ]
Line_10 $$ final Collection<File> classpath = ProjectPaths.getCompilationClasspath(chunk, false)-->Line_50 $$ compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink, compilingTool)[ FD ]
Line_23 $$ final BuildRootIndex index = pd.getBuildRootIndex()-->Line_25 $$ for (JavaSourceRootDescriptor rd : index.getTempTargetRoots(target, context)) [ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_5 $$ if (!hasSourcesToCompile && !dirtyFilesHolder.hasRemovedFiles()) [ CD ]
Line_14 $$ if (hasSourcesToCompile) -->Line_21 $$ exitCode = ExitCode.OK[ CD ]
Line_29 $$ final DiagnosticSink diagnosticSink = new DiagnosticSink(context)-->Line_63 $$ if (!Utils.PROCEED_ON_ERROR_KEY.get(context, Boolean.FALSE) && diagnosticSink.getErrorCount() > 0) [ FD ]
Line_14 $$ if (hasSourcesToCompile) -->Line_31 $$ context.processMessage(new ProgressMessage("Parsing java... [" + chunk.getPresentableShortName() + "]"))[ CD ]
Line_14 $$ if (hasSourcesToCompile) -->Line_15 $$ final AtomicReference<String> ref = COMPILER_VERSION_INFO.get(context)[ CD ]
Line_14 $$ if (hasSourcesToCompile) -->Line_32 $$ final int filesCount = files.size()[ CD ]
Line_14 $$ if (hasSourcesToCompile) -->Line_17 $$ if (versionInfo != null) [ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_50 $$ compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink, compilingTool)[ FD ]
Line_34 $$ if (filesCount > 0) -->Line_35 $$ LOG.info("Compiling " + filesCount + " java files; module: " + chunkName + (chunk.containsTests() ? " (tests)" : ""))[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_71 $$ JavaBuilderUtil.registerFilesToCompile(context, files)[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_4 $$ final boolean hasSourcesToCompile = !files.isEmpty()[ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_24 $$ for (ModuleBuildTarget target : chunk.getTargets()) [ FD ]
Line_29 $$ final DiagnosticSink diagnosticSink = new DiagnosticSink(context)-->Line_61 $$ diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, "Compilation failed: internal java compiler error"))[ FD ]
Line_29 $$ final DiagnosticSink diagnosticSink = new DiagnosticSink(context)-->Line_60 $$ if (!compiledOk && diagnosticSink.getErrorCount() == 0) [ FD ]
Line_14 $$ if (hasSourcesToCompile) -->Line_63 $$ if (!Utils.PROCEED_ON_ERROR_KEY.get(context, Boolean.FALSE) && diagnosticSink.getErrorCount() > 0) [ CD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_19 $$ context.processMessage(new CompilerMessage("", BuildMessage.Kind.INFO, versionInfo))[ FD ]
Line_36 $$ if (LOG.isDebugEnabled()) -->Line_44 $$ LOG.debug(" platform classpath for " + chunkName + ":")[ CD ]
Line_34 $$ if (filesCount > 0) -->Line_36 $$ if (LOG.isDebugEnabled()) [ CD ]
Line_12 $$ final OutputFilesSink outputSink = new OutputFilesSink(context, outputConsumer, JavaBuilderUtil.getDependenciesRegistrar(context), chunk.getPresentableShortName())-->Line_50 $$ compiledOk = compileJava(context, chunk, files, classpath, platformCp, srcPath, diagnosticSink, outputSink, compilingTool)[ FD ]
Line_2 $$ private ExitCode compile(final CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, Collection<File> files, OutputConsumer outputConsumer, @NotNull JavaCompilingTool compilingTool) throws Exception -->Line_10 $$ final Collection<File> classpath = ProjectPaths.getCompilationClasspath(chunk, false)[ FD ]
Line_14 $$ if (hasSourcesToCompile) -->Line_30 $$ final String chunkName = chunk.getName()[ CD ]
