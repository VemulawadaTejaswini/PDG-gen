Line_16 $$ final String relativeDataLocationPath = "indices/test/" + Integer.toString(shardRouting.getId()) + "/index"-->Line_17 $$ Path file = PathUtils.get(path).resolve(relativeDataLocationPath)[ FD ]
Line_22 $$ if (includePerCommitFiles || isPerSegmentFile(item.getFileName().toString())) -->Line_23 $$ files.add(item)[ CD ]
Line_4 $$ GroupShardsIterator shardIterators = state.getRoutingNodes().getRoutingTable().activePrimaryShardsGrouped(new String[] -->Line_5 $$ List<ShardIterator> iterators = iterableAsArrayList(shardIterators)[ FD ]
Line_17 $$ Path file = PathUtils.get(path).resolve(relativeDataLocationPath)-->Line_19 $$ try (DirectoryStream<Path> stream = Files.newDirectoryStream(file)) [ FD ]
Line_2 $$ private ShardRouting corruptRandomPrimaryFile(final boolean includePerCommitFiles) throws IOException -->Line_8 $$ assertNotNull(shardRouting)[ CD ]
Line_7 $$ ShardRouting shardRouting = shardIterator.nextOrNull()-->Line_16 $$ final String relativeDataLocationPath = "indices/test/" + Integer.toString(shardRouting.getId()) + "/index"[ FD ]
Line_2 $$ private ShardRouting corruptRandomPrimaryFile(final boolean includePerCommitFiles) throws IOException -->Line_7 $$ ShardRouting shardRouting = shardIterator.nextOrNull()[ CD ]
Line_2 $$ private ShardRouting corruptRandomPrimaryFile(final boolean includePerCommitFiles) throws IOException -->Line_5 $$ List<ShardIterator> iterators = iterableAsArrayList(shardIterators)[ CD ]
Line_2 $$ private ShardRouting corruptRandomPrimaryFile(final boolean includePerCommitFiles) throws IOException -->Line_6 $$ ShardIterator shardIterator = RandomPicks.randomFrom(getRandom(), iterators)[ CD ]
Line_14 $$ for (FsInfo.Path info : nodeStatses.getNodes()[0].getFs()) -->Line_15 $$ String path = info.getPath()[ FD ]
Line_2 $$ private ShardRouting corruptRandomPrimaryFile(final boolean includePerCommitFiles) throws IOException -->Line_10 $$ assertTrue(shardRouting.assignedToNode())[ CD ]
Line_2 $$ private ShardRouting corruptRandomPrimaryFile(final boolean includePerCommitFiles) throws IOException -->Line_3 $$ ClusterState state = client().admin().cluster().prepareState().get().getState()[ CD ]
Line_11 $$ String nodeId = shardRouting.currentNodeId()-->Line_12 $$ NodesStatsResponse nodeStatses = client().admin().cluster().prepareNodesStats(nodeId).setFs(true).get()[ FD ]
Line_20 $$ for (Path item : stream) -->Line_22 $$ if (includePerCommitFiles || isPerSegmentFile(item.getFileName().toString())) [ FD ]
Line_15 $$ String path = info.getPath()-->Line_17 $$ Path file = PathUtils.get(path).resolve(relativeDataLocationPath)[ FD ]
Line_7 $$ ShardRouting shardRouting = shardIterator.nextOrNull()-->Line_10 $$ assertTrue(shardRouting.assignedToNode())[ FD ]
Line_3 $$ ClusterState state = client().admin().cluster().prepareState().get().getState()-->Line_4 $$ GroupShardsIterator shardIterators = state.getRoutingNodes().getRoutingTable().activePrimaryShardsGrouped(new String[] [ FD ]
Line_2 $$ private ShardRouting corruptRandomPrimaryFile(final boolean includePerCommitFiles) throws IOException -->Line_32 $$ return shardRouting[ CD ]
Line_2 $$ private ShardRouting corruptRandomPrimaryFile(final boolean includePerCommitFiles) throws IOException -->Line_4 $$ GroupShardsIterator shardIterators = state.getRoutingNodes().getRoutingTable().activePrimaryShardsGrouped(new String[] [ CD ]
Line_7 $$ ShardRouting shardRouting = shardIterator.nextOrNull()-->Line_9 $$ assertTrue(shardRouting.primary())[ FD ]
Line_6 $$ ShardIterator shardIterator = RandomPicks.randomFrom(getRandom(), iterators)-->Line_7 $$ ShardRouting shardRouting = shardIterator.nextOrNull()[ FD ]
Line_7 $$ ShardRouting shardRouting = shardIterator.nextOrNull()-->Line_8 $$ assertNotNull(shardRouting)[ FD ]
Line_5 $$ List<ShardIterator> iterators = iterableAsArrayList(shardIterators)-->Line_6 $$ ShardIterator shardIterator = RandomPicks.randomFrom(getRandom(), iterators)[ FD ]
Line_2 $$ private ShardRouting corruptRandomPrimaryFile(final boolean includePerCommitFiles) throws IOException -->Line_22 $$ if (includePerCommitFiles || isPerSegmentFile(item.getFileName().toString())) [ FD ]
Line_13 $$ Set<Path> files = new TreeSet()-->Line_23 $$ files.add(item)[ FD ]
Line_2 $$ private ShardRouting corruptRandomPrimaryFile(final boolean includePerCommitFiles) throws IOException -->Line_31 $$ CorruptionUtils.corruptFile(getRandom(), files.toArray(new Path[0]))[ CD ]
Line_20 $$ for (Path item : stream) -->Line_21 $$ if (Files.isRegularFile(item) && "write.lock".equals(item.getFileName().toString()) == false) [ FD ]
Line_21 $$ if (Files.isRegularFile(item) && "write.lock".equals(item.getFileName().toString()) == false) -->Line_22 $$ if (includePerCommitFiles || isPerSegmentFile(item.getFileName().toString())) [ CD ]
Line_20 $$ for (Path item : stream) -->Line_23 $$ files.add(item)[ FD ]
Line_12 $$ NodesStatsResponse nodeStatses = client().admin().cluster().prepareNodesStats(nodeId).setFs(true).get()-->Line_14 $$ for (FsInfo.Path info : nodeStatses.getNodes()[0].getFs()) [ FD ]
Line_2 $$ private ShardRouting corruptRandomPrimaryFile(final boolean includePerCommitFiles) throws IOException -->Line_11 $$ String nodeId = shardRouting.currentNodeId()[ CD ]
Line_17 $$ Path file = PathUtils.get(path).resolve(relativeDataLocationPath)-->Line_18 $$ if (Files.exists(file)) [ FD ]
Line_2 $$ private ShardRouting corruptRandomPrimaryFile(final boolean includePerCommitFiles) throws IOException -->Line_13 $$ Set<Path> files = new TreeSet()[ CD ]
Line_2 $$ private ShardRouting corruptRandomPrimaryFile(final boolean includePerCommitFiles) throws IOException -->Line_9 $$ assertTrue(shardRouting.primary())[ CD ]
Line_7 $$ ShardRouting shardRouting = shardIterator.nextOrNull()-->Line_11 $$ String nodeId = shardRouting.currentNodeId()[ FD ]
Line_13 $$ Set<Path> files = new TreeSet()-->Line_30 $$ pruneOldDeleteGenerations(files)[ FD ]
Line_2 $$ private ShardRouting corruptRandomPrimaryFile(final boolean includePerCommitFiles) throws IOException -->Line_12 $$ NodesStatsResponse nodeStatses = client().admin().cluster().prepareNodesStats(nodeId).setFs(true).get()[ CD ]
Line_13 $$ Set<Path> files = new TreeSet()-->Line_31 $$ CorruptionUtils.corruptFile(getRandom(), files.toArray(new Path[0]))[ FD ]
Line_2 $$ private ShardRouting corruptRandomPrimaryFile(final boolean includePerCommitFiles) throws IOException -->Line_30 $$ pruneOldDeleteGenerations(files)[ CD ]
