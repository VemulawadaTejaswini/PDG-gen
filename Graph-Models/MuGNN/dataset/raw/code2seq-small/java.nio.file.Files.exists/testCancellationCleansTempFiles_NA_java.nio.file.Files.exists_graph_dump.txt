Line_20 $$ for (DiscoveryNode node : clusterService.state().nodes()) -->Line_21 $$ if (!node.equals(clusterService.localNode())) [ FD ]
Line_2 $$ public void testCancellationCleansTempFiles() throws Exception -->Line_12 $$ indexRandom(true, requests)[ CD ]
Line_2 $$ public void testCancellationCleansTempFiles() throws Exception -->Line_4 $$ final String p_node = internalCluster().startNode()[ CD ]
Line_3 $$ final String indexName = "test"-->Line_37 $$ assertThat(node + " indicates assigned replicas", state.getRoutingTable().index(indexName).shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1))[ FD ]
Line_3 $$ final String indexName = "test"-->Line_5 $$ client().admin().indices().prepareCreate(indexName).setSettings(Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1, IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)).get()[ FD ]
Line_7 $$ List<IndexRequestBuilder> requests = new ArrayList()-->Line_12 $$ indexRandom(true, requests)[ FD ]
Line_32 $$ for (String node : internalCluster().getNodeNames()) -->Line_33 $$ if (node.equals(p_node)) [ FD ]
Line_20 $$ for (DiscoveryNode node : clusterService.state().nodes()) -->Line_33 $$ if (node.equals(p_node)) [ FD ]
Line_18 $$ ClusterService clusterService = internalCluster().getInstance(ClusterService.class, p_node)-->Line_21 $$ if (!node.equals(clusterService.localNode())) [ FD ]
Line_45 $$ if (Files.exists(shardLoc)) -->Line_46 $$ assertBusy(new Runnable() [ CD ]
Line_4 $$ final String p_node = internalCluster().startNode()-->Line_33 $$ if (node.equals(p_node)) [ FD ]
Line_2 $$ public void testCancellationCleansTempFiles() throws Exception -->Line_14 $$ flush()[ CD ]
Line_4 $$ final String p_node = internalCluster().startNode()-->Line_18 $$ ClusterService clusterService = internalCluster().getInstance(ClusterService.class, p_node)[ FD ]
Line_2 $$ public void testCancellationCleansTempFiles() throws Exception -->Line_8 $$ int numDocs = scaledRandomIntBetween(25, 250)[ CD ]
Line_20 $$ for (DiscoveryNode node : clusterService.state().nodes()) -->Line_36 $$ ClusterState state = client(node).admin().cluster().prepareState().setLocal(true).get().getState()[ FD ]
Line_49 $$ Files.walkFileTree(shardLoc, new SimpleFileVisitor<Path>() -->Line_51 $$ assertThat("found a temporary recovery file: " + file, file.getFileName().toString(), not(startsWith("recovery.")))[ CD ]
Line_20 $$ for (DiscoveryNode node : clusterService.state().nodes()) -->Line_22 $$ mockTransportService.addDelegate(internalCluster().getInstance(TransportService.class, node.getName()), new RecoveryCorruption(mockTransportService.original(), corruptionCount))[ FD ]
Line_49 $$ Files.walkFileTree(shardLoc, new SimpleFileVisitor<Path>() -->Line_52 $$ return FileVisitResult.CONTINUE[ CD ]
Line_19 $$ MockTransportService mockTransportService = (MockTransportService) internalCluster().getInstance(TransportService.class, p_node)-->Line_22 $$ mockTransportService.addDelegate(internalCluster().getInstance(TransportService.class, node.getName()), new RecoveryCorruption(mockTransportService.original(), corruptionCount))[ FD ]
Line_7 $$ List<IndexRequestBuilder> requests = new ArrayList()-->Line_10 $$ requests.add(client().prepareIndex(indexName, "type").setCreate(true).setSource("[ FD ]
Line_2 $$ public void testCancellationCleansTempFiles() throws Exception -->Line_30 $$ assertBusy(new Runnable() [ CD ]
Line_9 $$ for (int i = 0; i < numDocs; i++) -->Line_10 $$ requests.add(client().prepareIndex(indexName, "type").setCreate(true).setSource("[ CD ]
Line_4 $$ final String p_node = internalCluster().startNode()-->Line_19 $$ MockTransportService mockTransportService = (MockTransportService) internalCluster().getInstance(TransportService.class, p_node)[ FD ]
Line_2 $$ public void testCancellationCleansTempFiles() throws Exception -->Line_13 $$ assertFalse(client().admin().cluster().prepareHealth().setWaitForNodes("3").setWaitForGreenStatus().get().isTimedOut())[ CD ]
Line_21 $$ if (!node.equals(clusterService.localNode())) -->Line_22 $$ mockTransportService.addDelegate(internalCluster().getInstance(TransportService.class, node.getName()), new RecoveryCorruption(mockTransportService.original(), corruptionCount))[ CD ]
Line_20 $$ for (DiscoveryNode node : clusterService.state().nodes()) -->Line_43 $$ NodeEnvironment nodeEnvironment = internalCluster().getInstance(NodeEnvironment.class, node)[ FD ]
Line_2 $$ public void testCancellationCleansTempFiles() throws Exception -->Line_17 $$ CountDownLatch corruptionCount = new CountDownLatch(allowedFailures)[ CD ]
Line_2 $$ public void testCancellationCleansTempFiles() throws Exception -->Line_19 $$ MockTransportService mockTransportService = (MockTransportService) internalCluster().getInstance(TransportService.class, p_node)[ CD ]
Line_2 $$ public void testCancellationCleansTempFiles() throws Exception -->Line_6 $$ internalCluster().startNodesAsync(2).get()[ CD ]
Line_3 $$ final String indexName = "test"-->Line_25 $$ client().admin().indices().prepareUpdateSettings(indexName).setSettings(Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1)).get()[ FD ]
Line_36 $$ ClusterState state = client(node).admin().cluster().prepareState().setLocal(true).get().getState()-->Line_37 $$ assertThat(node + " indicates assigned replicas", state.getRoutingTable().index(indexName).shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1))[ FD ]
Line_2 $$ public void testCancellationCleansTempFiles() throws Exception -->Line_9 $$ for (int i = 0; i < numDocs; i++) [ CD ]
Line_2 $$ public void testCancellationCleansTempFiles() throws Exception -->Line_26 $$ corruptionCount.await()[ CD ]
Line_2 $$ public void testCancellationCleansTempFiles() throws Exception -->Line_5 $$ client().admin().indices().prepareCreate(indexName).setSettings(Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1, IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)).get()[ CD ]
Line_49 $$ Files.walkFileTree(shardLoc, new SimpleFileVisitor<Path>() -->Line_51 $$ assertThat("found a temporary recovery file: " + file, file.getFileName().toString(), not(startsWith("recovery.")))[ FD ]
Line_2 $$ public void testCancellationCleansTempFiles() throws Exception -->Line_3 $$ final String indexName = "test"[ CD ]
Line_17 $$ CountDownLatch corruptionCount = new CountDownLatch(allowedFailures)-->Line_26 $$ corruptionCount.await()[ FD ]
Line_3 $$ final String indexName = "test"-->Line_10 $$ requests.add(client().prepareIndex(indexName, "type").setCreate(true).setSource("[ FD ]
Line_32 $$ for (String node : internalCluster().getNodeNames()) -->Line_43 $$ NodeEnvironment nodeEnvironment = internalCluster().getInstance(NodeEnvironment.class, node)[ FD ]
Line_2 $$ public void testCancellationCleansTempFiles() throws Exception -->Line_7 $$ List<IndexRequestBuilder> requests = new ArrayList()[ CD ]
Line_8 $$ int numDocs = scaledRandomIntBetween(25, 250)-->Line_9 $$ for (int i = 0; i < numDocs; i++) [ FD ]
Line_2 $$ public void testCancellationCleansTempFiles() throws Exception -->Line_15 $$ int allowedFailures = randomIntBetween(3, 10)[ CD ]
Line_2 $$ public void testCancellationCleansTempFiles() throws Exception -->Line_28 $$ assertAcked(client().admin().cluster().prepareUpdateSettings().setTransientSettings(Settings.builder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(), "none")))[ CD ]
Line_2 $$ public void testCancellationCleansTempFiles() throws Exception -->Line_18 $$ ClusterService clusterService = internalCluster().getInstance(ClusterService.class, p_node)[ CD ]
Line_18 $$ ClusterService clusterService = internalCluster().getInstance(ClusterService.class, p_node)-->Line_20 $$ for (DiscoveryNode node : clusterService.state().nodes()) [ FD ]
Line_2 $$ public void testCancellationCleansTempFiles() throws Exception -->Line_25 $$ client().admin().indices().prepareUpdateSettings(indexName).setSettings(Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1)).get()[ CD ]
Line_32 $$ for (String node : internalCluster().getNodeNames()) -->Line_36 $$ ClusterState state = client(node).admin().cluster().prepareState().setLocal(true).get().getState()[ FD ]
