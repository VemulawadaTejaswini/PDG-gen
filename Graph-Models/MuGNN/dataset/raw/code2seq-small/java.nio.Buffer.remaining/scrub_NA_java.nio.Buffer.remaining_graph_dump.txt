Line_93 $$ if (!outOfOrder.isEmpty()) -->Line_101 $$ finished.add(newInOrderSstable)[ CD ]
Line_14 $$ while (!dataFile.isEOF()) -->Line_25 $$ updateIndexKey()[ CD ]
Line_113 $$ if (badRows > 0)-->Line_116 $$ outputHandler.output("Scrub of " + sstable + " complete; looks like all " + emptyRows + " rows were tombstoned")[ CD ]
Line_14 $$ while (!dataFile.isEOF()) -->Line_28 $$ long dataSizeFromIndex = -1[ CD ]
Line_47 $$ try (UnfilteredRowIterator iterator = withValidation(new SSTableIdentityIterator(sstable, dataFile, key), dataFile.getPath())) -->Line_68 $$ saveOutOfOrderRow(prevKey, key, iterator)[ FD ]
Line_96 $$ try (SSTableWriter inOrderWriter = CompactionManager.createWriter(cfs, destination, expectedBloomFilterSize, repairedAt, sstable, transaction)) -->Line_98 $$ newInOrderSstable = inOrderWriter.finish(-1, sstable.maxDataAge, true)[ FD ]
Line_61 $$ if (currentIndexKey != null && (key == null || !key.getKey().equals(currentIndexKey) || dataStart != dataStartFromIndex)) -->Line_86 $$ outputHandler.warn("Row starting at position " + dataStart + " is unreadable; skipping to next")[ CD ]
Line_13 $$ DecoratedKey prevKey = null-->Line_57 $$ prevKey = key[ FD ]
Line_14 $$ while (!dataFile.isEOF()) -->Line_19 $$ DecoratedKey key = null[ CD ]
Line_119 $$ if (badRows > 0)-->Line_120 $$ outputHandler.warn("Unable to recover " + badRows + " rows that were skipped.  You can attempt manual recovery from the pre-scrub snapshot.  You can also run nodetool repair to transfer the data from a healthy replica, if any")[ CD ]
Line_2 $$ public void scrub() -->Line_3 $$ List<SSTableReader> finished = new ArrayList()[ CD ]
Line_33 $$ String keyName = key == null ? "(unreadable key)" : ByteBufferUtil.bytesToHex(key.getKey())-->Line_34 $$ outputHandler.debug(String.format("row %s is %s bytes", keyName, dataSizeFromIndex))[ FD ]
Line_61 $$ if (currentIndexKey != null && (key == null || !key.getKey().equals(currentIndexKey) || dataStart != dataStartFromIndex)) -->Line_63 $$ key = sstable.decorateKey(currentIndexKey)[ CD ]
Line_88 $$ if (currentIndexKey != null)-->Line_89 $$ seekToNextRow()[ CD ]
Line_27 $$ long dataStartFromIndex = -1-->Line_30 $$ dataStartFromIndex = currentRowPositionFromIndex + 2 + currentIndexKey.remaining()[ FD ]
Line_13 $$ DecoratedKey prevKey = null-->Line_76 $$ prevKey = key[ FD ]
Line_57 $$ prevKey = key-->Line_76 $$ prevKey = key[ FD ]
Line_63 $$ key = sstable.decorateKey(currentIndexKey)-->Line_85 $$ throwIfCannotContinue(key, th)[ FD ]
Line_61 $$ if (currentIndexKey != null && (key == null || !key.getKey().equals(currentIndexKey) || dataStart != dataStartFromIndex)) -->Line_88 $$ if (currentIndexKey != null)[ CD ]
Line_6 $$ try (SSTableRewriter writer = new SSTableRewriter(transaction, sstable.maxDataAge, isOffline)) -->Line_104 $$ finished.addAll(writer.setRepairedAt(badRows > 0 ? ActiveRepairService.UNREPAIRED_SSTABLE : sstable.getSSTableMetadata().repairedAt).finish())[ FD ]
Line_19 $$ DecoratedKey key = null-->Line_57 $$ prevKey = key[ FD ]
Line_29 $$ if (currentIndexKey != null) -->Line_30 $$ dataStartFromIndex = currentRowPositionFromIndex + 2 + currentIndexKey.remaining()[ CD ]
Line_3 $$ List<SSTableReader> finished = new ArrayList()-->Line_110 $$ finished.forEach( sstable -> sstable.selfRef().release())[ FD ]
Line_14 $$ while (!dataFile.isEOF()) -->Line_27 $$ long dataStartFromIndex = -1[ CD ]
Line_19 $$ DecoratedKey key = null-->Line_76 $$ prevKey = key[ FD ]
Line_30 $$ dataStartFromIndex = currentRowPositionFromIndex + 2 + currentIndexKey.remaining()-->Line_31 $$ dataSizeFromIndex = nextRowPositionFromIndex - dataStartFromIndex[ FD ]
Line_21 $$ key = sstable.decorateKey(ByteBufferUtil.readWithShortLength(dataFile))-->Line_63 $$ key = sstable.decorateKey(currentIndexKey)[ FD ]
Line_28 $$ long dataSizeFromIndex = -1-->Line_34 $$ outputHandler.debug(String.format("row %s is %s bytes", keyName, dataSizeFromIndex))[ FD ]
Line_19 $$ DecoratedKey key = null-->Line_49 $$ saveOutOfOrderRow(prevKey, key, iterator)[ FD ]
Line_31 $$ dataSizeFromIndex = nextRowPositionFromIndex - dataStartFromIndex-->Line_34 $$ outputHandler.debug(String.format("row %s is %s bytes", keyName, dataSizeFromIndex))[ FD ]
Line_6 $$ try (SSTableRewriter writer = new SSTableRewriter(transaction, sstable.maxDataAge, isOffline)) -->Line_52 $$ if (writer.tryAppend(iterator) == null)[ FD ]
Line_76 $$ prevKey = key-->Line_68 $$ saveOutOfOrderRow(prevKey, key, iterator)[ FD ]
Line_63 $$ key = sstable.decorateKey(currentIndexKey)-->Line_57 $$ prevKey = key[ FD ]
Line_76 $$ prevKey = key-->Line_49 $$ saveOutOfOrderRow(prevKey, key, iterator)[ FD ]
Line_30 $$ dataStartFromIndex = currentRowPositionFromIndex + 2 + currentIndexKey.remaining()-->Line_62 $$ outputHandler.output(String.format("Retrying from row index; data is %s bytes starting at %s", dataSizeFromIndex, dataStartFromIndex))[ FD ]
Line_63 $$ key = sstable.decorateKey(currentIndexKey)-->Line_37 $$ if (key == null)[ FD ]
Line_63 $$ key = sstable.decorateKey(currentIndexKey)-->Line_49 $$ saveOutOfOrderRow(prevKey, key, iterator)[ FD ]
Line_57 $$ prevKey = key-->Line_67 $$ if (prevKey != null && prevKey.compareTo(key) > 0) [ FD ]
Line_13 $$ DecoratedKey prevKey = null-->Line_67 $$ if (prevKey != null && prevKey.compareTo(key) > 0) [ FD ]
Line_96 $$ try (SSTableWriter inOrderWriter = CompactionManager.createWriter(cfs, destination, expectedBloomFilterSize, repairedAt, sstable, transaction)) -->Line_97 $$ inOrderWriter.append(partition.unfilteredIterator())[ FD ]
Line_19 $$ DecoratedKey key = null-->Line_33 $$ String keyName = key == null ? "(unreadable key)" : ByteBufferUtil.bytesToHex(key.getKey())[ FD ]
Line_48 $$ if (prevKey != null && prevKey.compareTo(key) > 0) -->Line_49 $$ saveOutOfOrderRow(prevKey, key, iterator)[ CD ]
Line_8 $$ if (indexAvailable()) -->Line_9 $$ long firstRowPositionFromIndex = rowIndexEntrySerializer.deserialize(indexFile).position[ CD ]
Line_98 $$ newInOrderSstable = inOrderWriter.finish(-1, sstable.maxDataAge, true)-->Line_101 $$ finished.add(newInOrderSstable)[ FD ]
Line_29 $$ if (currentIndexKey != null) -->Line_31 $$ dataSizeFromIndex = nextRowPositionFromIndex - dataStartFromIndex[ CD ]
Line_21 $$ key = sstable.decorateKey(ByteBufferUtil.readWithShortLength(dataFile))-->Line_49 $$ saveOutOfOrderRow(prevKey, key, iterator)[ FD ]
Line_63 $$ key = sstable.decorateKey(currentIndexKey)-->Line_61 $$ if (currentIndexKey != null && (key == null || !key.getKey().equals(currentIndexKey) || dataStart != dataStartFromIndex)) [ FD ]
Line_13 $$ DecoratedKey prevKey = null-->Line_48 $$ if (prevKey != null && prevKey.compareTo(key) > 0) [ FD ]
Line_21 $$ key = sstable.decorateKey(ByteBufferUtil.readWithShortLength(dataFile))-->Line_33 $$ String keyName = key == null ? "(unreadable key)" : ByteBufferUtil.bytesToHex(key.getKey())[ FD ]
Line_21 $$ key = sstable.decorateKey(ByteBufferUtil.readWithShortLength(dataFile))-->Line_68 $$ saveOutOfOrderRow(prevKey, key, iterator)[ FD ]
Line_27 $$ long dataStartFromIndex = -1-->Line_46 $$ outputHandler.warn(String.format("Data file row position %d differs from index file row position %d", dataStart, dataStartFromIndex))[ FD ]
Line_19 $$ DecoratedKey key = null-->Line_63 $$ key = sstable.decorateKey(currentIndexKey)[ FD ]
Line_76 $$ prevKey = key-->Line_67 $$ if (prevKey != null && prevKey.compareTo(key) > 0) [ FD ]
Line_112 $$ if (completed) -->Line_113 $$ if (badRows > 0)[ CD ]
Line_14 $$ while (!dataFile.isEOF()) -->Line_34 $$ outputHandler.debug(String.format("row %s is %s bytes", keyName, dataSizeFromIndex))[ CD ]
Line_28 $$ long dataSizeFromIndex = -1-->Line_62 $$ outputHandler.output(String.format("Retrying from row index; data is %s bytes starting at %s", dataSizeFromIndex, dataStartFromIndex))[ FD ]
Line_57 $$ prevKey = key-->Line_48 $$ if (prevKey != null && prevKey.compareTo(key) > 0) [ FD ]
Line_2 $$ public void scrub() -->Line_112 $$ if (completed) [ CD ]
Line_63 $$ key = sstable.decorateKey(currentIndexKey)-->Line_48 $$ if (prevKey != null && prevKey.compareTo(key) > 0) [ FD ]
Line_57 $$ prevKey = key-->Line_68 $$ saveOutOfOrderRow(prevKey, key, iterator)[ FD ]
Line_95 $$ SSTableReader newInOrderSstable-->Line_100 $$ transaction.update(newInOrderSstable, false)[ FD ]
Line_6 $$ try (SSTableRewriter writer = new SSTableRewriter(transaction, sstable.maxDataAge, isOffline)) -->Line_71 $$ if (writer.tryAppend(iterator) == null)[ FD ]
Line_3 $$ List<SSTableReader> finished = new ArrayList()-->Line_104 $$ finished.addAll(writer.setRepairedAt(badRows > 0 ? ActiveRepairService.UNREPAIRED_SSTABLE : sstable.getSSTableMetadata().repairedAt).finish())[ FD ]
Line_19 $$ DecoratedKey key = null-->Line_21 $$ key = sstable.decorateKey(ByteBufferUtil.readWithShortLength(dataFile))[ FD ]
Line_57 $$ prevKey = key-->Line_49 $$ saveOutOfOrderRow(prevKey, key, iterator)[ FD ]
Line_19 $$ DecoratedKey key = null-->Line_79 $$ throwIfCannotContinue(key, th2)[ FD ]
Line_4 $$ boolean completed = false-->Line_105 $$ completed = true[ FD ]
Line_63 $$ key = sstable.decorateKey(currentIndexKey)-->Line_79 $$ throwIfCannotContinue(key, th2)[ FD ]
Line_27 $$ long dataStartFromIndex = -1-->Line_62 $$ outputHandler.output(String.format("Retrying from row index; data is %s bytes starting at %s", dataSizeFromIndex, dataStartFromIndex))[ FD ]
Line_21 $$ key = sstable.decorateKey(ByteBufferUtil.readWithShortLength(dataFile))-->Line_76 $$ prevKey = key[ FD ]
Line_14 $$ while (!dataFile.isEOF()) -->Line_33 $$ String keyName = key == null ? "(unreadable key)" : ByteBufferUtil.bytesToHex(key.getKey())[ CD ]
Line_95 $$ SSTableReader newInOrderSstable-->Line_98 $$ newInOrderSstable = inOrderWriter.finish(-1, sstable.maxDataAge, true)[ FD ]
Line_19 $$ DecoratedKey key = null-->Line_68 $$ saveOutOfOrderRow(prevKey, key, iterator)[ FD ]
Line_26 $$ long dataStart = dataFile.getFilePointer()-->Line_46 $$ outputHandler.warn(String.format("Data file row position %d differs from index file row position %d", dataStart, dataStartFromIndex))[ FD ]
Line_21 $$ key = sstable.decorateKey(ByteBufferUtil.readWithShortLength(dataFile))-->Line_61 $$ if (currentIndexKey != null && (key == null || !key.getKey().equals(currentIndexKey) || dataStart != dataStartFromIndex)) [ FD ]
Line_6 $$ try (SSTableRewriter writer = new SSTableRewriter(transaction, sstable.maxDataAge, isOffline)) -->Line_12 $$ writer.switchWriter(CompactionManager.createWriter(cfs, destination, expectedBloomFilterSize, sstable.getSSTableMetadata().repairedAt, sstable, transaction))[ FD ]
Line_95 $$ SSTableReader newInOrderSstable-->Line_101 $$ finished.add(newInOrderSstable)[ FD ]
Line_93 $$ if (!outOfOrder.isEmpty()) -->Line_100 $$ transaction.update(newInOrderSstable, false)[ CD ]
Line_19 $$ DecoratedKey key = null-->Line_39 $$ if (currentIndexKey != null && !key.getKey().equals(currentIndexKey)) [ FD ]
Line_95 $$ SSTableReader newInOrderSstable-->Line_102 $$ outputHandler.warn(String.format("%d out of order rows found while scrubbing %s; Those have been written (in order) to a new sstable (%s)", outOfOrder.size(), sstable, newInOrderSstable))[ FD ]
Line_94 $$ long repairedAt = badRows > 0 ? ActiveRepairService.UNREPAIRED_SSTABLE : sstable.getSSTableMetadata().repairedAt-->Line_96 $$ try (SSTableWriter inOrderWriter = CompactionManager.createWriter(cfs, destination, expectedBloomFilterSize, repairedAt, sstable, transaction)) [ FD ]
Line_93 $$ if (!outOfOrder.isEmpty()) -->Line_95 $$ SSTableReader newInOrderSstable[ CD ]
Line_21 $$ key = sstable.decorateKey(ByteBufferUtil.readWithShortLength(dataFile))-->Line_57 $$ prevKey = key[ FD ]
Line_2 $$ public void scrub() -->Line_4 $$ boolean completed = false[ CD ]
Line_21 $$ key = sstable.decorateKey(ByteBufferUtil.readWithShortLength(dataFile))-->Line_37 $$ if (key == null)[ FD ]
Line_27 $$ long dataStartFromIndex = -1-->Line_65 $$ dataFile.seek(dataStartFromIndex)[ FD ]
Line_63 $$ key = sstable.decorateKey(currentIndexKey)-->Line_76 $$ prevKey = key[ FD ]
Line_30 $$ dataStartFromIndex = currentRowPositionFromIndex + 2 + currentIndexKey.remaining()-->Line_46 $$ outputHandler.warn(String.format("Data file row position %d differs from index file row position %d", dataStart, dataStartFromIndex))[ FD ]
Line_3 $$ List<SSTableReader> finished = new ArrayList()-->Line_101 $$ finished.add(newInOrderSstable)[ FD ]
Line_27 $$ long dataStartFromIndex = -1-->Line_31 $$ dataSizeFromIndex = nextRowPositionFromIndex - dataStartFromIndex[ FD ]
Line_61 $$ if (currentIndexKey != null && (key == null || !key.getKey().equals(currentIndexKey) || dataStart != dataStartFromIndex)) -->Line_85 $$ throwIfCannotContinue(key, th)[ CD ]
Line_14 $$ while (!dataFile.isEOF()) -->Line_29 $$ if (currentIndexKey != null) [ CD ]
Line_19 $$ DecoratedKey key = null-->Line_37 $$ if (key == null)[ FD ]
Line_21 $$ key = sstable.decorateKey(ByteBufferUtil.readWithShortLength(dataFile))-->Line_79 $$ throwIfCannotContinue(key, th2)[ FD ]
Line_21 $$ key = sstable.decorateKey(ByteBufferUtil.readWithShortLength(dataFile))-->Line_48 $$ if (prevKey != null && prevKey.compareTo(key) > 0) [ FD ]
Line_63 $$ key = sstable.decorateKey(currentIndexKey)-->Line_68 $$ saveOutOfOrderRow(prevKey, key, iterator)[ FD ]
Line_21 $$ key = sstable.decorateKey(ByteBufferUtil.readWithShortLength(dataFile))-->Line_85 $$ throwIfCannotContinue(key, th)[ FD ]
Line_61 $$ if (currentIndexKey != null && (key == null || !key.getKey().equals(currentIndexKey) || dataStart != dataStartFromIndex)) -->Line_62 $$ outputHandler.output(String.format("Retrying from row index; data is %s bytes starting at %s", dataSizeFromIndex, dataStartFromIndex))[ CD ]
Line_93 $$ if (!outOfOrder.isEmpty()) -->Line_102 $$ outputHandler.warn(String.format("%d out of order rows found while scrubbing %s; Those have been written (in order) to a new sstable (%s)", outOfOrder.size(), sstable, newInOrderSstable))[ CD ]
Line_14 $$ while (!dataFile.isEOF()) -->Line_18 $$ outputHandler.debug("Reading row at " + rowStart)[ CD ]
Line_21 $$ key = sstable.decorateKey(ByteBufferUtil.readWithShortLength(dataFile))-->Line_39 $$ if (currentIndexKey != null && !key.getKey().equals(currentIndexKey)) [ FD ]
Line_45 $$ if (indexFile != null && dataStart != dataStartFromIndex)-->Line_46 $$ outputHandler.warn(String.format("Data file row position %d differs from index file row position %d", dataStart, dataStartFromIndex))[ CD ]
Line_112 $$ if (completed) -->Line_118 $$ outputHandler.output("Scrub of " + sstable + " complete: " + goodRows + " rows in new sstable and " + emptyRows + " empty (tombstoned) rows dropped")[ CD ]
Line_14 $$ while (!dataFile.isEOF()) -->Line_17 $$ long rowStart = dataFile.getFilePointer()[ CD ]
Line_2 $$ public void scrub() -->Line_5 $$ outputHandler.output(String.format("Scrubbing %s (%s bytes)", sstable, dataFile.length()))[ CD ]
Line_19 $$ DecoratedKey key = null-->Line_85 $$ throwIfCannotContinue(key, th)[ FD ]
Line_113 $$ if (badRows > 0)-->Line_114 $$ outputHandler.warn("No valid rows found while scrubbing " + sstable + "; it is marked for deletion now. If you want to attempt manual recovery, you can find a copy in the pre-scrub snapshot")[ CD ]
Line_30 $$ dataStartFromIndex = currentRowPositionFromIndex + 2 + currentIndexKey.remaining()-->Line_65 $$ dataFile.seek(dataStartFromIndex)[ FD ]
Line_28 $$ long dataSizeFromIndex = -1-->Line_31 $$ dataSizeFromIndex = nextRowPositionFromIndex - dataStartFromIndex[ FD ]
Line_31 $$ dataSizeFromIndex = nextRowPositionFromIndex - dataStartFromIndex-->Line_62 $$ outputHandler.output(String.format("Retrying from row index; data is %s bytes starting at %s", dataSizeFromIndex, dataStartFromIndex))[ FD ]
Line_14 $$ while (!dataFile.isEOF()) -->Line_15 $$ if (scrubInfo.isStopRequested())[ CD ]
Line_98 $$ newInOrderSstable = inOrderWriter.finish(-1, sstable.maxDataAge, true)-->Line_100 $$ transaction.update(newInOrderSstable, false)[ FD ]
Line_67 $$ if (prevKey != null && prevKey.compareTo(key) > 0) -->Line_68 $$ saveOutOfOrderRow(prevKey, key, iterator)[ CD ]
Line_21 $$ key = sstable.decorateKey(ByteBufferUtil.readWithShortLength(dataFile))-->Line_67 $$ if (prevKey != null && prevKey.compareTo(key) > 0) [ FD ]
Line_109 $$ if (transaction.isOffline())-->Line_110 $$ finished.forEach( sstable -> sstable.selfRef().release())[ CD ]
Line_93 $$ if (!outOfOrder.isEmpty()) -->Line_94 $$ long repairedAt = badRows > 0 ? ActiveRepairService.UNREPAIRED_SSTABLE : sstable.getSSTableMetadata().repairedAt[ CD ]
Line_47 $$ try (UnfilteredRowIterator iterator = withValidation(new SSTableIdentityIterator(sstable, dataFile, key), dataFile.getPath())) -->Line_71 $$ if (writer.tryAppend(iterator) == null)[ FD ]
Line_14 $$ while (!dataFile.isEOF()) -->Line_26 $$ long dataStart = dataFile.getFilePointer()[ CD ]
Line_63 $$ key = sstable.decorateKey(currentIndexKey)-->Line_33 $$ String keyName = key == null ? "(unreadable key)" : ByteBufferUtil.bytesToHex(key.getKey())[ FD ]
Line_13 $$ DecoratedKey prevKey = null-->Line_68 $$ saveOutOfOrderRow(prevKey, key, iterator)[ FD ]
Line_19 $$ DecoratedKey key = null-->Line_48 $$ if (prevKey != null && prevKey.compareTo(key) > 0) [ FD ]
Line_112 $$ if (completed) -->Line_119 $$ if (badRows > 0)[ CD ]
Line_76 $$ prevKey = key-->Line_48 $$ if (prevKey != null && prevKey.compareTo(key) > 0) [ FD ]
Line_47 $$ try (UnfilteredRowIterator iterator = withValidation(new SSTableIdentityIterator(sstable, dataFile, key), dataFile.getPath())) -->Line_49 $$ saveOutOfOrderRow(prevKey, key, iterator)[ FD ]
Line_63 $$ key = sstable.decorateKey(currentIndexKey)-->Line_39 $$ if (currentIndexKey != null && !key.getKey().equals(currentIndexKey)) [ FD ]
Line_63 $$ key = sstable.decorateKey(currentIndexKey)-->Line_67 $$ if (prevKey != null && prevKey.compareTo(key) > 0) [ FD ]
Line_47 $$ try (UnfilteredRowIterator iterator = withValidation(new SSTableIdentityIterator(sstable, dataFile, key), dataFile.getPath())) -->Line_52 $$ if (writer.tryAppend(iterator) == null)[ FD ]
Line_13 $$ DecoratedKey prevKey = null-->Line_49 $$ saveOutOfOrderRow(prevKey, key, iterator)[ FD ]
Line_98 $$ newInOrderSstable = inOrderWriter.finish(-1, sstable.maxDataAge, true)-->Line_102 $$ outputHandler.warn(String.format("%d out of order rows found while scrubbing %s; Those have been written (in order) to a new sstable (%s)", outOfOrder.size(), sstable, newInOrderSstable))[ FD ]
Line_19 $$ DecoratedKey key = null-->Line_61 $$ if (currentIndexKey != null && (key == null || !key.getKey().equals(currentIndexKey) || dataStart != dataStartFromIndex)) [ FD ]
Line_19 $$ DecoratedKey key = null-->Line_67 $$ if (prevKey != null && prevKey.compareTo(key) > 0) [ FD ]
