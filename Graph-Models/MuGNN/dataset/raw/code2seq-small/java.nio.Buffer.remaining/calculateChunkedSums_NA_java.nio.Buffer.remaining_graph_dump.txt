Line_2 $$ public void calculateChunkedSums(ByteBuffer data, ByteBuffer checksums) -->Line_25 $$ data.reset()[ FD ]
Line_17 $$ while (data.remaining() > 0) -->Line_18 $$ int n = Math.min(data.remaining(), bytesPerChecksum)[ CD ]
Line_2 $$ public void calculateChunkedSums(ByteBuffer data, ByteBuffer checksums) -->Line_22 $$ checksums.putInt((int) summer.getValue())[ FD ]
Line_17 $$ while (data.remaining() > 0) -->Line_19 $$ data.get(buf, 0, n)[ CD ]
Line_2 $$ public void calculateChunkedSums(ByteBuffer data, ByteBuffer checksums) -->Line_14 $$ checksums.mark()[ CD ]
Line_2 $$ public void calculateChunkedSums(ByteBuffer data, ByteBuffer checksums) -->Line_13 $$ data.mark()[ FD ]
Line_3 $$ if (type.size == 0)-->Line_4 $$ return[ CD ]
Line_5 $$ if (data.hasArray() && checksums.hasArray()) -->Line_6 $$ calculateChunkedSums(data.array(), data.arrayOffset() + data.position(), data.remaining(), checksums.array(), checksums.arrayOffset() + checksums.position())[ CD ]
Line_17 $$ while (data.remaining() > 0) -->Line_22 $$ checksums.putInt((int) summer.getValue())[ CD ]
Line_2 $$ public void calculateChunkedSums(ByteBuffer data, ByteBuffer checksums) -->Line_10 $$ NativeCrc32.calculateChunkedSums(bytesPerChecksum, type.id, checksums, data)[ FD ]
Line_2 $$ public void calculateChunkedSums(ByteBuffer data, ByteBuffer checksums) -->Line_14 $$ checksums.mark()[ FD ]
Line_9 $$ if (NativeCrc32.isAvailable()) -->Line_10 $$ NativeCrc32.calculateChunkedSums(bytesPerChecksum, type.id, checksums, data)[ CD ]
Line_2 $$ public void calculateChunkedSums(ByteBuffer data, ByteBuffer checksums) -->Line_19 $$ data.get(buf, 0, n)[ FD ]
Line_5 $$ if (data.hasArray() && checksums.hasArray()) -->Line_7 $$ return[ CD ]
Line_17 $$ while (data.remaining() > 0) -->Line_21 $$ summer.update(buf, 0, n)[ CD ]
Line_18 $$ int n = Math.min(data.remaining(), bytesPerChecksum)-->Line_21 $$ summer.update(buf, 0, n)[ FD ]
Line_2 $$ public void calculateChunkedSums(ByteBuffer data, ByteBuffer checksums) -->Line_5 $$ if (data.hasArray() && checksums.hasArray()) [ FD ]
Line_9 $$ if (NativeCrc32.isAvailable()) -->Line_11 $$ return[ CD ]
Line_2 $$ public void calculateChunkedSums(ByteBuffer data, ByteBuffer checksums) -->Line_9 $$ if (NativeCrc32.isAvailable()) [ CD ]
Line_2 $$ public void calculateChunkedSums(ByteBuffer data, ByteBuffer checksums) -->Line_17 $$ while (data.remaining() > 0) [ FD ]
Line_2 $$ public void calculateChunkedSums(ByteBuffer data, ByteBuffer checksums) -->Line_26 $$ checksums.reset()[ FD ]
Line_2 $$ public void calculateChunkedSums(ByteBuffer data, ByteBuffer checksums) -->Line_6 $$ calculateChunkedSums(data.array(), data.arrayOffset() + data.position(), data.remaining(), checksums.array(), checksums.arrayOffset() + checksums.position())[ FD ]
Line_16 $$ byte[] buf = new byte[bytesPerChecksum]-->Line_21 $$ summer.update(buf, 0, n)[ FD ]
Line_17 $$ while (data.remaining() > 0) -->Line_20 $$ summer.reset()[ CD ]
Line_2 $$ public void calculateChunkedSums(ByteBuffer data, ByteBuffer checksums) -->Line_3 $$ if (type.size == 0)[ CD ]
Line_2 $$ public void calculateChunkedSums(ByteBuffer data, ByteBuffer checksums) -->Line_18 $$ int n = Math.min(data.remaining(), bytesPerChecksum)[ FD ]
Line_18 $$ int n = Math.min(data.remaining(), bytesPerChecksum)-->Line_19 $$ data.get(buf, 0, n)[ FD ]
Line_16 $$ byte[] buf = new byte[bytesPerChecksum]-->Line_19 $$ data.get(buf, 0, n)[ FD ]
Line_2 $$ public void calculateChunkedSums(ByteBuffer data, ByteBuffer checksums) -->Line_5 $$ if (data.hasArray() && checksums.hasArray()) [ CD ]
Line_2 $$ public void calculateChunkedSums(ByteBuffer data, ByteBuffer checksums) -->Line_13 $$ data.mark()[ CD ]
