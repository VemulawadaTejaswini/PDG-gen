Line_55 $$ if (dataLeft == 0 && pos + bytesToRead >= bytesNeededToFinish) -->Line_56 $$ PacketHeader hdr = new PacketHeader()[ CD ]
Line_56 $$ PacketHeader hdr = new PacketHeader()-->Line_58 $$ if (!hdr.isLastPacketInBlock() || hdr.getDataLen() != 0) [ FD ]
Line_33 $$ if (checksumSize > 0) -->Line_41 $$ bytesToRead = Math.min(dataLeft, len)[ CD ]
Line_37 $$ bytesToRead = Math.min(checksumsToRead * bytesPerChecksum, dataLeft)-->Line_48 $$ IOUtils.readFully(in, buf, offset, bytesToRead)[ FD ]
Line_13 $$ if (dataLeft <= 0) -->Line_22 $$ lastSeqNo = header.getSeqno()[ CD ]
Line_32 $$ int checksumsToRead, bytesToRead-->Line_41 $$ bytesToRead = Math.min(dataLeft, len)[ FD ]
Line_13 $$ if (dataLeft <= 0) -->Line_19 $$ if (!header.sanityCheck(lastSeqNo)) [ CD ]
Line_32 $$ int checksumsToRead, bytesToRead-->Line_63 $$ if (bytesToRead == 0) [ FD ]
Line_33 $$ if (checksumSize > 0) -->Line_42 $$ checksumsToRead = 0[ CD ]
Line_2 $$ protected synchronized int readChunk(long pos, byte[] buf, int offset, int len, byte[] checksumBuf) throws IOException -->Line_63 $$ if (bytesToRead == 0) [ CD ]
Line_44 $$ if (bytesToRead > 0) -->Line_49 $$ checksumBytes.get(checksumBuf, 0, checksumSize * checksumsToRead)[ CD ]
Line_32 $$ int checksumsToRead, bytesToRead-->Line_48 $$ IOUtils.readFully(in, buf, offset, bytesToRead)[ FD ]
Line_2 $$ protected synchronized int readChunk(long pos, byte[] buf, int offset, int len, byte[] checksumBuf) throws IOException -->Line_7 $$ if (lastChunkLen > 0) [ CD ]
Line_7 $$ if (lastChunkLen > 0) -->Line_8 $$ chunkOffset += lastChunkLen[ CD ]
Line_13 $$ if (dataLeft <= 0) -->Line_14 $$ PacketHeader header = new PacketHeader()[ CD ]
Line_33 $$ if (checksumSize > 0) -->Line_34 $$ int chunksLeft = (dataLeft - 1) / bytesPerChecksum + 1[ CD ]
Line_63 $$ if (bytesToRead == 0) -->Line_64 $$ return -1[ CD ]
Line_36 $$ checksumsToRead = Math.min(chunksLeft, chunksCanFit)-->Line_42 $$ checksumsToRead = 0[ FD ]
Line_13 $$ if (dataLeft <= 0) -->Line_15 $$ header.readFields(in)[ CD ]
Line_2 $$ protected synchronized int readChunk(long pos, byte[] buf, int offset, int len, byte[] checksumBuf) throws IOException -->Line_10 $$ if ((pos + firstChunkOffset) != chunkOffset) [ CD ]
Line_44 $$ if (bytesToRead > 0) -->Line_48 $$ IOUtils.readFully(in, buf, offset, bytesToRead)[ CD ]
Line_2 $$ protected synchronized int readChunk(long pos, byte[] buf, int offset, int len, byte[] checksumBuf) throws IOException -->Line_66 $$ return bytesToRead[ CD ]
Line_16 $$ if (LOG.isDebugEnabled()) -->Line_17 $$ LOG.debug("DFSClient readChunk got header " + header)[ CD ]
Line_13 $$ if (dataLeft <= 0) -->Line_23 $$ dataLeft = header.getDataLen()[ CD ]
Line_2 $$ protected synchronized int readChunk(long pos, byte[] buf, int offset, int len, byte[] checksumBuf) throws IOException -->Line_49 $$ checksumBytes.get(checksumBuf, 0, checksumSize * checksumsToRead)[ FD ]
Line_55 $$ if (dataLeft == 0 && pos + bytesToRead >= bytesNeededToFinish) -->Line_58 $$ if (!hdr.isLastPacketInBlock() || hdr.getDataLen() != 0) [ CD ]
Line_41 $$ bytesToRead = Math.min(dataLeft, len)-->Line_63 $$ if (bytesToRead == 0) [ FD ]
Line_41 $$ bytesToRead = Math.min(dataLeft, len)-->Line_48 $$ IOUtils.readFully(in, buf, offset, bytesToRead)[ FD ]
Line_14 $$ PacketHeader header = new PacketHeader()-->Line_22 $$ lastSeqNo = header.getSeqno()[ FD ]
Line_2 $$ protected synchronized int readChunk(long pos, byte[] buf, int offset, int len, byte[] checksumBuf) throws IOException -->Line_33 $$ if (checksumSize > 0) [ CD ]
Line_14 $$ PacketHeader header = new PacketHeader()-->Line_24 $$ adjustChecksumBytes(header.getDataLen())[ FD ]
Line_32 $$ int checksumsToRead, bytesToRead-->Line_36 $$ checksumsToRead = Math.min(chunksLeft, chunksCanFit)[ FD ]
Line_37 $$ bytesToRead = Math.min(checksumsToRead * bytesPerChecksum, dataLeft)-->Line_63 $$ if (bytesToRead == 0) [ FD ]
Line_32 $$ int checksumsToRead, bytesToRead-->Line_44 $$ if (bytesToRead > 0) [ FD ]
Line_2 $$ protected synchronized int readChunk(long pos, byte[] buf, int offset, int len, byte[] checksumBuf) throws IOException -->Line_6 $$ long chunkOffset = lastChunkOffset[ CD ]
Line_34 $$ int chunksLeft = (dataLeft - 1) / bytesPerChecksum + 1-->Line_36 $$ checksumsToRead = Math.min(chunksLeft, chunksCanFit)[ FD ]
Line_13 $$ if (dataLeft <= 0) -->Line_24 $$ adjustChecksumBytes(header.getDataLen())[ CD ]
Line_35 $$ int chunksCanFit = Math.min(len / bytesPerChecksum, checksumBuf.length / checksumSize)-->Line_36 $$ checksumsToRead = Math.min(chunksLeft, chunksCanFit)[ FD ]
Line_32 $$ int checksumsToRead, bytesToRead-->Line_42 $$ checksumsToRead = 0[ FD ]
Line_2 $$ protected synchronized int readChunk(long pos, byte[] buf, int offset, int len, byte[] checksumBuf) throws IOException -->Line_3 $$ if (eos) [ CD ]
Line_14 $$ PacketHeader header = new PacketHeader()-->Line_15 $$ header.readFields(in)[ FD ]
Line_2 $$ protected synchronized int readChunk(long pos, byte[] buf, int offset, int len, byte[] checksumBuf) throws IOException -->Line_13 $$ if (dataLeft <= 0) [ CD ]
Line_14 $$ PacketHeader header = new PacketHeader()-->Line_19 $$ if (!header.sanityCheck(lastSeqNo)) [ FD ]
Line_33 $$ if (checksumSize > 0) -->Line_36 $$ checksumsToRead = Math.min(chunksLeft, chunksCanFit)[ CD ]
Line_14 $$ PacketHeader header = new PacketHeader()-->Line_23 $$ dataLeft = header.getDataLen()[ FD ]
Line_2 $$ protected synchronized int readChunk(long pos, byte[] buf, int offset, int len, byte[] checksumBuf) throws IOException -->Line_44 $$ if (bytesToRead > 0) [ CD ]
Line_2 $$ protected synchronized int readChunk(long pos, byte[] buf, int offset, int len, byte[] checksumBuf) throws IOException -->Line_55 $$ if (dataLeft == 0 && pos + bytesToRead >= bytesNeededToFinish) [ CD ]
Line_55 $$ if (dataLeft == 0 && pos + bytesToRead >= bytesNeededToFinish) -->Line_57 $$ hdr.readFields(in)[ CD ]
Line_13 $$ if (dataLeft <= 0) -->Line_25 $$ if (header.getDataLen() > 0) [ CD ]
Line_3 $$ if (eos) -->Line_4 $$ return -1[ CD ]
Line_37 $$ bytesToRead = Math.min(checksumsToRead * bytesPerChecksum, dataLeft)-->Line_44 $$ if (bytesToRead > 0) [ FD ]
Line_2 $$ protected synchronized int readChunk(long pos, byte[] buf, int offset, int len, byte[] checksumBuf) throws IOException -->Line_32 $$ int checksumsToRead, bytesToRead[ CD ]
Line_6 $$ long chunkOffset = lastChunkOffset-->Line_10 $$ if ((pos + firstChunkOffset) != chunkOffset) [ FD ]
Line_41 $$ bytesToRead = Math.min(dataLeft, len)-->Line_44 $$ if (bytesToRead > 0) [ FD ]
Line_2 $$ protected synchronized int readChunk(long pos, byte[] buf, int offset, int len, byte[] checksumBuf) throws IOException -->Line_48 $$ IOUtils.readFully(in, buf, offset, bytesToRead)[ FD ]
Line_14 $$ PacketHeader header = new PacketHeader()-->Line_25 $$ if (header.getDataLen() > 0) [ FD ]
Line_8 $$ chunkOffset += lastChunkLen-->Line_10 $$ if ((pos + firstChunkOffset) != chunkOffset) [ FD ]
Line_13 $$ if (dataLeft <= 0) -->Line_16 $$ if (LOG.isDebugEnabled()) [ CD ]
Line_56 $$ PacketHeader hdr = new PacketHeader()-->Line_57 $$ hdr.readFields(in)[ FD ]
Line_33 $$ if (checksumSize > 0) -->Line_37 $$ bytesToRead = Math.min(checksumsToRead * bytesPerChecksum, dataLeft)[ CD ]
Line_25 $$ if (header.getDataLen() > 0) -->Line_26 $$ IOUtils.readFully(in, checksumBytes.array(), 0, checksumBytes.limit())[ CD ]
Line_2 $$ protected synchronized int readChunk(long pos, byte[] buf, int offset, int len, byte[] checksumBuf) throws IOException -->Line_41 $$ bytesToRead = Math.min(dataLeft, len)[ FD ]
Line_37 $$ bytesToRead = Math.min(checksumsToRead * bytesPerChecksum, dataLeft)-->Line_41 $$ bytesToRead = Math.min(dataLeft, len)[ FD ]
Line_6 $$ long chunkOffset = lastChunkOffset-->Line_8 $$ chunkOffset += lastChunkLen[ FD ]
Line_33 $$ if (checksumSize > 0) -->Line_35 $$ int chunksCanFit = Math.min(len / bytesPerChecksum, checksumBuf.length / checksumSize)[ CD ]
Line_32 $$ int checksumsToRead, bytesToRead-->Line_37 $$ bytesToRead = Math.min(checksumsToRead * bytesPerChecksum, dataLeft)[ FD ]
