Line_11 $$ in = new DataInputStreamPlus(new LengthAvailableInputStream(new BufferedInputStream(streamFactory.getInputStream(dataPath, crcPath)), dataPath.length()))-->Line_17 $$ String ksname = in.readUTF()[ FD ]
Line_15 $$ ArrayDeque<Future<Pair<K, V>>> futures = new ArrayDeque<Future<Pair<K, V>>>()-->Line_37 $$ while ((future = futures.poll()) != null) [ FD ]
Line_5 $$ File dataPath = getCacheDataPath(CURRENT_VERSION)-->Line_10 $$ logger.info(String.format("reading saved cache %s", dataPath))[ FD ]
Line_36 $$ Future<Pair<K, V>> future = null-->Line_37 $$ while ((future = futures.poll()) != null) [ FD ]
Line_3 $$ int count = 0-->Line_53 $$ logger.trace("completed reading ([ FD ]
Line_52 $$ if (logger.isTraceEnabled())-->Line_53 $$ logger.trace("completed reading ([ CD ]
Line_16 $$ while (in.available() > 0) -->Line_20 $$ Future<Pair<K, V>> entryFuture = cacheLoader.deserialize(in, cfs)[ CD ]
Line_2 $$ public int loadSaved() -->Line_7 $$ if (dataPath.exists() && crcPath.exists()) [ CD ]
Line_26 $$ while (futures.peek() != null && futures.peek().isDone()) -->Line_28 $$ Pair<K, V> entry = future.get()[ CD ]
Line_8 $$ DataInputStreamPlus in = null-->Line_20 $$ Future<Pair<K, V>> entryFuture = cacheLoader.deserialize(in, cfs)[ FD ]
Line_15 $$ ArrayDeque<Future<Pair<K, V>>> futures = new ArrayDeque<Future<Pair<K, V>>>()-->Line_32 $$ if (futures.size() > 1000)[ FD ]
Line_15 $$ ArrayDeque<Future<Pair<K, V>>> futures = new ArrayDeque<Future<Pair<K, V>>>()-->Line_25 $$ do [ FD ]
Line_2 $$ public int loadSaved() -->Line_3 $$ int count = 0[ CD ]
Line_27 $$ Future<Pair<K, V>> future = futures.poll()-->Line_28 $$ Pair<K, V> entry = future.get()[ FD ]
Line_8 $$ DataInputStreamPlus in = null-->Line_49 $$ FileUtils.closeQuietly(in)[ FD ]
Line_8 $$ DataInputStreamPlus in = null-->Line_16 $$ while (in.available() > 0) [ FD ]
Line_2 $$ public int loadSaved() -->Line_54 $$ return count[ CD ]
Line_11 $$ in = new DataInputStreamPlus(new LengthAvailableInputStream(new BufferedInputStream(streamFactory.getInputStream(dataPath, crcPath)), dataPath.length()))-->Line_12 $$ UUID schemaVersion = new UUID(in.readLong(), in.readLong())[ FD ]
Line_6 $$ File crcPath = getCacheCrcPath(CURRENT_VERSION)-->Line_7 $$ if (dataPath.exists() && crcPath.exists()) [ FD ]
Line_8 $$ DataInputStreamPlus in = null-->Line_17 $$ String ksname = in.readUTF()[ FD ]
Line_16 $$ while (in.available() > 0) -->Line_23 $$ futures.offer(entryFuture)[ CD ]
Line_3 $$ int count = 0-->Line_24 $$ count++[ FD ]
Line_5 $$ File dataPath = getCacheDataPath(CURRENT_VERSION)-->Line_11 $$ in = new DataInputStreamPlus(new LengthAvailableInputStream(new BufferedInputStream(streamFactory.getInputStream(dataPath, crcPath)), dataPath.length()))[ FD ]
Line_27 $$ Future<Pair<K, V>> future = futures.poll()-->Line_38 $$ Pair<K, V> entry = future.get()[ FD ]
Line_16 $$ while (in.available() > 0) -->Line_25 $$ do [ CD ]
Line_17 $$ String ksname = in.readUTF()-->Line_19 $$ ColumnFamilyStore cfs = Schema.instance.getColumnFamilyStoreIncludingIndexes(Pair.create(ksname, cfname))[ FD ]
Line_7 $$ if (dataPath.exists() && crcPath.exists()) -->Line_8 $$ DataInputStreamPlus in = null[ CD ]
Line_16 $$ while (in.available() > 0) -->Line_21 $$ if (entryFuture == null)[ CD ]
Line_8 $$ DataInputStreamPlus in = null-->Line_12 $$ UUID schemaVersion = new UUID(in.readLong(), in.readLong())[ FD ]
Line_19 $$ ColumnFamilyStore cfs = Schema.instance.getColumnFamilyStoreIncludingIndexes(Pair.create(ksname, cfname))-->Line_20 $$ Future<Pair<K, V>> entryFuture = cacheLoader.deserialize(in, cfs)[ FD ]
Line_25 $$ do -->Line_26 $$ while (futures.peek() != null && futures.peek().isDone()) [ CD ]
Line_26 $$ while (futures.peek() != null && futures.peek().isDone()) -->Line_27 $$ Future<Pair<K, V>> future = futures.poll()[ CD ]
Line_39 $$ if (entry != null && entry.right != null)-->Line_40 $$ put(entry.left, entry.right)[ CD ]
Line_5 $$ File dataPath = getCacheDataPath(CURRENT_VERSION)-->Line_47 $$ logger.info(String.format("Harmless error reading saved cache %s", dataPath.getAbsolutePath()), t)[ FD ]
Line_6 $$ File crcPath = getCacheCrcPath(CURRENT_VERSION)-->Line_11 $$ in = new DataInputStreamPlus(new LengthAvailableInputStream(new BufferedInputStream(streamFactory.getInputStream(dataPath, crcPath)), dataPath.length()))[ FD ]
Line_16 $$ while (in.available() > 0) -->Line_19 $$ ColumnFamilyStore cfs = Schema.instance.getColumnFamilyStoreIncludingIndexes(Pair.create(ksname, cfname))[ CD ]
Line_2 $$ public int loadSaved() -->Line_5 $$ File dataPath = getCacheDataPath(CURRENT_VERSION)[ CD ]
Line_18 $$ String cfname = in.readUTF()-->Line_19 $$ ColumnFamilyStore cfs = Schema.instance.getColumnFamilyStoreIncludingIndexes(Pair.create(ksname, cfname))[ FD ]
Line_8 $$ DataInputStreamPlus in = null-->Line_11 $$ in = new DataInputStreamPlus(new LengthAvailableInputStream(new BufferedInputStream(streamFactory.getInputStream(dataPath, crcPath)), dataPath.length()))[ FD ]
Line_15 $$ ArrayDeque<Future<Pair<K, V>>> futures = new ArrayDeque<Future<Pair<K, V>>>()-->Line_27 $$ Future<Pair<K, V>> future = futures.poll()[ FD ]
Line_5 $$ File dataPath = getCacheDataPath(CURRENT_VERSION)-->Line_44 $$ logger.warn(String.format("Non-fatal checksum error reading saved cache %s", dataPath.getAbsolutePath()), e)[ FD ]
Line_29 $$ if (entry != null && entry.right != null)-->Line_30 $$ put(entry.left, entry.right)[ CD ]
Line_25 $$ do -->Line_32 $$ if (futures.size() > 1000)[ CD ]
Line_2 $$ public int loadSaved() -->Line_4 $$ long start = System.nanoTime()[ CD ]
Line_5 $$ File dataPath = getCacheDataPath(CURRENT_VERSION)-->Line_7 $$ if (dataPath.exists() && crcPath.exists()) [ FD ]
Line_11 $$ in = new DataInputStreamPlus(new LengthAvailableInputStream(new BufferedInputStream(streamFactory.getInputStream(dataPath, crcPath)), dataPath.length()))-->Line_16 $$ while (in.available() > 0) [ FD ]
Line_11 $$ in = new DataInputStreamPlus(new LengthAvailableInputStream(new BufferedInputStream(streamFactory.getInputStream(dataPath, crcPath)), dataPath.length()))-->Line_18 $$ String cfname = in.readUTF()[ FD ]
Line_27 $$ Future<Pair<K, V>> future = futures.poll()-->Line_37 $$ while ((future = futures.poll()) != null) [ FD ]
Line_2 $$ public int loadSaved() -->Line_52 $$ if (logger.isTraceEnabled())[ CD ]
Line_5 $$ File dataPath = getCacheDataPath(CURRENT_VERSION)-->Line_53 $$ logger.trace("completed reading ([ FD ]
Line_12 $$ UUID schemaVersion = new UUID(in.readLong(), in.readLong())-->Line_14 $$ throw new RuntimeException("Cache schema version " + schemaVersion.toString() + " does not match current schema version " + Schema.instance.getVersion())[ FD ]
Line_11 $$ in = new DataInputStreamPlus(new LengthAvailableInputStream(new BufferedInputStream(streamFactory.getInputStream(dataPath, crcPath)), dataPath.length()))-->Line_49 $$ FileUtils.closeQuietly(in)[ FD ]
Line_32 $$ if (futures.size() > 1000)-->Line_33 $$ Thread.yield()[ CD ]
Line_15 $$ ArrayDeque<Future<Pair<K, V>>> futures = new ArrayDeque<Future<Pair<K, V>>>()-->Line_26 $$ while (futures.peek() != null && futures.peek().isDone()) [ FD ]
Line_11 $$ in = new DataInputStreamPlus(new LengthAvailableInputStream(new BufferedInputStream(streamFactory.getInputStream(dataPath, crcPath)), dataPath.length()))-->Line_20 $$ Future<Pair<K, V>> entryFuture = cacheLoader.deserialize(in, cfs)[ FD ]
Line_15 $$ ArrayDeque<Future<Pair<K, V>>> futures = new ArrayDeque<Future<Pair<K, V>>>()-->Line_23 $$ futures.offer(entryFuture)[ FD ]
Line_37 $$ while ((future = futures.poll()) != null) -->Line_38 $$ Pair<K, V> entry = future.get()[ CD ]
Line_37 $$ while ((future = futures.poll()) != null) -->Line_38 $$ Pair<K, V> entry = future.get()[ FD ]
Line_8 $$ DataInputStreamPlus in = null-->Line_18 $$ String cfname = in.readUTF()[ FD ]
Line_36 $$ Future<Pair<K, V>> future = null-->Line_38 $$ Pair<K, V> entry = future.get()[ FD ]
Line_12 $$ UUID schemaVersion = new UUID(in.readLong(), in.readLong())-->Line_13 $$ if (!schemaVersion.equals(Schema.instance.getVersion()))[ FD ]
Line_37 $$ while ((future = futures.poll()) != null) -->Line_39 $$ if (entry != null && entry.right != null)[ CD ]
Line_26 $$ while (futures.peek() != null && futures.peek().isDone()) -->Line_29 $$ if (entry != null && entry.right != null)[ CD ]
Line_16 $$ while (in.available() > 0) -->Line_18 $$ String cfname = in.readUTF()[ CD ]
Line_20 $$ Future<Pair<K, V>> entryFuture = cacheLoader.deserialize(in, cfs)-->Line_21 $$ if (entryFuture == null)[ FD ]
Line_2 $$ public int loadSaved() -->Line_6 $$ File crcPath = getCacheCrcPath(CURRENT_VERSION)[ CD ]
Line_20 $$ Future<Pair<K, V>> entryFuture = cacheLoader.deserialize(in, cfs)-->Line_23 $$ futures.offer(entryFuture)[ FD ]
Line_16 $$ while (in.available() > 0) -->Line_17 $$ String ksname = in.readUTF()[ CD ]
Line_16 $$ while (in.available() > 0) -->Line_24 $$ count++[ CD ]
