Line_13 $$ PriorityQueue<Sidetracks<Node>> queue = new PriorityQueue<Sidetracks<Node>>()-->Line_33 $$ queue.add(new Sidetracks<Node>(current.myLength - e.myEdge.getDelta() + child.myEdge.getDelta(), current.myEdges.getTail().prepend(child)))[ FD ]
Line_27 $$ if (next != null) -->Line_28 $$ final HeapNode<Node> f = next.getRoot()[ CD ]
Line_16 $$ final Heap<Node> heap = myHeaps.get(myStart)-->Line_17 $$ if (heap != null) [ FD ]
Line_13 $$ PriorityQueue<Sidetracks<Node>> queue = new PriorityQueue<Sidetracks<Node>>()-->Line_20 $$ if (queue.isEmpty())[ FD ]
Line_2 $$ public List<List<Node>> findShortestPaths(int k) -->Line_19 $$ for (int i = 2; i <= k; i++) [ FD ]
Line_14 $$ List<FList<HeapNode<Node>>> sidetracks = new ArrayList<FList<HeapNode<Node>>>()-->Line_24 $$ sidetracks.add(current.myEdges)[ FD ]
Line_4 $$ if (myStart.equals(myFinish)) -->Line_5 $$ return Collections.singletonList(Collections.singletonList(myStart))[ CD ]
Line_13 $$ PriorityQueue<Sidetracks<Node>> queue = new PriorityQueue<Sidetracks<Node>>()-->Line_18 $$ queue.add(new Sidetracks<Node>(0, FList.<HeapNode<Node>>emptyList().prepend(heap.getRoot())))[ FD ]
Line_13 $$ PriorityQueue<Sidetracks<Node>> queue = new PriorityQueue<Sidetracks<Node>>()-->Line_29 $$ queue.add(new Sidetracks<Node>(current.myLength + f.myEdge.getDelta(), current.myEdges.prepend(f)))[ FD ]
Line_26 $$ final Heap<Node> next = myHeaps.get(e.myEdge.getFinish())-->Line_27 $$ if (next != null) [ FD ]
Line_19 $$ for (int i = 2; i <= k; i++) -->Line_27 $$ if (next != null) [ CD ]
Line_19 $$ for (int i = 2; i <= k; i++) -->Line_24 $$ sidetracks.add(current.myEdges)[ CD ]
Line_31 $$ for (HeapNode<Node> child : e.myChildren) -->Line_33 $$ queue.add(new Sidetracks<Node>(current.myLength - e.myEdge.getDelta() + child.myEdge.getDelta(), current.myEdges.getTail().prepend(child)))[ FD ]
Line_14 $$ List<FList<HeapNode<Node>>> sidetracks = new ArrayList<FList<HeapNode<Node>>>()-->Line_38 $$ return computePathsBySidetracks(sidetracks)[ FD ]
Line_27 $$ if (next != null) -->Line_29 $$ queue.add(new Sidetracks<Node>(current.myLength + f.myEdge.getDelta(), current.myEdges.prepend(f)))[ CD ]
Line_17 $$ if (heap != null) -->Line_18 $$ queue.add(new Sidetracks<Node>(0, FList.<HeapNode<Node>>emptyList().prepend(heap.getRoot())))[ CD ]
Line_13 $$ PriorityQueue<Sidetracks<Node>> queue = new PriorityQueue<Sidetracks<Node>>()-->Line_23 $$ final Sidetracks<Node> current = queue.remove()[ FD ]
Line_19 $$ for (int i = 2; i <= k; i++) -->Line_20 $$ if (queue.isEmpty())[ CD ]
Line_17 $$ if (heap != null) -->Line_19 $$ for (int i = 2; i <= k; i++) [ CD ]
Line_8 $$ if (!myNextNodes.containsKey(myStart)) -->Line_9 $$ return Collections.emptyList()[ CD ]
Line_19 $$ for (int i = 2; i <= k; i++) -->Line_25 $$ final HeapNode<Node> e = current.myEdges.getHead()[ CD ]
Line_28 $$ final HeapNode<Node> f = next.getRoot()-->Line_29 $$ queue.add(new Sidetracks<Node>(current.myLength + f.myEdge.getDelta(), current.myEdges.prepend(f)))[ FD ]
Line_19 $$ for (int i = 2; i <= k; i++) -->Line_23 $$ final Sidetracks<Node> current = queue.remove()[ CD ]
Line_14 $$ List<FList<HeapNode<Node>>> sidetracks = new ArrayList<FList<HeapNode<Node>>>()-->Line_15 $$ sidetracks.add(FList.<HeapNode<Node>>emptyList())[ FD ]
Line_26 $$ final Heap<Node> next = myHeaps.get(e.myEdge.getFinish())-->Line_28 $$ final HeapNode<Node> f = next.getRoot()[ FD ]
Line_31 $$ for (HeapNode<Node> child : e.myChildren) -->Line_32 $$ if (child != null) [ FD ]
Line_19 $$ for (int i = 2; i <= k; i++) -->Line_26 $$ final Heap<Node> next = myHeaps.get(e.myEdge.getFinish())[ CD ]
Line_32 $$ if (child != null) -->Line_33 $$ queue.add(new Sidetracks<Node>(current.myLength - e.myEdge.getDelta() + child.myEdge.getDelta(), current.myEdges.getTail().prepend(child)))[ CD ]
Line_16 $$ final Heap<Node> heap = myHeaps.get(myStart)-->Line_18 $$ queue.add(new Sidetracks<Node>(0, FList.<HeapNode<Node>>emptyList().prepend(heap.getRoot())))[ FD ]
Line_19 $$ for (int i = 2; i <= k; i++) -->Line_22 $$ myProgressIndicator.checkCanceled()[ CD ]
