Line_7 $$ final LiteralTextEscaper<? extends PsiLanguageInjectionHost> textEscaper = ((PsiLanguageInjectionHost) element).createLiteralTextEscaper()-->Line_9 $$ textEscaper.decode(textRange, sb)[ FD ]
Line_10 $$ final List<TextRange> ranges = getMatchingRanges(myCompiledValuePattern.matcher(StringPattern.newBombedCharSequence(sb)), sb.length())-->Line_11 $$ return !ranges.isEmpty() ? ContainerUtil.map(ranges, new Function<TextRange, TextRange>() [ FD ]
Line_3 $$ final TextRange textRange = ElementManipulators.getValueTextRange(element)-->Line_9 $$ textEscaper.decode(textRange, sb)[ FD ]
Line_3 $$ final TextRange textRange = ElementManipulators.getValueTextRange(element)-->Line_13 $$ return new TextRange(textEscaper.getOffsetInHost(s.getStartOffset(), textRange), textEscaper.getOffsetInHost(s.getEndOffset(), textRange))[ FD ]
Line_4 $$ if (myCompiledValuePattern == null) -->Line_5 $$ return Collections.singletonList(textRange)[ CD ]
Line_2 $$ public List<TextRange> getInjectedArea(final PsiElement element) -->Line_4 $$ if (myCompiledValuePattern == null) [ CD ]
Line_2 $$ public List<TextRange> getInjectedArea(final PsiElement element) -->Line_3 $$ final TextRange textRange = ElementManipulators.getValueTextRange(element)[ FD ]
Line_8 $$ final StringBuilder sb = new StringBuilder()-->Line_9 $$ textEscaper.decode(textRange, sb)[ FD ]
Line_4 $$ if (myCompiledValuePattern == null) -->Line_10 $$ final List<TextRange> ranges = getMatchingRanges(myCompiledValuePattern.matcher(StringPattern.newBombedCharSequence(sb)), sb.length())[ CD ]
Line_2 $$ public List<TextRange> getInjectedArea(final PsiElement element) -->Line_3 $$ final TextRange textRange = ElementManipulators.getValueTextRange(element)[ CD ]
Line_3 $$ final TextRange textRange = ElementManipulators.getValueTextRange(element)-->Line_5 $$ return Collections.singletonList(textRange)[ FD ]
Line_4 $$ if (myCompiledValuePattern == null) -->Line_9 $$ textEscaper.decode(textRange, sb)[ CD ]
Line_4 $$ if (myCompiledValuePattern == null) -->Line_8 $$ final StringBuilder sb = new StringBuilder()[ CD ]
Line_11 $$ return !ranges.isEmpty() ? ContainerUtil.map(ranges, new Function<TextRange, TextRange>() -->Line_13 $$ return new TextRange(textEscaper.getOffsetInHost(s.getStartOffset(), textRange), textEscaper.getOffsetInHost(s.getEndOffset(), textRange))[ FD ]
Line_4 $$ if (myCompiledValuePattern == null) -->Line_7 $$ final LiteralTextEscaper<? extends PsiLanguageInjectionHost> textEscaper = ((PsiLanguageInjectionHost) element).createLiteralTextEscaper()[ CD ]
Line_7 $$ final LiteralTextEscaper<? extends PsiLanguageInjectionHost> textEscaper = ((PsiLanguageInjectionHost) element).createLiteralTextEscaper()-->Line_13 $$ return new TextRange(textEscaper.getOffsetInHost(s.getStartOffset(), textRange), textEscaper.getOffsetInHost(s.getEndOffset(), textRange))[ FD ]
Line_11 $$ return !ranges.isEmpty() ? ContainerUtil.map(ranges, new Function<TextRange, TextRange>() -->Line_13 $$ return new TextRange(textEscaper.getOffsetInHost(s.getStartOffset(), textRange), textEscaper.getOffsetInHost(s.getEndOffset(), textRange))[ CD ]
Line_8 $$ final StringBuilder sb = new StringBuilder()-->Line_10 $$ final List<TextRange> ranges = getMatchingRanges(myCompiledValuePattern.matcher(StringPattern.newBombedCharSequence(sb)), sb.length())[ FD ]
Line_4 $$ if (myCompiledValuePattern == null) -->Line_11 $$ return !ranges.isEmpty() ? ContainerUtil.map(ranges, new Function<TextRange, TextRange>() [ CD ]
