Line_14 $$ ChunkBuildOutputConsumerImpl outputConsumer = new ChunkBuildOutputConsumerImpl(context)-->Line_50 $$ final ModuleLevelBuilder.ExitCode buildResult = builder.build(context, chunk, dirtyFilesHolder, outputConsumer)[ FD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_8 $$ boolean doneSomething = false[ CD ]
Line_59 $$ if (buildResult == ModuleLevelBuilder.ExitCode.CHUNK_REBUILD_REQUIRED) -->Line_60 $$ if (!rebuildFromScratchRequested && !JavaBuilderUtil.isForcedRecompilationAllJavaModules(context)) [ CD ]
Line_28 $$ final Set<File> files = entry.getValue()-->Line_29 $$ if (!files.isEmpty()) [ FD ]
Line_4 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) -->Line_50 $$ final ModuleLevelBuilder.ExitCode buildResult = builder.build(context, chunk, dirtyFilesHolder, outputConsumer)[ FD ]
Line_17 $$ nextPassRequired = false-->Line_87 $$ if (nextPassRequired && !rebuildFromScratchRequested) [ FD ]
Line_3 $$ for (BuilderCategory category : BuilderCategory.values()) -->Line_4 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) [ FD ]
Line_50 $$ final ModuleLevelBuilder.ExitCode buildResult = builder.build(context, chunk, dirtyFilesHolder, outputConsumer)-->Line_57 $$ if (buildResult == ModuleLevelBuilder.ExitCode.ADDITIONAL_PASS_REQUIRED) [ FD ]
Line_19 $$ DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder = new DirtyFilesHolderBase<JavaSourceRootDescriptor, ModuleBuildTarget>(context) -->Line_50 $$ final ModuleLevelBuilder.ExitCode buildResult = builder.build(context, chunk, dirtyFilesHolder, outputConsumer)[ FD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_10 $$ float stageCount = myTotalModuleLevelBuilderCount[ CD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_64 $$ context.getProjectDescriptor().fsState.clearContextRoundData(context)[ FD ]
Line_14 $$ ChunkBuildOutputConsumerImpl outputConsumer = new ChunkBuildOutputConsumerImpl(context)-->Line_70 $$ outputConsumer.clear()[ FD ]
Line_4 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) -->Line_54 $$ throw new StopBuildException("Builder " + builder.getPresentableName() + " requested build stop")[ FD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_83 $$ final boolean moreToCompile = JavaBuilderUtil.updateMappingsOnRoundCompletion(context, dirtyFilesHolder, chunk)[ FD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_80 $$ updateDoneFraction(context, modulesInChunk / (stageCount))[ FD ]
Line_60 $$ if (!rebuildFromScratchRequested && !JavaBuilderUtil.isForcedRecompilationAllJavaModules(context)) -->Line_61 $$ LOG.info("Builder " + builder.getPresentableName() + " requested rebuild of module chunk " + chunk.getName())[ CD ]
Line_3 $$ for (BuilderCategory category : BuilderCategory.values()) -->Line_100 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) [ FD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_12 $$ int buildersPassed = 0[ CD ]
Line_3 $$ for (BuilderCategory category : BuilderCategory.values()) -->Line_39 $$ if (category == BuilderCategory.CLASS_POST_PROCESSOR) [ FD ]
Line_46 $$ for (ModuleLevelBuilder builder : builders) -->Line_50 $$ final ModuleLevelBuilder.ExitCode buildResult = builder.build(context, chunk, dirtyFilesHolder, outputConsumer)[ FD ]
Line_19 $$ DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder = new DirtyFilesHolderBase<JavaSourceRootDescriptor, ModuleBuildTarget>(context) -->Line_21 $$ FSOperations.processFilesToRecompile(context, chunk, processor)[ FD ]
Line_37 $$ for (BuilderCategory category : BuilderCategory.values()) -->Line_100 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) [ FD ]
Line_46 $$ for (ModuleLevelBuilder builder : builders) -->Line_54 $$ throw new StopBuildException("Builder " + builder.getPresentableName() + " requested build stop")[ FD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_30 $$ final SourceToOutputMapping mapping = context.getProjectDescriptor().dataManager.getSourceToOutputMap(target)[ FD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_25 $$ final Map<ModuleBuildTarget, Set<File>> cleanedSources = BuildOperations.cleanOutputsCorrespondingToChangedFiles(context, dirtyFilesHolder)[ FD ]
Line_4 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) -->Line_61 $$ LOG.info("Builder " + builder.getPresentableName() + " requested rebuild of module chunk " + chunk.getName())[ FD ]
Line_29 $$ if (!files.isEmpty()) -->Line_30 $$ final SourceToOutputMapping mapping = context.getProjectDescriptor().dataManager.getSourceToOutputMap(target)[ CD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_21 $$ FSOperations.processFilesToRecompile(context, chunk, processor)[ FD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_61 $$ LOG.info("Builder " + builder.getPresentableName() + " requested rebuild of module chunk " + chunk.getName())[ FD ]
Line_14 $$ ChunkBuildOutputConsumerImpl outputConsumer = new ChunkBuildOutputConsumerImpl(context)-->Line_97 $$ outputConsumer.fireFileGeneratedEvents()[ FD ]
Line_50 $$ final ModuleLevelBuilder.ExitCode buildResult = builder.build(context, chunk, dirtyFilesHolder, outputConsumer)-->Line_59 $$ if (buildResult == ModuleLevelBuilder.ExitCode.CHUNK_REBUILD_REQUIRED) [ FD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_50 $$ final ModuleLevelBuilder.ExitCode buildResult = builder.build(context, chunk, dirtyFilesHolder, outputConsumer)[ FD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_60 $$ if (!rebuildFromScratchRequested && !JavaBuilderUtil.isForcedRecompilationAllJavaModules(context)) [ FD ]
Line_27 $$ final ModuleBuildTarget target = entry.getKey()-->Line_30 $$ final SourceToOutputMapping mapping = context.getProjectDescriptor().dataManager.getSourceToOutputMap(target)[ FD ]
Line_14 $$ ChunkBuildOutputConsumerImpl outputConsumer = new ChunkBuildOutputConsumerImpl(context)-->Line_40 $$ saveInstrumentedClasses(outputConsumer)[ FD ]
Line_19 $$ DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder = new DirtyFilesHolderBase<JavaSourceRootDescriptor, ModuleBuildTarget>(context) -->Line_25 $$ final Map<ModuleBuildTarget, Set<File>> cleanedSources = BuildOperations.cleanOutputsCorrespondingToChangedFiles(context, dirtyFilesHolder)[ FD ]
Line_46 $$ for (ModuleLevelBuilder builder : builders) -->Line_51 $$ storeBuilderStatistics(builder, System.nanoTime() - start, outputConsumer.getNumberOfProcessedSources() - processedSourcesBefore)[ FD ]
Line_16 $$ do -->Line_18 $$ myProjectDescriptor.fsState.beforeNextRoundStart(context, chunk)[ CD ]
Line_14 $$ ChunkBuildOutputConsumerImpl outputConsumer = new ChunkBuildOutputConsumerImpl(context)-->Line_49 $$ int processedSourcesBefore = outputConsumer.getNumberOfProcessedSources()[ FD ]
Line_38 $$ final List<ModuleLevelBuilder> builders = myBuilderRegistry.getBuilders(category)-->Line_42 $$ if (builders.isEmpty()) [ FD ]
Line_25 $$ final Map<ModuleBuildTarget, Set<File>> cleanedSources = BuildOperations.cleanOutputsCorrespondingToChangedFiles(context, dirtyFilesHolder)-->Line_26 $$ for (Map.Entry<ModuleBuildTarget, Set<File>> entry : cleanedSources.entrySet()) [ FD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_65 $$ FSOperations.markDirty(context, CompilationRound.NEXT, chunk, null)[ FD ]
Line_26 $$ for (Map.Entry<ModuleBuildTarget, Set<File>> entry : cleanedSources.entrySet()) -->Line_27 $$ final ModuleBuildTarget target = entry.getKey()[ FD ]
Line_16 $$ do -->Line_24 $$ if (!JavaBuilderUtil.isForcedRecompilationAllJavaModules(context)) [ CD ]
Line_3 $$ for (BuilderCategory category : BuilderCategory.values()) -->Line_38 $$ final List<ModuleLevelBuilder> builders = myBuilderRegistry.getBuilders(category)[ FD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_11 $$ final int modulesInChunk = chunk.getModules().size()[ FD ]
Line_24 $$ if (!JavaBuilderUtil.isForcedRecompilationAllJavaModules(context)) -->Line_25 $$ final Map<ModuleBuildTarget, Set<File>> cleanedSources = BuildOperations.cleanOutputsCorrespondingToChangedFiles(context, dirtyFilesHolder)[ CD ]
Line_19 $$ DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder = new DirtyFilesHolderBase<JavaSourceRootDescriptor, ModuleBuildTarget>(context) -->Line_21 $$ FSOperations.processFilesToRecompile(context, chunk, processor)[ CD ]
Line_39 $$ if (category == BuilderCategory.CLASS_POST_PROCESSOR) -->Line_40 $$ saveInstrumentedClasses(outputConsumer)[ CD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_47 $$ processDeletedPaths(context, chunk.getTargets())[ FD ]
Line_14 $$ ChunkBuildOutputConsumerImpl outputConsumer = new ChunkBuildOutputConsumerImpl(context)-->Line_51 $$ storeBuilderStatistics(builder, System.nanoTime() - start, outputConsumer.getNumberOfProcessedSources() - processedSourcesBefore)[ FD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_11 $$ final int modulesInChunk = chunk.getModules().size()[ CD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_5 $$ builder.chunkBuildStarted(context, chunk)[ FD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_14 $$ ChunkBuildOutputConsumerImpl outputConsumer = new ChunkBuildOutputConsumerImpl(context)[ CD ]
Line_4 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) -->Line_51 $$ storeBuilderStatistics(builder, System.nanoTime() - start, outputConsumer.getNumberOfProcessedSources() - processedSourcesBefore)[ FD ]
Line_13 $$ boolean nextPassRequired-->Line_17 $$ nextPassRequired = false[ FD ]
Line_4 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) -->Line_5 $$ builder.chunkBuildStarted(context, chunk)[ FD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_24 $$ if (!JavaBuilderUtil.isForcedRecompilationAllJavaModules(context)) [ FD ]
Line_14 $$ ChunkBuildOutputConsumerImpl outputConsumer = new ChunkBuildOutputConsumerImpl(context)-->Line_96 $$ saveInstrumentedClasses(outputConsumer)[ FD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_18 $$ myProjectDescriptor.fsState.beforeNextRoundStart(context, chunk)[ FD ]
Line_37 $$ for (BuilderCategory category : BuilderCategory.values()) -->Line_38 $$ final List<ModuleLevelBuilder> builders = myBuilderRegistry.getBuilders(category)[ FD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_105 $$ return doneSomething[ CD ]
Line_60 $$ if (!rebuildFromScratchRequested && !JavaBuilderUtil.isForcedRecompilationAllJavaModules(context)) -->Line_76 $$ LOG.debug("Builder " + builder.getPresentableName() + " requested second chunk rebuild")[ CD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_13 $$ boolean nextPassRequired[ CD ]
Line_46 $$ for (ModuleLevelBuilder builder : builders) -->Line_76 $$ LOG.debug("Builder " + builder.getPresentableName() + " requested second chunk rebuild")[ FD ]
Line_37 $$ for (BuilderCategory category : BuilderCategory.values()) -->Line_39 $$ if (category == BuilderCategory.CLASS_POST_PROCESSOR) [ FD ]
Line_19 $$ DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder = new DirtyFilesHolderBase<JavaSourceRootDescriptor, ModuleBuildTarget>(context) -->Line_83 $$ final boolean moreToCompile = JavaBuilderUtil.updateMappingsOnRoundCompletion(context, dirtyFilesHolder, chunk)[ FD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_101 $$ builder.chunkBuildFinished(context, chunk)[ FD ]
Line_46 $$ for (ModuleLevelBuilder builder : builders) -->Line_61 $$ LOG.info("Builder " + builder.getPresentableName() + " requested rebuild of module chunk " + chunk.getName())[ FD ]
Line_4 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) -->Line_101 $$ builder.chunkBuildFinished(context, chunk)[ FD ]
Line_31 $$ for (File srcFile : files) -->Line_32 $$ mapping.setOutputs(srcFile.getPath(), Collections.<String>emptyList())[ FD ]
Line_16 $$ do -->Line_19 $$ DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder = new DirtyFilesHolderBase<JavaSourceRootDescriptor, ModuleBuildTarget>(context) [ CD ]
Line_16 $$ do -->Line_17 $$ nextPassRequired = false[ CD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_56 $$ context.checkCanceled()[ FD ]
Line_14 $$ ChunkBuildOutputConsumerImpl outputConsumer = new ChunkBuildOutputConsumerImpl(context)-->Line_98 $$ outputConsumer.clear()[ FD ]
Line_50 $$ final ModuleLevelBuilder.ExitCode buildResult = builder.build(context, chunk, dirtyFilesHolder, outputConsumer)-->Line_53 $$ if (buildResult == ModuleLevelBuilder.ExitCode.ABORT) [ FD ]
Line_26 $$ for (Map.Entry<ModuleBuildTarget, Set<File>> entry : cleanedSources.entrySet()) -->Line_28 $$ final Set<File> files = entry.getValue()[ FD ]
Line_57 $$ if (buildResult == ModuleLevelBuilder.ExitCode.ADDITIONAL_PASS_REQUIRED) -->Line_59 $$ if (buildResult == ModuleLevelBuilder.ExitCode.CHUNK_REBUILD_REQUIRED) [ CD ]
Line_13 $$ boolean nextPassRequired-->Line_87 $$ if (nextPassRequired && !rebuildFromScratchRequested) [ FD ]
Line_2 $$ private boolean runModuleLevelBuilders(final CompileContext context, final ModuleChunk chunk) throws ProjectBuildException, IOException -->Line_9 $$ boolean rebuildFromScratchRequested = false[ CD ]
Line_46 $$ for (ModuleLevelBuilder builder : builders) -->Line_101 $$ builder.chunkBuildFinished(context, chunk)[ FD ]
Line_4 $$ for (ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) -->Line_76 $$ LOG.debug("Builder " + builder.getPresentableName() + " requested second chunk rebuild")[ FD ]
Line_30 $$ final SourceToOutputMapping mapping = context.getProjectDescriptor().dataManager.getSourceToOutputMap(target)-->Line_32 $$ mapping.setOutputs(srcFile.getPath(), Collections.<String>emptyList())[ FD ]
