Line_2 $$ public Collection<ClassObject> compileJavaCode(List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, File outputDir) throws IOException, CompilationException -->Line_6 $$ final SdkTypeId type = sdk.getSdkType()[ CD ]
Line_2 $$ public Collection<ClassObject> compileJavaCode(List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, File outputDir) throws IOException, CompilationException -->Line_16 $$ if (!sourcePath.isEmpty()) [ FD ]
Line_40 $$ final List<ClassObject> result = new ArrayList<ClassObject>()-->Line_43 $$ result.add(new CompiledClass(fileObject.getName(), fileObject.getClassName(), content != null ? content.toByteArray() : null))[ FD ]
Line_2 $$ public Collection<ClassObject> compileJavaCode(List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, File outputDir) throws IOException, CompilationException -->Line_7 $$ if (type instanceof JavaSdkType) [ CD ]
Line_4 $$ String javaHome = null-->Line_8 $$ javaHome = sdk.getHomePath()[ FD ]
Line_31 $$ if (!compiledOk) -->Line_32 $$ final List<CompilationException.Message> messages = new SmartList<CompilationException.Message>()[ CD ]
Line_35 $$ final URI uri = source != null ? source.toUri() : null-->Line_36 $$ messages.add(new CompilationException.Message(kindToCategory(d.getKind()), d.getMessage(Locale.US), uri != null ? uri.toURL().toString() : null, (int) d.getLineNumber(), (int) d.getColumnNumber()))[ FD ]
Line_15 $$ final Set<File> sourceRoots = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_28 $$ final Map<File, Set<File>> outs = Collections.singletonMap(outputDir, sourceRoots)[ FD ]
Line_34 $$ final JavaFileObject source = d.getSource()-->Line_35 $$ final URI uri = source != null ? source.toUri() : null[ FD ]
Line_41 $$ for (OutputFileObject fileObject : outputCollector.getCompiledClasses()) -->Line_43 $$ result.add(new CompiledClass(fileObject.getName(), fileObject.getClassName(), content != null ? content.toByteArray() : null))[ FD ]
Line_42 $$ final BinaryContent content = fileObject.getContent()-->Line_43 $$ result.add(new CompiledClass(fileObject.getName(), fileObject.getClassName(), content != null ? content.toByteArray() : null))[ FD ]
Line_2 $$ public Collection<ClassObject> compileJavaCode(List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, File outputDir) throws IOException, CompilationException -->Line_28 $$ final Map<File, Set<File>> outs = Collections.singletonMap(outputDir, sourceRoots)[ CD ]
Line_29 $$ final ExternalJavacManager javacManager = getJavacManager()-->Line_30 $$ boolean compiledOk = javacManager != null && javacManager.forkJavac(javaHome, -1, Collections.<String>emptyList(), options, platformCp, classpath, sourcePath, files, outs, diagnostic, outputCollector, new JavacCompilerTool(), CanceledStatus.NULL)[ FD ]
Line_2 $$ public Collection<ClassObject> compileJavaCode(List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, File outputDir) throws IOException, CompilationException -->Line_3 $$ final Pair<Sdk, JavaSdkVersion> runtime = BuildManager.getBuildProcessRuntimeSdk(myProject)[ CD ]
Line_22 $$ final File parentFile = file.getParentFile()-->Line_24 $$ sourceRoots.add(parentFile)[ FD ]
Line_15 $$ final Set<File> sourceRoots = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_18 $$ sourceRoots.add(file)[ FD ]
Line_2 $$ public Collection<ClassObject> compileJavaCode(List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, File outputDir) throws IOException, CompilationException -->Line_31 $$ if (!compiledOk) [ CD ]
Line_22 $$ final File parentFile = file.getParentFile()-->Line_23 $$ if (parentFile != null) [ FD ]
Line_13 $$ final OutputCollector outputCollector = new OutputCollector()-->Line_30 $$ boolean compiledOk = javacManager != null && javacManager.forkJavac(javaHome, -1, Collections.<String>emptyList(), options, platformCp, classpath, sourcePath, files, outs, diagnostic, outputCollector, new JavacCompilerTool(), CanceledStatus.NULL)[ FD ]
Line_13 $$ final OutputCollector outputCollector = new OutputCollector()-->Line_41 $$ for (OutputFileObject fileObject : outputCollector.getCompiledClasses()) [ FD ]
Line_14 $$ DiagnosticCollector diagnostic = new DiagnosticCollector()-->Line_33 $$ for (Diagnostic<? extends JavaFileObject> d : diagnostic.getDiagnostics()) [ FD ]
Line_32 $$ final List<CompilationException.Message> messages = new SmartList<CompilationException.Message>()-->Line_36 $$ messages.add(new CompilationException.Message(kindToCategory(d.getKind()), d.getMessage(Locale.US), uri != null ? uri.toURL().toString() : null, (int) d.getLineNumber(), (int) d.getColumnNumber()))[ FD ]
Line_33 $$ for (Diagnostic<? extends JavaFileObject> d : diagnostic.getDiagnostics()) -->Line_36 $$ messages.add(new CompilationException.Message(kindToCategory(d.getKind()), d.getMessage(Locale.US), uri != null ? uri.toURL().toString() : null, (int) d.getLineNumber(), (int) d.getColumnNumber()))[ FD ]
Line_41 $$ for (OutputFileObject fileObject : outputCollector.getCompiledClasses()) -->Line_42 $$ final BinaryContent content = fileObject.getContent()[ FD ]
Line_5 $$ final Sdk sdk = runtime.getFirst()-->Line_8 $$ javaHome = sdk.getHomePath()[ FD ]
Line_14 $$ DiagnosticCollector diagnostic = new DiagnosticCollector()-->Line_30 $$ boolean compiledOk = javacManager != null && javacManager.forkJavac(javaHome, -1, Collections.<String>emptyList(), options, platformCp, classpath, sourcePath, files, outs, diagnostic, outputCollector, new JavacCompilerTool(), CanceledStatus.NULL)[ FD ]
Line_30 $$ boolean compiledOk = javacManager != null && javacManager.forkJavac(javaHome, -1, Collections.<String>emptyList(), options, platformCp, classpath, sourcePath, files, outs, diagnostic, outputCollector, new JavacCompilerTool(), CanceledStatus.NULL)-->Line_31 $$ if (!compiledOk) [ FD ]
Line_2 $$ public Collection<ClassObject> compileJavaCode(List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, File outputDir) throws IOException, CompilationException -->Line_29 $$ final ExternalJavacManager javacManager = getJavacManager()[ CD ]
Line_7 $$ if (type instanceof JavaSdkType) -->Line_8 $$ javaHome = sdk.getHomePath()[ CD ]
Line_28 $$ final Map<File, Set<File>> outs = Collections.singletonMap(outputDir, sourceRoots)-->Line_30 $$ boolean compiledOk = javacManager != null && javacManager.forkJavac(javaHome, -1, Collections.<String>emptyList(), options, platformCp, classpath, sourcePath, files, outs, diagnostic, outputCollector, new JavacCompilerTool(), CanceledStatus.NULL)[ FD ]
Line_6 $$ final SdkTypeId type = sdk.getSdkType()-->Line_7 $$ if (type instanceof JavaSdkType) [ FD ]
Line_2 $$ public Collection<ClassObject> compileJavaCode(List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, File outputDir) throws IOException, CompilationException -->Line_30 $$ boolean compiledOk = javacManager != null && javacManager.forkJavac(javaHome, -1, Collections.<String>emptyList(), options, platformCp, classpath, sourcePath, files, outs, diagnostic, outputCollector, new JavacCompilerTool(), CanceledStatus.NULL)[ FD ]
Line_2 $$ public Collection<ClassObject> compileJavaCode(List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, File outputDir) throws IOException, CompilationException -->Line_40 $$ final List<ClassObject> result = new ArrayList<ClassObject>()[ CD ]
Line_2 $$ public Collection<ClassObject> compileJavaCode(List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, File outputDir) throws IOException, CompilationException -->Line_13 $$ final OutputCollector outputCollector = new OutputCollector()[ CD ]
Line_2 $$ public Collection<ClassObject> compileJavaCode(List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, File outputDir) throws IOException, CompilationException -->Line_28 $$ final Map<File, Set<File>> outs = Collections.singletonMap(outputDir, sourceRoots)[ FD ]
Line_8 $$ javaHome = sdk.getHomePath()-->Line_30 $$ boolean compiledOk = javacManager != null && javacManager.forkJavac(javaHome, -1, Collections.<String>emptyList(), options, platformCp, classpath, sourcePath, files, outs, diagnostic, outputCollector, new JavacCompilerTool(), CanceledStatus.NULL)[ FD ]
Line_4 $$ String javaHome = null-->Line_30 $$ boolean compiledOk = javacManager != null && javacManager.forkJavac(javaHome, -1, Collections.<String>emptyList(), options, platformCp, classpath, sourcePath, files, outs, diagnostic, outputCollector, new JavacCompilerTool(), CanceledStatus.NULL)[ FD ]
Line_2 $$ public Collection<ClassObject> compileJavaCode(List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, File outputDir) throws IOException, CompilationException -->Line_14 $$ DiagnosticCollector diagnostic = new DiagnosticCollector()[ CD ]
Line_2 $$ public Collection<ClassObject> compileJavaCode(List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, File outputDir) throws IOException, CompilationException -->Line_10 $$ if (javaHome == null) [ CD ]
Line_17 $$ for (File file : sourcePath) -->Line_22 $$ final File parentFile = file.getParentFile()[ FD ]
Line_23 $$ if (parentFile != null) -->Line_24 $$ sourceRoots.add(parentFile)[ CD ]
Line_15 $$ final Set<File> sourceRoots = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_24 $$ sourceRoots.add(parentFile)[ FD ]
Line_2 $$ public Collection<ClassObject> compileJavaCode(List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, File outputDir) throws IOException, CompilationException -->Line_4 $$ String javaHome = null[ CD ]
Line_17 $$ for (File file : sourcePath) -->Line_18 $$ sourceRoots.add(file)[ FD ]
Line_8 $$ javaHome = sdk.getHomePath()-->Line_10 $$ if (javaHome == null) [ FD ]
Line_5 $$ final Sdk sdk = runtime.getFirst()-->Line_6 $$ final SdkTypeId type = sdk.getSdkType()[ FD ]
Line_2 $$ public Collection<ClassObject> compileJavaCode(List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, File outputDir) throws IOException, CompilationException -->Line_5 $$ final Sdk sdk = runtime.getFirst()[ CD ]
Line_2 $$ public Collection<ClassObject> compileJavaCode(List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, File outputDir) throws IOException, CompilationException -->Line_16 $$ if (!sourcePath.isEmpty()) [ CD ]
Line_2 $$ public Collection<ClassObject> compileJavaCode(List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, File outputDir) throws IOException, CompilationException -->Line_45 $$ return result[ CD ]
Line_3 $$ final Pair<Sdk, JavaSdkVersion> runtime = BuildManager.getBuildProcessRuntimeSdk(myProject)-->Line_5 $$ final Sdk sdk = runtime.getFirst()[ FD ]
Line_4 $$ String javaHome = null-->Line_10 $$ if (javaHome == null) [ FD ]
Line_2 $$ public Collection<ClassObject> compileJavaCode(List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, File outputDir) throws IOException, CompilationException -->Line_30 $$ boolean compiledOk = javacManager != null && javacManager.forkJavac(javaHome, -1, Collections.<String>emptyList(), options, platformCp, classpath, sourcePath, files, outs, diagnostic, outputCollector, new JavacCompilerTool(), CanceledStatus.NULL)[ CD ]
Line_2 $$ public Collection<ClassObject> compileJavaCode(List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, File outputDir) throws IOException, CompilationException -->Line_15 $$ final Set<File> sourceRoots = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)[ CD ]
Line_33 $$ for (Diagnostic<? extends JavaFileObject> d : diagnostic.getDiagnostics()) -->Line_34 $$ final JavaFileObject source = d.getSource()[ FD ]
