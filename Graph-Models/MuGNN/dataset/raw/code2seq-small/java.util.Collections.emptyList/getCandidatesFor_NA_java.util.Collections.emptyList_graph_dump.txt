Line_31 $$ candidates = new HashSet(ageSortedSSTables(candidates).subList(0, MAX_COMPACTING_L0))-->Line_36 $$ Set<SSTableReader> l1overlapping = overlapping(candidates, getLevel(1))[ FD ]
Line_16 $$ Set<SSTableReader> candidates = new HashSet()-->Line_39 $$ if (!overlapping(candidates, compactingL0).isEmpty())[ FD ]
Line_16 $$ Set<SSTableReader> candidates = new HashSet()-->Line_41 $$ candidates = Sets.union(candidates, l1overlapping)[ FD ]
Line_43 $$ if (candidates.size() < 2)-->Line_44 $$ return Collections.emptyList()[ CD ]
Line_31 $$ candidates = new HashSet(ageSortedSSTables(candidates).subList(0, MAX_COMPACTING_L0))-->Line_60 $$ if (Iterables.any(candidates, suspectP))[ FD ]
Line_41 $$ candidates = Sets.union(candidates, l1overlapping)-->Line_62 $$ if (Sets.intersection(candidates, compacting).isEmpty())[ FD ]
Line_2 $$ private Collection<SSTableReader> getCandidatesFor(int level) -->Line_50 $$ for (int i = 0; i < getLevel(level).size(); i++) [ FD ]
Line_50 $$ for (int i = 0; i < getLevel(level).size(); i++) -->Line_57 $$ for (int i = 0; i < getLevel(level).size(); i++) [ FD ]
Line_57 $$ for (int i = 0; i < getLevel(level).size(); i++) -->Line_60 $$ if (Iterables.any(candidates, suspectP))[ CD ]
Line_50 $$ for (int i = 0; i < getLevel(level).size(); i++) -->Line_51 $$ SSTableReader sstable = getLevel(level).get(i)[ CD ]
Line_16 $$ Set<SSTableReader> candidates = new HashSet()-->Line_43 $$ if (candidates.size() < 2)[ FD ]
Line_31 $$ candidates = new HashSet(ageSortedSSTables(candidates).subList(0, MAX_COMPACTING_L0))-->Line_39 $$ if (!overlapping(candidates, compactingL0).isEmpty())[ FD ]
Line_13 $$ if (lastCompactingKey == null || candidate.last.compareTo(lastCompactingKey) > 0)-->Line_14 $$ lastCompactingKey = candidate.last[ CD ]
Line_2 $$ private Collection<SSTableReader> getCandidatesFor(int level) -->Line_5 $$ final Set<SSTableReader> compacting = cfs.getTracker().getCompacting()[ CD ]
Line_6 $$ if (level == 0) -->Line_9 $$ PartitionPosition firstCompactingKey = null[ CD ]
Line_25 $$ for (SSTableReader newCandidate : overlappedL0) -->Line_27 $$ candidates.add(newCandidate)[ FD ]
Line_17 $$ Set<SSTableReader> remaining = new HashSet()-->Line_22 $$ Sets.SetView<SSTableReader> overlappedL0 = Sets.union(Collections.singleton(sstable), overlapping(sstable, remaining))[ FD ]
Line_43 $$ if (candidates.size() < 2)-->Line_46 $$ return candidates[ CD ]
Line_17 $$ Set<SSTableReader> remaining = new HashSet()-->Line_19 $$ for (SSTableReader sstable : ageSortedSSTables(remaining)) [ FD ]
Line_59 $$ Set<SSTableReader> candidates = Sets.union(Collections.singleton(sstable), overlapping(sstable, getLevel(level + 1)))-->Line_60 $$ if (Iterables.any(candidates, suspectP))[ FD ]
Line_16 $$ Set<SSTableReader> candidates = new HashSet()-->Line_36 $$ Set<SSTableReader> l1overlapping = overlapping(candidates, getLevel(1))[ FD ]
Line_6 $$ if (level == 0) -->Line_43 $$ if (candidates.size() < 2)[ CD ]
Line_31 $$ candidates = new HashSet(ageSortedSSTables(candidates).subList(0, MAX_COMPACTING_L0))-->Line_62 $$ if (Sets.intersection(candidates, compacting).isEmpty())[ FD ]
Line_50 $$ for (int i = 0; i < getLevel(level).size(); i++) -->Line_52 $$ if (sstable.first.compareTo(lastCompactedKeys[level]) > 0) [ CD ]
Line_8 $$ PartitionPosition lastCompactingKey = null-->Line_13 $$ if (lastCompactingKey == null || candidate.last.compareTo(lastCompactingKey) > 0)[ FD ]
Line_35 $$ if (SSTableReader.getTotalBytes(candidates) > maxSSTableSizeInBytes) -->Line_37 $$ if (Sets.intersection(l1overlapping, compacting).size() > 0)[ CD ]
Line_5 $$ final Set<SSTableReader> compacting = cfs.getTracker().getCompacting()-->Line_62 $$ if (Sets.intersection(candidates, compacting).isEmpty())[ FD ]
Line_26 $$ if (firstCompactingKey == null || lastCompactingKey == null || overlapping(firstCompactingKey.getToken(), lastCompactingKey.getToken(), Arrays.asList(newCandidate)).size() == 0)-->Line_27 $$ candidates.add(newCandidate)[ CD ]
Line_6 $$ if (level == 0) -->Line_7 $$ Set<SSTableReader> compactingL0 = getCompacting(0)[ CD ]
Line_41 $$ candidates = Sets.union(candidates, l1overlapping)-->Line_43 $$ if (candidates.size() < 2)[ FD ]
Line_35 $$ if (SSTableReader.getTotalBytes(candidates) > maxSSTableSizeInBytes) -->Line_36 $$ Set<SSTableReader> l1overlapping = overlapping(candidates, getLevel(1))[ CD ]
Line_62 $$ if (Sets.intersection(candidates, compacting).isEmpty())-->Line_63 $$ return candidates[ CD ]
Line_2 $$ private Collection<SSTableReader> getCandidatesFor(int level) -->Line_65 $$ return Collections.emptyList()[ CD ]
Line_2 $$ private Collection<SSTableReader> getCandidatesFor(int level) -->Line_49 $$ int start = 0[ CD ]
Line_16 $$ Set<SSTableReader> candidates = new HashSet()-->Line_60 $$ if (Iterables.any(candidates, suspectP))[ FD ]
Line_57 $$ for (int i = 0; i < getLevel(level).size(); i++) -->Line_59 $$ Set<SSTableReader> candidates = Sets.union(Collections.singleton(sstable), overlapping(sstable, getLevel(level + 1)))[ CD ]
Line_16 $$ Set<SSTableReader> candidates = new HashSet()-->Line_27 $$ candidates.add(newCandidate)[ FD ]
Line_2 $$ private Collection<SSTableReader> getCandidatesFor(int level) -->Line_51 $$ SSTableReader sstable = getLevel(level).get(i)[ FD ]
Line_31 $$ candidates = new HashSet(ageSortedSSTables(candidates).subList(0, MAX_COMPACTING_L0))-->Line_35 $$ if (SSTableReader.getTotalBytes(candidates) > maxSSTableSizeInBytes) [ FD ]
Line_35 $$ if (SSTableReader.getTotalBytes(candidates) > maxSSTableSizeInBytes) -->Line_41 $$ candidates = Sets.union(candidates, l1overlapping)[ CD ]
Line_41 $$ candidates = Sets.union(candidates, l1overlapping)-->Line_60 $$ if (Iterables.any(candidates, suspectP))[ FD ]
Line_2 $$ private Collection<SSTableReader> getCandidatesFor(int level) -->Line_48 $$ Collections.sort(getLevel(level), SSTableReader.sstableComparator)[ CD ]
Line_57 $$ for (int i = 0; i < getLevel(level).size(); i++) -->Line_58 $$ SSTableReader sstable = getLevel(level).get((start + i) % getLevel(level).size())[ CD ]
Line_16 $$ Set<SSTableReader> candidates = new HashSet()-->Line_20 $$ if (candidates.contains(sstable))[ FD ]
Line_19 $$ for (SSTableReader sstable : ageSortedSSTables(remaining)) -->Line_59 $$ Set<SSTableReader> candidates = Sets.union(Collections.singleton(sstable), overlapping(sstable, getLevel(level + 1)))[ FD ]
Line_11 $$ if (firstCompactingKey == null || candidate.first.compareTo(firstCompactingKey) < 0)-->Line_12 $$ firstCompactingKey = candidate.first[ CD ]
Line_6 $$ if (level == 0) -->Line_8 $$ PartitionPosition lastCompactingKey = null[ CD ]
Line_30 $$ if (candidates.size() > MAX_COMPACTING_L0) -->Line_31 $$ candidates = new HashSet(ageSortedSSTables(candidates).subList(0, MAX_COMPACTING_L0))[ CD ]
Line_2 $$ private Collection<SSTableReader> getCandidatesFor(int level) -->Line_3 $$ assert !getLevel(level).isEmpty()[ FD ]
Line_36 $$ Set<SSTableReader> l1overlapping = overlapping(candidates, getLevel(1))-->Line_41 $$ candidates = Sets.union(candidates, l1overlapping)[ FD ]
Line_39 $$ if (!overlapping(candidates, compactingL0).isEmpty())-->Line_40 $$ return Collections.emptyList()[ CD ]
Line_6 $$ if (level == 0) -->Line_16 $$ Set<SSTableReader> candidates = new HashSet()[ CD ]
Line_16 $$ Set<SSTableReader> candidates = new HashSet()-->Line_30 $$ if (candidates.size() > MAX_COMPACTING_L0) [ FD ]
Line_5 $$ final Set<SSTableReader> compacting = cfs.getTracker().getCompacting()-->Line_37 $$ if (Sets.intersection(l1overlapping, compacting).size() > 0)[ FD ]
Line_2 $$ private Collection<SSTableReader> getCandidatesFor(int level) -->Line_57 $$ for (int i = 0; i < getLevel(level).size(); i++) [ FD ]
Line_8 $$ PartitionPosition lastCompactingKey = null-->Line_14 $$ lastCompactingKey = candidate.last[ FD ]
Line_22 $$ Sets.SetView<SSTableReader> overlappedL0 = Sets.union(Collections.singleton(sstable), overlapping(sstable, remaining))-->Line_23 $$ if (!Sets.intersection(overlappedL0, compactingL0).isEmpty())[ FD ]
Line_2 $$ private Collection<SSTableReader> getCandidatesFor(int level) -->Line_57 $$ for (int i = 0; i < getLevel(level).size(); i++) [ CD ]
Line_51 $$ SSTableReader sstable = getLevel(level).get(i)-->Line_59 $$ Set<SSTableReader> candidates = Sets.union(Collections.singleton(sstable), overlapping(sstable, getLevel(level + 1)))[ FD ]
Line_7 $$ Set<SSTableReader> compactingL0 = getCompacting(0)-->Line_23 $$ if (!Sets.intersection(overlappedL0, compactingL0).isEmpty())[ FD ]
Line_59 $$ Set<SSTableReader> candidates = Sets.union(Collections.singleton(sstable), overlapping(sstable, getLevel(level + 1)))-->Line_62 $$ if (Sets.intersection(candidates, compacting).isEmpty())[ FD ]
Line_25 $$ for (SSTableReader newCandidate : overlappedL0) -->Line_26 $$ if (firstCompactingKey == null || lastCompactingKey == null || overlapping(firstCompactingKey.getToken(), lastCompactingKey.getToken(), Arrays.asList(newCandidate)).size() == 0)[ FD ]
Line_58 $$ SSTableReader sstable = getLevel(level).get((start + i) % getLevel(level).size())-->Line_59 $$ Set<SSTableReader> candidates = Sets.union(Collections.singleton(sstable), overlapping(sstable, getLevel(level + 1)))[ FD ]
Line_9 $$ PartitionPosition firstCompactingKey = null-->Line_11 $$ if (firstCompactingKey == null || candidate.first.compareTo(firstCompactingKey) < 0)[ FD ]
Line_57 $$ for (int i = 0; i < getLevel(level).size(); i++) -->Line_62 $$ if (Sets.intersection(candidates, compacting).isEmpty())[ CD ]
Line_37 $$ if (Sets.intersection(l1overlapping, compacting).size() > 0)-->Line_38 $$ return Collections.emptyList()[ CD ]
Line_19 $$ for (SSTableReader sstable : ageSortedSSTables(remaining)) -->Line_20 $$ if (candidates.contains(sstable))[ FD ]
Line_6 $$ if (level == 0) -->Line_17 $$ Set<SSTableReader> remaining = new HashSet()[ CD ]
Line_19 $$ for (SSTableReader sstable : ageSortedSSTables(remaining)) -->Line_22 $$ Sets.SetView<SSTableReader> overlappedL0 = Sets.union(Collections.singleton(sstable), overlapping(sstable, remaining))[ FD ]
Line_8 $$ PartitionPosition lastCompactingKey = null-->Line_26 $$ if (firstCompactingKey == null || lastCompactingKey == null || overlapping(firstCompactingKey.getToken(), lastCompactingKey.getToken(), Arrays.asList(newCandidate)).size() == 0)[ FD ]
Line_14 $$ lastCompactingKey = candidate.last-->Line_26 $$ if (firstCompactingKey == null || lastCompactingKey == null || overlapping(firstCompactingKey.getToken(), lastCompactingKey.getToken(), Arrays.asList(newCandidate)).size() == 0)[ FD ]
Line_16 $$ Set<SSTableReader> candidates = new HashSet()-->Line_35 $$ if (SSTableReader.getTotalBytes(candidates) > maxSSTableSizeInBytes) [ FD ]
Line_49 $$ int start = 0-->Line_53 $$ start = i[ FD ]
Line_12 $$ firstCompactingKey = candidate.first-->Line_26 $$ if (firstCompactingKey == null || lastCompactingKey == null || overlapping(firstCompactingKey.getToken(), lastCompactingKey.getToken(), Arrays.asList(newCandidate)).size() == 0)[ FD ]
Line_6 $$ if (level == 0) -->Line_18 $$ Iterables.addAll(remaining, Iterables.filter(getLevel(0), Predicates.not(suspectP)))[ CD ]
Line_17 $$ Set<SSTableReader> remaining = new HashSet()-->Line_28 $$ remaining.remove(newCandidate)[ FD ]
Line_25 $$ for (SSTableReader newCandidate : overlappedL0) -->Line_28 $$ remaining.remove(newCandidate)[ FD ]
Line_2 $$ private Collection<SSTableReader> getCandidatesFor(int level) -->Line_6 $$ if (level == 0) [ FD ]
Line_2 $$ private Collection<SSTableReader> getCandidatesFor(int level) -->Line_4 $$ logger.trace("Choosing candidates for L[ CD ]
Line_16 $$ Set<SSTableReader> candidates = new HashSet()-->Line_31 $$ candidates = new HashSet(ageSortedSSTables(candidates).subList(0, MAX_COMPACTING_L0))[ FD ]
Line_2 $$ private Collection<SSTableReader> getCandidatesFor(int level) -->Line_50 $$ for (int i = 0; i < getLevel(level).size(); i++) [ CD ]
Line_7 $$ Set<SSTableReader> compactingL0 = getCompacting(0)-->Line_39 $$ if (!overlapping(candidates, compactingL0).isEmpty())[ FD ]
Line_9 $$ PartitionPosition firstCompactingKey = null-->Line_12 $$ firstCompactingKey = candidate.first[ FD ]
Line_50 $$ for (int i = 0; i < getLevel(level).size(); i++) -->Line_51 $$ SSTableReader sstable = getLevel(level).get(i)[ FD ]
Line_9 $$ PartitionPosition firstCompactingKey = null-->Line_26 $$ if (firstCompactingKey == null || lastCompactingKey == null || overlapping(firstCompactingKey.getToken(), lastCompactingKey.getToken(), Arrays.asList(newCandidate)).size() == 0)[ FD ]
Line_31 $$ candidates = new HashSet(ageSortedSSTables(candidates).subList(0, MAX_COMPACTING_L0))-->Line_41 $$ candidates = Sets.union(candidates, l1overlapping)[ FD ]
Line_52 $$ if (sstable.first.compareTo(lastCompactedKeys[level]) > 0) -->Line_53 $$ start = i[ CD ]
Line_50 $$ for (int i = 0; i < getLevel(level).size(); i++) -->Line_53 $$ start = i[ FD ]
Line_2 $$ private Collection<SSTableReader> getCandidatesFor(int level) -->Line_6 $$ if (level == 0) [ CD ]
Line_31 $$ candidates = new HashSet(ageSortedSSTables(candidates).subList(0, MAX_COMPACTING_L0))-->Line_43 $$ if (candidates.size() < 2)[ FD ]
Line_16 $$ Set<SSTableReader> candidates = new HashSet()-->Line_62 $$ if (Sets.intersection(candidates, compacting).isEmpty())[ FD ]
Line_2 $$ private Collection<SSTableReader> getCandidatesFor(int level) -->Line_58 $$ SSTableReader sstable = getLevel(level).get((start + i) % getLevel(level).size())[ FD ]
Line_2 $$ private Collection<SSTableReader> getCandidatesFor(int level) -->Line_4 $$ logger.trace("Choosing candidates for L[ FD ]
Line_36 $$ Set<SSTableReader> l1overlapping = overlapping(candidates, getLevel(1))-->Line_37 $$ if (Sets.intersection(l1overlapping, compacting).size() > 0)[ FD ]
Line_17 $$ Set<SSTableReader> remaining = new HashSet()-->Line_18 $$ Iterables.addAll(remaining, Iterables.filter(getLevel(0), Predicates.not(suspectP)))[ FD ]
Line_2 $$ private Collection<SSTableReader> getCandidatesFor(int level) -->Line_48 $$ Collections.sort(getLevel(level), SSTableReader.sstableComparator)[ FD ]
Line_6 $$ if (level == 0) -->Line_35 $$ if (SSTableReader.getTotalBytes(candidates) > maxSSTableSizeInBytes) [ CD ]
Line_35 $$ if (SSTableReader.getTotalBytes(candidates) > maxSSTableSizeInBytes) -->Line_39 $$ if (!overlapping(candidates, compactingL0).isEmpty())[ CD ]
