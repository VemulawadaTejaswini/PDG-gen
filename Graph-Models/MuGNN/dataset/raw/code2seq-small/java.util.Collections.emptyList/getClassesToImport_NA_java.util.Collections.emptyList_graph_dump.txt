Line_51 $$ classList = filtered-->Line_53 $$ filterAlreadyImportedButUnresolved(classList)[ FD ]
Line_14 $$ if (name == null) -->Line_15 $$ return Collections.emptyList()[ CD ]
Line_25 $$ List<PsiClass> classList = new ArrayList<PsiClass>(classes.length)-->Line_51 $$ classList = filtered[ FD ]
Line_27 $$ final PsiFile file = myElement.getContainingFile()-->Line_54 $$ filerByPackageName(classList, file)[ FD ]
Line_17 $$ if (!canReferenceClass(myRef)) -->Line_18 $$ return Collections.emptyList()[ CD ]
Line_28 $$ for (PsiClass aClass : classes) -->Line_33 $$ if (referenceHasTypeParameters && !aClass.hasTypeParameters())[ FD ]
Line_28 $$ for (PsiClass aClass : classes) -->Line_35 $$ String qName = aClass.getQualifiedName()[ FD ]
Line_35 $$ String qName = aClass.getQualifiedName()-->Line_36 $$ if (qName != null) [ FD ]
Line_25 $$ List<PsiClass> classList = new ArrayList<PsiClass>(classes.length)-->Line_48 $$ classList = filterByRequiredMemberName(classList)[ FD ]
Line_12 $$ String name = getReferenceName(myRef)-->Line_14 $$ if (name == null) [ FD ]
Line_5 $$ JavaResolveResult result = ((PsiJavaReference) myRef).advancedResolve(true)-->Line_6 $$ PsiElement element = result.getElement()[ FD ]
Line_48 $$ classList = filterByRequiredMemberName(classList)-->Line_53 $$ filterAlreadyImportedButUnresolved(classList)[ FD ]
Line_48 $$ classList = filterByRequiredMemberName(classList)-->Line_49 $$ List<PsiClass> filtered = filterByContext(classList, myElement)[ FD ]
Line_28 $$ for (PsiClass aClass : classes) -->Line_29 $$ if (isAnnotationReference && !aClass.isAnnotationType())[ FD ]
Line_12 $$ String name = getReferenceName(myRef)-->Line_22 $$ PsiClass[] classes = PsiShortNamesCache.getInstance(project).getClassesByName(name, scope)[ FD ]
Line_28 $$ for (PsiClass aClass : classes) -->Line_31 $$ if (JavaCompletionUtil.isInExcludedPackage(aClass, false))[ FD ]
Line_41 $$ if (qName.endsWith(name) && (file == null || ImportFilter.shouldImport(file, qName))) -->Line_42 $$ if (isAccessible(aClass, myElement)) [ CD ]
Line_49 $$ List<PsiClass> filtered = filterByContext(classList, myElement)-->Line_50 $$ if (!filtered.isEmpty()) [ FD ]
Line_23 $$ if (classes.length == 0)-->Line_24 $$ return Collections.emptyList()[ CD ]
Line_35 $$ String qName = aClass.getQualifiedName()-->Line_41 $$ if (qName.endsWith(name) && (file == null || ImportFilter.shouldImport(file, qName))) [ FD ]
Line_25 $$ List<PsiClass> classList = new ArrayList<PsiClass>(classes.length)-->Line_49 $$ List<PsiClass> filtered = filterByContext(classList, myElement)[ FD ]
Line_50 $$ if (!filtered.isEmpty()) -->Line_51 $$ classList = filtered[ CD ]
Line_13 $$ GlobalSearchScope scope = myElement.getResolveScope()-->Line_22 $$ PsiClass[] classes = PsiShortNamesCache.getInstance(project).getClassesByName(name, scope)[ FD ]
Line_42 $$ if (isAccessible(aClass, myElement)) -->Line_43 $$ classList.add(aClass)[ CD ]
Line_48 $$ classList = filterByRequiredMemberName(classList)-->Line_51 $$ classList = filtered[ FD ]
Line_51 $$ classList = filtered-->Line_54 $$ filerByPackageName(classList, file)[ FD ]
Line_25 $$ List<PsiClass> classList = new ArrayList<PsiClass>(classes.length)-->Line_53 $$ filterAlreadyImportedButUnresolved(classList)[ FD ]
Line_25 $$ List<PsiClass> classList = new ArrayList<PsiClass>(classes.length)-->Line_54 $$ filerByPackageName(classList, file)[ FD ]
Line_48 $$ classList = filterByRequiredMemberName(classList)-->Line_54 $$ filerByPackageName(classList, file)[ FD ]
Line_20 $$ boolean referenceHasTypeParameters = hasTypeParameters(myRef)-->Line_33 $$ if (referenceHasTypeParameters && !aClass.hasTypeParameters())[ FD ]
Line_4 $$ if (myRef instanceof PsiJavaReference) -->Line_6 $$ PsiElement element = result.getElement()[ CD ]
Line_49 $$ List<PsiClass> filtered = filterByContext(classList, myElement)-->Line_51 $$ classList = filtered[ FD ]
Line_36 $$ if (qName != null) -->Line_41 $$ if (qName.endsWith(name) && (file == null || ImportFilter.shouldImport(file, qName))) [ CD ]
Line_4 $$ if (myRef instanceof PsiJavaReference) -->Line_5 $$ JavaResolveResult result = ((PsiJavaReference) myRef).advancedResolve(true)[ CD ]
Line_26 $$ boolean isAnnotationReference = myElement.getParent() instanceof PsiAnnotation-->Line_29 $$ if (isAnnotationReference && !aClass.isAnnotationType())[ FD ]
Line_21 $$ final Project project = myElement.getProject()-->Line_22 $$ PsiClass[] classes = PsiShortNamesCache.getInstance(project).getClassesByName(name, scope)[ FD ]
Line_28 $$ for (PsiClass aClass : classes) -->Line_42 $$ if (isAccessible(aClass, myElement)) [ FD ]
Line_27 $$ final PsiFile file = myElement.getContainingFile()-->Line_41 $$ if (qName.endsWith(name) && (file == null || ImportFilter.shouldImport(file, qName))) [ FD ]
Line_25 $$ List<PsiClass> classList = new ArrayList<PsiClass>(classes.length)-->Line_43 $$ classList.add(aClass)[ FD ]
Line_12 $$ String name = getReferenceName(myRef)-->Line_41 $$ if (qName.endsWith(name) && (file == null || ImportFilter.shouldImport(file, qName))) [ FD ]
Line_28 $$ for (PsiClass aClass : classes) -->Line_43 $$ classList.add(aClass)[ FD ]
