Line_12 $$ final IndexMetaData indexMetaData = metaData.index(shard.getIndex())-->Line_14 $$ if (shard.allocatedPostIndexCreate(indexMetaData) == false) [ FD ]
Line_33 $$ enoughAllocationsFound = nodesAndVersions.allocationsFound > 0-->Line_35 $$ enoughAllocationsFound = isEnoughVersionBasedAllocationsFound(shard, indexMetaData, nodesAndVersions)[ FD ]
Line_24 $$ final Set<String> lastActiveAllocationIds = indexMetaData.activeAllocationIds(shard.id())-->Line_42 $$ logger.debug("[[ FD ]
Line_6 $$ final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = routingNodes.unassigned().iterator()-->Line_65 $$ unassignedIterator.initialize(node.id(), nodesAndVersions.highestVersion, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)[ FD ]
Line_24 $$ final Set<String> lastActiveAllocationIds = indexMetaData.activeAllocationIds(shard.id())-->Line_29 $$ if (lastActiveAllocationIds.isEmpty()) [ FD ]
Line_7 $$ while (unassignedIterator.hasNext()) -->Line_8 $$ final ShardRouting shard = unassignedIterator.next()[ CD ]
Line_35 $$ enoughAllocationsFound = isEnoughVersionBasedAllocationsFound(shard, indexMetaData, nodesAndVersions)-->Line_44 $$ if (enoughAllocationsFound == false) [ FD ]
Line_56 $$ if (nodesToAllocate.yesNodes.isEmpty() == false) -->Line_59 $$ changed = true[ CD ]
Line_44 $$ if (enoughAllocationsFound == false) -->Line_45 $$ if (snapshotRestore) [ CD ]
Line_61 $$ if (nodesToAllocate.throttleNodes.isEmpty() == true && nodesToAllocate.noNodes.isEmpty() == false) -->Line_62 $$ DiscoveryNode node = nodesToAllocate.noNodes.get(0)[ CD ]
Line_26 $$ final boolean recoverOnAnyNode = recoverOnAnyNode(indexSettings)-->Line_45 $$ if (snapshotRestore) [ FD ]
Line_45 $$ if (snapshotRestore) -->Line_46 $$ logger.debug("[[ CD ]
Line_6 $$ final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = routingNodes.unassigned().iterator()-->Line_8 $$ final ShardRouting shard = unassignedIterator.next()[ FD ]
Line_28 $$ final boolean enoughAllocationsFound-->Line_44 $$ if (enoughAllocationsFound == false) [ FD ]
Line_7 $$ while (unassignedIterator.hasNext()) -->Line_12 $$ final IndexMetaData indexMetaData = metaData.index(shard.getIndex())[ CD ]
Line_29 $$ if (lastActiveAllocationIds.isEmpty()) -->Line_41 $$ enoughAllocationsFound = nodesAndVersions.allocationsFound > 0[ CD ]
Line_27 $$ final NodesAndVersions nodesAndVersions-->Line_31 $$ nodesAndVersions = buildNodesAndVersions(shard, snapshotRestore || recoverOnAnyNode, allocation.getIgnoreNodes(shard.shardId()), shardState)[ FD ]
Line_8 $$ final ShardRouting shard = unassignedIterator.next()-->Line_31 $$ nodesAndVersions = buildNodesAndVersions(shard, snapshotRestore || recoverOnAnyNode, allocation.getIgnoreNodes(shard.shardId()), shardState)[ FD ]
Line_8 $$ final ShardRouting shard = unassignedIterator.next()-->Line_46 $$ logger.debug("[[ FD ]
Line_8 $$ final ShardRouting shard = unassignedIterator.next()-->Line_48 $$ logger.debug("[[ FD ]
Line_2 $$ public boolean allocateUnassigned(RoutingAllocation allocation) -->Line_20 $$ allocation.setHasPendingAsyncFetch()[ FD ]
Line_7 $$ while (unassignedIterator.hasNext()) -->Line_55 $$ final NodesToAllocate nodesToAllocate = buildNodesToAllocate(shard, allocation, nodesAndVersions.nodes)[ CD ]
Line_61 $$ if (nodesToAllocate.throttleNodes.isEmpty() == true && nodesToAllocate.noNodes.isEmpty() == false) -->Line_65 $$ unassignedIterator.initialize(node.id(), nodesAndVersions.highestVersion, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)[ CD ]
Line_29 $$ if (lastActiveAllocationIds.isEmpty()) -->Line_42 $$ logger.debug("[[ CD ]
Line_57 $$ DiscoveryNode node = nodesToAllocate.yesNodes.get(0)-->Line_60 $$ unassignedIterator.initialize(node.id(), nodesAndVersions.highestVersion, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)[ FD ]
Line_7 $$ while (unassignedIterator.hasNext()) -->Line_25 $$ final boolean snapshotRestore = shard.restoreSource() != null[ CD ]
Line_61 $$ if (nodesToAllocate.throttleNodes.isEmpty() == true && nodesToAllocate.noNodes.isEmpty() == false) -->Line_64 $$ changed = true[ CD ]
Line_6 $$ final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = routingNodes.unassigned().iterator()-->Line_68 $$ unassignedIterator.removeAndIgnore()[ FD ]
Line_61 $$ if (nodesToAllocate.throttleNodes.isEmpty() == true && nodesToAllocate.noNodes.isEmpty() == false) -->Line_68 $$ unassignedIterator.removeAndIgnore()[ CD ]
Line_8 $$ final ShardRouting shard = unassignedIterator.next()-->Line_14 $$ if (shard.allocatedPostIndexCreate(indexMetaData) == false) [ FD ]
Line_40 $$ nodesAndVersions = buildAllocationIdBasedNodes(shard, snapshotRestore || recoverOnAnyNode, allocation.getIgnoreNodes(shard.shardId()), lastActiveAllocationIds, shardState)-->Line_35 $$ enoughAllocationsFound = isEnoughVersionBasedAllocationsFound(shard, indexMetaData, nodesAndVersions)[ FD ]
Line_27 $$ final NodesAndVersions nodesAndVersions-->Line_35 $$ enoughAllocationsFound = isEnoughVersionBasedAllocationsFound(shard, indexMetaData, nodesAndVersions)[ FD ]
Line_2 $$ public boolean allocateUnassigned(RoutingAllocation allocation) -->Line_40 $$ nodesAndVersions = buildAllocationIdBasedNodes(shard, snapshotRestore || recoverOnAnyNode, allocation.getIgnoreNodes(shard.shardId()), lastActiveAllocationIds, shardState)[ FD ]
Line_31 $$ nodesAndVersions = buildNodesAndVersions(shard, snapshotRestore || recoverOnAnyNode, allocation.getIgnoreNodes(shard.shardId()), shardState)-->Line_40 $$ nodesAndVersions = buildAllocationIdBasedNodes(shard, snapshotRestore || recoverOnAnyNode, allocation.getIgnoreNodes(shard.shardId()), lastActiveAllocationIds, shardState)[ FD ]
Line_13 $$ final IndexSettings indexSettings = new IndexSettings(indexMetaData, settings, Collections.emptyList())-->Line_26 $$ final boolean recoverOnAnyNode = recoverOnAnyNode(indexSettings)[ FD ]
Line_8 $$ final ShardRouting shard = unassignedIterator.next()-->Line_37 $$ logger.debug("[[ FD ]
Line_5 $$ final MetaData metaData = routingNodes.metaData()-->Line_12 $$ final IndexMetaData indexMetaData = metaData.index(shard.getIndex())[ FD ]
Line_7 $$ while (unassignedIterator.hasNext()) -->Line_14 $$ if (shard.allocatedPostIndexCreate(indexMetaData) == false) [ CD ]
Line_7 $$ while (unassignedIterator.hasNext()) -->Line_24 $$ final Set<String> lastActiveAllocationIds = indexMetaData.activeAllocationIds(shard.id())[ CD ]
Line_2 $$ public boolean allocateUnassigned(RoutingAllocation allocation) -->Line_71 $$ return changed[ CD ]
Line_45 $$ if (snapshotRestore) -->Line_47 $$ if (recoverOnAnyNode) [ CD ]
Line_8 $$ final ShardRouting shard = unassignedIterator.next()-->Line_67 $$ logger.debug("[[ FD ]
Line_2 $$ public boolean allocateUnassigned(RoutingAllocation allocation) -->Line_5 $$ final MetaData metaData = routingNodes.metaData()[ CD ]
Line_6 $$ final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = routingNodes.unassigned().iterator()-->Line_7 $$ while (unassignedIterator.hasNext()) [ FD ]
Line_7 $$ while (unassignedIterator.hasNext()) -->Line_17 $$ final AsyncShardFetch.FetchResult<TransportNodesListGatewayStartedShards.NodeGatewayStartedShards> shardState = fetchData(shard, allocation)[ CD ]
Line_29 $$ if (lastActiveAllocationIds.isEmpty()) -->Line_37 $$ logger.debug("[[ CD ]
Line_41 $$ enoughAllocationsFound = nodesAndVersions.allocationsFound > 0-->Line_44 $$ if (enoughAllocationsFound == false) [ FD ]
Line_56 $$ if (nodesToAllocate.yesNodes.isEmpty() == false) -->Line_60 $$ unassignedIterator.initialize(node.id(), nodesAndVersions.highestVersion, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)[ CD ]
Line_33 $$ enoughAllocationsFound = nodesAndVersions.allocationsFound > 0-->Line_41 $$ enoughAllocationsFound = nodesAndVersions.allocationsFound > 0[ FD ]
Line_57 $$ DiscoveryNode node = nodesToAllocate.yesNodes.get(0)-->Line_63 $$ logger.debug("[[ FD ]
Line_29 $$ if (lastActiveAllocationIds.isEmpty()) -->Line_40 $$ nodesAndVersions = buildAllocationIdBasedNodes(shard, snapshotRestore || recoverOnAnyNode, allocation.getIgnoreNodes(shard.shardId()), lastActiveAllocationIds, shardState)[ CD ]
Line_47 $$ if (recoverOnAnyNode) -->Line_48 $$ logger.debug("[[ CD ]
Line_8 $$ final ShardRouting shard = unassignedIterator.next()-->Line_12 $$ final IndexMetaData indexMetaData = metaData.index(shard.getIndex())[ FD ]
Line_28 $$ final boolean enoughAllocationsFound-->Line_35 $$ enoughAllocationsFound = isEnoughVersionBasedAllocationsFound(shard, indexMetaData, nodesAndVersions)[ FD ]
Line_17 $$ final AsyncShardFetch.FetchResult<TransportNodesListGatewayStartedShards.NodeGatewayStartedShards> shardState = fetchData(shard, allocation)-->Line_40 $$ nodesAndVersions = buildAllocationIdBasedNodes(shard, snapshotRestore || recoverOnAnyNode, allocation.getIgnoreNodes(shard.shardId()), lastActiveAllocationIds, shardState)[ FD ]
Line_28 $$ final boolean enoughAllocationsFound-->Line_41 $$ enoughAllocationsFound = nodesAndVersions.allocationsFound > 0[ FD ]
Line_7 $$ while (unassignedIterator.hasNext()) -->Line_18 $$ if (shardState.hasData() == false) [ CD ]
Line_28 $$ final boolean enoughAllocationsFound-->Line_33 $$ enoughAllocationsFound = nodesAndVersions.allocationsFound > 0[ FD ]
Line_8 $$ final ShardRouting shard = unassignedIterator.next()-->Line_25 $$ final boolean snapshotRestore = shard.restoreSource() != null[ FD ]
Line_18 $$ if (shardState.hasData() == false) -->Line_21 $$ unassignedIterator.removeAndIgnore()[ CD ]
Line_8 $$ final ShardRouting shard = unassignedIterator.next()-->Line_17 $$ final AsyncShardFetch.FetchResult<TransportNodesListGatewayStartedShards.NodeGatewayStartedShards> shardState = fetchData(shard, allocation)[ FD ]
Line_2 $$ public boolean allocateUnassigned(RoutingAllocation allocation) -->Line_4 $$ final RoutingNodes routingNodes = allocation.routingNodes()[ CD ]
Line_7 $$ while (unassignedIterator.hasNext()) -->Line_29 $$ if (lastActiveAllocationIds.isEmpty()) [ CD ]
Line_24 $$ final Set<String> lastActiveAllocationIds = indexMetaData.activeAllocationIds(shard.id())-->Line_40 $$ nodesAndVersions = buildAllocationIdBasedNodes(shard, snapshotRestore || recoverOnAnyNode, allocation.getIgnoreNodes(shard.shardId()), lastActiveAllocationIds, shardState)[ FD ]
Line_4 $$ final RoutingNodes routingNodes = allocation.routingNodes()-->Line_5 $$ final MetaData metaData = routingNodes.metaData()[ FD ]
Line_12 $$ final IndexMetaData indexMetaData = metaData.index(shard.getIndex())-->Line_35 $$ enoughAllocationsFound = isEnoughVersionBasedAllocationsFound(shard, indexMetaData, nodesAndVersions)[ FD ]
Line_24 $$ final Set<String> lastActiveAllocationIds = indexMetaData.activeAllocationIds(shard.id())-->Line_39 $$ assert lastActiveAllocationIds.isEmpty() == false[ FD ]
Line_6 $$ final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = routingNodes.unassigned().iterator()-->Line_21 $$ unassignedIterator.removeAndIgnore()[ FD ]
Line_6 $$ final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = routingNodes.unassigned().iterator()-->Line_50 $$ unassignedIterator.removeAndIgnore()[ FD ]
Line_35 $$ enoughAllocationsFound = isEnoughVersionBasedAllocationsFound(shard, indexMetaData, nodesAndVersions)-->Line_41 $$ enoughAllocationsFound = nodesAndVersions.allocationsFound > 0[ FD ]
Line_13 $$ final IndexSettings indexSettings = new IndexSettings(indexMetaData, settings, Collections.emptyList())-->Line_30 $$ assert indexSettings.getIndexVersionCreated().before(Version.V_3_0_0) : "trying to allocated a primary with an empty allocation id set, but index is new"[ FD ]
Line_12 $$ final IndexMetaData indexMetaData = metaData.index(shard.getIndex())-->Line_24 $$ final Set<String> lastActiveAllocationIds = indexMetaData.activeAllocationIds(shard.id())[ FD ]
Line_32 $$ if (snapshotRestore || recoverOnAnyNode) -->Line_35 $$ enoughAllocationsFound = isEnoughVersionBasedAllocationsFound(shard, indexMetaData, nodesAndVersions)[ CD ]
Line_2 $$ public boolean allocateUnassigned(RoutingAllocation allocation) -->Line_7 $$ while (unassignedIterator.hasNext()) [ CD ]
Line_61 $$ if (nodesToAllocate.throttleNodes.isEmpty() == true && nodesToAllocate.noNodes.isEmpty() == false) -->Line_67 $$ logger.debug("[[ CD ]
Line_2 $$ public boolean allocateUnassigned(RoutingAllocation allocation) -->Line_3 $$ boolean changed = false[ CD ]
Line_3 $$ boolean changed = false-->Line_64 $$ changed = true[ FD ]
Line_7 $$ while (unassignedIterator.hasNext()) -->Line_27 $$ final NodesAndVersions nodesAndVersions[ CD ]
Line_27 $$ final NodesAndVersions nodesAndVersions-->Line_40 $$ nodesAndVersions = buildAllocationIdBasedNodes(shard, snapshotRestore || recoverOnAnyNode, allocation.getIgnoreNodes(shard.shardId()), lastActiveAllocationIds, shardState)[ FD ]
Line_2 $$ public boolean allocateUnassigned(RoutingAllocation allocation) -->Line_6 $$ final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = routingNodes.unassigned().iterator()[ CD ]
Line_47 $$ if (recoverOnAnyNode) -->Line_50 $$ unassignedIterator.removeAndIgnore()[ CD ]
Line_33 $$ enoughAllocationsFound = nodesAndVersions.allocationsFound > 0-->Line_44 $$ if (enoughAllocationsFound == false) [ FD ]
Line_56 $$ if (nodesToAllocate.yesNodes.isEmpty() == false) -->Line_57 $$ DiscoveryNode node = nodesToAllocate.yesNodes.get(0)[ CD ]
Line_57 $$ DiscoveryNode node = nodesToAllocate.yesNodes.get(0)-->Line_58 $$ logger.debug("[[ FD ]
Line_2 $$ public boolean allocateUnassigned(RoutingAllocation allocation) -->Line_31 $$ nodesAndVersions = buildNodesAndVersions(shard, snapshotRestore || recoverOnAnyNode, allocation.getIgnoreNodes(shard.shardId()), shardState)[ FD ]
Line_6 $$ final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = routingNodes.unassigned().iterator()-->Line_60 $$ unassignedIterator.initialize(node.id(), nodesAndVersions.highestVersion, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)[ FD ]
Line_8 $$ final ShardRouting shard = unassignedIterator.next()-->Line_42 $$ logger.debug("[[ FD ]
Line_8 $$ final ShardRouting shard = unassignedIterator.next()-->Line_55 $$ final NodesToAllocate nodesToAllocate = buildNodesToAllocate(shard, allocation, nodesAndVersions.nodes)[ FD ]
Line_8 $$ final ShardRouting shard = unassignedIterator.next()-->Line_19 $$ logger.trace("[ FD ]
Line_25 $$ final boolean snapshotRestore = shard.restoreSource() != null-->Line_32 $$ if (snapshotRestore || recoverOnAnyNode) [ FD ]
Line_7 $$ while (unassignedIterator.hasNext()) -->Line_26 $$ final boolean recoverOnAnyNode = recoverOnAnyNode(indexSettings)[ CD ]
Line_47 $$ if (recoverOnAnyNode) -->Line_51 $$ logger.debug("[[ CD ]
Line_59 $$ changed = true-->Line_64 $$ changed = true[ FD ]
Line_57 $$ DiscoveryNode node = nodesToAllocate.yesNodes.get(0)-->Line_65 $$ unassignedIterator.initialize(node.id(), nodesAndVersions.highestVersion, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)[ FD ]
Line_8 $$ final ShardRouting shard = unassignedIterator.next()-->Line_40 $$ nodesAndVersions = buildAllocationIdBasedNodes(shard, snapshotRestore || recoverOnAnyNode, allocation.getIgnoreNodes(shard.shardId()), lastActiveAllocationIds, shardState)[ FD ]
Line_29 $$ if (lastActiveAllocationIds.isEmpty()) -->Line_31 $$ nodesAndVersions = buildNodesAndVersions(shard, snapshotRestore || recoverOnAnyNode, allocation.getIgnoreNodes(shard.shardId()), shardState)[ CD ]
Line_26 $$ final boolean recoverOnAnyNode = recoverOnAnyNode(indexSettings)-->Line_32 $$ if (snapshotRestore || recoverOnAnyNode) [ FD ]
Line_18 $$ if (shardState.hasData() == false) -->Line_19 $$ logger.trace("[ CD ]
Line_29 $$ if (lastActiveAllocationIds.isEmpty()) -->Line_32 $$ if (snapshotRestore || recoverOnAnyNode) [ CD ]
Line_7 $$ while (unassignedIterator.hasNext()) -->Line_13 $$ final IndexSettings indexSettings = new IndexSettings(indexMetaData, settings, Collections.emptyList())[ CD ]
Line_17 $$ final AsyncShardFetch.FetchResult<TransportNodesListGatewayStartedShards.NodeGatewayStartedShards> shardState = fetchData(shard, allocation)-->Line_31 $$ nodesAndVersions = buildNodesAndVersions(shard, snapshotRestore || recoverOnAnyNode, allocation.getIgnoreNodes(shard.shardId()), shardState)[ FD ]
Line_7 $$ while (unassignedIterator.hasNext()) -->Line_56 $$ if (nodesToAllocate.yesNodes.isEmpty() == false) [ CD ]
Line_8 $$ final ShardRouting shard = unassignedIterator.next()-->Line_58 $$ logger.debug("[[ FD ]
Line_31 $$ nodesAndVersions = buildNodesAndVersions(shard, snapshotRestore || recoverOnAnyNode, allocation.getIgnoreNodes(shard.shardId()), shardState)-->Line_35 $$ enoughAllocationsFound = isEnoughVersionBasedAllocationsFound(shard, indexMetaData, nodesAndVersions)[ FD ]
Line_17 $$ final AsyncShardFetch.FetchResult<TransportNodesListGatewayStartedShards.NodeGatewayStartedShards> shardState = fetchData(shard, allocation)-->Line_18 $$ if (shardState.hasData() == false) [ FD ]
Line_8 $$ final ShardRouting shard = unassignedIterator.next()-->Line_24 $$ final Set<String> lastActiveAllocationIds = indexMetaData.activeAllocationIds(shard.id())[ FD ]
Line_56 $$ if (nodesToAllocate.yesNodes.isEmpty() == false) -->Line_61 $$ if (nodesToAllocate.throttleNodes.isEmpty() == true && nodesToAllocate.noNodes.isEmpty() == false) [ CD ]
Line_18 $$ if (shardState.hasData() == false) -->Line_20 $$ allocation.setHasPendingAsyncFetch()[ CD ]
Line_7 $$ while (unassignedIterator.hasNext()) -->Line_44 $$ if (enoughAllocationsFound == false) [ CD ]
Line_8 $$ final ShardRouting shard = unassignedIterator.next()-->Line_35 $$ enoughAllocationsFound = isEnoughVersionBasedAllocationsFound(shard, indexMetaData, nodesAndVersions)[ FD ]
Line_2 $$ public boolean allocateUnassigned(RoutingAllocation allocation) -->Line_17 $$ final AsyncShardFetch.FetchResult<TransportNodesListGatewayStartedShards.NodeGatewayStartedShards> shardState = fetchData(shard, allocation)[ FD ]
Line_8 $$ final ShardRouting shard = unassignedIterator.next()-->Line_51 $$ logger.debug("[[ FD ]
Line_2 $$ public boolean allocateUnassigned(RoutingAllocation allocation) -->Line_4 $$ final RoutingNodes routingNodes = allocation.routingNodes()[ FD ]
Line_4 $$ final RoutingNodes routingNodes = allocation.routingNodes()-->Line_6 $$ final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = routingNodes.unassigned().iterator()[ FD ]
Line_2 $$ public boolean allocateUnassigned(RoutingAllocation allocation) -->Line_55 $$ final NodesToAllocate nodesToAllocate = buildNodesToAllocate(shard, allocation, nodesAndVersions.nodes)[ FD ]
Line_61 $$ if (nodesToAllocate.throttleNodes.isEmpty() == true && nodesToAllocate.noNodes.isEmpty() == false) -->Line_63 $$ logger.debug("[[ CD ]
Line_32 $$ if (snapshotRestore || recoverOnAnyNode) -->Line_33 $$ enoughAllocationsFound = nodesAndVersions.allocationsFound > 0[ CD ]
Line_7 $$ while (unassignedIterator.hasNext()) -->Line_9 $$ if (shard.primary() == false) [ CD ]
Line_8 $$ final ShardRouting shard = unassignedIterator.next()-->Line_9 $$ if (shard.primary() == false) [ FD ]
Line_3 $$ boolean changed = false-->Line_59 $$ changed = true[ FD ]
Line_7 $$ while (unassignedIterator.hasNext()) -->Line_28 $$ final boolean enoughAllocationsFound[ CD ]
Line_56 $$ if (nodesToAllocate.yesNodes.isEmpty() == false) -->Line_58 $$ logger.debug("[[ CD ]
Line_8 $$ final ShardRouting shard = unassignedIterator.next()-->Line_63 $$ logger.debug("[[ FD ]
