Line_3 $$ boolean skipFirst = false-->Line_12 $$ if (skipFirst || skipLast) [ FD ]
Line_5 $$ if (!partitions.isEmpty() && command instanceof PartitionRangeReadCommand) -->Line_7 $$ boolean isExcludingBounds = keyRange instanceof ExcludingBounds[ CD ]
Line_30 $$ ClusteringIndexFilter filter = command.clusteringIndexFilter(partition.partitionKey())-->Line_32 $$ return filter.filter(partition.sliceableUnfilteredIterator(command.columnFilter(), filter.isReversed()))[ FD ]
Line_13 $$ toReturn = partitions.size() == 1 ? Collections.emptyList() : partitions.subList(skipFirst ? 1 : 0, skipLast ? partitions.size() - 1 : partitions.size())-->Line_15 $$ toReturn = partitions[ FD ]
Line_11 $$ final List<ImmutableBTreePartition> toReturn-->Line_26 $$ return idx < toReturn.size()[ FD ]
Line_13 $$ toReturn = partitions.size() == 1 ? Collections.emptyList() : partitions.subList(skipFirst ? 1 : 0, skipLast ? partitions.size() - 1 : partitions.size())-->Line_29 $$ ImmutableBTreePartition partition = toReturn.get(idx++)[ FD ]
Line_5 $$ if (!partitions.isEmpty() && command instanceof PartitionRangeReadCommand) -->Line_6 $$ AbstractBounds<PartitionPosition> keyRange = ((PartitionRangeReadCommand) command).dataRange().keyRange()[ CD ]
Line_29 $$ ImmutableBTreePartition partition = toReturn.get(idx++)-->Line_30 $$ ClusteringIndexFilter filter = command.clusteringIndexFilter(partition.partitionKey())[ FD ]
Line_17 $$ return new AbstractUnfilteredPartitionIterator() -->Line_31 $$ if (!command.metadata().isCompound())[ CD ]
Line_17 $$ return new AbstractUnfilteredPartitionIterator() -->Line_30 $$ ClusteringIndexFilter filter = command.clusteringIndexFilter(partition.partitionKey())[ CD ]
Line_12 $$ if (skipFirst || skipLast) -->Line_15 $$ toReturn = partitions[ CD ]
Line_2 $$ public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, final ReadCommand command) -->Line_5 $$ if (!partitions.isEmpty() && command instanceof PartitionRangeReadCommand) [ CD ]
Line_2 $$ public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, final ReadCommand command) -->Line_32 $$ return filter.filter(partition.sliceableUnfilteredIterator(command.columnFilter(), filter.isReversed()))[ FD ]
Line_17 $$ return new AbstractUnfilteredPartitionIterator() -->Line_29 $$ ImmutableBTreePartition partition = toReturn.get(idx++)[ CD ]
Line_29 $$ ImmutableBTreePartition partition = toReturn.get(idx++)-->Line_33 $$ return partition.unfilteredIterator(command.columnFilter(), Slices.ALL, filter.isReversed())[ FD ]
Line_5 $$ if (!partitions.isEmpty() && command instanceof PartitionRangeReadCommand) -->Line_8 $$ skipFirst = isExcludingBounds && !keyRange.contains(partitions.get(0).partitionKey())[ CD ]
Line_13 $$ toReturn = partitions.size() == 1 ? Collections.emptyList() : partitions.subList(skipFirst ? 1 : 0, skipLast ? partitions.size() - 1 : partitions.size())-->Line_26 $$ return idx < toReturn.size()[ FD ]
Line_11 $$ final List<ImmutableBTreePartition> toReturn-->Line_29 $$ ImmutableBTreePartition partition = toReturn.get(idx++)[ FD ]
Line_12 $$ if (skipFirst || skipLast) -->Line_13 $$ toReturn = partitions.size() == 1 ? Collections.emptyList() : partitions.subList(skipFirst ? 1 : 0, skipLast ? partitions.size() - 1 : partitions.size())[ CD ]
Line_15 $$ toReturn = partitions-->Line_29 $$ ImmutableBTreePartition partition = toReturn.get(idx++)[ FD ]
Line_2 $$ public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, final ReadCommand command) -->Line_4 $$ boolean skipLast = false[ CD ]
Line_30 $$ ClusteringIndexFilter filter = command.clusteringIndexFilter(partition.partitionKey())-->Line_33 $$ return partition.unfilteredIterator(command.columnFilter(), Slices.ALL, filter.isReversed())[ FD ]
Line_3 $$ boolean skipFirst = false-->Line_8 $$ skipFirst = isExcludingBounds && !keyRange.contains(partitions.get(0).partitionKey())[ FD ]
Line_2 $$ public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, final ReadCommand command) -->Line_3 $$ boolean skipFirst = false[ CD ]
Line_11 $$ final List<ImmutableBTreePartition> toReturn-->Line_15 $$ toReturn = partitions[ FD ]
Line_2 $$ public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, final ReadCommand command) -->Line_33 $$ return partition.unfilteredIterator(command.columnFilter(), Slices.ALL, filter.isReversed())[ FD ]
Line_4 $$ boolean skipLast = false-->Line_12 $$ if (skipFirst || skipLast) [ FD ]
Line_17 $$ return new AbstractUnfilteredPartitionIterator() -->Line_26 $$ return idx < toReturn.size()[ CD ]
Line_17 $$ return new AbstractUnfilteredPartitionIterator() -->Line_33 $$ return partition.unfilteredIterator(command.columnFilter(), Slices.ALL, filter.isReversed())[ CD ]
Line_9 $$ skipLast = (isExcludingBounds || keyRange instanceof IncludingExcludingBounds) && !keyRange.contains(partitions.get(partitions.size() - 1).partitionKey())-->Line_12 $$ if (skipFirst || skipLast) [ FD ]
Line_29 $$ ImmutableBTreePartition partition = toReturn.get(idx++)-->Line_32 $$ return filter.filter(partition.sliceableUnfilteredIterator(command.columnFilter(), filter.isReversed()))[ FD ]
Line_2 $$ public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, final ReadCommand command) -->Line_12 $$ if (skipFirst || skipLast) [ CD ]
Line_8 $$ skipFirst = isExcludingBounds && !keyRange.contains(partitions.get(0).partitionKey())-->Line_12 $$ if (skipFirst || skipLast) [ FD ]
Line_15 $$ toReturn = partitions-->Line_26 $$ return idx < toReturn.size()[ FD ]
Line_6 $$ AbstractBounds<PartitionPosition> keyRange = ((PartitionRangeReadCommand) command).dataRange().keyRange()-->Line_8 $$ skipFirst = isExcludingBounds && !keyRange.contains(partitions.get(0).partitionKey())[ FD ]
Line_11 $$ final List<ImmutableBTreePartition> toReturn-->Line_13 $$ toReturn = partitions.size() == 1 ? Collections.emptyList() : partitions.subList(skipFirst ? 1 : 0, skipLast ? partitions.size() - 1 : partitions.size())[ FD ]
Line_17 $$ return new AbstractUnfilteredPartitionIterator() -->Line_20 $$ return true[ CD ]
Line_2 $$ public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, final ReadCommand command) -->Line_31 $$ if (!command.metadata().isCompound())[ FD ]
Line_2 $$ public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, final ReadCommand command) -->Line_11 $$ final List<ImmutableBTreePartition> toReturn[ CD ]
Line_31 $$ if (!command.metadata().isCompound())-->Line_32 $$ return filter.filter(partition.sliceableUnfilteredIterator(command.columnFilter(), filter.isReversed()))[ CD ]
Line_7 $$ boolean isExcludingBounds = keyRange instanceof ExcludingBounds-->Line_8 $$ skipFirst = isExcludingBounds && !keyRange.contains(partitions.get(0).partitionKey())[ FD ]
Line_17 $$ return new AbstractUnfilteredPartitionIterator() -->Line_23 $$ return metadata[ CD ]
Line_2 $$ public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, final ReadCommand command) -->Line_30 $$ ClusteringIndexFilter filter = command.clusteringIndexFilter(partition.partitionKey())[ FD ]
Line_5 $$ if (!partitions.isEmpty() && command instanceof PartitionRangeReadCommand) -->Line_9 $$ skipLast = (isExcludingBounds || keyRange instanceof IncludingExcludingBounds) && !keyRange.contains(partitions.get(partitions.size() - 1).partitionKey())[ CD ]
Line_6 $$ AbstractBounds<PartitionPosition> keyRange = ((PartitionRangeReadCommand) command).dataRange().keyRange()-->Line_9 $$ skipLast = (isExcludingBounds || keyRange instanceof IncludingExcludingBounds) && !keyRange.contains(partitions.get(partitions.size() - 1).partitionKey())[ FD ]
Line_4 $$ boolean skipLast = false-->Line_9 $$ skipLast = (isExcludingBounds || keyRange instanceof IncludingExcludingBounds) && !keyRange.contains(partitions.get(partitions.size() - 1).partitionKey())[ FD ]
Line_2 $$ public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, final ReadCommand command) -->Line_17 $$ return new AbstractUnfilteredPartitionIterator() [ CD ]
