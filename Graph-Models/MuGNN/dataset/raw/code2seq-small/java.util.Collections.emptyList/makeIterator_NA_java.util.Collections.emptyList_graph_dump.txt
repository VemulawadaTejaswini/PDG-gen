Line_2 $$ public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, final ReadCommand command) -->Line_7 $$ boolean skipLast = false[ CD ]
Line_2 $$ public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, final ReadCommand command) -->Line_8 $$ if (!partitions.isEmpty() && command instanceof PartitionRangeReadCommand) [ CD ]
Line_14 $$ final List<ImmutableBTreePartition> toReturn-->Line_37 $$ ImmutableBTreePartition partition = toReturn.get(idx++)[ FD ]
Line_20 $$ return new AbstractUnfilteredPartitionIterator() -->Line_43 $$ return partition.unfilteredIterator(command.columnFilter(), Slices.ALL, filter.isReversed())[ CD ]
Line_20 $$ return new AbstractUnfilteredPartitionIterator() -->Line_25 $$ return true[ CD ]
Line_9 $$ AbstractBounds<PartitionPosition> keyRange = ((PartitionRangeReadCommand) command).dataRange().keyRange()-->Line_12 $$ skipLast = (isExcludingBounds || keyRange instanceof IncludingExcludingBounds) && !keyRange.contains(partitions.get(partitions.size() - 1).partitionKey())[ FD ]
Line_11 $$ skipFirst = isExcludingBounds && !keyRange.contains(partitions.get(0).partitionKey())-->Line_15 $$ if (skipFirst || skipLast) [ FD ]
Line_38 $$ ClusteringIndexFilter filter = command.clusteringIndexFilter(partition.partitionKey())-->Line_42 $$ return filter.filter(partition.sliceableUnfilteredIterator(command.columnFilter(), filter.isReversed()))[ FD ]
Line_7 $$ boolean skipLast = false-->Line_15 $$ if (skipFirst || skipLast) [ FD ]
Line_7 $$ boolean skipLast = false-->Line_12 $$ skipLast = (isExcludingBounds || keyRange instanceof IncludingExcludingBounds) && !keyRange.contains(partitions.get(partitions.size() - 1).partitionKey())[ FD ]
Line_18 $$ toReturn = partitions-->Line_37 $$ ImmutableBTreePartition partition = toReturn.get(idx++)[ FD ]
Line_2 $$ public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, final ReadCommand command) -->Line_14 $$ final List<ImmutableBTreePartition> toReturn[ CD ]
Line_9 $$ AbstractBounds<PartitionPosition> keyRange = ((PartitionRangeReadCommand) command).dataRange().keyRange()-->Line_11 $$ skipFirst = isExcludingBounds && !keyRange.contains(partitions.get(0).partitionKey())[ FD ]
Line_15 $$ if (skipFirst || skipLast) -->Line_18 $$ toReturn = partitions[ CD ]
Line_37 $$ ImmutableBTreePartition partition = toReturn.get(idx++)-->Line_42 $$ return filter.filter(partition.sliceableUnfilteredIterator(command.columnFilter(), filter.isReversed()))[ FD ]
Line_2 $$ public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, final ReadCommand command) -->Line_20 $$ return new AbstractUnfilteredPartitionIterator() [ CD ]
Line_20 $$ return new AbstractUnfilteredPartitionIterator() -->Line_33 $$ return idx < toReturn.size()[ CD ]
Line_20 $$ return new AbstractUnfilteredPartitionIterator() -->Line_38 $$ ClusteringIndexFilter filter = command.clusteringIndexFilter(partition.partitionKey())[ CD ]
Line_2 $$ public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, final ReadCommand command) -->Line_38 $$ ClusteringIndexFilter filter = command.clusteringIndexFilter(partition.partitionKey())[ FD ]
Line_8 $$ if (!partitions.isEmpty() && command instanceof PartitionRangeReadCommand) -->Line_12 $$ skipLast = (isExcludingBounds || keyRange instanceof IncludingExcludingBounds) && !keyRange.contains(partitions.get(partitions.size() - 1).partitionKey())[ CD ]
Line_16 $$ toReturn = partitions.size() == 1 ? Collections.emptyList() : partitions.subList(skipFirst ? 1 : 0, skipLast ? partitions.size() - 1 : partitions.size())-->Line_37 $$ ImmutableBTreePartition partition = toReturn.get(idx++)[ FD ]
Line_37 $$ ImmutableBTreePartition partition = toReturn.get(idx++)-->Line_43 $$ return partition.unfilteredIterator(command.columnFilter(), Slices.ALL, filter.isReversed())[ FD ]
Line_14 $$ final List<ImmutableBTreePartition> toReturn-->Line_33 $$ return idx < toReturn.size()[ FD ]
Line_2 $$ public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, final ReadCommand command) -->Line_42 $$ return filter.filter(partition.sliceableUnfilteredIterator(command.columnFilter(), filter.isReversed()))[ FD ]
Line_8 $$ if (!partitions.isEmpty() && command instanceof PartitionRangeReadCommand) -->Line_11 $$ skipFirst = isExcludingBounds && !keyRange.contains(partitions.get(0).partitionKey())[ CD ]
Line_14 $$ final List<ImmutableBTreePartition> toReturn-->Line_18 $$ toReturn = partitions[ FD ]
Line_14 $$ final List<ImmutableBTreePartition> toReturn-->Line_16 $$ toReturn = partitions.size() == 1 ? Collections.emptyList() : partitions.subList(skipFirst ? 1 : 0, skipLast ? partitions.size() - 1 : partitions.size())[ FD ]
Line_38 $$ ClusteringIndexFilter filter = command.clusteringIndexFilter(partition.partitionKey())-->Line_43 $$ return partition.unfilteredIterator(command.columnFilter(), Slices.ALL, filter.isReversed())[ FD ]
Line_16 $$ toReturn = partitions.size() == 1 ? Collections.emptyList() : partitions.subList(skipFirst ? 1 : 0, skipLast ? partitions.size() - 1 : partitions.size())-->Line_33 $$ return idx < toReturn.size()[ FD ]
Line_2 $$ public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, final ReadCommand command) -->Line_43 $$ return partition.unfilteredIterator(command.columnFilter(), Slices.ALL, filter.isReversed())[ FD ]
Line_8 $$ if (!partitions.isEmpty() && command instanceof PartitionRangeReadCommand) -->Line_10 $$ boolean isExcludingBounds = keyRange instanceof ExcludingBounds[ CD ]
Line_16 $$ toReturn = partitions.size() == 1 ? Collections.emptyList() : partitions.subList(skipFirst ? 1 : 0, skipLast ? partitions.size() - 1 : partitions.size())-->Line_18 $$ toReturn = partitions[ FD ]
Line_20 $$ return new AbstractUnfilteredPartitionIterator() -->Line_37 $$ ImmutableBTreePartition partition = toReturn.get(idx++)[ CD ]
Line_12 $$ skipLast = (isExcludingBounds || keyRange instanceof IncludingExcludingBounds) && !keyRange.contains(partitions.get(partitions.size() - 1).partitionKey())-->Line_15 $$ if (skipFirst || skipLast) [ FD ]
Line_10 $$ boolean isExcludingBounds = keyRange instanceof ExcludingBounds-->Line_11 $$ skipFirst = isExcludingBounds && !keyRange.contains(partitions.get(0).partitionKey())[ FD ]
Line_18 $$ toReturn = partitions-->Line_33 $$ return idx < toReturn.size()[ FD ]
Line_2 $$ public UnfilteredPartitionIterator makeIterator(CFMetaData metadata, final ReadCommand command) -->Line_15 $$ if (skipFirst || skipLast) [ CD ]
Line_20 $$ return new AbstractUnfilteredPartitionIterator() -->Line_29 $$ return metadata[ CD ]
Line_15 $$ if (skipFirst || skipLast) -->Line_16 $$ toReturn = partitions.size() == 1 ? Collections.emptyList() : partitions.subList(skipFirst ? 1 : 0, skipLast ? partitions.size() - 1 : partitions.size())[ CD ]
Line_37 $$ ImmutableBTreePartition partition = toReturn.get(idx++)-->Line_38 $$ ClusteringIndexFilter filter = command.clusteringIndexFilter(partition.partitionKey())[ FD ]
Line_8 $$ if (!partitions.isEmpty() && command instanceof PartitionRangeReadCommand) -->Line_9 $$ AbstractBounds<PartitionPosition> keyRange = ((PartitionRangeReadCommand) command).dataRange().keyRange()[ CD ]
