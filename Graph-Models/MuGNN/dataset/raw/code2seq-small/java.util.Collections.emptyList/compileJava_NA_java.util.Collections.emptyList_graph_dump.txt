Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_8 $$ final Set<JpsModule> modules = chunk.getModules()[ CD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_40 $$ classpath = joined[ FD ]
Line_10 $$ if (modules.size() == 1) -->Line_13 $$ String message = validateCycle(chunk, javaExt, compilerConfig, modules)[ CD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_26 $$ final int chunkSdkVersion = getChunkSdkVersion(chunk)[ FD ]
Line_19 $$ final Map<File, Set<File>> outs = buildOutputDirectoriesMap(context, chunk)-->Line_45 $$ rc = JavacMain.compile(options, files, classpath, _platformCp, sourcePath, outs, diagnosticSink, classesConsumer, context.getCancelStatus(), compilingTool)[ FD ]
Line_10 $$ if (modules.size() == 1) -->Line_11 $$ profile = compilerConfig.getAnnotationProcessingProfile(modules.iterator().next())[ CD ]
Line_22 $$ if (LOG.isDebugEnabled()) -->Line_23 $$ LOG.debug("Compiling chunk [" + chunk.getName() + "] with options: \"" + StringUtil.join(options, " ") + "\"")[ CD ]
Line_40 $$ classpath = joined-->Line_45 $$ rc = JavacMain.compile(options, files, classpath, _platformCp, sourcePath, outs, diagnosticSink, classesConsumer, context.getCancelStatus(), compilingTool)[ FD ]
Line_44 $$ if (!shouldForkCompilerProcess(context, chunkSdkVersion)) -->Line_53 $$ final List<String> vmOptions = getCompilationVMOptions(context, compilingTool)[ CD ]
Line_43 $$ final boolean rc-->Line_45 $$ rc = JavacMain.compile(options, files, classpath, _platformCp, sourcePath, outs, diagnosticSink, classesConsumer, context.getCancelStatus(), compilingTool)[ FD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_54 $$ final ExternalJavacManager server = ensureJavacServerStarted(context)[ FD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_39 $$ joined.addAll(classpath)[ FD ]
Line_27 $$ Collection<File> _platformCp = calcEffectivePlatformCp(platformCp, options, compilingTool)-->Line_32 $$ if (chunkSdkVersion >= 9 && !_platformCp.isEmpty()) [ FD ]
Line_40 $$ classpath = joined-->Line_55 $$ rc = server.forkJavac(sdkHome, getExternalJavacHeapSize(context), vmOptions, options, _platformCp, classpath, sourcePath, files, outs, diagnosticSink, classesConsumer, compilingTool, context.getCancelStatus())[ FD ]
Line_27 $$ Collection<File> _platformCp = calcEffectivePlatformCp(platformCp, options, compilingTool)-->Line_38 $$ joined.addAll(_platformCp)[ FD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_19 $$ final Map<File, Set<File>> outs = buildOutputDirectoriesMap(context, chunk)[ FD ]
Line_8 $$ final Set<JpsModule> modules = chunk.getModules()-->Line_13 $$ String message = validateCycle(chunk, javaExt, compilerConfig, modules)[ FD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_20 $$ final List<String> options = getCompilationOptions(context, chunk, profile, compilingTool)[ CD ]
Line_14 $$ if (message != null) -->Line_16 $$ return true[ CD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_6 $$ final JpsJavaCompilerConfiguration compilerConfig = javaExt.getCompilerConfiguration(context.getProjectDescriptor().getProject())[ CD ]
Line_20 $$ final List<String> options = getCompilationOptions(context, chunk, profile, compilingTool)-->Line_45 $$ rc = JavacMain.compile(options, files, classpath, _platformCp, sourcePath, outs, diagnosticSink, classesConsumer, context.getCancelStatus(), compilingTool)[ FD ]
Line_44 $$ if (!shouldForkCompilerProcess(context, chunkSdkVersion)) -->Line_45 $$ rc = JavacMain.compile(options, files, classpath, _platformCp, sourcePath, outs, diagnosticSink, classesConsumer, context.getCancelStatus(), compilingTool)[ CD ]
Line_32 $$ if (chunkSdkVersion >= 9 && !_platformCp.isEmpty()) -->Line_38 $$ joined.addAll(_platformCp)[ CD ]
Line_26 $$ final int chunkSdkVersion = getChunkSdkVersion(chunk)-->Line_44 $$ if (!shouldForkCompilerProcess(context, chunkSdkVersion)) [ FD ]
Line_28 $$ if (_platformCp == null) -->Line_30 $$ return true[ CD ]
Line_21 $$ final ClassProcessingConsumer classesConsumer = new ClassProcessingConsumer(context, outputSink)-->Line_55 $$ rc = server.forkJavac(sdkHome, getExternalJavacHeapSize(context), vmOptions, options, _platformCp, classpath, sourcePath, files, outs, diagnosticSink, classesConsumer, compilingTool, context.getCancelStatus())[ FD ]
Line_3 $$ final TasksCounter counter = new TasksCounter()-->Line_59 $$ counter.await()[ FD ]
Line_27 $$ Collection<File> _platformCp = calcEffectivePlatformCp(platformCp, options, compilingTool)-->Line_55 $$ rc = server.forkJavac(sdkHome, getExternalJavacHeapSize(context), vmOptions, options, _platformCp, classpath, sourcePath, files, outs, diagnosticSink, classesConsumer, compilingTool, context.getCancelStatus())[ FD ]
Line_43 $$ final boolean rc-->Line_55 $$ rc = server.forkJavac(sdkHome, getExternalJavacHeapSize(context), vmOptions, options, _platformCp, classpath, sourcePath, files, outs, diagnosticSink, classesConsumer, compilingTool, context.getCancelStatus())[ FD ]
Line_44 $$ if (!shouldForkCompilerProcess(context, chunkSdkVersion)) -->Line_55 $$ rc = server.forkJavac(sdkHome, getExternalJavacHeapSize(context), vmOptions, options, _platformCp, classpath, sourcePath, files, outs, diagnosticSink, classesConsumer, compilingTool, context.getCancelStatus())[ CD ]
Line_49 $$ if (sdkHome == null) -->Line_50 $$ diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, "Cannot start javac process for " + chunk.getName() + ": unknown JDK home path.\nPlease check project configuration."))[ CD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_15 $$ diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, message))[ FD ]
Line_11 $$ profile = compilerConfig.getAnnotationProcessingProfile(modules.iterator().next())-->Line_20 $$ final List<String> options = getCompilationOptions(context, chunk, profile, compilingTool)[ FD ]
Line_49 $$ if (sdkHome == null) -->Line_51 $$ return true[ CD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_9 $$ ProcessorConfigProfile profile = null[ CD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_27 $$ Collection<File> _platformCp = calcEffectivePlatformCp(platformCp, options, compilingTool)[ FD ]
Line_27 $$ Collection<File> _platformCp = calcEffectivePlatformCp(platformCp, options, compilingTool)-->Line_28 $$ if (_platformCp == null) [ FD ]
Line_45 $$ rc = JavacMain.compile(options, files, classpath, _platformCp, sourcePath, outs, diagnosticSink, classesConsumer, context.getCancelStatus(), compilingTool)-->Line_55 $$ rc = server.forkJavac(sdkHome, getExternalJavacHeapSize(context), vmOptions, options, _platformCp, classpath, sourcePath, files, outs, diagnosticSink, classesConsumer, compilingTool, context.getCancelStatus())[ FD ]
Line_13 $$ String message = validateCycle(chunk, javaExt, compilerConfig, modules)-->Line_14 $$ if (message != null) [ FD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_13 $$ String message = validateCycle(chunk, javaExt, compilerConfig, modules)[ FD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_53 $$ final List<String> vmOptions = getCompilationVMOptions(context, compilingTool)[ FD ]
Line_27 $$ Collection<File> _platformCp = calcEffectivePlatformCp(platformCp, options, compilingTool)-->Line_45 $$ rc = JavacMain.compile(options, files, classpath, _platformCp, sourcePath, outs, diagnosticSink, classesConsumer, context.getCancelStatus(), compilingTool)[ FD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_4 $$ COUNTER_KEY.set(context, counter)[ FD ]
Line_54 $$ final ExternalJavacManager server = ensureJavacServerStarted(context)-->Line_55 $$ rc = server.forkJavac(sdkHome, getExternalJavacHeapSize(context), vmOptions, options, _platformCp, classpath, sourcePath, files, outs, diagnosticSink, classesConsumer, compilingTool, context.getCancelStatus())[ FD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_45 $$ rc = JavacMain.compile(options, files, classpath, _platformCp, sourcePath, outs, diagnosticSink, classesConsumer, context.getCancelStatus(), compilingTool)[ FD ]
Line_5 $$ final JpsJavaExtensionService javaExt = JpsJavaExtensionService.getInstance()-->Line_13 $$ String message = validateCycle(chunk, javaExt, compilerConfig, modules)[ FD ]
Line_21 $$ final ClassProcessingConsumer classesConsumer = new ClassProcessingConsumer(context, outputSink)-->Line_45 $$ rc = JavacMain.compile(options, files, classpath, _platformCp, sourcePath, outs, diagnosticSink, classesConsumer, context.getCancelStatus(), compilingTool)[ FD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_44 $$ if (!shouldForkCompilerProcess(context, chunkSdkVersion)) [ FD ]
Line_6 $$ final JpsJavaCompilerConfiguration compilerConfig = javaExt.getCompilerConfiguration(context.getProjectDescriptor().getProject())-->Line_11 $$ profile = compilerConfig.getAnnotationProcessingProfile(modules.iterator().next())[ FD ]
Line_28 $$ if (_platformCp == null) -->Line_29 $$ context.processMessage(new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.ERROR, "Compact compilation profile was requested, but target platform for module \"" + chunk.getName() + "\" differs from javac's platform (" + System.getProperty("java.version") + ")\nCompilation profiles are not supported for such configuration"))[ CD ]
Line_10 $$ if (modules.size() == 1) -->Line_14 $$ if (message != null) [ CD ]
Line_9 $$ ProcessorConfigProfile profile = null-->Line_20 $$ final List<String> options = getCompilationOptions(context, chunk, profile, compilingTool)[ FD ]
Line_44 $$ if (!shouldForkCompilerProcess(context, chunkSdkVersion)) -->Line_49 $$ if (sdkHome == null) [ CD ]
Line_27 $$ Collection<File> _platformCp = calcEffectivePlatformCp(platformCp, options, compilingTool)-->Line_41 $$ _platformCp = Collections.emptyList()[ FD ]
Line_53 $$ final List<String> vmOptions = getCompilationVMOptions(context, compilingTool)-->Line_55 $$ rc = server.forkJavac(sdkHome, getExternalJavacHeapSize(context), vmOptions, options, _platformCp, classpath, sourcePath, files, outs, diagnosticSink, classesConsumer, compilingTool, context.getCancelStatus())[ FD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_8 $$ final Set<JpsModule> modules = chunk.getModules()[ FD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_29 $$ context.processMessage(new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.ERROR, "Compact compilation profile was requested, but target platform for module \"" + chunk.getName() + "\" differs from javac's platform (" + System.getProperty("java.version") + ")\nCompilation profiles are not supported for such configuration"))[ FD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_19 $$ final Map<File, Set<File>> outs = buildOutputDirectoriesMap(context, chunk)[ CD ]
Line_41 $$ _platformCp = Collections.emptyList()-->Line_55 $$ rc = server.forkJavac(sdkHome, getExternalJavacHeapSize(context), vmOptions, options, _platformCp, classpath, sourcePath, files, outs, diagnosticSink, classesConsumer, compilingTool, context.getCancelStatus())[ FD ]
Line_19 $$ final Map<File, Set<File>> outs = buildOutputDirectoriesMap(context, chunk)-->Line_55 $$ rc = server.forkJavac(sdkHome, getExternalJavacHeapSize(context), vmOptions, options, _platformCp, classpath, sourcePath, files, outs, diagnosticSink, classesConsumer, compilingTool, context.getCancelStatus())[ FD ]
Line_8 $$ final Set<JpsModule> modules = chunk.getModules()-->Line_11 $$ profile = compilerConfig.getAnnotationProcessingProfile(modules.iterator().next())[ FD ]
Line_20 $$ final List<String> options = getCompilationOptions(context, chunk, profile, compilingTool)-->Line_55 $$ rc = server.forkJavac(sdkHome, getExternalJavacHeapSize(context), vmOptions, options, _platformCp, classpath, sourcePath, files, outs, diagnosticSink, classesConsumer, compilingTool, context.getCancelStatus())[ FD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_21 $$ final ClassProcessingConsumer classesConsumer = new ClassProcessingConsumer(context, outputSink)[ CD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_22 $$ if (LOG.isDebugEnabled()) [ CD ]
Line_8 $$ final Set<JpsModule> modules = chunk.getModules()-->Line_10 $$ if (modules.size() == 1) [ FD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_3 $$ final TasksCounter counter = new TasksCounter()[ CD ]
Line_9 $$ ProcessorConfigProfile profile = null-->Line_11 $$ profile = compilerConfig.getAnnotationProcessingProfile(modules.iterator().next())[ FD ]
Line_14 $$ if (message != null) -->Line_15 $$ diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, message))[ CD ]
Line_20 $$ final List<String> options = getCompilationOptions(context, chunk, profile, compilingTool)-->Line_23 $$ LOG.debug("Compiling chunk [" + chunk.getName() + "] with options: \"" + StringUtil.join(options, " ") + "\"")[ FD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_50 $$ diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, "Cannot start javac process for " + chunk.getName() + ": unknown JDK home path.\nPlease check project configuration."))[ FD ]
Line_41 $$ _platformCp = Collections.emptyList()-->Line_45 $$ rc = JavacMain.compile(options, files, classpath, _platformCp, sourcePath, outs, diagnosticSink, classesConsumer, context.getCancelStatus(), compilingTool)[ FD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_4 $$ COUNTER_KEY.set(context, counter)[ CD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_20 $$ final List<String> options = getCompilationOptions(context, chunk, profile, compilingTool)[ FD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_23 $$ LOG.debug("Compiling chunk [" + chunk.getName() + "] with options: \"" + StringUtil.join(options, " ") + "\"")[ FD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_5 $$ final JpsJavaExtensionService javaExt = JpsJavaExtensionService.getInstance()[ CD ]
Line_32 $$ if (chunkSdkVersion >= 9 && !_platformCp.isEmpty()) -->Line_39 $$ joined.addAll(classpath)[ CD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_10 $$ if (modules.size() == 1) [ CD ]
Line_6 $$ final JpsJavaCompilerConfiguration compilerConfig = javaExt.getCompilerConfiguration(context.getProjectDescriptor().getProject())-->Line_13 $$ String message = validateCycle(chunk, javaExt, compilerConfig, modules)[ FD ]
Line_20 $$ final List<String> options = getCompilationOptions(context, chunk, profile, compilingTool)-->Line_27 $$ Collection<File> _platformCp = calcEffectivePlatformCp(platformCp, options, compilingTool)[ FD ]
Line_3 $$ final TasksCounter counter = new TasksCounter()-->Line_4 $$ COUNTER_KEY.set(context, counter)[ FD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_6 $$ final JpsJavaCompilerConfiguration compilerConfig = javaExt.getCompilerConfiguration(context.getProjectDescriptor().getProject())[ FD ]
Line_32 $$ if (chunkSdkVersion >= 9 && !_platformCp.isEmpty()) -->Line_40 $$ classpath = joined[ CD ]
Line_5 $$ final JpsJavaExtensionService javaExt = JpsJavaExtensionService.getInstance()-->Line_6 $$ final JpsJavaCompilerConfiguration compilerConfig = javaExt.getCompilerConfiguration(context.getProjectDescriptor().getProject())[ FD ]
Line_32 $$ if (chunkSdkVersion >= 9 && !_platformCp.isEmpty()) -->Line_41 $$ _platformCp = Collections.emptyList()[ CD ]
Line_44 $$ if (!shouldForkCompilerProcess(context, chunkSdkVersion)) -->Line_54 $$ final ExternalJavacManager server = ensureJavacServerStarted(context)[ CD ]
Line_2 $$ private boolean compileJava(final CompileContext context, ModuleChunk chunk, Collection<File> files, Collection<File> classpath, Collection<File> platformCp, Collection<File> sourcePath, DiagnosticOutputConsumer diagnosticSink, final OutputFileConsumer outputSink, JavaCompilingTool compilingTool) throws Exception -->Line_55 $$ rc = server.forkJavac(sdkHome, getExternalJavacHeapSize(context), vmOptions, options, _platformCp, classpath, sourcePath, files, outs, diagnosticSink, classesConsumer, compilingTool, context.getCancelStatus())[ FD ]
