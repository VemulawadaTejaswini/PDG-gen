Line_7 $$ final MethodHandle handle = method.handle-->Line_23 $$ return handle.invokeWithArguments(parameters)[ FD ]
Line_2 $$ public static Object methodCall(final Object owner, final String name, final Definition definition, final Object[] arguments, final boolean[] typesafe) -->Line_25 $$ throw new IllegalArgumentException("Error invoking method [" + name + "] " + "with owner class [" + owner.getClass().getCanonicalName() + "].", throwable)[ FD ]
Line_16 $$ if (typesafe[count]) -->Line_20 $$ parameters[count + 1] = transform == null ? arguments[count] : transform.method.handle.invoke(arguments[count])[ CD ]
Line_2 $$ public static Object methodCall(final Object owner, final String name, final Definition definition, final Object[] arguments, final boolean[] typesafe) -->Line_9 $$ final Object[] parameters = new Object[arguments.length + 1][ CD ]
Line_8 $$ final List<Type> types = method.arguments-->Line_12 $$ throw new IllegalArgumentException("When dynamically calling [" + name + "] from class " + "[" + owner.getClass() + "] expected [" + types.size() + "] arguments," + " but found [" + arguments.length + "].")[ FD ]
Line_2 $$ public static Object methodCall(final Object owner, final String name, final Definition definition, final Object[] arguments, final boolean[] typesafe) -->Line_19 $$ final Transform transform = getTransform(arguments[count].getClass(), types.get(count).clazz, definition)[ FD ]
Line_2 $$ public static Object methodCall(final Object owner, final String name, final Definition definition, final Object[] arguments, final boolean[] typesafe) -->Line_3 $$ final Method method = getMethod(owner, name, definition)[ CD ]
Line_2 $$ public static Object methodCall(final Object owner, final String name, final Definition definition, final Object[] arguments, final boolean[] typesafe) -->Line_4 $$ if (method == null) [ CD ]
Line_2 $$ public static Object methodCall(final Object owner, final String name, final Definition definition, final Object[] arguments, final boolean[] typesafe) -->Line_12 $$ throw new IllegalArgumentException("When dynamically calling [" + name + "] from class " + "[" + owner.getClass() + "] expected [" + types.size() + "] arguments," + " but found [" + arguments.length + "].")[ FD ]
Line_2 $$ public static Object methodCall(final Object owner, final String name, final Definition definition, final Object[] arguments, final boolean[] typesafe) -->Line_10 $$ parameters[0] = owner[ CD ]
Line_2 $$ public static Object methodCall(final Object owner, final String name, final Definition definition, final Object[] arguments, final boolean[] typesafe) -->Line_10 $$ parameters[0] = owner[ FD ]
Line_2 $$ public static Object methodCall(final Object owner, final String name, final Definition definition, final Object[] arguments, final boolean[] typesafe) -->Line_5 $$ throw new IllegalArgumentException("Unable to find dynamic method [" + name + "] " + "for class [" + owner.getClass().getCanonicalName() + "].")[ FD ]
Line_2 $$ public static Object methodCall(final Object owner, final String name, final Definition definition, final Object[] arguments, final boolean[] typesafe) -->Line_11 $$ if (types.size() != arguments.length) [ CD ]
Line_8 $$ final List<Type> types = method.arguments-->Line_19 $$ final Transform transform = getTransform(arguments[count].getClass(), types.get(count).clazz, definition)[ FD ]
Line_15 $$ for (int count = 0; count < arguments.length; ++count) -->Line_19 $$ final Transform transform = getTransform(arguments[count].getClass(), types.get(count).clazz, definition)[ FD ]
Line_2 $$ public static Object methodCall(final Object owner, final String name, final Definition definition, final Object[] arguments, final boolean[] typesafe) -->Line_3 $$ final Method method = getMethod(owner, name, definition)[ FD ]
Line_9 $$ final Object[] parameters = new Object[arguments.length + 1]-->Line_23 $$ return handle.invokeWithArguments(parameters)[ FD ]
Line_3 $$ final Method method = getMethod(owner, name, definition)-->Line_4 $$ if (method == null) [ FD ]
Line_15 $$ for (int count = 0; count < arguments.length; ++count) -->Line_16 $$ if (typesafe[count]) [ CD ]
Line_15 $$ for (int count = 0; count < arguments.length; ++count) -->Line_16 $$ if (typesafe[count]) [ FD ]
Line_8 $$ final List<Type> types = method.arguments-->Line_11 $$ if (types.size() != arguments.length) [ FD ]
Line_2 $$ public static Object methodCall(final Object owner, final String name, final Definition definition, final Object[] arguments, final boolean[] typesafe) -->Line_8 $$ final List<Type> types = method.arguments[ CD ]
Line_16 $$ if (typesafe[count]) -->Line_17 $$ parameters[count + 1] = arguments[count][ CD ]
Line_2 $$ public static Object methodCall(final Object owner, final String name, final Definition definition, final Object[] arguments, final boolean[] typesafe) -->Line_16 $$ if (typesafe[count]) [ FD ]
Line_2 $$ public static Object methodCall(final Object owner, final String name, final Definition definition, final Object[] arguments, final boolean[] typesafe) -->Line_7 $$ final MethodHandle handle = method.handle[ CD ]
Line_16 $$ if (typesafe[count]) -->Line_19 $$ final Transform transform = getTransform(arguments[count].getClass(), types.get(count).clazz, definition)[ CD ]
