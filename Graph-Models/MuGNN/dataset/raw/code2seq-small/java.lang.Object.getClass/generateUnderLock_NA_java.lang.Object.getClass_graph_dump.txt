Line_47 $$ if (property.injector) -->Line_48 $$ builder.addInjectorProperty(property)[ CD ]
Line_21 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_107 $$ subclass = builder.generate()[ FD ]
Line_33 $$ if (classMetaData.conventionAware && !IConventionAware.class.isAssignableFrom(type)) -->Line_34 $$ builder.mixInConventionAware()[ CD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_3 $$ Map<Class<?>, Class<?>> cache = GENERATED_CLASSES.get(getClass())[ CD ]
Line_21 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_76 $$ builder.applyConventionMappingToSetter(property, setter)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_12 $$ if (Modifier.isPrivate(type.getModifiers())) [ CD ]
Line_9 $$ if (generatedClass != null) -->Line_10 $$ return generatedClass.asSubclass(type)[ CD ]
Line_8 $$ Class<?> generatedClass = cache.get(type)-->Line_10 $$ return generatedClass.asSubclass(type)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_15 $$ if (Modifier.isAbstract(type.getModifiers())) [ CD ]
Line_107 $$ subclass = builder.generate()-->Line_112 $$ cache.put(subclass, subclass)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_16 $$ throw new GradleException(String.format("Cannot create a proxy class for abstract class '%s'.", type.getSimpleName()))[ FD ]
Line_3 $$ Map<Class<?>, Class<?>> cache = GENERATED_CLASSES.get(getClass())-->Line_6 $$ GENERATED_CLASSES.put(getClass(), cache)[ FD ]
Line_43 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_98 $$ builder.applyConventionMappingToSetMethod(property, setMethod)[ FD ]
Line_21 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_70 $$ builder.applyConventionMappingToGetter(property, getter)[ FD ]
Line_3 $$ Map<Class<?>, Class<?>> cache = GENERATED_CLASSES.get(getClass())-->Line_4 $$ if (cache == null) [ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_15 $$ if (Modifier.isAbstract(type.getModifiers())) [ FD ]
Line_82 $$ for (Method method : actionMethods) -->Line_83 $$ builder.addActionMethod(method)[ FD ]
Line_21 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_34 $$ builder.mixInConventionAware()[ FD ]
Line_52 $$ for (Method setter : property.setters) -->Line_76 $$ builder.applyConventionMappingToSetter(property, setter)[ FD ]
Line_5 $$ cache = new ReferenceMap(AbstractReferenceMap.WEAK, AbstractReferenceMap.WEAK)-->Line_111 $$ cache.put(type, subclass)[ FD ]
Line_49 $$ for (Method getter : property.getters) -->Line_50 $$ builder.applyServiceInjectionToGetter(property, getter)[ FD ]
Line_21 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_94 $$ builder.addSetMethod(property, setter)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_9 $$ if (generatedClass != null) [ CD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_102 $$ for (Constructor<?> constructor : type.getConstructors()) [ FD ]
Line_21 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_27 $$ builder.mixInDynamicAware()[ FD ]
Line_43 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_67 $$ conventionProperties.add(property)[ FD ]
Line_37 $$ for (Class<?> c = type; c != null && noMappingClass == Object.class; c = c.getSuperclass()) -->Line_38 $$ if (c.getAnnotation(NoConventionMapping.class) != null) [ CD ]
Line_107 $$ subclass = builder.generate()-->Line_111 $$ cache.put(type, subclass)[ FD ]
Line_92 $$ if (property.setMethods.isEmpty()) -->Line_96 $$ if (conventionProperties.contains(property)) [ CD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_8 $$ Class<?> generatedClass = cache.get(type)[ CD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_112 $$ cache.put(subclass, subclass)[ CD ]
Line_18 $$ Class<? extends T> subclass-->Line_111 $$ cache.put(type, subclass)[ FD ]
Line_38 $$ if (c.getAnnotation(NoConventionMapping.class) != null) -->Line_39 $$ noMappingClass = c[ CD ]
Line_21 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_48 $$ builder.addInjectorProperty(property)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_29 $$ if (!GroovyObject.class.isAssignableFrom(type)) [ FD ]
Line_21 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_32 $$ builder.addDynamicMethods()[ FD ]
Line_36 $$ Class noMappingClass = Object.class-->Line_39 $$ noMappingClass = c[ FD ]
Line_37 $$ for (Class<?> c = type; c != null && noMappingClass == Object.class; c = c.getSuperclass()) -->Line_39 $$ noMappingClass = c[ FD ]
Line_52 $$ for (Method setter : property.setters) -->Line_75 $$ if (!Modifier.isFinal(setter.getModifiers())) [ FD ]
Line_20 $$ ClassMetaData classMetaData = inspectType(type)-->Line_58 $$ if (classMetaData.isExtensible()) [ FD ]
Line_4 $$ if (cache == null) -->Line_5 $$ cache = new ReferenceMap(AbstractReferenceMap.WEAK, AbstractReferenceMap.WEAK)[ CD ]
Line_18 $$ Class<? extends T> subclass-->Line_107 $$ subclass = builder.generate()[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_12 $$ if (Modifier.isPrivate(type.getModifiers())) [ FD ]
Line_43 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_47 $$ if (property.injector) [ FD ]
Line_21 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_22 $$ builder.startClass()[ FD ]
Line_43 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_94 $$ builder.addSetMethod(property, setter)[ FD ]
Line_49 $$ for (Method getter : property.getters) -->Line_70 $$ builder.applyConventionMappingToGetter(property, getter)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_10 $$ return generatedClass.asSubclass(type)[ FD ]
Line_66 $$ if (needsConventionMapping) -->Line_68 $$ builder.addConventionProperty(property)[ CD ]
Line_102 $$ for (Constructor<?> constructor : type.getConstructors()) -->Line_103 $$ if (Modifier.isPublic(constructor.getModifiers())) [ FD ]
Line_3 $$ Map<Class<?>, Class<?>> cache = GENERATED_CLASSES.get(getClass())-->Line_112 $$ cache.put(subclass, subclass)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_111 $$ cache.put(type, subclass)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_33 $$ if (classMetaData.conventionAware && !IConventionAware.class.isAssignableFrom(type)) [ FD ]
Line_3 $$ Map<Class<?>, Class<?>> cache = GENERATED_CLASSES.get(getClass())-->Line_8 $$ Class<?> generatedClass = cache.get(type)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_13 $$ throw new GradleException(String.format("Cannot create a proxy class for private class '%s'.", type.getSimpleName()))[ FD ]
Line_43 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_96 $$ if (conventionProperties.contains(property)) [ FD ]
Line_103 $$ if (Modifier.isPublic(constructor.getModifiers())) -->Line_104 $$ builder.addConstructor(constructor)[ CD ]
Line_43 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_70 $$ builder.applyConventionMappingToGetter(property, getter)[ FD ]
Line_21 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_50 $$ builder.applyServiceInjectionToGetter(property, getter)[ FD ]
Line_21 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_68 $$ builder.addConventionProperty(property)[ FD ]
Line_39 $$ noMappingClass = c-->Line_60 $$ if (!Modifier.isFinal(getter.getModifiers()) && !getter.getDeclaringClass().isAssignableFrom(noMappingClass)) [ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_23 $$ if (!DynamicObjectAware.class.isAssignableFrom(type)) [ FD ]
Line_49 $$ for (Method getter : property.getters) -->Line_60 $$ if (!Modifier.isFinal(getter.getModifiers()) && !getter.getDeclaringClass().isAssignableFrom(noMappingClass)) [ FD ]
Line_43 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_89 $$ if (Iterable.class.isAssignableFrom(property.getType())) [ FD ]
Line_43 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_50 $$ builder.applyServiceInjectionToGetter(property, getter)[ FD ]
Line_8 $$ Class<?> generatedClass = cache.get(type)-->Line_9 $$ if (generatedClass != null) [ FD ]
Line_23 $$ if (!DynamicObjectAware.class.isAssignableFrom(type)) -->Line_24 $$ if (ExtensionAware.class.isAssignableFrom(type)) [ CD ]
Line_52 $$ for (Method setter : property.setters) -->Line_94 $$ builder.addSetMethod(property, setter)[ FD ]
Line_5 $$ cache = new ReferenceMap(AbstractReferenceMap.WEAK, AbstractReferenceMap.WEAK)-->Line_8 $$ Class<?> generatedClass = cache.get(type)[ FD ]
Line_4 $$ if (cache == null) -->Line_6 $$ GENERATED_CLASSES.put(getClass(), cache)[ CD ]
Line_21 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_83 $$ builder.addActionMethod(method)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_113 $$ return subclass[ CD ]
Line_102 $$ for (Constructor<?> constructor : type.getConstructors()) -->Line_104 $$ builder.addConstructor(constructor)[ FD ]
Line_37 $$ for (Class<?> c = type; c != null && noMappingClass == Object.class; c = c.getSuperclass()) -->Line_38 $$ if (c.getAnnotation(NoConventionMapping.class) != null) [ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_111 $$ cache.put(type, subclass)[ CD ]
Line_3 $$ Map<Class<?>, Class<?>> cache = GENERATED_CLASSES.get(getClass())-->Line_111 $$ cache.put(type, subclass)[ FD ]
Line_57 $$ boolean needsConventionMapping = false-->Line_61 $$ needsConventionMapping = true[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_20 $$ ClassMetaData classMetaData = inspectType(type)[ FD ]
Line_29 $$ if (!GroovyObject.class.isAssignableFrom(type)) -->Line_30 $$ builder.mixInGroovyObject()[ CD ]
Line_43 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_53 $$ builder.applyServiceInjectionToSetter(property, setter)[ FD ]
Line_97 $$ for (Method setMethod : property.setMethods) -->Line_98 $$ builder.applyConventionMappingToSetMethod(property, setMethod)[ FD ]
Line_5 $$ cache = new ReferenceMap(AbstractReferenceMap.WEAK, AbstractReferenceMap.WEAK)-->Line_112 $$ cache.put(subclass, subclass)[ FD ]
Line_75 $$ if (!Modifier.isFinal(setter.getModifiers())) -->Line_76 $$ builder.applyConventionMappingToSetter(property, setter)[ CD ]
Line_66 $$ if (needsConventionMapping) -->Line_67 $$ conventionProperties.add(property)[ CD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_21 $$ ClassBuilder<T> builder = start(type, classMetaData)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_8 $$ Class<?> generatedClass = cache.get(type)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_4 $$ if (cache == null) [ CD ]
Line_18 $$ Class<? extends T> subclass-->Line_112 $$ cache.put(subclass, subclass)[ FD ]
Line_21 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_104 $$ builder.addConstructor(constructor)[ FD ]
Line_42 $$ Set<PropertyMetaData> conventionProperties = new HashSet<PropertyMetaData>()-->Line_67 $$ conventionProperties.add(property)[ FD ]
Line_21 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_30 $$ builder.mixInGroovyObject()[ FD ]
Line_52 $$ for (Method setter : property.setters) -->Line_53 $$ builder.applyServiceInjectionToSetter(property, setter)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_24 $$ if (ExtensionAware.class.isAssignableFrom(type)) [ FD ]
Line_43 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_48 $$ builder.addInjectorProperty(property)[ FD ]
Line_3 $$ Map<Class<?>, Class<?>> cache = GENERATED_CLASSES.get(getClass())-->Line_5 $$ cache = new ReferenceMap(AbstractReferenceMap.WEAK, AbstractReferenceMap.WEAK)[ FD ]
Line_21 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_53 $$ builder.applyServiceInjectionToSetter(property, setter)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_109 $$ throw new GradleException(String.format("Could not generate a proxy class for class %s.", type.getName()), e)[ FD ]
Line_36 $$ Class noMappingClass = Object.class-->Line_60 $$ if (!Modifier.isFinal(getter.getModifiers()) && !getter.getDeclaringClass().isAssignableFrom(noMappingClass)) [ FD ]
Line_60 $$ if (!Modifier.isFinal(getter.getModifiers()) && !getter.getDeclaringClass().isAssignableFrom(noMappingClass)) -->Line_61 $$ needsConventionMapping = true[ CD ]
Line_5 $$ cache = new ReferenceMap(AbstractReferenceMap.WEAK, AbstractReferenceMap.WEAK)-->Line_6 $$ GENERATED_CLASSES.put(getClass(), cache)[ FD ]
Line_21 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_98 $$ builder.applyConventionMappingToSetMethod(property, setMethod)[ FD ]
Line_43 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_76 $$ builder.applyConventionMappingToSetter(property, setter)[ FD ]
Line_43 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_68 $$ builder.addConventionProperty(property)[ FD ]
Line_20 $$ ClassMetaData classMetaData = inspectType(type)-->Line_21 $$ ClassBuilder<T> builder = start(type, classMetaData)[ FD ]
Line_42 $$ Set<PropertyMetaData> conventionProperties = new HashSet<PropertyMetaData>()-->Line_96 $$ if (conventionProperties.contains(property)) [ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_18 $$ Class<? extends T> subclass[ CD ]
Line_23 $$ if (!DynamicObjectAware.class.isAssignableFrom(type)) -->Line_27 $$ builder.mixInDynamicAware()[ CD ]
