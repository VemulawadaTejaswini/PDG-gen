Line_2 $$ public void testMultipleCachingEval() throws Exception -->Line_6 $$ Collection<ConcurrentMapCache> caches = Collections.singleton(new ConcurrentMapCache("test"))[ CD ]
Line_9 $$ Iterator<CacheOperation> it = ops.iterator()-->Line_11 $$ Object keyA = eval.key(it.next().getKey(), key, evalCtx)[ FD ]
Line_10 $$ AnnotatedElementKey key = new AnnotatedElementKey(method, AnnotatedClass.class)-->Line_12 $$ Object keyB = eval.key(it.next().getKey(), key, evalCtx)[ FD ]
Line_4 $$ Method method = ReflectionUtils.findMethod(AnnotatedClass.class, "multipleCaching", Object.class, Object.class)-->Line_7 $$ EvaluationContext evalCtx = eval.createEvaluationContext(caches, method, args, target, target.getClass(), null)[ FD ]
Line_3 $$ AnnotatedClass target = new AnnotatedClass()-->Line_7 $$ EvaluationContext evalCtx = eval.createEvaluationContext(caches, method, args, target, target.getClass(), null)[ FD ]
Line_2 $$ public void testMultipleCachingEval() throws Exception -->Line_13 $$ assertEquals(args[0], keyA)[ CD ]
Line_2 $$ public void testMultipleCachingEval() throws Exception -->Line_5 $$ Object[] args = new Object[] [ CD ]
Line_12 $$ Object keyB = eval.key(it.next().getKey(), key, evalCtx)-->Line_14 $$ assertEquals(args[1], keyB)[ FD ]
Line_8 $$ Collection<CacheOperation> ops = getOps("multipleCaching")-->Line_9 $$ Iterator<CacheOperation> it = ops.iterator()[ FD ]
Line_2 $$ public void testMultipleCachingEval() throws Exception -->Line_8 $$ Collection<CacheOperation> ops = getOps("multipleCaching")[ CD ]
Line_6 $$ Collection<ConcurrentMapCache> caches = Collections.singleton(new ConcurrentMapCache("test"))-->Line_7 $$ EvaluationContext evalCtx = eval.createEvaluationContext(caches, method, args, target, target.getClass(), null)[ FD ]
Line_2 $$ public void testMultipleCachingEval() throws Exception -->Line_9 $$ Iterator<CacheOperation> it = ops.iterator()[ CD ]
Line_2 $$ public void testMultipleCachingEval() throws Exception -->Line_11 $$ Object keyA = eval.key(it.next().getKey(), key, evalCtx)[ CD ]
Line_11 $$ Object keyA = eval.key(it.next().getKey(), key, evalCtx)-->Line_13 $$ assertEquals(args[0], keyA)[ FD ]
Line_2 $$ public void testMultipleCachingEval() throws Exception -->Line_3 $$ AnnotatedClass target = new AnnotatedClass()[ CD ]
Line_7 $$ EvaluationContext evalCtx = eval.createEvaluationContext(caches, method, args, target, target.getClass(), null)-->Line_11 $$ Object keyA = eval.key(it.next().getKey(), key, evalCtx)[ FD ]
Line_2 $$ public void testMultipleCachingEval() throws Exception -->Line_14 $$ assertEquals(args[1], keyB)[ CD ]
Line_2 $$ public void testMultipleCachingEval() throws Exception -->Line_4 $$ Method method = ReflectionUtils.findMethod(AnnotatedClass.class, "multipleCaching", Object.class, Object.class)[ CD ]
Line_10 $$ AnnotatedElementKey key = new AnnotatedElementKey(method, AnnotatedClass.class)-->Line_11 $$ Object keyA = eval.key(it.next().getKey(), key, evalCtx)[ FD ]
Line_2 $$ public void testMultipleCachingEval() throws Exception -->Line_10 $$ AnnotatedElementKey key = new AnnotatedElementKey(method, AnnotatedClass.class)[ CD ]
Line_2 $$ public void testMultipleCachingEval() throws Exception -->Line_7 $$ EvaluationContext evalCtx = eval.createEvaluationContext(caches, method, args, target, target.getClass(), null)[ CD ]
Line_5 $$ Object[] args = new Object[] -->Line_7 $$ EvaluationContext evalCtx = eval.createEvaluationContext(caches, method, args, target, target.getClass(), null)[ FD ]
Line_9 $$ Iterator<CacheOperation> it = ops.iterator()-->Line_12 $$ Object keyB = eval.key(it.next().getKey(), key, evalCtx)[ FD ]
Line_7 $$ EvaluationContext evalCtx = eval.createEvaluationContext(caches, method, args, target, target.getClass(), null)-->Line_12 $$ Object keyB = eval.key(it.next().getKey(), key, evalCtx)[ FD ]
Line_2 $$ public void testMultipleCachingEval() throws Exception -->Line_12 $$ Object keyB = eval.key(it.next().getKey(), key, evalCtx)[ CD ]
