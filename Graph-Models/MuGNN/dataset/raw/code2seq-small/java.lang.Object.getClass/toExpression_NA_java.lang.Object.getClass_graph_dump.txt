Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_17 $$ if (type.equals(DOUBLE)) [ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_48 $$ Signature signature = FunctionRegistry.getMagicLiteralFunctionSignature(type)[ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_15 $$ return new LongLiteral(object.toString())[ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_52 $$ Expression rawLiteral = toExpression(object, FunctionRegistry.typeForMagicLiteral(type))[ CD ]
Line_46 $$ if (object instanceof Slice && !type.equals(VARCHAR)) -->Line_48 $$ Signature signature = FunctionRegistry.getMagicLiteralFunctionSignature(type)[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_52 $$ Expression rawLiteral = toExpression(object, FunctionRegistry.typeForMagicLiteral(type))[ FD ]
Line_46 $$ if (object instanceof Slice && !type.equals(VARCHAR)) -->Line_47 $$ FunctionCall fromBase64 = new FunctionCall(new QualifiedName("from_base64"), ImmutableList.of(new StringLiteral(VarbinaryFunctions.toBase64((Slice) object).toStringUtf8())))[ CD ]
Line_42 $$ SliceOutput output = new DynamicSliceOutput(((Block) object).getSizeInBytes())-->Line_43 $$ BlockSerdeUtil.writeBlock(output, (Block) object)[ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_8 $$ if (type.equals(UNKNOWN)) [ FD ]
Line_19 $$ if (value.isNaN()) -->Line_21 $$ if (value.equals(Double.NEGATIVE_INFINITY)) [ CD ]
Line_47 $$ FunctionCall fromBase64 = new FunctionCall(new QualifiedName("from_base64"), ImmutableList.of(new StringLiteral(VarbinaryFunctions.toBase64((Slice) object).toStringUtf8())))-->Line_49 $$ return new FunctionCall(new QualifiedName(signature.getName()), ImmutableList.of(fromBase64))[ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_11 $$ return new Cast(new NullLiteral(), type.getTypeSignature().toString())[ FD ]
Line_29 $$ if (type.equals(VARCHAR)) -->Line_30 $$ if (object instanceof Slice) [ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_41 $$ if (object instanceof Block) [ CD ]
Line_52 $$ Expression rawLiteral = toExpression(object, FunctionRegistry.typeForMagicLiteral(type))-->Line_53 $$ return new FunctionCall(new QualifiedName(signature.getName()), ImmutableList.of(rawLiteral))[ FD ]
Line_19 $$ if (value.isNaN()) -->Line_20 $$ return new FunctionCall(new QualifiedName("nan"), ImmutableList.<Expression>of())[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_41 $$ if (object instanceof Block) [ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_44 $$ object = output.slice()[ FD ]
Line_8 $$ if (type.equals(UNKNOWN)) -->Line_9 $$ return new NullLiteral()[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_26 $$ return new DoubleLiteral(object.toString())[ FD ]
Line_17 $$ if (type.equals(DOUBLE)) -->Line_18 $$ Double value = (Double) object[ CD ]
Line_18 $$ Double value = (Double) object-->Line_19 $$ if (value.isNaN()) [ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_14 $$ if (type.equals(BIGINT)) [ FD ]
Line_21 $$ if (value.equals(Double.NEGATIVE_INFINITY)) -->Line_23 $$ if (value.equals(Double.POSITIVE_INFINITY)) [ CD ]
Line_41 $$ if (object instanceof Block) -->Line_43 $$ BlockSerdeUtil.writeBlock(output, (Block) object)[ CD ]
Line_46 $$ if (object instanceof Slice && !type.equals(VARCHAR)) -->Line_49 $$ return new FunctionCall(new QualifiedName(signature.getName()), ImmutableList.of(fromBase64))[ CD ]
Line_44 $$ object = output.slice()-->Line_52 $$ Expression rawLiteral = toExpression(object, FunctionRegistry.typeForMagicLiteral(type))[ FD ]
Line_48 $$ Signature signature = FunctionRegistry.getMagicLiteralFunctionSignature(type)-->Line_49 $$ return new FunctionCall(new QualifiedName(signature.getName()), ImmutableList.of(fromBase64))[ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_38 $$ if (type.equals(BOOLEAN)) [ CD ]
Line_18 $$ Double value = (Double) object-->Line_21 $$ if (value.equals(Double.NEGATIVE_INFINITY)) [ FD ]
Line_23 $$ if (value.equals(Double.POSITIVE_INFINITY)) -->Line_26 $$ return new DoubleLiteral(object.toString())[ CD ]
Line_21 $$ if (value.equals(Double.NEGATIVE_INFINITY)) -->Line_22 $$ return ArithmeticUnaryExpression.negative(new FunctionCall(new QualifiedName("infinity"), ImmutableList.<Expression>of()))[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_33 $$ if (object instanceof String) [ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_46 $$ if (object instanceof Slice && !type.equals(VARCHAR)) [ FD ]
Line_7 $$ if (object == null) -->Line_11 $$ return new Cast(new NullLiteral(), type.getTypeSignature().toString())[ CD ]
Line_48 $$ Signature signature = FunctionRegistry.getMagicLiteralFunctionSignature(type)-->Line_53 $$ return new FunctionCall(new QualifiedName(signature.getName()), ImmutableList.of(rawLiteral))[ FD ]
Line_14 $$ if (type.equals(BIGINT)) -->Line_15 $$ return new LongLiteral(object.toString())[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_46 $$ if (object instanceof Slice && !type.equals(VARCHAR)) [ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_51 $$ Signature signature = FunctionRegistry.getMagicLiteralFunctionSignature(type)[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_14 $$ if (type.equals(BIGINT)) [ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_30 $$ if (object instanceof Slice) [ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_7 $$ if (object == null) [ CD ]
Line_30 $$ if (object instanceof Slice) -->Line_31 $$ return new StringLiteral(((Slice) object).toStringUtf8())[ CD ]
Line_38 $$ if (type.equals(BOOLEAN)) -->Line_39 $$ return new BooleanLiteral(object.toString())[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_17 $$ if (type.equals(DOUBLE)) [ FD ]
Line_29 $$ if (type.equals(VARCHAR)) -->Line_33 $$ if (object instanceof String) [ CD ]
Line_17 $$ if (type.equals(DOUBLE)) -->Line_19 $$ if (value.isNaN()) [ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_4 $$ if (object instanceof Expression) [ CD ]
Line_18 $$ Double value = (Double) object-->Line_23 $$ if (value.equals(Double.POSITIVE_INFINITY)) [ FD ]
Line_33 $$ if (object instanceof String) -->Line_34 $$ return new StringLiteral((String) object)[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_39 $$ return new BooleanLiteral(object.toString())[ FD ]
Line_41 $$ if (object instanceof Block) -->Line_44 $$ object = output.slice()[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_29 $$ if (type.equals(VARCHAR)) [ FD ]
Line_7 $$ if (object == null) -->Line_8 $$ if (type.equals(UNKNOWN)) [ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_3 $$ requireNonNull(type, "type is null")[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_38 $$ if (type.equals(BOOLEAN)) [ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_53 $$ return new FunctionCall(new QualifiedName(signature.getName()), ImmutableList.of(rawLiteral))[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_51 $$ Signature signature = FunctionRegistry.getMagicLiteralFunctionSignature(type)[ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_4 $$ if (object instanceof Expression) [ FD ]
Line_41 $$ if (object instanceof Block) -->Line_42 $$ SliceOutput output = new DynamicSliceOutput(((Block) object).getSizeInBytes())[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_13 $$ checkArgument(Primitives.wrap(type.getJavaType()).isInstance(object), "object.getClass (%s) and type.getJavaType (%s) do not agree", object.getClass(), type.getJavaType())[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_7 $$ if (object == null) [ FD ]
Line_42 $$ SliceOutput output = new DynamicSliceOutput(((Block) object).getSizeInBytes())-->Line_44 $$ object = output.slice()[ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_13 $$ checkArgument(Primitives.wrap(type.getJavaType()).isInstance(object), "object.getClass (%s) and type.getJavaType (%s) do not agree", object.getClass(), type.getJavaType())[ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_29 $$ if (type.equals(VARCHAR)) [ CD ]
Line_4 $$ if (object instanceof Expression) -->Line_5 $$ return (Expression) object[ CD ]
Line_23 $$ if (value.equals(Double.POSITIVE_INFINITY)) -->Line_24 $$ return new FunctionCall(new QualifiedName("infinity"), ImmutableList.<Expression>of())[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_3 $$ requireNonNull(type, "type is null")[ FD ]
