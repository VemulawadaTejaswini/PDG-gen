Line_9 $$ beanName = scopedBeanName-->Line_28 $$ beanFactory.setCurrentlyInCreation(beanName, false)[ FD ]
Line_2 $$ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy) throws Throwable -->Line_12 $$ if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) && factoryContainsBean(beanFactory, beanName)) [ CD ]
Line_2 $$ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy) throws Throwable -->Line_23 $$ return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)[ FD ]
Line_2 $$ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy) throws Throwable -->Line_3 $$ ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)[ CD ]
Line_4 $$ String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)-->Line_28 $$ beanFactory.setCurrentlyInCreation(beanName, false)[ FD ]
Line_9 $$ beanName = scopedBeanName-->Line_12 $$ if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) && factoryContainsBean(beanFactory, beanName)) [ FD ]
Line_2 $$ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy) throws Throwable -->Line_21 $$ logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " + "assignable to Spring's BeanFactoryPostProcessor interface. This will " + "result in a failure to process annotations such as @Autowired, " + "@Resource and @PostConstruct within the method's declaring " + "@Configuration class. Add the 'static' modifier to this method to avoid " + "these container lifecycle issues; see @Bean javadoc for complete details.", beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))[ FD ]
Line_9 $$ beanName = scopedBeanName-->Line_30 $$ Object beanInstance = (!ObjectUtils.isEmpty(beanMethodArgs) ? beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName))[ FD ]
Line_2 $$ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy) throws Throwable -->Line_5 $$ Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)[ CD ]
Line_2 $$ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy) throws Throwable -->Line_20 $$ if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) [ FD ]
Line_3 $$ ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)-->Line_30 $$ Object beanInstance = (!ObjectUtils.isEmpty(beanMethodArgs) ? beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName))[ FD ]
Line_9 $$ beanName = scopedBeanName-->Line_34 $$ BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName)[ FD ]
Line_14 $$ if (factoryBean instanceof ScopedProxyFactoryBean) -->Line_16 $$ return enhanceFactoryBean(factoryBean, beanFactory, beanName)[ CD ]
Line_4 $$ String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)-->Line_12 $$ if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) && factoryContainsBean(beanFactory, beanName)) [ FD ]
Line_4 $$ String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)-->Line_34 $$ BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName)[ FD ]
Line_3 $$ ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)-->Line_16 $$ return enhanceFactoryBean(factoryBean, beanFactory, beanName)[ FD ]
Line_8 $$ if (beanFactory.isCurrentlyInCreation(scopedBeanName)) -->Line_9 $$ beanName = scopedBeanName[ CD ]
Line_9 $$ beanName = scopedBeanName-->Line_25 $$ boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)[ FD ]
Line_2 $$ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy) throws Throwable -->Line_19 $$ if (isCurrentlyInvokedFactoryMethod(beanMethod)) [ FD ]
Line_13 $$ Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)-->Line_14 $$ if (factoryBean instanceof ScopedProxyFactoryBean) [ FD ]
Line_2 $$ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy) throws Throwable -->Line_5 $$ Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)[ FD ]
Line_9 $$ beanName = scopedBeanName-->Line_16 $$ return enhanceFactoryBean(factoryBean, beanFactory, beanName)[ FD ]
Line_20 $$ if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) -->Line_21 $$ logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " + "assignable to Spring's BeanFactoryPostProcessor interface. This will " + "result in a failure to process annotations such as @Autowired, " + "@Resource and @PostConstruct within the method's declaring " + "@Configuration class. Add the 'static' modifier to this method to avoid " + "these container lifecycle issues; see @Bean javadoc for complete details.", beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()))[ CD ]
Line_3 $$ ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)-->Line_12 $$ if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) && factoryContainsBean(beanFactory, beanName)) [ FD ]
Line_19 $$ if (isCurrentlyInvokedFactoryMethod(beanMethod)) -->Line_25 $$ boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)[ CD ]
Line_4 $$ String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)-->Line_30 $$ Object beanInstance = (!ObjectUtils.isEmpty(beanMethodArgs) ? beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName))[ FD ]
Line_3 $$ ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)-->Line_28 $$ beanFactory.setCurrentlyInCreation(beanName, false)[ FD ]
Line_2 $$ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy) throws Throwable -->Line_30 $$ Object beanInstance = (!ObjectUtils.isEmpty(beanMethodArgs) ? beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName))[ FD ]
Line_2 $$ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy) throws Throwable -->Line_3 $$ ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)[ FD ]
Line_7 $$ String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)-->Line_8 $$ if (beanFactory.isCurrentlyInCreation(scopedBeanName)) [ FD ]
Line_5 $$ Scope scope = AnnotationUtils.findAnnotation(beanMethod, Scope.class)-->Line_6 $$ if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) [ FD ]
Line_4 $$ String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)-->Line_7 $$ String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)[ FD ]
Line_12 $$ if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) && factoryContainsBean(beanFactory, beanName)) -->Line_14 $$ if (factoryBean instanceof ScopedProxyFactoryBean) [ CD ]
Line_19 $$ if (isCurrentlyInvokedFactoryMethod(beanMethod)) -->Line_20 $$ if (BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) [ CD ]
Line_34 $$ BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName)-->Line_35 $$ msg += " Overriding bean of same name declared in: " + beanDefinition.getResourceDescription()[ FD ]
Line_6 $$ if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) -->Line_7 $$ String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)[ CD ]
Line_3 $$ ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)-->Line_43 $$ beanFactory.setCurrentlyInCreation(beanName, true)[ FD ]
Line_19 $$ if (isCurrentlyInvokedFactoryMethod(beanMethod)) -->Line_23 $$ return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs)[ CD ]
Line_2 $$ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy) throws Throwable -->Line_6 $$ if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) [ CD ]
Line_30 $$ Object beanInstance = (!ObjectUtils.isEmpty(beanMethodArgs) ? beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName))-->Line_31 $$ if (beanInstance != null && !ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) [ FD ]
Line_30 $$ Object beanInstance = (!ObjectUtils.isEmpty(beanMethodArgs) ? beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName))-->Line_32 $$ String msg = String.format("@Bean method %s.%s called as a bean reference " + "for type [%s] but overridden by non-compatible bean instance of type [%s].", beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(), beanMethod.getReturnType().getName(), beanInstance.getClass().getName())[ FD ]
Line_13 $$ Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)-->Line_16 $$ return enhanceFactoryBean(factoryBean, beanFactory, beanName)[ FD ]
Line_32 $$ String msg = String.format("@Bean method %s.%s called as a bean reference " + "for type [%s] but overridden by non-compatible bean instance of type [%s].", beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(), beanMethod.getReturnType().getName(), beanInstance.getClass().getName())-->Line_35 $$ msg += " Overriding bean of same name declared in: " + beanDefinition.getResourceDescription()[ FD ]
Line_6 $$ if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) -->Line_8 $$ if (beanFactory.isCurrentlyInCreation(scopedBeanName)) [ CD ]
Line_2 $$ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy) throws Throwable -->Line_4 $$ String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)[ FD ]
Line_3 $$ ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)-->Line_8 $$ if (beanFactory.isCurrentlyInCreation(scopedBeanName)) [ FD ]
Line_3 $$ ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)-->Line_34 $$ BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName)[ FD ]
Line_42 $$ if (alreadyInCreation) -->Line_43 $$ beanFactory.setCurrentlyInCreation(beanName, true)[ CD ]
Line_9 $$ beanName = scopedBeanName-->Line_43 $$ beanFactory.setCurrentlyInCreation(beanName, true)[ FD ]
Line_2 $$ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy) throws Throwable -->Line_4 $$ String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)[ CD ]
Line_7 $$ String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName)-->Line_9 $$ beanName = scopedBeanName[ FD ]
Line_4 $$ String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)-->Line_25 $$ boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)[ FD ]
Line_3 $$ ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)-->Line_13 $$ Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)[ FD ]
Line_31 $$ if (beanInstance != null && !ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) -->Line_32 $$ String msg = String.format("@Bean method %s.%s called as a bean reference " + "for type [%s] but overridden by non-compatible bean instance of type [%s].", beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(), beanMethod.getReturnType().getName(), beanInstance.getClass().getName())[ CD ]
Line_3 $$ ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance)-->Line_25 $$ boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName)[ FD ]
Line_4 $$ String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)-->Line_9 $$ beanName = scopedBeanName[ FD ]
Line_27 $$ if (alreadyInCreation) -->Line_28 $$ beanFactory.setCurrentlyInCreation(beanName, false)[ CD ]
Line_4 $$ String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)-->Line_16 $$ return enhanceFactoryBean(factoryBean, beanFactory, beanName)[ FD ]
Line_2 $$ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy) throws Throwable -->Line_32 $$ String msg = String.format("@Bean method %s.%s called as a bean reference " + "for type [%s] but overridden by non-compatible bean instance of type [%s].", beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(), beanMethod.getReturnType().getName(), beanInstance.getClass().getName())[ FD ]
Line_2 $$ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy) throws Throwable -->Line_31 $$ if (beanInstance != null && !ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) [ FD ]
Line_2 $$ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy) throws Throwable -->Line_19 $$ if (isCurrentlyInvokedFactoryMethod(beanMethod)) [ CD ]
Line_4 $$ String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod)-->Line_43 $$ beanFactory.setCurrentlyInCreation(beanName, true)[ FD ]
Line_12 $$ if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) && factoryContainsBean(beanFactory, beanName)) -->Line_13 $$ Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName)[ CD ]
