Line_44 $$ long taskEnd = 0-->Line_48 $$ taskEnd = Math.max(taskEnd, split.getDoneNanos())[ FD ]
Line_41 $$ Distribution taskParallelismDistribution = new Distribution()-->Line_59 $$ Map<Double, Long> parallelismPercentiles = taskParallelismDistribution.getPercentiles()[ FD ]
Line_42 $$ for (SimulationTask task : entry.getValue()) -->Line_46 $$ for (SimulationSplit split : task.getSplits()) [ FD ]
Line_3 $$ Multimap<Integer, SimulationTask> tasks = Multimaps.synchronizedListMultimap(ArrayListMultimap.<Integer, SimulationTask>create())-->Line_12 $$ ListenableFuture<?> future = createUser("small_" + userId, 5, taskExecutor, done, tasks)[ FD ]
Line_7 $$ for (int userId = 0; userId < 2; userId++) -->Line_15 $$ for (int userId = 0; userId < 1; userId++) [ FD ]
Line_39 $$ for (Entry<Integer, Collection<SimulationTask>> entry : middleTasks.entrySet()) -->Line_42 $$ for (SimulationTask task : entry.getValue()) [ FD ]
Line_3 $$ Multimap<Integer, SimulationTask> tasks = Multimaps.synchronizedListMultimap(ArrayListMultimap.<Integer, SimulationTask>create())-->Line_8 $$ ListenableFuture<?> future = createUser("large_" + userId, 100, taskExecutor, done, tasks)[ FD ]
Line_2 $$ public void run() throws Exception -->Line_23 $$ tasks.clear()[ CD ]
Line_41 $$ Distribution taskParallelismDistribution = new Distribution()-->Line_54 $$ taskParallelismDistribution.add((long) (taskParallelism * 100))[ FD ]
Line_46 $$ for (SimulationSplit split : task.getSplits()) -->Line_47 $$ taskStart = Math.min(taskStart, split.getStartNanos())[ FD ]
Line_15 $$ for (int userId = 0; userId < 1; userId++) -->Line_17 $$ finishFutures.add(future)[ CD ]
Line_11 $$ for (int userId = 0; userId < 4; userId++) -->Line_15 $$ for (int userId = 0; userId < 1; userId++) [ FD ]
Line_2 $$ public void run() throws Exception -->Line_28 $$ Map<Integer, Collection<SimulationTask>> middleTasks[ CD ]
Line_8 $$ ListenableFuture<?> future = createUser("large_" + userId, 100, taskExecutor, done, tasks)-->Line_13 $$ finishFutures.add(future)[ FD ]
Line_11 $$ for (int userId = 0; userId < 4; userId++) -->Line_13 $$ finishFutures.add(future)[ CD ]
Line_12 $$ ListenableFuture<?> future = createUser("small_" + userId, 5, taskExecutor, done, tasks)-->Line_17 $$ finishFutures.add(future)[ FD ]
Line_5 $$ AtomicBoolean done = new AtomicBoolean()-->Line_16 $$ ListenableFuture<?> future = createUser("tiny_" + userId, 1, taskExecutor, done, tasks)[ FD ]
Line_2 $$ public void run() throws Exception -->Line_6 $$ long start = System.nanoTime()[ CD ]
Line_16 $$ ListenableFuture<?> future = createUser("tiny_" + userId, 1, taskExecutor, done, tasks)-->Line_17 $$ finishFutures.add(future)[ FD ]
Line_2 $$ public void run() throws Exception -->Line_63 $$ Thread.sleep(10)[ CD ]
Line_45 $$ long totalCpuTime = 0-->Line_49 $$ totalCpuTime += TimeUnit.MILLISECONDS.toNanos(split.getRequiredProcessMillis())[ FD ]
Line_46 $$ for (SimulationSplit split : task.getSplits()) -->Line_48 $$ taskEnd = Math.max(taskEnd, split.getDoneNanos())[ FD ]
Line_2 $$ public void run() throws Exception -->Line_33 $$ Futures.allAsList(finishFutures).get(1, TimeUnit.MINUTES)[ CD ]
Line_3 $$ Multimap<Integer, SimulationTask> tasks = Multimaps.synchronizedListMultimap(ArrayListMultimap.<Integer, SimulationTask>create())-->Line_23 $$ tasks.clear()[ FD ]
Line_5 $$ AtomicBoolean done = new AtomicBoolean()-->Line_12 $$ ListenableFuture<?> future = createUser("small_" + userId, 5, taskExecutor, done, tasks)[ FD ]
Line_6 $$ long start = System.nanoTime()-->Line_34 $$ Duration runtime = Duration.nanosSince(start).convertToMostSuccinctTimeUnit()[ FD ]
Line_24 $$ for (int i = 0; i < 60; i++) -->Line_26 $$ System.out.println(taskExecutor)[ CD ]
Line_4 $$ Set<ListenableFuture<?>> finishFutures = newConcurrentHashSet()-->Line_33 $$ Futures.allAsList(finishFutures).get(1, TimeUnit.MINUTES)[ FD ]
Line_30 $$ middleTasks = new TreeMap(tasks.asMap())-->Line_39 $$ for (Entry<Integer, Collection<SimulationTask>> entry : middleTasks.entrySet()) [ FD ]
Line_7 $$ for (int userId = 0; userId < 2; userId++) -->Line_8 $$ ListenableFuture<?> future = createUser("large_" + userId, 100, taskExecutor, done, tasks)[ CD ]
Line_24 $$ for (int i = 0; i < 60; i++) -->Line_25 $$ TimeUnit.MILLISECONDS.sleep(1000)[ CD ]
Line_28 $$ Map<Integer, Collection<SimulationTask>> middleTasks-->Line_30 $$ middleTasks = new TreeMap(tasks.asMap())[ FD ]
Line_46 $$ for (SimulationSplit split : task.getSplits()) -->Line_49 $$ totalCpuTime += TimeUnit.MILLISECONDS.toNanos(split.getRequiredProcessMillis())[ FD ]
Line_40 $$ Distribution durationDistribution = new Distribution()-->Line_52 $$ durationDistribution.add(taskDuration.toMillis())[ FD ]
Line_2 $$ public void run() throws Exception -->Line_5 $$ AtomicBoolean done = new AtomicBoolean()[ CD ]
Line_3 $$ Multimap<Integer, SimulationTask> tasks = Multimaps.synchronizedListMultimap(ArrayListMultimap.<Integer, SimulationTask>create())-->Line_16 $$ ListenableFuture<?> future = createUser("tiny_" + userId, 1, taskExecutor, done, tasks)[ FD ]
Line_2 $$ public void run() throws Exception -->Line_3 $$ Multimap<Integer, SimulationTask> tasks = Multimaps.synchronizedListMultimap(ArrayListMultimap.<Integer, SimulationTask>create())[ CD ]
Line_4 $$ Set<ListenableFuture<?>> finishFutures = newConcurrentHashSet()-->Line_13 $$ finishFutures.add(future)[ FD ]
Line_11 $$ for (int userId = 0; userId < 4; userId++) -->Line_12 $$ ListenableFuture<?> future = createUser("small_" + userId, 5, taskExecutor, done, tasks)[ CD ]
Line_5 $$ AtomicBoolean done = new AtomicBoolean()-->Line_8 $$ ListenableFuture<?> future = createUser("large_" + userId, 100, taskExecutor, done, tasks)[ FD ]
Line_2 $$ public void run() throws Exception -->Line_24 $$ for (int i = 0; i < 60; i++) [ CD ]
Line_2 $$ public void run() throws Exception -->Line_7 $$ for (int userId = 0; userId < 2; userId++) [ CD ]
Line_59 $$ Map<Double, Long> parallelismPercentiles = taskParallelismDistribution.getPercentiles()-->Line_60 $$ System.out.printf("    parallelism :: p99 %4.2f :: p95 %4.2f :: p90 %4.2f :: p75 %4.2f :: p50 %4.2f :: p25 %4.2f :: p10 %4.2f :: p05 %4.2f :: p01 %4.2f\n", parallelismPercentiles.get(0.99) / 100.0, parallelismPercentiles.get(0.95) / 100.0, parallelismPercentiles.get(0.90) / 100.0, parallelismPercentiles.get(0.75) / 100.0, parallelismPercentiles.get(0.50) / 100.0, parallelismPercentiles.get(0.25) / 100.0, parallelismPercentiles.get(0.10) / 100.0, parallelismPercentiles.get(0.05) / 100.0, parallelismPercentiles.get(0.01) / 100.0)[ FD ]
Line_5 $$ AtomicBoolean done = new AtomicBoolean()-->Line_32 $$ done.set(true)[ FD ]
Line_4 $$ Set<ListenableFuture<?>> finishFutures = newConcurrentHashSet()-->Line_17 $$ finishFutures.add(future)[ FD ]
Line_4 $$ Set<ListenableFuture<?>> finishFutures = newConcurrentHashSet()-->Line_9 $$ finishFutures.add(future)[ FD ]
Line_7 $$ for (int userId = 0; userId < 2; userId++) -->Line_11 $$ for (int userId = 0; userId < 4; userId++) [ FD ]
Line_12 $$ ListenableFuture<?> future = createUser("small_" + userId, 5, taskExecutor, done, tasks)-->Line_13 $$ finishFutures.add(future)[ FD ]
Line_15 $$ for (int userId = 0; userId < 1; userId++) -->Line_16 $$ ListenableFuture<?> future = createUser("tiny_" + userId, 1, taskExecutor, done, tasks)[ CD ]
Line_19 $$ for (int i = 0; i < 30; i++) -->Line_24 $$ for (int i = 0; i < 60; i++) [ FD ]
Line_43 $$ long taskStart = Long.MAX_VALUE-->Line_47 $$ taskStart = Math.min(taskStart, split.getStartNanos())[ FD ]
Line_57 $$ Map<Double, Long> durationPercentiles = durationDistribution.getPercentiles()-->Line_58 $$ System.out.printf("   wall time ms :: p01 %4s :: p05 %4s :: p10 %4s :: p97 %4s :: p50 %4s :: p75 %4s :: p90 %4s :: p95 %4s :: p99 %4s\n", durationPercentiles.get(0.01), durationPercentiles.get(0.05), durationPercentiles.get(0.10), durationPercentiles.get(0.25), durationPercentiles.get(0.50), durationPercentiles.get(0.75), durationPercentiles.get(0.90), durationPercentiles.get(0.95), durationPercentiles.get(0.99))[ FD ]
Line_51 $$ Duration taskDuration = new Duration(taskEnd - taskStart, NANOSECONDS).convertTo(TimeUnit.MILLISECONDS)-->Line_52 $$ durationDistribution.add(taskDuration.toMillis())[ FD ]
Line_2 $$ public void run() throws Exception -->Line_34 $$ Duration runtime = Duration.nanosSince(start).convertToMostSuccinctTimeUnit()[ CD ]
Line_7 $$ for (int userId = 0; userId < 2; userId++) -->Line_9 $$ finishFutures.add(future)[ CD ]
Line_19 $$ for (int i = 0; i < 30; i++) -->Line_20 $$ TimeUnit.MILLISECONDS.sleep(1000)[ CD ]
Line_39 $$ for (Entry<Integer, Collection<SimulationTask>> entry : middleTasks.entrySet()) -->Line_56 $$ System.out.println("Splits " + entry.getKey() + ": Completed " + entry.getValue().size())[ FD ]
Line_8 $$ ListenableFuture<?> future = createUser("large_" + userId, 100, taskExecutor, done, tasks)-->Line_9 $$ finishFutures.add(future)[ FD ]
Line_2 $$ public void run() throws Exception -->Line_4 $$ Set<ListenableFuture<?>> finishFutures = newConcurrentHashSet()[ CD ]
Line_2 $$ public void run() throws Exception -->Line_15 $$ for (int userId = 0; userId < 1; userId++) [ CD ]
Line_3 $$ Multimap<Integer, SimulationTask> tasks = Multimaps.synchronizedListMultimap(ArrayListMultimap.<Integer, SimulationTask>create())-->Line_30 $$ middleTasks = new TreeMap(tasks.asMap())[ FD ]
Line_2 $$ public void run() throws Exception -->Line_32 $$ done.set(true)[ CD ]
Line_28 $$ Map<Integer, Collection<SimulationTask>> middleTasks-->Line_39 $$ for (Entry<Integer, Collection<SimulationTask>> entry : middleTasks.entrySet()) [ FD ]
Line_2 $$ public void run() throws Exception -->Line_11 $$ for (int userId = 0; userId < 4; userId++) [ CD ]
Line_8 $$ ListenableFuture<?> future = createUser("large_" + userId, 100, taskExecutor, done, tasks)-->Line_17 $$ finishFutures.add(future)[ FD ]
Line_2 $$ public void run() throws Exception -->Line_19 $$ for (int i = 0; i < 30; i++) [ CD ]
Line_40 $$ Distribution durationDistribution = new Distribution()-->Line_57 $$ Map<Double, Long> durationPercentiles = durationDistribution.getPercentiles()[ FD ]
Line_19 $$ for (int i = 0; i < 30; i++) -->Line_21 $$ System.out.println(taskExecutor)[ CD ]
