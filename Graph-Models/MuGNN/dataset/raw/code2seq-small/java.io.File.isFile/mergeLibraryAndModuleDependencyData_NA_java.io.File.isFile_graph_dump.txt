Line_13 $$ final DataNode<?> libraryNodeParent = libraryDependencyDataNode.getParent()-->Line_70 $$ libraryNodeParent.createChild(ProjectKeys.MODULE_DEPENDENCY, moduleDependencyData)[ FD ]
Line_16 $$ final LibraryDependencyData libraryDependencyData = libraryDependencyDataNode.getData()-->Line_59 $$ moduleDependencyData.setScope(libraryDependencyData.getScope())[ FD ]
Line_101 $$ if (binaryPath.isFile()) -->Line_104 $$ if (gradleHomeDir != null && gradleVersion != null) [ CD ]
Line_101 $$ if (binaryPath.isFile()) -->Line_109 $$ toRemove.add(path)[ CD ]
Line_24 $$ while (!unprocessedPaths.isEmpty()) -->Line_63 $$ final DataNode<ModuleDependencyData> found = ExternalSystemApiUtil.find(libraryNodeParent, ProjectKeys.MODULE_DEPENDENCY, new BooleanFunction<DataNode<ModuleDependencyData>>() [ CD ]
Line_24 $$ while (!unprocessedPaths.isEmpty()) -->Line_89 $$ final ExternalSourceDirectorySet directorySet = pair.second.getSources().get(sourceTypePair.second)[ CD ]
Line_35 $$ moduleId = sourceTypePair.first-->Line_39 $$ final Pair<DataNode<GradleSourceSetData>, ExternalSourceSet> pair = sourceSetMap.get(moduleId)[ FD ]
Line_43 $$ final ModuleData moduleData = pair.first.getData()-->Line_51 $$ ContainerUtil.addAllNotNull(testSet, moduleData.getCompileOutputPath(ExternalSystemSourceType.TEST), moduleData.getCompileOutputPath(ExternalSystemSourceType.TEST_RESOURCE))[ FD ]
Line_23 $$ final LinkedList<String> unprocessedPaths = ContainerUtil.newLinkedList(libraryPaths)-->Line_25 $$ final String path = unprocessedPaths.remove()[ FD ]
Line_80 $$ if (found != null) -->Line_81 $$ libraryPaths.remove(path)[ CD ]
Line_2 $$ private static void mergeLibraryAndModuleDependencyData(DataNode<ProjectData> projectDataNode, @Nullable File gradleHomeDir, @Nullable GradleVersion gradleVersion) -->Line_3 $$ final Map<String, Pair<DataNode<GradleSourceSetData>, ExternalSourceSet>> sourceSetMap = projectDataNode.getUserData(RESOLVED_SOURCE_SETS)[ FD ]
Line_2 $$ private static void mergeLibraryAndModuleDependencyData(DataNode<ProjectData> projectDataNode, @Nullable File gradleHomeDir, @Nullable GradleVersion gradleVersion) -->Line_7 $$ final Map<String, String> artifactsMap = projectDataNode.getUserData(CONFIGURATION_ARTIFACTS)[ CD ]
Line_31 $$ if (moduleId != null) -->Line_32 $$ targetModuleOutputPaths = ContainerUtil.set(path)[ CD ]
Line_32 $$ targetModuleOutputPaths = ContainerUtil.set(path)-->Line_72 $$ libraryPaths.removeAll(targetModuleOutputPaths)[ FD ]
Line_17 $$ final LibraryData libraryData = libraryDependencyData.getTarget()-->Line_21 $$ if (StringUtil.isNotEmpty(libraryData.getExternalName()))[ FD ]
Line_18 $$ final Set<String> libraryPaths = libraryData.getPaths(LibraryPathType.BINARY)-->Line_52 $$ if (compileSet.isEmpty() && ContainerUtil.intersects(libraryPaths, testSet)) [ FD ]
Line_68 $$ if (targetModuleOutputPaths != null) -->Line_80 $$ if (found != null) [ CD ]
Line_26 $$ Set<String> targetModuleOutputPaths = null-->Line_32 $$ targetModuleOutputPaths = ContainerUtil.set(path)[ FD ]
Line_74 $$ if (libraryPaths.isEmpty()) -->Line_75 $$ libraryDependencyDataNode.clear(true)[ CD ]
Line_45 $$ final Set<String> compileSet = ContainerUtil.newHashSet()-->Line_47 $$ if (!compileSet.isEmpty() && ContainerUtil.intersects(libraryPaths, compileSet)) [ FD ]
Line_60 $$ if ("test".equals(pair.second.getName())) -->Line_61 $$ moduleDependencyData.setProductionOnTestDependency(true)[ CD ]
Line_50 $$ final Set<String> testSet = ContainerUtil.newHashSet()-->Line_51 $$ ContainerUtil.addAllNotNull(testSet, moduleData.getCompileOutputPath(ExternalSystemSourceType.TEST), moduleData.getCompileOutputPath(ExternalSystemSourceType.TEST_RESOURCE))[ FD ]
Line_48 $$ targetModuleOutputPaths = compileSet-->Line_68 $$ if (targetModuleOutputPaths != null) [ FD ]
Line_32 $$ targetModuleOutputPaths = ContainerUtil.set(path)-->Line_73 $$ unprocessedPaths.removeAll(targetModuleOutputPaths)[ FD ]
Line_58 $$ final ModuleDependencyData moduleDependencyData = new ModuleDependencyData(ownerModule, moduleData)-->Line_59 $$ moduleDependencyData.setScope(libraryDependencyData.getScope())[ FD ]
Line_18 $$ final Set<String> libraryPaths = libraryData.getPaths(LibraryPathType.BINARY)-->Line_82 $$ if (libraryPaths.isEmpty()) [ FD ]
Line_39 $$ final Pair<DataNode<GradleSourceSetData>, ExternalSourceSet> pair = sourceSetMap.get(moduleId)-->Line_40 $$ if (pair == null) [ FD ]
Line_18 $$ final Set<String> libraryPaths = libraryData.getPaths(LibraryPathType.BINARY)-->Line_74 $$ if (libraryPaths.isEmpty()) [ FD ]
Line_63 $$ final DataNode<ModuleDependencyData> found = ExternalSystemApiUtil.find(libraryNodeParent, ProjectKeys.MODULE_DEPENDENCY, new BooleanFunction<DataNode<ModuleDependencyData>>() -->Line_80 $$ if (found != null) [ FD ]
Line_30 $$ moduleId = artifactsMap.get(path)-->Line_39 $$ final Pair<DataNode<GradleSourceSetData>, ExternalSourceSet> pair = sourceSetMap.get(moduleId)[ FD ]
Line_26 $$ Set<String> targetModuleOutputPaths = null-->Line_68 $$ if (targetModuleOutputPaths != null) [ FD ]
Line_29 $$ if (sourceTypePair == null) -->Line_30 $$ moduleId = artifactsMap.get(path)[ CD ]
Line_18 $$ final Set<String> libraryPaths = libraryData.getPaths(LibraryPathType.BINARY)-->Line_113 $$ if (libraryPaths.isEmpty()) [ FD ]
Line_30 $$ moduleId = artifactsMap.get(path)-->Line_31 $$ if (moduleId != null) [ FD ]
Line_24 $$ while (!unprocessedPaths.isEmpty()) -->Line_40 $$ if (pair == null) [ CD ]
Line_44 $$ if (targetModuleOutputPaths == null) -->Line_46 $$ ContainerUtil.addAllNotNull(compileSet, moduleData.getCompileOutputPath(ExternalSystemSourceType.SOURCE), moduleData.getCompileOutputPath(ExternalSystemSourceType.RESOURCE))[ CD ]
Line_27 $$ final String moduleId-->Line_31 $$ if (moduleId != null) [ FD ]
Line_10 $$ for (DataNode<LibraryDependencyData> libraryDependencyDataNode : libraryDependencies) -->Line_108 $$ libraryDependencyDataNode.getParent().createChild(ProjectKeys.LIBRARY_DEPENDENCY, extractedDependencyData)[ FD ]
Line_23 $$ final LinkedList<String> unprocessedPaths = ContainerUtil.newLinkedList(libraryPaths)-->Line_24 $$ while (!unprocessedPaths.isEmpty()) [ FD ]
Line_69 $$ if (found == null) -->Line_70 $$ libraryNodeParent.createChild(ProjectKeys.MODULE_DEPENDENCY, moduleDependencyData)[ CD ]
Line_10 $$ for (DataNode<LibraryDependencyData> libraryDependencyDataNode : libraryDependencies) -->Line_16 $$ final LibraryDependencyData libraryDependencyData = libraryDependencyDataNode.getData()[ FD ]
Line_35 $$ moduleId = sourceTypePair.first-->Line_37 $$ if (moduleId == null)[ FD ]
Line_26 $$ Set<String> targetModuleOutputPaths = null-->Line_48 $$ targetModuleOutputPaths = compileSet[ FD ]
Line_18 $$ final Set<String> libraryPaths = libraryData.getPaths(LibraryPathType.BINARY)-->Line_23 $$ final LinkedList<String> unprocessedPaths = ContainerUtil.newLinkedList(libraryPaths)[ FD ]
Line_48 $$ targetModuleOutputPaths = compileSet-->Line_72 $$ libraryPaths.removeAll(targetModuleOutputPaths)[ FD ]
Line_24 $$ while (!unprocessedPaths.isEmpty()) -->Line_25 $$ final String path = unprocessedPaths.remove()[ CD ]
Line_24 $$ while (!unprocessedPaths.isEmpty()) -->Line_59 $$ moduleDependencyData.setScope(libraryDependencyData.getScope())[ CD ]
Line_25 $$ final String path = unprocessedPaths.remove()-->Line_81 $$ libraryPaths.remove(path)[ FD ]
Line_18 $$ final Set<String> libraryPaths = libraryData.getPaths(LibraryPathType.BINARY)-->Line_112 $$ libraryPaths.removeAll(toRemove)[ FD ]
Line_2 $$ private static void mergeLibraryAndModuleDependencyData(DataNode<ProjectData> projectDataNode, @Nullable File gradleHomeDir, @Nullable GradleVersion gradleVersion) -->Line_5 $$ final Map<String, Pair<String, ExternalSystemSourceType>> moduleOutputsMap = projectDataNode.getUserData(MODULES_OUTPUTS)[ FD ]
Line_2 $$ private static void mergeLibraryAndModuleDependencyData(DataNode<ProjectData> projectDataNode, @Nullable File gradleHomeDir, @Nullable GradleVersion gradleVersion) -->Line_5 $$ final Map<String, Pair<String, ExternalSystemSourceType>> moduleOutputsMap = projectDataNode.getUserData(MODULES_OUTPUTS)[ CD ]
Line_16 $$ final LibraryDependencyData libraryDependencyData = libraryDependencyDataNode.getData()-->Line_107 $$ LibraryDependencyData extractedDependencyData = new LibraryDependencyData(libraryDependencyData.getOwnerModule(), extractedLibrary, LibraryLevel.MODULE)[ FD ]
Line_2 $$ private static void mergeLibraryAndModuleDependencyData(DataNode<ProjectData> projectDataNode, @Nullable File gradleHomeDir, @Nullable GradleVersion gradleVersion) -->Line_105 $$ attachGradleSdkSources(binaryPath, extractedLibrary, gradleHomeDir, gradleVersion)[ FD ]
Line_18 $$ final Set<String> libraryPaths = libraryData.getPaths(LibraryPathType.BINARY)-->Line_72 $$ libraryPaths.removeAll(targetModuleOutputPaths)[ FD ]
Line_24 $$ while (!unprocessedPaths.isEmpty()) -->Line_37 $$ if (moduleId == null)[ CD ]
Line_52 $$ if (compileSet.isEmpty() && ContainerUtil.intersects(libraryPaths, testSet)) -->Line_53 $$ targetModuleOutputPaths = testSet[ CD ]
Line_24 $$ while (!unprocessedPaths.isEmpty()) -->Line_28 $$ final Pair<String, ExternalSystemSourceType> sourceTypePair = moduleOutputsMap.get(path)[ CD ]
Line_32 $$ targetModuleOutputPaths = ContainerUtil.set(path)-->Line_48 $$ targetModuleOutputPaths = compileSet[ FD ]
Line_80 $$ if (found != null) -->Line_82 $$ if (libraryPaths.isEmpty()) [ CD ]
Line_24 $$ while (!unprocessedPaths.isEmpty()) -->Line_58 $$ final ModuleDependencyData moduleDependencyData = new ModuleDependencyData(ownerModule, moduleData)[ CD ]
Line_104 $$ if (gradleHomeDir != null && gradleVersion != null) -->Line_105 $$ attachGradleSdkSources(binaryPath, extractedLibrary, gradleHomeDir, gradleVersion)[ CD ]
Line_26 $$ Set<String> targetModuleOutputPaths = null-->Line_53 $$ targetModuleOutputPaths = testSet[ FD ]
Line_25 $$ final String path = unprocessedPaths.remove()-->Line_109 $$ toRemove.add(path)[ FD ]
Line_68 $$ if (targetModuleOutputPaths != null) -->Line_69 $$ if (found == null) [ CD ]
Line_35 $$ moduleId = sourceTypePair.first-->Line_31 $$ if (moduleId != null) [ FD ]
Line_50 $$ final Set<String> testSet = ContainerUtil.newHashSet()-->Line_53 $$ targetModuleOutputPaths = testSet[ FD ]
Line_53 $$ targetModuleOutputPaths = testSet-->Line_72 $$ libraryPaths.removeAll(targetModuleOutputPaths)[ FD ]
Line_63 $$ final DataNode<ModuleDependencyData> found = ExternalSystemApiUtil.find(libraryNodeParent, ProjectKeys.MODULE_DEPENDENCY, new BooleanFunction<DataNode<ModuleDependencyData>>() -->Line_65 $$ return moduleDependencyData.equals(node.getData())[ CD ]
Line_25 $$ final String path = unprocessedPaths.remove()-->Line_30 $$ moduleId = artifactsMap.get(path)[ FD ]
Line_28 $$ final Pair<String, ExternalSystemSourceType> sourceTypePair = moduleOutputsMap.get(path)-->Line_29 $$ if (sourceTypePair == null) [ FD ]
Line_113 $$ if (libraryPaths.isEmpty()) -->Line_114 $$ libraryDependencyDataNode.clear(true)[ CD ]
Line_24 $$ while (!unprocessedPaths.isEmpty()) -->Line_60 $$ if ("test".equals(pair.second.getName())) [ CD ]
Line_18 $$ final Set<String> libraryPaths = libraryData.getPaths(LibraryPathType.BINARY)-->Line_81 $$ libraryPaths.remove(path)[ FD ]
Line_45 $$ final Set<String> compileSet = ContainerUtil.newHashSet()-->Line_46 $$ ContainerUtil.addAllNotNull(compileSet, moduleData.getCompileOutputPath(ExternalSystemSourceType.SOURCE), moduleData.getCompileOutputPath(ExternalSystemSourceType.RESOURCE))[ FD ]
Line_24 $$ while (!unprocessedPaths.isEmpty()) -->Line_90 $$ if (directorySet != null) [ CD ]
Line_53 $$ targetModuleOutputPaths = testSet-->Line_73 $$ unprocessedPaths.removeAll(targetModuleOutputPaths)[ FD ]
Line_97 $$ if (libraryPaths.size() > 1) -->Line_112 $$ libraryPaths.removeAll(toRemove)[ CD ]
Line_50 $$ final Set<String> testSet = ContainerUtil.newHashSet()-->Line_52 $$ if (compileSet.isEmpty() && ContainerUtil.intersects(libraryPaths, testSet)) [ FD ]
Line_32 $$ targetModuleOutputPaths = ContainerUtil.set(path)-->Line_53 $$ targetModuleOutputPaths = testSet[ FD ]
Line_82 $$ if (libraryPaths.isEmpty()) -->Line_83 $$ libraryDependencyDataNode.clear(true)[ CD ]
Line_23 $$ final LinkedList<String> unprocessedPaths = ContainerUtil.newLinkedList(libraryPaths)-->Line_73 $$ unprocessedPaths.removeAll(targetModuleOutputPaths)[ FD ]
Line_97 $$ if (libraryPaths.size() > 1) -->Line_113 $$ if (libraryPaths.isEmpty()) [ CD ]
Line_2 $$ private static void mergeLibraryAndModuleDependencyData(DataNode<ProjectData> projectDataNode, @Nullable File gradleHomeDir, @Nullable GradleVersion gradleVersion) -->Line_3 $$ final Map<String, Pair<DataNode<GradleSourceSetData>, ExternalSourceSet>> sourceSetMap = projectDataNode.getUserData(RESOLVED_SOURCE_SETS)[ CD ]
Line_27 $$ final String moduleId-->Line_30 $$ moduleId = artifactsMap.get(path)[ FD ]
Line_47 $$ if (!compileSet.isEmpty() && ContainerUtil.intersects(libraryPaths, compileSet)) -->Line_48 $$ targetModuleOutputPaths = compileSet[ CD ]
Line_24 $$ while (!unprocessedPaths.isEmpty()) -->Line_44 $$ if (targetModuleOutputPaths == null) [ CD ]
Line_96 $$ if (libraryDependencyDataNode.getParent() != null) -->Line_97 $$ if (libraryPaths.size() > 1) [ CD ]
Line_16 $$ final LibraryDependencyData libraryDependencyData = libraryDependencyDataNode.getData()-->Line_102 $$ final LibraryData extractedLibrary = new LibraryData(libraryDependencyData.getOwner(), "")[ FD ]
Line_47 $$ if (!compileSet.isEmpty() && ContainerUtil.intersects(libraryPaths, compileSet)) -->Line_51 $$ ContainerUtil.addAllNotNull(testSet, moduleData.getCompileOutputPath(ExternalSystemSourceType.TEST), moduleData.getCompileOutputPath(ExternalSystemSourceType.TEST_RESOURCE))[ CD ]
Line_5 $$ final Map<String, Pair<String, ExternalSystemSourceType>> moduleOutputsMap = projectDataNode.getUserData(MODULES_OUTPUTS)-->Line_28 $$ final Pair<String, ExternalSystemSourceType> sourceTypePair = moduleOutputsMap.get(path)[ FD ]
Line_16 $$ final LibraryDependencyData libraryDependencyData = libraryDependencyDataNode.getData()-->Line_17 $$ final LibraryData libraryData = libraryDependencyData.getTarget()[ FD ]
Line_17 $$ final LibraryData libraryData = libraryDependencyData.getTarget()-->Line_18 $$ final Set<String> libraryPaths = libraryData.getPaths(LibraryPathType.BINARY)[ FD ]
Line_48 $$ targetModuleOutputPaths = compileSet-->Line_44 $$ if (targetModuleOutputPaths == null) [ FD ]
Line_3 $$ final Map<String, Pair<DataNode<GradleSourceSetData>, ExternalSourceSet>> sourceSetMap = projectDataNode.getUserData(RESOLVED_SOURCE_SETS)-->Line_39 $$ final Pair<DataNode<GradleSourceSetData>, ExternalSourceSet> pair = sourceSetMap.get(moduleId)[ FD ]
Line_53 $$ targetModuleOutputPaths = testSet-->Line_68 $$ if (targetModuleOutputPaths != null) [ FD ]
Line_32 $$ targetModuleOutputPaths = ContainerUtil.set(path)-->Line_44 $$ if (targetModuleOutputPaths == null) [ FD ]
Line_47 $$ if (!compileSet.isEmpty() && ContainerUtil.intersects(libraryPaths, compileSet)) -->Line_50 $$ final Set<String> testSet = ContainerUtil.newHashSet()[ CD ]
Line_58 $$ final ModuleDependencyData moduleDependencyData = new ModuleDependencyData(ownerModule, moduleData)-->Line_65 $$ return moduleDependencyData.equals(node.getData())[ FD ]
Line_26 $$ Set<String> targetModuleOutputPaths = null-->Line_73 $$ unprocessedPaths.removeAll(targetModuleOutputPaths)[ FD ]
Line_2 $$ private static void mergeLibraryAndModuleDependencyData(DataNode<ProjectData> projectDataNode, @Nullable File gradleHomeDir, @Nullable GradleVersion gradleVersion) -->Line_7 $$ final Map<String, String> artifactsMap = projectDataNode.getUserData(CONFIGURATION_ARTIFACTS)[ FD ]
Line_24 $$ while (!unprocessedPaths.isEmpty()) -->Line_29 $$ if (sourceTypePair == null) [ CD ]
Line_63 $$ final DataNode<ModuleDependencyData> found = ExternalSystemApiUtil.find(libraryNodeParent, ProjectKeys.MODULE_DEPENDENCY, new BooleanFunction<DataNode<ModuleDependencyData>>() -->Line_65 $$ return moduleDependencyData.equals(node.getData())[ FD ]
Line_26 $$ Set<String> targetModuleOutputPaths = null-->Line_72 $$ libraryPaths.removeAll(targetModuleOutputPaths)[ FD ]
Line_13 $$ final DataNode<?> libraryNodeParent = libraryDependencyDataNode.getParent()-->Line_14 $$ if (libraryNodeParent == null)[ FD ]
Line_47 $$ if (!compileSet.isEmpty() && ContainerUtil.intersects(libraryPaths, compileSet)) -->Line_52 $$ if (compileSet.isEmpty() && ContainerUtil.intersects(libraryPaths, testSet)) [ CD ]
Line_2 $$ private static void mergeLibraryAndModuleDependencyData(DataNode<ProjectData> projectDataNode, @Nullable File gradleHomeDir, @Nullable GradleVersion gradleVersion) -->Line_9 $$ final Collection<DataNode<LibraryDependencyData>> libraryDependencies = ExternalSystemApiUtil.findAllRecursively(projectDataNode, ProjectKeys.LIBRARY_DEPENDENCY)[ FD ]
Line_45 $$ final Set<String> compileSet = ContainerUtil.newHashSet()-->Line_48 $$ targetModuleOutputPaths = compileSet[ FD ]
Line_58 $$ final ModuleDependencyData moduleDependencyData = new ModuleDependencyData(ownerModule, moduleData)-->Line_61 $$ moduleDependencyData.setProductionOnTestDependency(true)[ FD ]
Line_101 $$ if (binaryPath.isFile()) -->Line_103 $$ extractedLibrary.addPath(LibraryPathType.BINARY, path)[ CD ]
Line_24 $$ while (!unprocessedPaths.isEmpty()) -->Line_43 $$ final ModuleData moduleData = pair.first.getData()[ CD ]
Line_18 $$ final Set<String> libraryPaths = libraryData.getPaths(LibraryPathType.BINARY)-->Line_97 $$ if (libraryPaths.size() > 1) [ FD ]
Line_18 $$ final Set<String> libraryPaths = libraryData.getPaths(LibraryPathType.BINARY)-->Line_19 $$ if (libraryPaths.isEmpty())[ FD ]
Line_24 $$ while (!unprocessedPaths.isEmpty()) -->Line_39 $$ final Pair<DataNode<GradleSourceSetData>, ExternalSourceSet> pair = sourceSetMap.get(moduleId)[ CD ]
Line_48 $$ targetModuleOutputPaths = compileSet-->Line_73 $$ unprocessedPaths.removeAll(targetModuleOutputPaths)[ FD ]
Line_27 $$ final String moduleId-->Line_39 $$ final Pair<DataNode<GradleSourceSetData>, ExternalSourceSet> pair = sourceSetMap.get(moduleId)[ FD ]
Line_32 $$ targetModuleOutputPaths = ContainerUtil.set(path)-->Line_68 $$ if (targetModuleOutputPaths != null) [ FD ]
Line_10 $$ for (DataNode<LibraryDependencyData> libraryDependencyDataNode : libraryDependencies) -->Line_96 $$ if (libraryDependencyDataNode.getParent() != null) [ FD ]
Line_68 $$ if (targetModuleOutputPaths != null) -->Line_74 $$ if (libraryPaths.isEmpty()) [ CD ]
Line_30 $$ moduleId = artifactsMap.get(path)-->Line_37 $$ if (moduleId == null)[ FD ]
Line_63 $$ final DataNode<ModuleDependencyData> found = ExternalSystemApiUtil.find(libraryNodeParent, ProjectKeys.MODULE_DEPENDENCY, new BooleanFunction<DataNode<ModuleDependencyData>>() -->Line_69 $$ if (found == null) [ FD ]
Line_24 $$ while (!unprocessedPaths.isEmpty()) -->Line_57 $$ final ModuleData ownerModule = libraryDependencyData.getOwnerModule()[ CD ]
Line_10 $$ for (DataNode<LibraryDependencyData> libraryDependencyDataNode : libraryDependencies) -->Line_13 $$ final DataNode<?> libraryNodeParent = libraryDependencyDataNode.getParent()[ FD ]
Line_91 $$ for (File file : directorySet.getSrcDirs()) -->Line_92 $$ libraryData.addPath(LibraryPathType.SOURCE, file.getAbsolutePath())[ FD ]
Line_24 $$ while (!unprocessedPaths.isEmpty()) -->Line_26 $$ Set<String> targetModuleOutputPaths = null[ CD ]
Line_26 $$ Set<String> targetModuleOutputPaths = null-->Line_44 $$ if (targetModuleOutputPaths == null) [ FD ]
Line_44 $$ if (targetModuleOutputPaths == null) -->Line_47 $$ if (!compileSet.isEmpty() && ContainerUtil.intersects(libraryPaths, compileSet)) [ CD ]
Line_25 $$ final String path = unprocessedPaths.remove()-->Line_28 $$ final Pair<String, ExternalSystemSourceType> sourceTypePair = moduleOutputsMap.get(path)[ FD ]
Line_25 $$ final String path = unprocessedPaths.remove()-->Line_32 $$ targetModuleOutputPaths = ContainerUtil.set(path)[ FD ]
Line_58 $$ final ModuleDependencyData moduleDependencyData = new ModuleDependencyData(ownerModule, moduleData)-->Line_70 $$ libraryNodeParent.createChild(ProjectKeys.MODULE_DEPENDENCY, moduleDependencyData)[ FD ]
Line_10 $$ for (DataNode<LibraryDependencyData> libraryDependencyDataNode : libraryDependencies) -->Line_83 $$ libraryDependencyDataNode.clear(true)[ FD ]
Line_7 $$ final Map<String, String> artifactsMap = projectDataNode.getUserData(CONFIGURATION_ARTIFACTS)-->Line_30 $$ moduleId = artifactsMap.get(path)[ FD ]
Line_17 $$ final LibraryData libraryData = libraryDependencyData.getTarget()-->Line_92 $$ libraryData.addPath(LibraryPathType.SOURCE, file.getAbsolutePath())[ FD ]
Line_89 $$ final ExternalSourceDirectorySet directorySet = pair.second.getSources().get(sourceTypePair.second)-->Line_90 $$ if (directorySet != null) [ FD ]
Line_68 $$ if (targetModuleOutputPaths != null) -->Line_73 $$ unprocessedPaths.removeAll(targetModuleOutputPaths)[ CD ]
Line_2 $$ private static void mergeLibraryAndModuleDependencyData(DataNode<ProjectData> projectDataNode, @Nullable File gradleHomeDir, @Nullable GradleVersion gradleVersion) -->Line_9 $$ final Collection<DataNode<LibraryDependencyData>> libraryDependencies = ExternalSystemApiUtil.findAllRecursively(projectDataNode, ProjectKeys.LIBRARY_DEPENDENCY)[ CD ]
Line_97 $$ if (libraryPaths.size() > 1) -->Line_98 $$ List<String> toRemove = ContainerUtil.newSmartList()[ CD ]
Line_18 $$ final Set<String> libraryPaths = libraryData.getPaths(LibraryPathType.BINARY)-->Line_47 $$ if (!compileSet.isEmpty() && ContainerUtil.intersects(libraryPaths, compileSet)) [ FD ]
Line_44 $$ if (targetModuleOutputPaths == null) -->Line_45 $$ final Set<String> compileSet = ContainerUtil.newHashSet()[ CD ]
Line_27 $$ final String moduleId-->Line_37 $$ if (moduleId == null)[ FD ]
Line_101 $$ if (binaryPath.isFile()) -->Line_108 $$ libraryDependencyDataNode.getParent().createChild(ProjectKeys.LIBRARY_DEPENDENCY, extractedDependencyData)[ CD ]
Line_13 $$ final DataNode<?> libraryNodeParent = libraryDependencyDataNode.getParent()-->Line_63 $$ final DataNode<ModuleDependencyData> found = ExternalSystemApiUtil.find(libraryNodeParent, ProjectKeys.MODULE_DEPENDENCY, new BooleanFunction<DataNode<ModuleDependencyData>>() [ FD ]
Line_24 $$ while (!unprocessedPaths.isEmpty()) -->Line_27 $$ final String moduleId[ CD ]
Line_10 $$ for (DataNode<LibraryDependencyData> libraryDependencyDataNode : libraryDependencies) -->Line_75 $$ libraryDependencyDataNode.clear(true)[ FD ]
Line_29 $$ if (sourceTypePair == null) -->Line_35 $$ moduleId = sourceTypePair.first[ CD ]
Line_29 $$ if (sourceTypePair == null) -->Line_31 $$ if (moduleId != null) [ CD ]
Line_25 $$ final String path = unprocessedPaths.remove()-->Line_103 $$ extractedLibrary.addPath(LibraryPathType.BINARY, path)[ FD ]
Line_68 $$ if (targetModuleOutputPaths != null) -->Line_72 $$ libraryPaths.removeAll(targetModuleOutputPaths)[ CD ]
Line_30 $$ moduleId = artifactsMap.get(path)-->Line_35 $$ moduleId = sourceTypePair.first[ FD ]
Line_89 $$ final ExternalSourceDirectorySet directorySet = pair.second.getSources().get(sourceTypePair.second)-->Line_91 $$ for (File file : directorySet.getSrcDirs()) [ FD ]
Line_43 $$ final ModuleData moduleData = pair.first.getData()-->Line_46 $$ ContainerUtil.addAllNotNull(compileSet, moduleData.getCompileOutputPath(ExternalSystemSourceType.SOURCE), moduleData.getCompileOutputPath(ExternalSystemSourceType.RESOURCE))[ FD ]
Line_27 $$ final String moduleId-->Line_35 $$ moduleId = sourceTypePair.first[ FD ]
Line_48 $$ targetModuleOutputPaths = compileSet-->Line_53 $$ targetModuleOutputPaths = testSet[ FD ]
Line_24 $$ while (!unprocessedPaths.isEmpty()) -->Line_68 $$ if (targetModuleOutputPaths != null) [ CD ]
Line_10 $$ for (DataNode<LibraryDependencyData> libraryDependencyDataNode : libraryDependencies) -->Line_11 $$ if (!libraryDependencyDataNode.getChildren().isEmpty())[ FD ]
Line_16 $$ final LibraryDependencyData libraryDependencyData = libraryDependencyDataNode.getData()-->Line_57 $$ final ModuleData ownerModule = libraryDependencyData.getOwnerModule()[ FD ]
Line_53 $$ targetModuleOutputPaths = testSet-->Line_44 $$ if (targetModuleOutputPaths == null) [ FD ]
Line_10 $$ for (DataNode<LibraryDependencyData> libraryDependencyDataNode : libraryDependencies) -->Line_114 $$ libraryDependencyDataNode.clear(true)[ FD ]
Line_45 $$ final Set<String> compileSet = ContainerUtil.newHashSet()-->Line_52 $$ if (compileSet.isEmpty() && ContainerUtil.intersects(libraryPaths, testSet)) [ FD ]
