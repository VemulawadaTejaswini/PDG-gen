Line_11 $$ Class<?> fieldClass = field.getType()-->Line_13 $$ addField(deleteAfterTestRunFieldBags, fieldClass, field)[ FD ]
Line_6 $$ for (Field field : testClass.getDeclaredFields()) -->Line_7 $$ DeleteAfterTestRun deleteAfterTestRun = field.getAnnotation(DeleteAfterTestRun.class)[ FD ]
Line_2 $$ public void afterMethod(Description description, Object object, Object target) -->Line_3 $$ Class<?> testClass = description.getTestClass()[ CD ]
Line_40 $$ StringBundler sb = new StringBundler(6)-->Line_42 $$ sb.append(field)[ FD ]
Line_55 $$ Class<?> clazz = entry.getKey()-->Line_63 $$ FieldBag fieldBag = deleteAfterTestRunFieldBags.remove(clazz)[ FD ]
Line_6 $$ for (Field field : testClass.getDeclaredFields()) -->Line_13 $$ addField(deleteAfterTestRunFieldBags, fieldClass, field)[ FD ]
Line_4 $$ Map<Class<?>, FieldBag> deleteAfterTestRunFieldBags = new HashMap()-->Line_63 $$ FieldBag fieldBag = deleteAfterTestRunFieldBags.remove(clazz)[ FD ]
Line_3 $$ Class<?> testClass = description.getTestClass()-->Line_5 $$ while (testClass != null) [ FD ]
Line_3 $$ Class<?> testClass = description.getTestClass()-->Line_6 $$ for (Field field : testClass.getDeclaredFields()) [ FD ]
Line_53 $$ while (iterator.hasNext()) -->Line_60 $$ removeField(entry.getValue(), target)[ CD ]
Line_2 $$ public void afterMethod(Description description, Object object, Object target) -->Line_3 $$ Class<?> testClass = description.getTestClass()[ FD ]
Line_11 $$ Class<?> fieldClass = field.getType()-->Line_12 $$ if (PersistedModel.class.isAssignableFrom(fieldClass)) [ FD ]
Line_2 $$ public void afterMethod(Description description, Object object, Object target) -->Line_53 $$ while (iterator.hasNext()) [ CD ]
Line_40 $$ StringBundler sb = new StringBundler(6)-->Line_44 $$ sb.append(PersistedModel.class.getName())[ FD ]
Line_49 $$ testClass = testClass.getSuperclass()-->Line_6 $$ for (Field field : testClass.getDeclaredFields()) [ FD ]
Line_4 $$ Map<Class<?>, FieldBag> deleteAfterTestRunFieldBags = new HashMap()-->Line_20 $$ addField(deleteAfterTestRunFieldBags, fieldClass.getComponentType(), field)[ FD ]
Line_7 $$ DeleteAfterTestRun deleteAfterTestRun = field.getAnnotation(DeleteAfterTestRun.class)-->Line_8 $$ if (deleteAfterTestRun == null) [ FD ]
Line_2 $$ public void afterMethod(Description description, Object object, Object target) -->Line_4 $$ Map<Class<?>, FieldBag> deleteAfterTestRunFieldBags = new HashMap()[ CD ]
Line_26 $$ Collection<?> collection = (Collection<?>) field.get(target)-->Line_27 $$ if ((collection == null) || collection.isEmpty()) [ FD ]
Line_40 $$ StringBundler sb = new StringBundler(6)-->Line_45 $$ sb.append(" nor an array or collection of ")[ FD ]
Line_2 $$ public void afterMethod(Description description, Object object, Object target) -->Line_5 $$ while (testClass != null) [ CD ]
Line_51 $$ Set<Map.Entry<Class<?>, FieldBag>> set = deleteAfterTestRunFieldBags.entrySet()-->Line_52 $$ Iterator<Map.Entry<Class<?>, FieldBag>> iterator = set.iterator()[ FD ]
Line_52 $$ Iterator<Map.Entry<Class<?>, FieldBag>> iterator = set.iterator()-->Line_53 $$ while (iterator.hasNext()) [ FD ]
Line_53 $$ while (iterator.hasNext()) -->Line_59 $$ iterator.remove()[ CD ]
Line_52 $$ Iterator<Map.Entry<Class<?>, FieldBag>> iterator = set.iterator()-->Line_59 $$ iterator.remove()[ FD ]
Line_53 $$ while (iterator.hasNext()) -->Line_54 $$ Map.Entry<Class<?>, FieldBag> entry = iterator.next()[ CD ]
Line_40 $$ StringBundler sb = new StringBundler(6)-->Line_41 $$ sb.append("Unable to annotate field ")[ FD ]
Line_6 $$ for (Field field : testClass.getDeclaredFields()) -->Line_11 $$ Class<?> fieldClass = field.getType()[ FD ]
Line_2 $$ public void afterMethod(Description description, Object object, Object target) -->Line_51 $$ Set<Map.Entry<Class<?>, FieldBag>> set = deleteAfterTestRunFieldBags.entrySet()[ CD ]
Line_54 $$ Map.Entry<Class<?>, FieldBag> entry = iterator.next()-->Line_55 $$ Class<?> clazz = entry.getKey()[ FD ]
Line_53 $$ while (iterator.hasNext()) -->Line_56 $$ if (_orderedClasses.contains(clazz)) [ CD ]
Line_4 $$ Map<Class<?>, FieldBag> deleteAfterTestRunFieldBags = new HashMap()-->Line_51 $$ Set<Map.Entry<Class<?>, FieldBag>> set = deleteAfterTestRunFieldBags.entrySet()[ FD ]
Line_63 $$ FieldBag fieldBag = deleteAfterTestRunFieldBags.remove(clazz)-->Line_64 $$ if (fieldBag == null) [ FD ]
Line_2 $$ public void afterMethod(Description description, Object object, Object target) -->Line_26 $$ Collection<?> collection = (Collection<?>) field.get(target)[ FD ]
Line_2 $$ public void afterMethod(Description description, Object object, Object target) -->Line_52 $$ Iterator<Map.Entry<Class<?>, FieldBag>> iterator = set.iterator()[ CD ]
Line_5 $$ while (testClass != null) -->Line_49 $$ testClass = testClass.getSuperclass()[ CD ]
Line_6 $$ for (Field field : testClass.getDeclaredFields()) -->Line_26 $$ Collection<?> collection = (Collection<?>) field.get(target)[ FD ]
Line_55 $$ Class<?> clazz = entry.getKey()-->Line_56 $$ if (_orderedClasses.contains(clazz)) [ FD ]
Line_12 $$ if (PersistedModel.class.isAssignableFrom(fieldClass)) -->Line_13 $$ addField(deleteAfterTestRunFieldBags, fieldClass, field)[ CD ]
Line_3 $$ Class<?> testClass = description.getTestClass()-->Line_49 $$ testClass = testClass.getSuperclass()[ FD ]
Line_63 $$ FieldBag fieldBag = deleteAfterTestRunFieldBags.remove(clazz)-->Line_67 $$ removeField(fieldBag, target)[ FD ]
Line_2 $$ public void afterMethod(Description description, Object object, Object target) -->Line_60 $$ removeField(entry.getValue(), target)[ FD ]
Line_16 $$ if (fieldClass.isArray()) -->Line_20 $$ addField(deleteAfterTestRunFieldBags, fieldClass.getComponentType(), field)[ CD ]
Line_30 $$ Class<?> collectionType = getCollectionType(collection)-->Line_34 $$ addField(deleteAfterTestRunFieldBags, collectionType, field)[ FD ]
Line_6 $$ for (Field field : testClass.getDeclaredFields()) -->Line_20 $$ addField(deleteAfterTestRunFieldBags, fieldClass.getComponentType(), field)[ FD ]
Line_11 $$ Class<?> fieldClass = field.getType()-->Line_17 $$ if (!PersistedModel.class.isAssignableFrom(fieldClass.getComponentType())) [ FD ]
Line_6 $$ for (Field field : testClass.getDeclaredFields()) -->Line_34 $$ addField(deleteAfterTestRunFieldBags, collectionType, field)[ FD ]
Line_40 $$ StringBundler sb = new StringBundler(6)-->Line_43 $$ sb.append(" because it is not type of ")[ FD ]
Line_40 $$ StringBundler sb = new StringBundler(6)-->Line_47 $$ throw new IllegalArgumentException(sb.toString())[ FD ]
Line_53 $$ while (iterator.hasNext()) -->Line_55 $$ Class<?> clazz = entry.getKey()[ CD ]
Line_11 $$ Class<?> fieldClass = field.getType()-->Line_23 $$ if (Collection.class.isAssignableFrom(fieldClass)) [ FD ]
Line_11 $$ Class<?> fieldClass = field.getType()-->Line_16 $$ if (fieldClass.isArray()) [ FD ]
Line_11 $$ Class<?> fieldClass = field.getType()-->Line_20 $$ addField(deleteAfterTestRunFieldBags, fieldClass.getComponentType(), field)[ FD ]
Line_62 $$ for (Class<?> clazz : _orderedClasses) -->Line_63 $$ FieldBag fieldBag = deleteAfterTestRunFieldBags.remove(clazz)[ FD ]
Line_49 $$ testClass = testClass.getSuperclass()-->Line_5 $$ while (testClass != null) [ FD ]
Line_52 $$ Iterator<Map.Entry<Class<?>, FieldBag>> iterator = set.iterator()-->Line_54 $$ Map.Entry<Class<?>, FieldBag> entry = iterator.next()[ FD ]
Line_4 $$ Map<Class<?>, FieldBag> deleteAfterTestRunFieldBags = new HashMap()-->Line_34 $$ addField(deleteAfterTestRunFieldBags, collectionType, field)[ FD ]
Line_26 $$ Collection<?> collection = (Collection<?>) field.get(target)-->Line_30 $$ Class<?> collectionType = getCollectionType(collection)[ FD ]
Line_54 $$ Map.Entry<Class<?>, FieldBag> entry = iterator.next()-->Line_60 $$ removeField(entry.getValue(), target)[ FD ]
Line_40 $$ StringBundler sb = new StringBundler(6)-->Line_46 $$ sb.append(PersistedModel.class.getName())[ FD ]
Line_30 $$ Class<?> collectionType = getCollectionType(collection)-->Line_31 $$ if (collectionType == null) [ FD ]
Line_16 $$ if (fieldClass.isArray()) -->Line_17 $$ if (!PersistedModel.class.isAssignableFrom(fieldClass.getComponentType())) [ CD ]
Line_6 $$ for (Field field : testClass.getDeclaredFields()) -->Line_25 $$ field.setAccessible(true)[ FD ]
Line_6 $$ for (Field field : testClass.getDeclaredFields()) -->Line_42 $$ sb.append(field)[ FD ]
Line_2 $$ public void afterMethod(Description description, Object object, Object target) -->Line_67 $$ removeField(fieldBag, target)[ FD ]
Line_4 $$ Map<Class<?>, FieldBag> deleteAfterTestRunFieldBags = new HashMap()-->Line_13 $$ addField(deleteAfterTestRunFieldBags, fieldClass, field)[ FD ]
