Line_2 $$ private void corruptRandomTranslogFiles() throws IOException -->Line_6 $$ ShardIterator shardIterator = RandomPicks.randomFrom(getRandom(), iterators)[ CD ]
Line_38 $$ ByteBuffer bb = ByteBuffer.wrap(new byte[1])-->Line_40 $$ bb.flip()[ FD ]
Line_2 $$ private void corruptRandomTranslogFiles() throws IOException -->Line_4 $$ GroupShardsIterator shardIterators = state.getRoutingNodes().getRoutingTable().activePrimaryShardsGrouped(new String[] [ CD ]
Line_2 $$ private void corruptRandomTranslogFiles() throws IOException -->Line_10 $$ assertTrue(shardRouting.assignedToNode())[ CD ]
Line_23 $$ if (Files.isRegularFile(item) && item.getFileName().toString().startsWith("translog-")) -->Line_24 $$ files.add(item)[ CD ]
Line_15 $$ String path = fsPath.getPath()-->Line_17 $$ Path file = PathUtils.get(path).resolve(relativeDataLocationPath)[ FD ]
Line_2 $$ private void corruptRandomTranslogFiles() throws IOException -->Line_31 $$ if (!files.isEmpty()) [ CD ]
Line_2 $$ private void corruptRandomTranslogFiles() throws IOException -->Line_11 $$ String nodeId = shardRouting.currentNodeId()[ CD ]
Line_42 $$ byte newValue = (byte) (oldValue + 1)-->Line_43 $$ bb.put(0, newValue)[ FD ]
Line_4 $$ GroupShardsIterator shardIterators = state.getRoutingNodes().getRoutingTable().activePrimaryShardsGrouped(new String[] -->Line_5 $$ List<ShardIterator> iterators = iterableAsArrayList(shardIterators)[ FD ]
Line_37 $$ long filePointer = raf.position()-->Line_44 $$ raf.position(filePointer)[ FD ]
Line_12 $$ NodesStatsResponse nodeStatses = client().admin().cluster().prepareNodesStats(nodeId).setFs(true).get()-->Line_14 $$ for (FsInfo.Path fsPath : nodeStatses.getNodes()[0].getFs()) [ FD ]
Line_35 $$ try (FileChannel raf = FileChannel.open(fileToCorrupt, StandardOpenOption.READ, StandardOpenOption.WRITE)) -->Line_39 $$ raf.read(bb)[ FD ]
Line_2 $$ private void corruptRandomTranslogFiles() throws IOException -->Line_13 $$ Set<Path> files = new TreeSet()[ CD ]
Line_11 $$ String nodeId = shardRouting.currentNodeId()-->Line_12 $$ NodesStatsResponse nodeStatses = client().admin().cluster().prepareNodesStats(nodeId).setFs(true).get()[ FD ]
Line_17 $$ Path file = PathUtils.get(path).resolve(relativeDataLocationPath)-->Line_20 $$ try (DirectoryStream<Path> stream = Files.newDirectoryStream(file)) [ FD ]
Line_32 $$ int corruptions = randomIntBetween(5, 20)-->Line_33 $$ for (int i = 0; i < corruptions; i++) [ FD ]
Line_35 $$ try (FileChannel raf = FileChannel.open(fileToCorrupt, StandardOpenOption.READ, StandardOpenOption.WRITE)) -->Line_36 $$ raf.position(randomIntBetween(0, (int) Math.min(Integer.MAX_VALUE, raf.size() - 1)))[ FD ]
Line_2 $$ private void corruptRandomTranslogFiles() throws IOException -->Line_9 $$ assertTrue(shardRouting.primary())[ CD ]
Line_7 $$ ShardRouting shardRouting = shardIterator.nextOrNull()-->Line_16 $$ final String relativeDataLocationPath = "indices/test/" + Integer.toString(shardRouting.getId()) + "/translog"[ FD ]
Line_35 $$ try (FileChannel raf = FileChannel.open(fileToCorrupt, StandardOpenOption.READ, StandardOpenOption.WRITE)) -->Line_37 $$ long filePointer = raf.position()[ FD ]
Line_13 $$ Set<Path> files = new TreeSet()-->Line_24 $$ files.add(item)[ FD ]
Line_13 $$ Set<Path> files = new TreeSet()-->Line_34 $$ fileToCorrupt = RandomPicks.randomFrom(getRandom(), files)[ FD ]
Line_7 $$ ShardRouting shardRouting = shardIterator.nextOrNull()-->Line_10 $$ assertTrue(shardRouting.assignedToNode())[ FD ]
Line_34 $$ fileToCorrupt = RandomPicks.randomFrom(getRandom(), files)-->Line_50 $$ assertThat("no file corrupted", fileToCorrupt, notNullValue())[ FD ]
Line_3 $$ ClusterState state = client().admin().cluster().prepareState().get().getState()-->Line_4 $$ GroupShardsIterator shardIterators = state.getRoutingNodes().getRoutingTable().activePrimaryShardsGrouped(new String[] [ FD ]
Line_30 $$ Path fileToCorrupt = null-->Line_34 $$ fileToCorrupt = RandomPicks.randomFrom(getRandom(), files)[ FD ]
Line_2 $$ private void corruptRandomTranslogFiles() throws IOException -->Line_30 $$ Path fileToCorrupt = null[ CD ]
Line_30 $$ Path fileToCorrupt = null-->Line_50 $$ assertThat("no file corrupted", fileToCorrupt, notNullValue())[ FD ]
Line_2 $$ private void corruptRandomTranslogFiles() throws IOException -->Line_8 $$ assertNotNull(shardRouting)[ CD ]
Line_2 $$ private void corruptRandomTranslogFiles() throws IOException -->Line_3 $$ ClusterState state = client().admin().cluster().prepareState().get().getState()[ CD ]
Line_16 $$ final String relativeDataLocationPath = "indices/test/" + Integer.toString(shardRouting.getId()) + "/translog"-->Line_17 $$ Path file = PathUtils.get(path).resolve(relativeDataLocationPath)[ FD ]
Line_30 $$ Path fileToCorrupt = null-->Line_35 $$ try (FileChannel raf = FileChannel.open(fileToCorrupt, StandardOpenOption.READ, StandardOpenOption.WRITE)) [ FD ]
Line_7 $$ ShardRouting shardRouting = shardIterator.nextOrNull()-->Line_9 $$ assertTrue(shardRouting.primary())[ FD ]
Line_13 $$ Set<Path> files = new TreeSet()-->Line_31 $$ if (!files.isEmpty()) [ FD ]
Line_34 $$ fileToCorrupt = RandomPicks.randomFrom(getRandom(), files)-->Line_35 $$ try (FileChannel raf = FileChannel.open(fileToCorrupt, StandardOpenOption.READ, StandardOpenOption.WRITE)) [ FD ]
Line_38 $$ ByteBuffer bb = ByteBuffer.wrap(new byte[1])-->Line_41 $$ byte oldValue = bb.get(0)[ FD ]
Line_6 $$ ShardIterator shardIterator = RandomPicks.randomFrom(getRandom(), iterators)-->Line_7 $$ ShardRouting shardRouting = shardIterator.nextOrNull()[ FD ]
Line_7 $$ ShardRouting shardRouting = shardIterator.nextOrNull()-->Line_8 $$ assertNotNull(shardRouting)[ FD ]
Line_5 $$ List<ShardIterator> iterators = iterableAsArrayList(shardIterators)-->Line_6 $$ ShardIterator shardIterator = RandomPicks.randomFrom(getRandom(), iterators)[ FD ]
Line_2 $$ private void corruptRandomTranslogFiles() throws IOException -->Line_7 $$ ShardRouting shardRouting = shardIterator.nextOrNull()[ CD ]
Line_21 $$ for (Path item : stream) -->Line_24 $$ files.add(item)[ FD ]
Line_21 $$ for (Path item : stream) -->Line_23 $$ if (Files.isRegularFile(item) && item.getFileName().toString().startsWith("translog-")) [ FD ]
Line_38 $$ ByteBuffer bb = ByteBuffer.wrap(new byte[1])-->Line_45 $$ raf.write(bb)[ FD ]
Line_2 $$ private void corruptRandomTranslogFiles() throws IOException -->Line_12 $$ NodesStatsResponse nodeStatses = client().admin().cluster().prepareNodesStats(nodeId).setFs(true).get()[ CD ]
Line_35 $$ try (FileChannel raf = FileChannel.open(fileToCorrupt, StandardOpenOption.READ, StandardOpenOption.WRITE)) -->Line_44 $$ raf.position(filePointer)[ FD ]
Line_2 $$ private void corruptRandomTranslogFiles() throws IOException -->Line_5 $$ List<ShardIterator> iterators = iterableAsArrayList(shardIterators)[ CD ]
Line_38 $$ ByteBuffer bb = ByteBuffer.wrap(new byte[1])-->Line_43 $$ bb.put(0, newValue)[ FD ]
Line_35 $$ try (FileChannel raf = FileChannel.open(fileToCorrupt, StandardOpenOption.READ, StandardOpenOption.WRITE)) -->Line_45 $$ raf.write(bb)[ FD ]
Line_31 $$ if (!files.isEmpty()) -->Line_32 $$ int corruptions = randomIntBetween(5, 20)[ CD ]
Line_2 $$ private void corruptRandomTranslogFiles() throws IOException -->Line_50 $$ assertThat("no file corrupted", fileToCorrupt, notNullValue())[ CD ]
Line_17 $$ Path file = PathUtils.get(path).resolve(relativeDataLocationPath)-->Line_18 $$ if (Files.exists(file)) [ FD ]
Line_14 $$ for (FsInfo.Path fsPath : nodeStatses.getNodes()[0].getFs()) -->Line_15 $$ String path = fsPath.getPath()[ FD ]
Line_7 $$ ShardRouting shardRouting = shardIterator.nextOrNull()-->Line_11 $$ String nodeId = shardRouting.currentNodeId()[ FD ]
Line_38 $$ ByteBuffer bb = ByteBuffer.wrap(new byte[1])-->Line_39 $$ raf.read(bb)[ FD ]
Line_31 $$ if (!files.isEmpty()) -->Line_33 $$ for (int i = 0; i < corruptions; i++) [ CD ]
Line_33 $$ for (int i = 0; i < corruptions; i++) -->Line_34 $$ fileToCorrupt = RandomPicks.randomFrom(getRandom(), files)[ CD ]
