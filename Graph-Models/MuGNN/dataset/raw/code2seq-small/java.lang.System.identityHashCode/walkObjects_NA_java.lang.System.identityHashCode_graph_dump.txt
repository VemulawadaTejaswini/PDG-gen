Line_15 $$ DebugReflectionUtil.processStronglyReferencedValues(root, new PairProcessor<Object, Field>() -->Line_17 $$ Class<?> valueClass = value.getClass()[ CD ]
Line_9 $$ if (toVisit.isEmpty())-->Line_10 $$ return[ CD ]
Line_15 $$ DebugReflectionUtil.processStronglyReferencedValues(root, new PairProcessor<Object, Field>() -->Line_23 $$ return true[ CD ]
Line_18 $$ if (lookFor.isAssignableFrom(valueClass) && isReallyLeak(value)) -->Line_21 $$ toVisit.addLast(new BackLink(value, field, backLink))[ CD ]
Line_12 $$ Object root = backLink.value-->Line_15 $$ DebugReflectionUtil.processStronglyReferencedValues(root, new PairProcessor<Object, Field>() [ FD ]
Line_8 $$ while (true) -->Line_13 $$ if (!visited.add(System.identityHashCode(root)))[ CD ]
Line_2 $$ private static void walkObjects(@NotNull final Class<?> lookFor, @NotNull Collection<Object> startRoots, @NotNull final Processor<BackLink> leakProcessor) -->Line_19 $$ leakProcessor.process(new BackLink(value, field, backLink))[ FD ]
Line_8 $$ while (true) -->Line_9 $$ if (toVisit.isEmpty())[ CD ]
Line_15 $$ DebugReflectionUtil.processStronglyReferencedValues(root, new PairProcessor<Object, Field>() -->Line_17 $$ Class<?> valueClass = value.getClass()[ FD ]
Line_8 $$ while (true) -->Line_11 $$ final BackLink backLink = toVisit.pullFirst()[ CD ]
Line_18 $$ if (lookFor.isAssignableFrom(valueClass) && isReallyLeak(value)) -->Line_19 $$ leakProcessor.process(new BackLink(value, field, backLink))[ CD ]
Line_15 $$ DebugReflectionUtil.processStronglyReferencedValues(root, new PairProcessor<Object, Field>() -->Line_18 $$ if (lookFor.isAssignableFrom(valueClass) && isReallyLeak(value)) [ FD ]
Line_17 $$ Class<?> valueClass = value.getClass()-->Line_18 $$ if (lookFor.isAssignableFrom(valueClass) && isReallyLeak(value)) [ FD ]
Line_2 $$ private static void walkObjects(@NotNull final Class<?> lookFor, @NotNull Collection<Object> startRoots, @NotNull final Processor<BackLink> leakProcessor) -->Line_18 $$ if (lookFor.isAssignableFrom(valueClass) && isReallyLeak(value)) [ FD ]
Line_8 $$ while (true) -->Line_12 $$ Object root = backLink.value[ CD ]
Line_12 $$ Object root = backLink.value-->Line_13 $$ if (!visited.add(System.identityHashCode(root)))[ FD ]
Line_15 $$ DebugReflectionUtil.processStronglyReferencedValues(root, new PairProcessor<Object, Field>() -->Line_18 $$ if (lookFor.isAssignableFrom(valueClass) && isReallyLeak(value)) [ CD ]
Line_2 $$ private static void walkObjects(@NotNull final Class<?> lookFor, @NotNull Collection<Object> startRoots, @NotNull final Processor<BackLink> leakProcessor) -->Line_8 $$ while (true) [ CD ]
Line_4 $$ final Queue<BackLink> toVisit = new Queue<BackLink>(1000000)-->Line_21 $$ toVisit.addLast(new BackLink(value, field, backLink))[ FD ]
Line_4 $$ final Queue<BackLink> toVisit = new Queue<BackLink>(1000000)-->Line_11 $$ final BackLink backLink = toVisit.pullFirst()[ FD ]
Line_8 $$ while (true) -->Line_15 $$ DebugReflectionUtil.processStronglyReferencedValues(root, new PairProcessor<Object, Field>() [ CD ]
Line_4 $$ final Queue<BackLink> toVisit = new Queue<BackLink>(1000000)-->Line_9 $$ if (toVisit.isEmpty())[ FD ]
Line_2 $$ private static void walkObjects(@NotNull final Class<?> lookFor, @NotNull Collection<Object> startRoots, @NotNull final Processor<BackLink> leakProcessor) -->Line_4 $$ final Queue<BackLink> toVisit = new Queue<BackLink>(1000000)[ CD ]
Line_3 $$ TIntHashSet visited = new TIntHashSet()-->Line_13 $$ if (!visited.add(System.identityHashCode(root)))[ FD ]
Line_4 $$ final Queue<BackLink> toVisit = new Queue<BackLink>(1000000)-->Line_6 $$ toVisit.addLast(new BackLink(startRoot, null, null))[ FD ]
Line_2 $$ private static void walkObjects(@NotNull final Class<?> lookFor, @NotNull Collection<Object> startRoots, @NotNull final Processor<BackLink> leakProcessor) -->Line_3 $$ TIntHashSet visited = new TIntHashSet()[ CD ]
