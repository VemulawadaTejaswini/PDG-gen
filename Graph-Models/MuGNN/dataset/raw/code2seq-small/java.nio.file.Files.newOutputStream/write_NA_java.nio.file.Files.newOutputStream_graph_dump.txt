Line_2 $$ public final void write(final T state, final long version, final Path... locations) throws IOException -->Line_28 $$ toXContent(builder, state)[ FD ]
Line_2 $$ public final void write(final T state, final long version, final Path... locations) throws IOException -->Line_53 $$ cleanupOldFiles(prefix, fileName, locations)[ CD ]
Line_2 $$ public final void write(final T state, final long version, final Path... locations) throws IOException -->Line_3 $$ if (locations == null) [ FD ]
Line_37 $$ for (int i = 1; i < locations.length; i++) -->Line_39 $$ Files.createDirectories(stateLocation)[ CD ]
Line_2 $$ public final void write(final T state, final long version, final Path... locations) throws IOException -->Line_14 $$ final Path tmpStatePath = stateLocation.resolve(fileName + ".tmp")[ CD ]
Line_15 $$ final Path finalStatePath = stateLocation.resolve(fileName)-->Line_35 $$ Files.move(tmpStatePath, finalStatePath, StandardCopyOption.ATOMIC_MOVE)[ FD ]
Line_40 $$ Path tmpPath = stateLocation.resolve(fileName + ".tmp")-->Line_47 $$ Files.deleteIfExists(tmpPath)[ FD ]
Line_12 $$ Path stateLocation = locations[0].resolve(STATE_DIR_NAME)-->Line_39 $$ Files.createDirectories(stateLocation)[ FD ]
Line_15 $$ final Path finalStatePath = stateLocation.resolve(fileName)-->Line_43 $$ Files.copy(finalStatePath, tmpPath)[ FD ]
Line_37 $$ for (int i = 1; i < locations.length; i++) -->Line_38 $$ stateLocation = locations[i].resolve(STATE_DIR_NAME)[ CD ]
Line_41 $$ Path finalPath = stateLocation.resolve(fileName)-->Line_44 $$ Files.move(tmpPath, finalPath, StandardCopyOption.ATOMIC_MOVE)[ FD ]
Line_37 $$ for (int i = 1; i < locations.length; i++) -->Line_41 $$ Path finalPath = stateLocation.resolve(fileName)[ CD ]
Line_22 $$ try (XContentBuilder builder = newXContentBuilder(format, new IndexOutputOutputStream(out) -->Line_26 $$ builder.startObject()[ FD ]
Line_2 $$ public final void write(final T state, final long version, final Path... locations) throws IOException -->Line_9 $$ final long maxStateId = findMaxStateId(prefix, locations) + 1[ FD ]
Line_2 $$ public final void write(final T state, final long version, final Path... locations) throws IOException -->Line_3 $$ if (locations == null) [ CD ]
Line_2 $$ public final void write(final T state, final long version, final Path... locations) throws IOException -->Line_6 $$ if (locations.length <= 0) [ CD ]
Line_22 $$ try (XContentBuilder builder = newXContentBuilder(format, new IndexOutputOutputStream(out) -->Line_28 $$ toXContent(builder, state)[ FD ]
Line_12 $$ Path stateLocation = locations[0].resolve(STATE_DIR_NAME)-->Line_14 $$ final Path tmpStatePath = stateLocation.resolve(fileName + ".tmp")[ FD ]
Line_12 $$ Path stateLocation = locations[0].resolve(STATE_DIR_NAME)-->Line_13 $$ Files.createDirectories(stateLocation)[ FD ]
Line_18 $$ try (OutputStreamIndexOutput out = new OutputStreamIndexOutput(resourceDesc, Files.newOutputStream(tmpStatePath), BUFFER_SIZE)) -->Line_21 $$ out.writeLong(version)[ FD ]
Line_2 $$ public final void write(final T state, final long version, final Path... locations) throws IOException -->Line_13 $$ Files.createDirectories(stateLocation)[ CD ]
Line_2 $$ public final void write(final T state, final long version, final Path... locations) throws IOException -->Line_21 $$ out.writeLong(version)[ FD ]
Line_14 $$ final Path tmpStatePath = stateLocation.resolve(fileName + ".tmp")-->Line_35 $$ Files.move(tmpStatePath, finalStatePath, StandardCopyOption.ATOMIC_MOVE)[ FD ]
Line_11 $$ final String fileName = prefix + maxStateId + STATE_FILE_EXTENSION-->Line_15 $$ final Path finalStatePath = stateLocation.resolve(fileName)[ FD ]
Line_18 $$ try (OutputStreamIndexOutput out = new OutputStreamIndexOutput(resourceDesc, Files.newOutputStream(tmpStatePath), BUFFER_SIZE)) -->Line_32 $$ CodecUtil.writeFooter(out)[ FD ]
Line_12 $$ Path stateLocation = locations[0].resolve(STATE_DIR_NAME)-->Line_15 $$ final Path finalStatePath = stateLocation.resolve(fileName)[ FD ]
Line_11 $$ final String fileName = prefix + maxStateId + STATE_FILE_EXTENSION-->Line_53 $$ cleanupOldFiles(prefix, fileName, locations)[ FD ]
Line_14 $$ final Path tmpStatePath = stateLocation.resolve(fileName + ".tmp")-->Line_34 $$ IOUtils.fsync(tmpStatePath, false)[ FD ]
Line_12 $$ Path stateLocation = locations[0].resolve(STATE_DIR_NAME)-->Line_40 $$ Path tmpPath = stateLocation.resolve(fileName + ".tmp")[ FD ]
Line_2 $$ public final void write(final T state, final long version, final Path... locations) throws IOException -->Line_53 $$ cleanupOldFiles(prefix, fileName, locations)[ FD ]
Line_18 $$ try (OutputStreamIndexOutput out = new OutputStreamIndexOutput(resourceDesc, Files.newOutputStream(tmpStatePath), BUFFER_SIZE)) -->Line_19 $$ CodecUtil.writeHeader(out, STATE_FILE_CODEC, STATE_FILE_VERSION)[ FD ]
Line_40 $$ Path tmpPath = stateLocation.resolve(fileName + ".tmp")-->Line_44 $$ Files.move(tmpPath, finalPath, StandardCopyOption.ATOMIC_MOVE)[ FD ]
Line_14 $$ final Path tmpStatePath = stateLocation.resolve(fileName + ".tmp")-->Line_51 $$ Files.deleteIfExists(tmpStatePath)[ FD ]
Line_22 $$ try (XContentBuilder builder = newXContentBuilder(format, new IndexOutputOutputStream(out) -->Line_30 $$ builder.endObject()[ FD ]
Line_12 $$ Path stateLocation = locations[0].resolve(STATE_DIR_NAME)-->Line_41 $$ Path finalPath = stateLocation.resolve(fileName)[ FD ]
Line_14 $$ final Path tmpStatePath = stateLocation.resolve(fileName + ".tmp")-->Line_18 $$ try (OutputStreamIndexOutput out = new OutputStreamIndexOutput(resourceDesc, Files.newOutputStream(tmpStatePath), BUFFER_SIZE)) [ FD ]
Line_12 $$ Path stateLocation = locations[0].resolve(STATE_DIR_NAME)-->Line_36 $$ IOUtils.fsync(stateLocation, true)[ FD ]
Line_2 $$ public final void write(final T state, final long version, final Path... locations) throws IOException -->Line_12 $$ Path stateLocation = locations[0].resolve(STATE_DIR_NAME)[ CD ]
Line_2 $$ public final void write(final T state, final long version, final Path... locations) throws IOException -->Line_15 $$ final Path finalStatePath = stateLocation.resolve(fileName)[ CD ]
Line_2 $$ public final void write(final T state, final long version, final Path... locations) throws IOException -->Line_11 $$ final String fileName = prefix + maxStateId + STATE_FILE_EXTENSION[ CD ]
Line_40 $$ Path tmpPath = stateLocation.resolve(fileName + ".tmp")-->Line_43 $$ Files.copy(finalStatePath, tmpPath)[ FD ]
Line_2 $$ public final void write(final T state, final long version, final Path... locations) throws IOException -->Line_9 $$ final long maxStateId = findMaxStateId(prefix, locations) + 1[ CD ]
Line_37 $$ for (int i = 1; i < locations.length; i++) -->Line_40 $$ Path tmpPath = stateLocation.resolve(fileName + ".tmp")[ CD ]
Line_12 $$ Path stateLocation = locations[0].resolve(STATE_DIR_NAME)-->Line_45 $$ IOUtils.fsync(stateLocation, true)[ FD ]
Line_11 $$ final String fileName = prefix + maxStateId + STATE_FILE_EXTENSION-->Line_41 $$ Path finalPath = stateLocation.resolve(fileName)[ FD ]
Line_18 $$ try (OutputStreamIndexOutput out = new OutputStreamIndexOutput(resourceDesc, Files.newOutputStream(tmpStatePath), BUFFER_SIZE)) -->Line_20 $$ out.writeInt(format.index())[ FD ]
