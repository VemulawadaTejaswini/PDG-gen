Line_14 $$ Class<?> actualType = parameterTypes[i]-->Line_18 $$ checkArgument(nullable, "Method %s has parameter with type %s that is missing @Nullable", method, actualType)[ FD ]
Line_13 $$ for (int i = 0; i < parameterTypes.length; i++) -->Line_14 $$ Class<?> actualType = parameterTypes[i][ CD ]
Line_2 $$ private static void verifyMethodSignature(Method method, TypeSignature returnTypeName, List<TypeSignature> argumentTypeNames, TypeManager typeManager) -->Line_6 $$ checkArgument(Primitives.unwrap(method.getReturnType()) == returnType.getJavaType(), "Expected method %s return type to be %s (%s)", method, returnType.getJavaType().getName(), returnType)[ FD ]
Line_2 $$ private static void verifyMethodSignature(Method method, TypeSignature returnTypeName, List<TypeSignature> argumentTypeNames, TypeManager typeManager) -->Line_23 $$ checkArgument(Primitives.unwrap(actualType) == expectedType.getJavaType(), "Expected method %s parameter %s type to be %s (%s)", method, i, expectedType.getJavaType().getName(), expectedType)[ FD ]
Line_14 $$ Class<?> actualType = parameterTypes[i]-->Line_17 $$ if (Primitives.isWrapperType(actualType)) [ FD ]
Line_2 $$ private static void verifyMethodSignature(Method method, TypeSignature returnTypeName, List<TypeSignature> argumentTypeNames, TypeManager typeManager) -->Line_7 $$ Class<?>[] parameterTypes = method.getParameterTypes()[ FD ]
Line_17 $$ if (Primitives.isWrapperType(actualType)) -->Line_18 $$ checkArgument(nullable, "Method %s has parameter with type %s that is missing @Nullable", method, actualType)[ CD ]
Line_5 $$ List<Type> argumentTypes = resolveTypes(argumentTypeNames, typeManager)-->Line_15 $$ Type expectedType = argumentTypes.get(i)[ FD ]
Line_13 $$ for (int i = 0; i < parameterTypes.length; i++) -->Line_20 $$ if (nullable) [ CD ]
Line_2 $$ private static void verifyMethodSignature(Method method, TypeSignature returnTypeName, List<TypeSignature> argumentTypeNames, TypeManager typeManager) -->Line_8 $$ Annotation[][] annotations = method.getParameterAnnotations()[ FD ]
Line_20 $$ if (nullable) -->Line_21 $$ checkArgument(!NON_NULLABLE_ARGUMENT_TYPES.contains(actualType), "Method %s has parameter type %s, but @Nullable is not supported on this type", method, actualType)[ CD ]
Line_2 $$ private static void verifyMethodSignature(Method method, TypeSignature returnTypeName, List<TypeSignature> argumentTypeNames, TypeManager typeManager) -->Line_7 $$ Class<?>[] parameterTypes = method.getParameterTypes()[ CD ]
Line_13 $$ for (int i = 0; i < parameterTypes.length; i++) -->Line_15 $$ Type expectedType = argumentTypes.get(i)[ CD ]
Line_13 $$ for (int i = 0; i < parameterTypes.length; i++) -->Line_16 $$ boolean nullable = Arrays.asList(annotations[i]).stream().anyMatch(Nullable.class::<>isInstance)[ CD ]
Line_9 $$ if (parameterTypes.length > 0 && parameterTypes[0] == ConnectorSession.class) -->Line_11 $$ annotations = Arrays.copyOfRange(annotations, 1, annotations.length)[ CD ]
Line_2 $$ private static void verifyMethodSignature(Method method, TypeSignature returnTypeName, List<TypeSignature> argumentTypeNames, TypeManager typeManager) -->Line_4 $$ requireNonNull(returnType, "returnType is null")[ CD ]
Line_2 $$ private static void verifyMethodSignature(Method method, TypeSignature returnTypeName, List<TypeSignature> argumentTypeNames, TypeManager typeManager) -->Line_5 $$ List<Type> argumentTypes = resolveTypes(argumentTypeNames, typeManager)[ FD ]
Line_9 $$ if (parameterTypes.length > 0 && parameterTypes[0] == ConnectorSession.class) -->Line_10 $$ parameterTypes = Arrays.copyOfRange(parameterTypes, 1, parameterTypes.length)[ CD ]
Line_2 $$ private static void verifyMethodSignature(Method method, TypeSignature returnTypeName, List<TypeSignature> argumentTypeNames, TypeManager typeManager) -->Line_3 $$ Type returnType = typeManager.getType(returnTypeName)[ CD ]
Line_2 $$ private static void verifyMethodSignature(Method method, TypeSignature returnTypeName, List<TypeSignature> argumentTypeNames, TypeManager typeManager) -->Line_6 $$ checkArgument(Primitives.unwrap(method.getReturnType()) == returnType.getJavaType(), "Expected method %s return type to be %s (%s)", method, returnType.getJavaType().getName(), returnType)[ CD ]
Line_2 $$ private static void verifyMethodSignature(Method method, TypeSignature returnTypeName, List<TypeSignature> argumentTypeNames, TypeManager typeManager) -->Line_8 $$ Annotation[][] annotations = method.getParameterAnnotations()[ CD ]
Line_15 $$ Type expectedType = argumentTypes.get(i)-->Line_23 $$ checkArgument(Primitives.unwrap(actualType) == expectedType.getJavaType(), "Expected method %s parameter %s type to be %s (%s)", method, i, expectedType.getJavaType().getName(), expectedType)[ FD ]
Line_2 $$ private static void verifyMethodSignature(Method method, TypeSignature returnTypeName, List<TypeSignature> argumentTypeNames, TypeManager typeManager) -->Line_3 $$ Type returnType = typeManager.getType(returnTypeName)[ FD ]
Line_2 $$ private static void verifyMethodSignature(Method method, TypeSignature returnTypeName, List<TypeSignature> argumentTypeNames, TypeManager typeManager) -->Line_18 $$ checkArgument(nullable, "Method %s has parameter with type %s that is missing @Nullable", method, actualType)[ FD ]
Line_13 $$ for (int i = 0; i < parameterTypes.length; i++) -->Line_17 $$ if (Primitives.isWrapperType(actualType)) [ CD ]
Line_2 $$ private static void verifyMethodSignature(Method method, TypeSignature returnTypeName, List<TypeSignature> argumentTypeNames, TypeManager typeManager) -->Line_5 $$ List<Type> argumentTypes = resolveTypes(argumentTypeNames, typeManager)[ CD ]
Line_3 $$ Type returnType = typeManager.getType(returnTypeName)-->Line_4 $$ requireNonNull(returnType, "returnType is null")[ FD ]
Line_13 $$ for (int i = 0; i < parameterTypes.length; i++) -->Line_23 $$ checkArgument(Primitives.unwrap(actualType) == expectedType.getJavaType(), "Expected method %s parameter %s type to be %s (%s)", method, i, expectedType.getJavaType().getName(), expectedType)[ CD ]
Line_2 $$ private static void verifyMethodSignature(Method method, TypeSignature returnTypeName, List<TypeSignature> argumentTypeNames, TypeManager typeManager) -->Line_9 $$ if (parameterTypes.length > 0 && parameterTypes[0] == ConnectorSession.class) [ CD ]
Line_13 $$ for (int i = 0; i < parameterTypes.length; i++) -->Line_15 $$ Type expectedType = argumentTypes.get(i)[ FD ]
Line_14 $$ Class<?> actualType = parameterTypes[i]-->Line_23 $$ checkArgument(Primitives.unwrap(actualType) == expectedType.getJavaType(), "Expected method %s parameter %s type to be %s (%s)", method, i, expectedType.getJavaType().getName(), expectedType)[ FD ]
Line_14 $$ Class<?> actualType = parameterTypes[i]-->Line_21 $$ checkArgument(!NON_NULLABLE_ARGUMENT_TYPES.contains(actualType), "Method %s has parameter type %s, but @Nullable is not supported on this type", method, actualType)[ FD ]
Line_2 $$ private static void verifyMethodSignature(Method method, TypeSignature returnTypeName, List<TypeSignature> argumentTypeNames, TypeManager typeManager) -->Line_13 $$ for (int i = 0; i < parameterTypes.length; i++) [ CD ]
Line_2 $$ private static void verifyMethodSignature(Method method, TypeSignature returnTypeName, List<TypeSignature> argumentTypeNames, TypeManager typeManager) -->Line_21 $$ checkArgument(!NON_NULLABLE_ARGUMENT_TYPES.contains(actualType), "Method %s has parameter type %s, but @Nullable is not supported on this type", method, actualType)[ FD ]
Line_8 $$ Annotation[][] annotations = method.getParameterAnnotations()-->Line_11 $$ annotations = Arrays.copyOfRange(annotations, 1, annotations.length)[ FD ]
Line_13 $$ for (int i = 0; i < parameterTypes.length; i++) -->Line_23 $$ checkArgument(Primitives.unwrap(actualType) == expectedType.getJavaType(), "Expected method %s parameter %s type to be %s (%s)", method, i, expectedType.getJavaType().getName(), expectedType)[ FD ]
Line_3 $$ Type returnType = typeManager.getType(returnTypeName)-->Line_6 $$ checkArgument(Primitives.unwrap(method.getReturnType()) == returnType.getJavaType(), "Expected method %s return type to be %s (%s)", method, returnType.getJavaType().getName(), returnType)[ FD ]
Line_7 $$ Class<?>[] parameterTypes = method.getParameterTypes()-->Line_10 $$ parameterTypes = Arrays.copyOfRange(parameterTypes, 1, parameterTypes.length)[ FD ]
Line_16 $$ boolean nullable = Arrays.asList(annotations[i]).stream().anyMatch(Nullable.class::<>isInstance)-->Line_18 $$ checkArgument(nullable, "Method %s has parameter with type %s that is missing @Nullable", method, actualType)[ FD ]
