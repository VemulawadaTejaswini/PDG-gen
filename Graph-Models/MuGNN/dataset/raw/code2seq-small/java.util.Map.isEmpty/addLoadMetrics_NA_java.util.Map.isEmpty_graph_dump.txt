Line_7 $$ Map<String, String> propertyMap = PROPERTY.unwrap(context, node)-->Line_32 $$ props.putAll(propertyMap)[ FD ]
Line_8 $$ Class<? extends LoadMetric> loadMetricClass = null-->Line_16 $$ loadMetricClass = (metric != null) ? metric.getLoadMetricClass() : null[ FD ]
Line_4 $$ ModelNode node = p.getValue()-->Line_7 $$ Map<String, String> propertyMap = PROPERTY.unwrap(context, node)[ FD ]
Line_11 $$ if (type.equals("mem")) -->Line_12 $$ ROOT_LOGGER.unsupportedMetric(type)[ CD ]
Line_9 $$ if (node.hasDefined(CommonAttributes.TYPE)) -->Line_18 $$ String className = CustomLoadMetricDefinition.CLASS.resolveModelAttribute(context, node).asString()[ CD ]
Line_20 $$ loadMetricClass = this.getClass().getClassLoader().loadClass(className).asSubclass(LoadMetric.class)-->Line_27 $$ LoadMetric metric = loadMetricClass.newInstance()[ FD ]
Line_2 $$ private void addLoadMetrics(Set<LoadMetric> metrics, ModelNode nodes, final OperationContext context) throws OperationFailedException -->Line_6 $$ int weight = WEIGHT.resolveModelAttribute(context, node).asInt()[ FD ]
Line_8 $$ Class<? extends LoadMetric> loadMetricClass = null-->Line_27 $$ LoadMetric metric = loadMetricClass.newInstance()[ FD ]
Line_9 $$ if (node.hasDefined(CommonAttributes.TYPE)) -->Line_16 $$ loadMetricClass = (metric != null) ? metric.getLoadMetricClass() : null[ CD ]
Line_8 $$ Class<? extends LoadMetric> loadMetricClass = null-->Line_20 $$ loadMetricClass = this.getClass().getClassLoader().loadClass(className).asSubclass(LoadMetric.class)[ FD ]
Line_20 $$ loadMetricClass = this.getClass().getClassLoader().loadClass(className).asSubclass(LoadMetric.class)-->Line_36 $$ ROOT_LOGGER.errorApplyingMetricProperties(ex, loadMetricClass.getCanonicalName())[ FD ]
Line_10 $$ String type = TYPE.resolveModelAttribute(context, node).asString()-->Line_11 $$ if (type.equals("mem")) [ FD ]
Line_20 $$ loadMetricClass = this.getClass().getClassLoader().loadClass(className).asSubclass(LoadMetric.class)-->Line_25 $$ if (loadMetricClass != null) [ FD ]
Line_31 $$ Properties props = new Properties()-->Line_34 $$ BeanUtils.mapJavaBeanProperties(metric, props, true)[ FD ]
Line_3 $$ for (Property p : nodes.asPropertyList()) -->Line_4 $$ ModelNode node = p.getValue()[ FD ]
Line_16 $$ loadMetricClass = (metric != null) ? metric.getLoadMetricClass() : null-->Line_25 $$ if (loadMetricClass != null) [ FD ]
Line_4 $$ ModelNode node = p.getValue()-->Line_6 $$ int weight = WEIGHT.resolveModelAttribute(context, node).asInt()[ FD ]
Line_15 $$ LoadMetricEnum metric = LoadMetricEnum.forType(type)-->Line_34 $$ BeanUtils.mapJavaBeanProperties(metric, props, true)[ FD ]
Line_9 $$ if (node.hasDefined(CommonAttributes.TYPE)) -->Line_11 $$ if (type.equals("mem")) [ CD ]
Line_7 $$ Map<String, String> propertyMap = PROPERTY.unwrap(context, node)-->Line_30 $$ if (propertyMap != null && !propertyMap.isEmpty()) [ FD ]
Line_15 $$ LoadMetricEnum metric = LoadMetricEnum.forType(type)-->Line_29 $$ metric.setWeight(weight)[ FD ]
Line_16 $$ loadMetricClass = (metric != null) ? metric.getLoadMetricClass() : null-->Line_36 $$ ROOT_LOGGER.errorApplyingMetricProperties(ex, loadMetricClass.getCanonicalName())[ FD ]
Line_2 $$ private void addLoadMetrics(Set<LoadMetric> metrics, ModelNode nodes, final OperationContext context) throws OperationFailedException -->Line_5 $$ double capacity = CAPACITY.resolveModelAttribute(context, node).asDouble()[ FD ]
Line_6 $$ int weight = WEIGHT.resolveModelAttribute(context, node).asInt()-->Line_29 $$ metric.setWeight(weight)[ FD ]
Line_4 $$ ModelNode node = p.getValue()-->Line_5 $$ double capacity = CAPACITY.resolveModelAttribute(context, node).asDouble()[ FD ]
Line_16 $$ loadMetricClass = (metric != null) ? metric.getLoadMetricClass() : null-->Line_20 $$ loadMetricClass = this.getClass().getClassLoader().loadClass(className).asSubclass(LoadMetric.class)[ FD ]
Line_4 $$ ModelNode node = p.getValue()-->Line_9 $$ if (node.hasDefined(CommonAttributes.TYPE)) [ FD ]
Line_18 $$ String className = CustomLoadMetricDefinition.CLASS.resolveModelAttribute(context, node).asString()-->Line_20 $$ loadMetricClass = this.getClass().getClassLoader().loadClass(className).asSubclass(LoadMetric.class)[ FD ]
Line_30 $$ if (propertyMap != null && !propertyMap.isEmpty()) -->Line_32 $$ props.putAll(propertyMap)[ CD ]
Line_10 $$ String type = TYPE.resolveModelAttribute(context, node).asString()-->Line_12 $$ ROOT_LOGGER.unsupportedMetric(type)[ FD ]
Line_2 $$ private void addLoadMetrics(Set<LoadMetric> metrics, ModelNode nodes, final OperationContext context) throws OperationFailedException -->Line_40 $$ metrics.add(metric)[ FD ]
Line_4 $$ ModelNode node = p.getValue()-->Line_18 $$ String className = CustomLoadMetricDefinition.CLASS.resolveModelAttribute(context, node).asString()[ FD ]
Line_10 $$ String type = TYPE.resolveModelAttribute(context, node).asString()-->Line_15 $$ LoadMetricEnum metric = LoadMetricEnum.forType(type)[ FD ]
Line_2 $$ private void addLoadMetrics(Set<LoadMetric> metrics, ModelNode nodes, final OperationContext context) throws OperationFailedException -->Line_18 $$ String className = CustomLoadMetricDefinition.CLASS.resolveModelAttribute(context, node).asString()[ FD ]
Line_5 $$ double capacity = CAPACITY.resolveModelAttribute(context, node).asDouble()-->Line_28 $$ metric.setCapacity(capacity)[ FD ]
Line_31 $$ Properties props = new Properties()-->Line_32 $$ props.putAll(propertyMap)[ FD ]
Line_8 $$ Class<? extends LoadMetric> loadMetricClass = null-->Line_36 $$ ROOT_LOGGER.errorApplyingMetricProperties(ex, loadMetricClass.getCanonicalName())[ FD ]
Line_2 $$ private void addLoadMetrics(Set<LoadMetric> metrics, ModelNode nodes, final OperationContext context) throws OperationFailedException -->Line_3 $$ for (Property p : nodes.asPropertyList()) [ FD ]
Line_2 $$ private void addLoadMetrics(Set<LoadMetric> metrics, ModelNode nodes, final OperationContext context) throws OperationFailedException -->Line_7 $$ Map<String, String> propertyMap = PROPERTY.unwrap(context, node)[ FD ]
Line_9 $$ if (node.hasDefined(CommonAttributes.TYPE)) -->Line_10 $$ String type = TYPE.resolveModelAttribute(context, node).asString()[ CD ]
Line_15 $$ LoadMetricEnum metric = LoadMetricEnum.forType(type)-->Line_28 $$ metric.setCapacity(capacity)[ FD ]
Line_15 $$ LoadMetricEnum metric = LoadMetricEnum.forType(type)-->Line_40 $$ metrics.add(metric)[ FD ]
Line_30 $$ if (propertyMap != null && !propertyMap.isEmpty()) -->Line_31 $$ Properties props = new Properties()[ CD ]
Line_4 $$ ModelNode node = p.getValue()-->Line_10 $$ String type = TYPE.resolveModelAttribute(context, node).asString()[ FD ]
Line_9 $$ if (node.hasDefined(CommonAttributes.TYPE)) -->Line_15 $$ LoadMetricEnum metric = LoadMetricEnum.forType(type)[ CD ]
Line_15 $$ LoadMetricEnum metric = LoadMetricEnum.forType(type)-->Line_16 $$ loadMetricClass = (metric != null) ? metric.getLoadMetricClass() : null[ FD ]
Line_16 $$ loadMetricClass = (metric != null) ? metric.getLoadMetricClass() : null-->Line_27 $$ LoadMetric metric = loadMetricClass.newInstance()[ FD ]
Line_2 $$ private void addLoadMetrics(Set<LoadMetric> metrics, ModelNode nodes, final OperationContext context) throws OperationFailedException -->Line_10 $$ String type = TYPE.resolveModelAttribute(context, node).asString()[ FD ]
Line_8 $$ Class<? extends LoadMetric> loadMetricClass = null-->Line_25 $$ if (loadMetricClass != null) [ FD ]
