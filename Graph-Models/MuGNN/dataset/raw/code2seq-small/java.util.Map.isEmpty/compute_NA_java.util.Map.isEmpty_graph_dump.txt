Line_11 $$ final Set<String> simplyImportedClasses = new LinkedHashSet<String>()-->Line_21 $$ GrImportStatement[] newImports = prepare(usedImports, simplyImportedClasses, staticallyImportedMembers, implicitlyImportedClasses, innerClasses, aliasImported, annotatedImports, unresolvedOnDemandImports)[ FD ]
Line_2 $$ public Runnable compute() -->Line_14 $$ final Set<GrImportStatement> unresolvedOnDemandImports = new HashSet<GrImportStatement>()[ CD ]
Line_2 $$ public Runnable compute() -->Line_26 $$ final GroovyFile tempFile = factory.createGroovyFile("", false, null)[ CD ]
Line_32 $$ final int endOffset = oldImports.get(oldImports.size() - 1).getTextRange().getEndOffset()-->Line_33 $$ String oldText = oldImports.isEmpty() ? "" : myFile.getText().substring(startOffset, endOffset)[ FD ]
Line_2 $$ public Runnable compute() -->Line_6 $$ final PsiDocumentManager documentManager = PsiDocumentManager.getInstance(file.getProject())[ CD ]
Line_30 $$ if (!oldImports.isEmpty()) -->Line_31 $$ final int startOffset = oldImports.get(0).getTextRange().getStartOffset()[ CD ]
Line_26 $$ final GroovyFile tempFile = factory.createGroovyFile("", false, null)-->Line_40 $$ for (GrImportStatement statement : tempFile.getImportStatements()) [ FD ]
Line_11 $$ final Set<String> simplyImportedClasses = new LinkedHashSet<String>()-->Line_19 $$ GroovyImportUtil.processFile(myFile, simplyImportedClasses, staticallyImportedMembers, usedImports, unresolvedOnDemandImports, implicitlyImportedClasses, innerClasses, aliasImported, annotatedImports)[ FD ]
Line_13 $$ final Set<GrImportStatement> usedImports = new HashSet<GrImportStatement>()-->Line_21 $$ GrImportStatement[] newImports = prepare(usedImports, simplyImportedClasses, staticallyImportedMembers, implicitlyImportedClasses, innerClasses, aliasImported, annotatedImports, unresolvedOnDemandImports)[ FD ]
Line_22 $$ if (oldImports.isEmpty() && newImports.length == 0 && aliasImported.isEmpty()) -->Line_23 $$ return EmptyRunnable.getInstance()[ CD ]
Line_5 $$ final GroovyFile file = ((GroovyFile) myFile)-->Line_44 $$ file.removeImport(importStatement)[ FD ]
Line_17 $$ Map<String, String> aliasImported = ContainerUtil.newHashMap()-->Line_22 $$ if (oldImports.isEmpty() && newImports.length == 0 && aliasImported.isEmpty()) [ FD ]
Line_7 $$ final Document document = documentManager.getDocument(file)-->Line_9 $$ documentManager.commitDocument(document)[ FD ]
Line_2 $$ public Runnable compute() -->Line_7 $$ final Document document = documentManager.getDocument(file)[ CD ]
Line_5 $$ final GroovyFile file = ((GroovyFile) myFile)-->Line_25 $$ GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(file.getProject())[ FD ]
Line_20 $$ final List<GrImportStatement> oldImports = PsiUtil.getValidImportStatements(file)-->Line_30 $$ if (!oldImports.isEmpty()) [ FD ]
Line_2 $$ public Runnable compute() -->Line_21 $$ GrImportStatement[] newImports = prepare(usedImports, simplyImportedClasses, staticallyImportedMembers, implicitlyImportedClasses, innerClasses, aliasImported, annotatedImports, unresolvedOnDemandImports)[ CD ]
Line_31 $$ final int startOffset = oldImports.get(0).getTextRange().getStartOffset()-->Line_33 $$ String oldText = oldImports.isEmpty() ? "" : myFile.getText().substring(startOffset, endOffset)[ FD ]
Line_17 $$ Map<String, String> aliasImported = ContainerUtil.newHashMap()-->Line_19 $$ GroovyImportUtil.processFile(myFile, simplyImportedClasses, staticallyImportedMembers, usedImports, unresolvedOnDemandImports, implicitlyImportedClasses, innerClasses, aliasImported, annotatedImports)[ FD ]
Line_18 $$ Map<String, String> annotatedImports = ContainerUtil.newHashMap()-->Line_19 $$ GroovyImportUtil.processFile(myFile, simplyImportedClasses, staticallyImportedMembers, usedImports, unresolvedOnDemandImports, implicitlyImportedClasses, innerClasses, aliasImported, annotatedImports)[ FD ]
Line_20 $$ final List<GrImportStatement> oldImports = PsiUtil.getValidImportStatements(file)-->Line_31 $$ final int startOffset = oldImports.get(0).getTextRange().getStartOffset()[ FD ]
Line_6 $$ final PsiDocumentManager documentManager = PsiDocumentManager.getInstance(file.getProject())-->Line_7 $$ final Document document = documentManager.getDocument(file)[ FD ]
Line_15 $$ final Set<String> implicitlyImportedClasses = new LinkedHashSet<String>()-->Line_19 $$ GroovyImportUtil.processFile(myFile, simplyImportedClasses, staticallyImportedMembers, usedImports, unresolvedOnDemandImports, implicitlyImportedClasses, innerClasses, aliasImported, annotatedImports)[ FD ]
Line_2 $$ public Runnable compute() -->Line_16 $$ final Set<String> innerClasses = new HashSet<String>()[ CD ]
Line_26 $$ final GroovyFile tempFile = factory.createGroovyFile("", false, null)-->Line_34 $$ if (tempFile.getText().trim().equals(oldText)) [ FD ]
Line_43 $$ for (GrImportStatement importStatement : oldImports) -->Line_44 $$ file.removeImport(importStatement)[ FD ]
Line_15 $$ final Set<String> implicitlyImportedClasses = new LinkedHashSet<String>()-->Line_21 $$ GrImportStatement[] newImports = prepare(usedImports, simplyImportedClasses, staticallyImportedMembers, implicitlyImportedClasses, innerClasses, aliasImported, annotatedImports, unresolvedOnDemandImports)[ FD ]
Line_30 $$ if (!oldImports.isEmpty()) -->Line_33 $$ String oldText = oldImports.isEmpty() ? "" : myFile.getText().substring(startOffset, endOffset)[ CD ]
Line_7 $$ final Document document = documentManager.getDocument(file)-->Line_8 $$ if (document != null) [ FD ]
Line_2 $$ public Runnable compute() -->Line_20 $$ final List<GrImportStatement> oldImports = PsiUtil.getValidImportStatements(file)[ CD ]
Line_30 $$ if (!oldImports.isEmpty()) -->Line_32 $$ final int endOffset = oldImports.get(oldImports.size() - 1).getTextRange().getEndOffset()[ CD ]
Line_6 $$ final PsiDocumentManager documentManager = PsiDocumentManager.getInstance(file.getProject())-->Line_9 $$ documentManager.commitDocument(document)[ FD ]
Line_2 $$ public Runnable compute() -->Line_25 $$ GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(file.getProject())[ CD ]
Line_2 $$ public Runnable compute() -->Line_3 $$ if (!(myFile instanceof GroovyFile))[ CD ]
Line_5 $$ final GroovyFile file = ((GroovyFile) myFile)-->Line_20 $$ final List<GrImportStatement> oldImports = PsiUtil.getValidImportStatements(file)[ FD ]
Line_34 $$ if (tempFile.getText().trim().equals(oldText)) -->Line_35 $$ return EmptyRunnable.getInstance()[ CD ]
Line_20 $$ final List<GrImportStatement> oldImports = PsiUtil.getValidImportStatements(file)-->Line_22 $$ if (oldImports.isEmpty() && newImports.length == 0 && aliasImported.isEmpty()) [ FD ]
Line_2 $$ public Runnable compute() -->Line_17 $$ Map<String, String> aliasImported = ContainerUtil.newHashMap()[ CD ]
Line_33 $$ String oldText = oldImports.isEmpty() ? "" : myFile.getText().substring(startOffset, endOffset)-->Line_34 $$ if (tempFile.getText().trim().equals(oldText)) [ FD ]
Line_40 $$ for (GrImportStatement statement : tempFile.getImportStatements()) -->Line_41 $$ file.addImport(statement)[ FD ]
Line_2 $$ public Runnable compute() -->Line_18 $$ Map<String, String> annotatedImports = ContainerUtil.newHashMap()[ CD ]
Line_12 $$ final Set<String> staticallyImportedMembers = new LinkedHashSet<String>()-->Line_19 $$ GroovyImportUtil.processFile(myFile, simplyImportedClasses, staticallyImportedMembers, usedImports, unresolvedOnDemandImports, implicitlyImportedClasses, innerClasses, aliasImported, annotatedImports)[ FD ]
Line_8 $$ if (document != null) -->Line_9 $$ documentManager.commitDocument(document)[ CD ]
Line_5 $$ final GroovyFile file = ((GroovyFile) myFile)-->Line_41 $$ file.addImport(statement)[ FD ]
Line_5 $$ final GroovyFile file = ((GroovyFile) myFile)-->Line_6 $$ final PsiDocumentManager documentManager = PsiDocumentManager.getInstance(file.getProject())[ FD ]
Line_14 $$ final Set<GrImportStatement> unresolvedOnDemandImports = new HashSet<GrImportStatement>()-->Line_19 $$ GroovyImportUtil.processFile(myFile, simplyImportedClasses, staticallyImportedMembers, usedImports, unresolvedOnDemandImports, implicitlyImportedClasses, innerClasses, aliasImported, annotatedImports)[ FD ]
Line_17 $$ Map<String, String> aliasImported = ContainerUtil.newHashMap()-->Line_21 $$ GrImportStatement[] newImports = prepare(usedImports, simplyImportedClasses, staticallyImportedMembers, implicitlyImportedClasses, innerClasses, aliasImported, annotatedImports, unresolvedOnDemandImports)[ FD ]
Line_30 $$ if (!oldImports.isEmpty()) -->Line_34 $$ if (tempFile.getText().trim().equals(oldText)) [ CD ]
Line_2 $$ public Runnable compute() -->Line_19 $$ GroovyImportUtil.processFile(myFile, simplyImportedClasses, staticallyImportedMembers, usedImports, unresolvedOnDemandImports, implicitlyImportedClasses, innerClasses, aliasImported, annotatedImports)[ CD ]
Line_2 $$ public Runnable compute() -->Line_11 $$ final Set<String> simplyImportedClasses = new LinkedHashSet<String>()[ CD ]
Line_25 $$ GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(file.getProject())-->Line_26 $$ final GroovyFile tempFile = factory.createGroovyFile("", false, null)[ FD ]
Line_5 $$ final GroovyFile file = ((GroovyFile) myFile)-->Line_7 $$ final Document document = documentManager.getDocument(file)[ FD ]
Line_2 $$ public Runnable compute() -->Line_5 $$ final GroovyFile file = ((GroovyFile) myFile)[ CD ]
Line_20 $$ final List<GrImportStatement> oldImports = PsiUtil.getValidImportStatements(file)-->Line_32 $$ final int endOffset = oldImports.get(oldImports.size() - 1).getTextRange().getEndOffset()[ FD ]
Line_3 $$ if (!(myFile instanceof GroovyFile))-->Line_4 $$ return EmptyRunnable.getInstance()[ CD ]
Line_26 $$ final GroovyFile tempFile = factory.createGroovyFile("", false, null)-->Line_28 $$ tempFile.addImport(newImport)[ FD ]
Line_20 $$ final List<GrImportStatement> oldImports = PsiUtil.getValidImportStatements(file)-->Line_33 $$ String oldText = oldImports.isEmpty() ? "" : myFile.getText().substring(startOffset, endOffset)[ FD ]
Line_16 $$ final Set<String> innerClasses = new HashSet<String>()-->Line_21 $$ GrImportStatement[] newImports = prepare(usedImports, simplyImportedClasses, staticallyImportedMembers, implicitlyImportedClasses, innerClasses, aliasImported, annotatedImports, unresolvedOnDemandImports)[ FD ]
Line_18 $$ Map<String, String> annotatedImports = ContainerUtil.newHashMap()-->Line_21 $$ GrImportStatement[] newImports = prepare(usedImports, simplyImportedClasses, staticallyImportedMembers, implicitlyImportedClasses, innerClasses, aliasImported, annotatedImports, unresolvedOnDemandImports)[ FD ]
Line_2 $$ public Runnable compute() -->Line_13 $$ final Set<GrImportStatement> usedImports = new HashSet<GrImportStatement>()[ CD ]
Line_2 $$ public Runnable compute() -->Line_15 $$ final Set<String> implicitlyImportedClasses = new LinkedHashSet<String>()[ CD ]
Line_13 $$ final Set<GrImportStatement> usedImports = new HashSet<GrImportStatement>()-->Line_19 $$ GroovyImportUtil.processFile(myFile, simplyImportedClasses, staticallyImportedMembers, usedImports, unresolvedOnDemandImports, implicitlyImportedClasses, innerClasses, aliasImported, annotatedImports)[ FD ]
Line_2 $$ public Runnable compute() -->Line_22 $$ if (oldImports.isEmpty() && newImports.length == 0 && aliasImported.isEmpty()) [ CD ]
Line_2 $$ public Runnable compute() -->Line_30 $$ if (!oldImports.isEmpty()) [ CD ]
Line_2 $$ public Runnable compute() -->Line_38 $$ return new Runnable() [ CD ]
Line_16 $$ final Set<String> innerClasses = new HashSet<String>()-->Line_19 $$ GroovyImportUtil.processFile(myFile, simplyImportedClasses, staticallyImportedMembers, usedImports, unresolvedOnDemandImports, implicitlyImportedClasses, innerClasses, aliasImported, annotatedImports)[ FD ]
Line_27 $$ for (GrImportStatement newImport : newImports) -->Line_28 $$ tempFile.addImport(newImport)[ FD ]
Line_12 $$ final Set<String> staticallyImportedMembers = new LinkedHashSet<String>()-->Line_21 $$ GrImportStatement[] newImports = prepare(usedImports, simplyImportedClasses, staticallyImportedMembers, implicitlyImportedClasses, innerClasses, aliasImported, annotatedImports, unresolvedOnDemandImports)[ FD ]
Line_2 $$ public Runnable compute() -->Line_12 $$ final Set<String> staticallyImportedMembers = new LinkedHashSet<String>()[ CD ]
Line_2 $$ public Runnable compute() -->Line_8 $$ if (document != null) [ CD ]
Line_14 $$ final Set<GrImportStatement> unresolvedOnDemandImports = new HashSet<GrImportStatement>()-->Line_21 $$ GrImportStatement[] newImports = prepare(usedImports, simplyImportedClasses, staticallyImportedMembers, implicitlyImportedClasses, innerClasses, aliasImported, annotatedImports, unresolvedOnDemandImports)[ FD ]
