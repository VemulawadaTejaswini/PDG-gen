Line_12 $$ final PriorityComparator secondaryComparator = PriorityComparator.getAllocationComparator(allocation)-->Line_22 $$ final int secondary = secondaryComparator.compare(o1, o2)[ FD ]
Line_58 $$ if (!node.containsShard(shard)) -->Line_60 $$ float currentWeight = weight.weight(Operation.ALLOCATE, this, node, shard.index())[ CD ]
Line_112 $$ if (logger.isTraceEnabled()) -->Line_113 $$ logger.trace("No Node found to assign shard [[ CD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_70 $$ final int minNodeHigh = minNode.highestPrimary(shard.index())[ FD ]
Line_13 $$ final Comparator<ShardRouting> comparator = new Comparator<ShardRouting>() -->Line_18 $$ final int indexCmp[ CD ]
Line_58 $$ if (!node.containsShard(shard)) -->Line_61 $$ Decision removed = node.removeShard(shard)[ CD ]
Line_103 $$ if (logger.isTraceEnabled()) -->Line_104 $$ logger.trace("Can not allocate on node [[ CD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_58 $$ if (!node.containsShard(shard)) [ FD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_97 $$ routingNodes.initialize(shard, routingNodes.node(minNode.getNodeId()).nodeId(), allocation.clusterInfo().getShardSize(shard, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE))[ FD ]
Line_93 $$ if (decision.type() == Type.YES) -->Line_101 $$ final RoutingNode node = routingNodes.node(minNode.getNodeId())[ CD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_36 $$ boolean drop = deciders.canAllocate(shard, allocation).type() == Type.NO[ FD ]
Line_13 $$ final Comparator<ShardRouting> comparator = new Comparator<ShardRouting>() -->Line_117 $$ while (secondaryLength > 0 && comparator.compare(shard, secondary[secondaryLength - 1]) == 0) [ FD ]
Line_37 $$ if (drop) -->Line_39 $$ while (i < primaryLength - 1 && comparator.compare(primary[i], primary[i + 1]) == 0) [ CD ]
Line_67 $$ if (currentDecision.type() == decision.type()) -->Line_71 $$ if ((((nodeHigh > repId && minNodeHigh > repId) || (nodeHigh < repId && minNodeHigh < repId)) && (nodeHigh < minNodeHigh)) || (nodeHigh > minNodeHigh && nodeHigh > repId && minNodeHigh < repId)) [ CD ]
Line_93 $$ if (decision.type() == Type.YES) -->Line_94 $$ if (logger.isTraceEnabled()) [ CD ]
Line_37 $$ if (drop) -->Line_38 $$ unassigned.ignoreShard(shard)[ CD ]
Line_33 $$ for (int i = 0; i < primaryLength; i++) -->Line_115 $$ unassigned.ignoreShard(shard)[ CD ]
Line_13 $$ final Comparator<ShardRouting> comparator = new Comparator<ShardRouting>() -->Line_22 $$ final int secondary = secondaryComparator.compare(o1, o2)[ CD ]
Line_2 $$ private boolean allocateUnassigned(RoutingNodes.UnassignedShards unassigned) -->Line_26 $$ ShardRouting[] primary = unassigned.drain()[ FD ]
Line_2 $$ private boolean allocateUnassigned(RoutingNodes.UnassignedShards unassigned) -->Line_10 $$ boolean changed = false[ CD ]
Line_2 $$ private boolean allocateUnassigned(RoutingNodes.UnassignedShards unassigned) -->Line_13 $$ final Comparator<ShardRouting> comparator = new Comparator<ShardRouting>() [ CD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_92 $$ minNode.addShard(shard, decision)[ FD ]
Line_13 $$ final Comparator<ShardRouting> comparator = new Comparator<ShardRouting>() -->Line_44 $$ while (i < primaryLength - 1 && comparator.compare(primary[i], primary[i + 1]) == 0) [ FD ]
Line_2 $$ private boolean allocateUnassigned(RoutingNodes.UnassignedShards unassigned) -->Line_31 $$ final Set<ModelNode> throttledNodes = Collections.newSetFromMap(new IdentityHashMap<ModelNode, Boolean>())[ CD ]
Line_4 $$ if (logger.isTraceEnabled()) -->Line_5 $$ logger.trace("Start allocating unassigned shards")[ CD ]
Line_2 $$ private boolean allocateUnassigned(RoutingNodes.UnassignedShards unassigned) -->Line_30 $$ ArrayUtil.timSort(primary, comparator)[ CD ]
Line_13 $$ final Comparator<ShardRouting> comparator = new Comparator<ShardRouting>() -->Line_15 $$ if (o1.primary() ^ o2.primary()) [ CD ]
Line_11 $$ final AllocationDeciders deciders = allocation.deciders()-->Line_64 $$ Decision currentDecision = deciders.canAllocate(shard, routingNodes.node(node.getNodeId()), allocation)[ FD ]
Line_2 $$ private boolean allocateUnassigned(RoutingNodes.UnassignedShards unassigned) -->Line_115 $$ unassigned.ignoreShard(shard)[ FD ]
Line_117 $$ while (secondaryLength > 0 && comparator.compare(shard, secondary[secondaryLength - 1]) == 0) -->Line_118 $$ unassigned.ignoreShard(secondary[--secondaryLength])[ CD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_64 $$ Decision currentDecision = deciders.canAllocate(shard, routingNodes.node(node.getNodeId()), allocation)[ FD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_113 $$ logger.trace("No Node found to assign shard [[ FD ]
Line_102 $$ if (deciders.canAllocate(node, allocation).type() != Type.YES) -->Line_106 $$ throttledNodes.add(minNode)[ CD ]
Line_13 $$ final Comparator<ShardRouting> comparator = new Comparator<ShardRouting>() -->Line_16 $$ return o1.primary() ? -1 : o2.primary() ? 1 : 0[ FD ]
Line_91 $$ if (minNode != null) -->Line_92 $$ minNode.addShard(shard, decision)[ CD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_38 $$ unassigned.ignoreShard(shard)[ FD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_49 $$ assert !shard.assignedToNode() : shard[ FD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_69 $$ final int nodeHigh = node.highestPrimary(shard.index())[ FD ]
Line_67 $$ if (currentDecision.type() == decision.type()) -->Line_68 $$ final int repId = shard.id()[ CD ]
Line_91 $$ if (minNode != null) -->Line_93 $$ if (decision.type() == Type.YES) [ CD ]
Line_109 $$ if (logger.isTraceEnabled()) -->Line_110 $$ logger.trace("No eligable node found to assign shard [[ CD ]
Line_32 $$ do -->Line_33 $$ for (int i = 0; i < primaryLength; i++) [ CD ]
Line_32 $$ do -->Line_125 $$ secondary = tmp[ CD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_61 $$ Decision removed = node.removeShard(shard)[ FD ]
Line_93 $$ if (decision.type() == Type.YES) -->Line_102 $$ if (deciders.canAllocate(node, allocation).type() != Type.YES) [ CD ]
Line_91 $$ if (minNode != null) -->Line_112 $$ if (logger.isTraceEnabled()) [ CD ]
Line_67 $$ if (currentDecision.type() == decision.type()) -->Line_78 $$ if (currentDecision.type() != Type.YES) [ CD ]
Line_2 $$ private boolean allocateUnassigned(RoutingNodes.UnassignedShards unassigned) -->Line_40 $$ unassigned.ignoreShard(primary[++i])[ FD ]
Line_63 $$ if (currentWeight <= minWeight) -->Line_64 $$ Decision currentDecision = deciders.canAllocate(shard, routingNodes.node(node.getNodeId()), allocation)[ CD ]
Line_13 $$ final Comparator<ShardRouting> comparator = new Comparator<ShardRouting>() -->Line_15 $$ if (o1.primary() ^ o2.primary()) [ FD ]
Line_44 $$ while (i < primaryLength - 1 && comparator.compare(primary[i], primary[i + 1]) == 0) -->Line_45 $$ secondary[secondaryLength++] = primary[++i][ CD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_115 $$ unassigned.ignoreShard(shard)[ FD ]
Line_33 $$ for (int i = 0; i < primaryLength; i++) -->Line_91 $$ if (minNode != null) [ CD ]
Line_2 $$ private boolean allocateUnassigned(RoutingNodes.UnassignedShards unassigned) -->Line_118 $$ unassigned.ignoreShard(secondary[--secondaryLength])[ FD ]
Line_15 $$ if (o1.primary() ^ o2.primary()) -->Line_16 $$ return o1.primary() ? -1 : o2.primary() ? 1 : 0[ CD ]
Line_2 $$ private boolean allocateUnassigned(RoutingNodes.UnassignedShards unassigned) -->Line_26 $$ ShardRouting[] primary = unassigned.drain()[ CD ]
Line_2 $$ private boolean allocateUnassigned(RoutingNodes.UnassignedShards unassigned) -->Line_7 $$ if (unassigned.isEmpty()) [ CD ]
Line_39 $$ while (i < primaryLength - 1 && comparator.compare(primary[i], primary[i + 1]) == 0) -->Line_40 $$ unassigned.ignoreShard(primary[++i])[ CD ]
Line_22 $$ final int secondary = secondaryComparator.compare(o1, o2)-->Line_125 $$ secondary = tmp[ FD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_35 $$ if (!shard.primary()) [ FD ]
Line_65 $$ if (currentDecision.type() == Type.YES || currentDecision.type() == Type.THROTTLE) -->Line_66 $$ if (currentWeight == minWeight) [ CD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_59 $$ node.addShard(shard, Decision.ALWAYS)[ FD ]
Line_58 $$ if (!node.containsShard(shard)) -->Line_59 $$ node.addShard(shard, Decision.ALWAYS)[ CD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_116 $$ if (!shard.primary()) [ FD ]
Line_67 $$ if (currentDecision.type() == decision.type()) -->Line_69 $$ final int nodeHigh = node.highestPrimary(shard.index())[ CD ]
Line_102 $$ if (deciders.canAllocate(node, allocation).type() != Type.YES) -->Line_103 $$ if (logger.isTraceEnabled()) [ CD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_95 $$ logger.trace("Assigned shard [[ FD ]
Line_13 $$ final Comparator<ShardRouting> comparator = new Comparator<ShardRouting>() -->Line_39 $$ while (i < primaryLength - 1 && comparator.compare(primary[i], primary[i + 1]) == 0) [ FD ]
Line_33 $$ for (int i = 0; i < primaryLength; i++) -->Line_53 $$ if (throttledNodes.size() < nodes.size()) [ CD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_117 $$ while (secondaryLength > 0 && comparator.compare(shard, secondary[secondaryLength - 1]) == 0) [ FD ]
Line_33 $$ for (int i = 0; i < primaryLength; i++) -->Line_34 $$ ShardRouting shard = primary[i][ CD ]
Line_2 $$ private boolean allocateUnassigned(RoutingNodes.UnassignedShards unassigned) -->Line_38 $$ unassigned.ignoreShard(shard)[ FD ]
Line_35 $$ if (!shard.primary()) -->Line_36 $$ boolean drop = deciders.canAllocate(shard, allocation).type() == Type.NO[ CD ]
Line_58 $$ if (!node.containsShard(shard)) -->Line_63 $$ if (currentWeight <= minWeight) [ CD ]
Line_35 $$ if (!shard.primary()) -->Line_37 $$ if (drop) [ CD ]
Line_33 $$ for (int i = 0; i < primaryLength; i++) -->Line_116 $$ if (!shard.primary()) [ CD ]
Line_66 $$ if (currentWeight == minWeight) -->Line_67 $$ if (currentDecision.type() == decision.type()) [ CD ]
Line_7 $$ if (unassigned.isEmpty()) -->Line_8 $$ return false[ CD ]
Line_2 $$ private boolean allocateUnassigned(RoutingNodes.UnassignedShards unassigned) -->Line_32 $$ do [ CD ]
Line_13 $$ final Comparator<ShardRouting> comparator = new Comparator<ShardRouting>() -->Line_20 $$ return o1.getId() - o2.getId()[ FD ]
Line_2 $$ private boolean allocateUnassigned(RoutingNodes.UnassignedShards unassigned) -->Line_11 $$ final AllocationDeciders deciders = allocation.deciders()[ CD ]
Line_2 $$ private boolean allocateUnassigned(RoutingNodes.UnassignedShards unassigned) -->Line_4 $$ if (logger.isTraceEnabled()) [ CD ]
Line_33 $$ for (int i = 0; i < primaryLength; i++) -->Line_35 $$ if (!shard.primary()) [ CD ]
Line_33 $$ for (int i = 0; i < primaryLength; i++) -->Line_40 $$ unassigned.ignoreShard(primary[++i])[ FD ]
Line_67 $$ if (currentDecision.type() == decision.type()) -->Line_70 $$ final int minNodeHigh = minNode.highestPrimary(shard.index())[ CD ]
Line_116 $$ if (!shard.primary()) -->Line_117 $$ while (secondaryLength > 0 && comparator.compare(shard, secondary[secondaryLength - 1]) == 0) [ CD ]
Line_13 $$ final Comparator<ShardRouting> comparator = new Comparator<ShardRouting>() -->Line_30 $$ ArrayUtil.timSort(primary, comparator)[ FD ]
Line_19 $$ if ((indexCmp = o1.index().compareTo(o2.index())) == 0) -->Line_20 $$ return o1.getId() - o2.getId()[ CD ]
Line_91 $$ if (minNode != null) -->Line_109 $$ if (logger.isTraceEnabled()) [ CD ]
Line_37 $$ if (drop) -->Line_44 $$ while (i < primaryLength - 1 && comparator.compare(primary[i], primary[i + 1]) == 0) [ CD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_110 $$ logger.trace("No eligable node found to assign shard [[ FD ]
Line_33 $$ for (int i = 0; i < primaryLength; i++) -->Line_45 $$ secondary[secondaryLength++] = primary[++i][ FD ]
Line_2 $$ private boolean allocateUnassigned(RoutingNodes.UnassignedShards unassigned) -->Line_7 $$ if (unassigned.isEmpty()) [ FD ]
Line_13 $$ final Comparator<ShardRouting> comparator = new Comparator<ShardRouting>() -->Line_22 $$ final int secondary = secondaryComparator.compare(o1, o2)[ FD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_60 $$ float currentWeight = weight.weight(Operation.ALLOCATE, this, node, shard.index())[ FD ]
Line_2 $$ private boolean allocateUnassigned(RoutingNodes.UnassignedShards unassigned) -->Line_12 $$ final PriorityComparator secondaryComparator = PriorityComparator.getAllocationComparator(allocation)[ CD ]
Line_34 $$ ShardRouting shard = primary[i]-->Line_68 $$ final int repId = shard.id()[ FD ]
Line_13 $$ final Comparator<ShardRouting> comparator = new Comparator<ShardRouting>() -->Line_19 $$ if ((indexCmp = o1.index().compareTo(o2.index())) == 0) [ FD ]
Line_13 $$ final Comparator<ShardRouting> comparator = new Comparator<ShardRouting>() -->Line_23 $$ return secondary == 0 ? indexCmp : secondary[ CD ]
Line_18 $$ final int indexCmp-->Line_19 $$ if ((indexCmp = o1.index().compareTo(o2.index())) == 0) [ FD ]
Line_2 $$ private boolean allocateUnassigned(RoutingNodes.UnassignedShards unassigned) -->Line_128 $$ return changed[ CD ]
Line_13 $$ final Comparator<ShardRouting> comparator = new Comparator<ShardRouting>() -->Line_19 $$ if ((indexCmp = o1.index().compareTo(o2.index())) == 0) [ CD ]
Line_11 $$ final AllocationDeciders deciders = allocation.deciders()-->Line_36 $$ boolean drop = deciders.canAllocate(shard, allocation).type() == Type.NO[ FD ]
Line_11 $$ final AllocationDeciders deciders = allocation.deciders()-->Line_102 $$ if (deciders.canAllocate(node, allocation).type() != Type.YES) [ FD ]
Line_94 $$ if (logger.isTraceEnabled()) -->Line_95 $$ logger.trace("Assigned shard [[ CD ]
Line_93 $$ if (decision.type() == Type.YES) -->Line_97 $$ routingNodes.initialize(shard, routingNodes.node(minNode.getNodeId()).nodeId(), allocation.clusterInfo().getShardSize(shard, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE))[ CD ]
