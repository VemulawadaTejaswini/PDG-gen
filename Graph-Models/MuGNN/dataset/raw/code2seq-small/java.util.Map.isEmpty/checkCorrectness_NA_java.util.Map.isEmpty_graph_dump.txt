Line_5 $$ for (Log read : logs) -->Line_10 $$ if (read.getValue() == null || isEmptyCollection(read))[ FD ]
Line_10 $$ if (read.getValue() == null || isEmptyCollection(read))-->Line_13 $$ reads++[ CD ]
Line_4 $$ int nullReads = 0, reads = 0, writes = 0-->Line_7 $$ writes++[ FD ]
Line_4 $$ int nullReads = 0, reads = 0, writes = 0-->Line_13 $$ reads++[ FD ]
Line_5 $$ for (Log read : logs) -->Line_38 $$ if (!possibleValues.containsKey(read.getValue())) [ FD ]
Line_14 $$ Map<T, Log<T>> possibleValues = new HashMap()-->Line_38 $$ if (!possibleValues.containsKey(read.getValue())) [ FD ]
Line_2 $$ private <T> void checkCorrectness(String dumpPrefix, List<Log<T>> logs, NavigableMap<Integer, List<Log<T>>> writesByTime) -->Line_23 $$ for (Map.Entry<Integer, List<Log<T>>> entry : writesByTime.headMap(read.before, false).descendingMap().entrySet()) [ FD ]
Line_10 $$ if (read.getValue() == null || isEmptyCollection(read))-->Line_11 $$ nullReads++[ CD ]
Line_5 $$ for (Log read : logs) -->Line_40 $$ exceptions.add(new IllegalStateException(String.format("R %s: %d .. %d (%s, %s) -> %s not in %s (%d+)", dumpPrefix, read.before, read.after, read.threadName, new SimpleDateFormat("HH:mm:ss,SSS").format(new Date(read.wallClockTime)), read.getValue(), possibleValues.values(), startOfLastWriteBeforeRead)))[ FD ]
Line_4 $$ int nullReads = 0, reads = 0, writes = 0-->Line_11 $$ nullReads++[ FD ]
Line_16 $$ for (Log<T> write : list) -->Line_19 $$ possibleValues.put(write.getValue(), write)[ FD ]
Line_2 $$ private <T> void checkCorrectness(String dumpPrefix, List<Log<T>> logs, NavigableMap<Integer, List<Log<T>>> writesByTime) -->Line_3 $$ Collections.sort(logs, WALL_CLOCK_TIME_COMPARATOR)[ FD ]
Line_2 $$ private <T> void checkCorrectness(String dumpPrefix, List<Log<T>> logs, NavigableMap<Integer, List<Log<T>>> writesByTime) -->Line_4 $$ int nullReads = 0, reads = 0, writes = 0[ CD ]
Line_14 $$ Map<T, Log<T>> possibleValues = new HashMap()-->Line_19 $$ possibleValues.put(write.getValue(), write)[ FD ]
Line_4 $$ int nullReads = 0, reads = 0, writes = 0-->Line_44 $$ log.infof("Checked %d null reads, %d reads and %d writes%n", nullReads, reads, writes)[ FD ]
Line_2 $$ private <T> void checkCorrectness(String dumpPrefix, List<Log<T>> logs, NavigableMap<Integer, List<Log<T>>> writesByTime) -->Line_15 $$ for (List<Log<T>> list : writesByTime.subMap(read.before, true, read.after, true).values()) [ FD ]
Line_38 $$ if (!possibleValues.containsKey(read.getValue())) -->Line_40 $$ exceptions.add(new IllegalStateException(String.format("R %s: %d .. %d (%s, %s) -> %s not in %s (%d+)", dumpPrefix, read.before, read.after, read.threadName, new SimpleDateFormat("HH:mm:ss,SSS").format(new Date(read.wallClockTime)), read.getValue(), possibleValues.values(), startOfLastWriteBeforeRead)))[ CD ]
Line_2 $$ private <T> void checkCorrectness(String dumpPrefix, List<Log<T>> logs, NavigableMap<Integer, List<Log<T>>> writesByTime) -->Line_40 $$ exceptions.add(new IllegalStateException(String.format("R %s: %d .. %d (%s, %s) -> %s not in %s (%d+)", dumpPrefix, read.before, read.after, read.threadName, new SimpleDateFormat("HH:mm:ss,SSS").format(new Date(read.wallClockTime)), read.getValue(), possibleValues.values(), startOfLastWriteBeforeRead)))[ FD ]
Line_22 $$ int startOfLastWriteBeforeRead = 0-->Line_25 $$ if (time < startOfLastWriteBeforeRead)[ FD ]
Line_2 $$ private <T> void checkCorrectness(String dumpPrefix, List<Log<T>> logs, NavigableMap<Integer, List<Log<T>>> writesByTime) -->Line_44 $$ log.infof("Checked %d null reads, %d reads and %d writes%n", nullReads, reads, writes)[ CD ]
Line_38 $$ if (!possibleValues.containsKey(read.getValue())) -->Line_39 $$ dumpLogs(dumpPrefix, logs)[ CD ]
Line_24 $$ int time = entry.getKey()-->Line_25 $$ if (time < startOfLastWriteBeforeRead)[ FD ]
Line_16 $$ for (Log<T> write : list) -->Line_17 $$ if (read.precedes(write))[ FD ]
Line_14 $$ Map<T, Log<T>> possibleValues = new HashMap()-->Line_34 $$ if (possibleValues.isEmpty()) [ FD ]
Line_22 $$ int startOfLastWriteBeforeRead = 0-->Line_40 $$ exceptions.add(new IllegalStateException(String.format("R %s: %d .. %d (%s, %s) -> %s not in %s (%d+)", dumpPrefix, read.before, read.after, read.threadName, new SimpleDateFormat("HH:mm:ss,SSS").format(new Date(read.wallClockTime)), read.getValue(), possibleValues.values(), startOfLastWriteBeforeRead)))[ FD ]
Line_2 $$ private <T> void checkCorrectness(String dumpPrefix, List<Log<T>> logs, NavigableMap<Integer, List<Log<T>>> writesByTime) -->Line_39 $$ dumpLogs(dumpPrefix, logs)[ FD ]
Line_28 $$ if (write.after < read.before && write.before > startOfLastWriteBeforeRead) -->Line_29 $$ startOfLastWriteBeforeRead = write.before[ CD ]
Line_29 $$ startOfLastWriteBeforeRead = write.before-->Line_40 $$ exceptions.add(new IllegalStateException(String.format("R %s: %d .. %d (%s, %s) -> %s not in %s (%d+)", dumpPrefix, read.before, read.after, read.threadName, new SimpleDateFormat("HH:mm:ss,SSS").format(new Date(read.wallClockTime)), read.getValue(), possibleValues.values(), startOfLastWriteBeforeRead)))[ FD ]
Line_14 $$ Map<T, Log<T>> possibleValues = new HashMap()-->Line_40 $$ exceptions.add(new IllegalStateException(String.format("R %s: %d .. %d (%s, %s) -> %s not in %s (%d+)", dumpPrefix, read.before, read.after, read.threadName, new SimpleDateFormat("HH:mm:ss,SSS").format(new Date(read.wallClockTime)), read.getValue(), possibleValues.values(), startOfLastWriteBeforeRead)))[ FD ]
Line_5 $$ for (Log read : logs) -->Line_17 $$ if (read.precedes(write))[ FD ]
Line_23 $$ for (Map.Entry<Integer, List<Log<T>>> entry : writesByTime.headMap(read.before, false).descendingMap().entrySet()) -->Line_27 $$ for (Log<T> write : entry.getValue()) [ FD ]
Line_22 $$ int startOfLastWriteBeforeRead = 0-->Line_29 $$ startOfLastWriteBeforeRead = write.before[ FD ]
Line_16 $$ for (Log<T> write : list) -->Line_31 $$ possibleValues.put(write.getValue(), write)[ FD ]
Line_6 $$ if (read.type != LogType.READ) -->Line_7 $$ writes++[ CD ]
Line_2 $$ private <T> void checkCorrectness(String dumpPrefix, List<Log<T>> logs, NavigableMap<Integer, List<Log<T>>> writesByTime) -->Line_3 $$ Collections.sort(logs, WALL_CLOCK_TIME_COMPARATOR)[ CD ]
Line_23 $$ for (Map.Entry<Integer, List<Log<T>>> entry : writesByTime.headMap(read.before, false).descendingMap().entrySet()) -->Line_24 $$ int time = entry.getKey()[ FD ]
Line_14 $$ Map<T, Log<T>> possibleValues = new HashMap()-->Line_31 $$ possibleValues.put(write.getValue(), write)[ FD ]
