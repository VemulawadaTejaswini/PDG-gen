Line_30 $$ for (int i = 0; i < numberOfShards; i++) -->Line_31 $$ if (activeAllocationIds.containsKey(i)) [ FD ]
Line_2 $$ public IndexMetaData build() -->Line_38 $$ final DiscoveryNodeFilters requireFilters[ CD ]
Line_53 $$ if (excludeMap.isEmpty()) -->Line_54 $$ excludeFilters = null[ CD ]
Line_2 $$ public IndexMetaData build() -->Line_62 $$ if (stringLuceneVersion != null) [ CD ]
Line_2 $$ public IndexMetaData build() -->Line_53 $$ if (excludeMap.isEmpty()) [ CD ]
Line_2 $$ public IndexMetaData build() -->Line_46 $$ if (includeMap.isEmpty()) [ CD ]
Line_46 $$ if (includeMap.isEmpty()) -->Line_47 $$ includeFilters = null[ CD ]
Line_30 $$ for (int i = 0; i < numberOfShards; i++) -->Line_31 $$ if (activeAllocationIds.containsKey(i)) [ CD ]
Line_2 $$ public IndexMetaData build() -->Line_13 $$ if (maybeNumberOfShards == null) [ CD ]
Line_58 $$ Version indexCreatedVersion = Version.indexCreated(settings)-->Line_59 $$ Version indexUpgradedVersion = settings.getAsVersion(IndexMetaData.SETTING_VERSION_UPGRADED, indexCreatedVersion)[ FD ]
Line_2 $$ public IndexMetaData build() -->Line_25 $$ if (numberOfReplicas < 0) [ CD ]
Line_61 $$ final org.apache.lucene.util.Version minimumCompatibleLuceneVersion-->Line_64 $$ minimumCompatibleLuceneVersion = org.apache.lucene.util.Version.parse(stringLuceneVersion)[ FD ]
Line_44 $$ Map<String, String> includeMap = settings.getByPrefix("index.routing.allocation.include.").getAsMap()-->Line_49 $$ includeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, includeMap)[ FD ]
Line_60 $$ String stringLuceneVersion = settings.get(SETTING_VERSION_MINIMUM_COMPATIBLE)-->Line_62 $$ if (stringLuceneVersion != null) [ FD ]
Line_2 $$ public IndexMetaData build() -->Line_45 $$ final DiscoveryNodeFilters includeFilters[ CD ]
Line_2 $$ public IndexMetaData build() -->Line_71 $$ return new IndexMetaData(index, version, state, numberOfShards, numberOfReplicas, tmpSettings, mappings.build(), tmpAliases.build(), customs.build(), filledActiveAllocationIds.build(), requireFilters, includeFilters, excludeFilters, indexCreatedVersion, indexUpgradedVersion, minimumCompatibleLuceneVersion)[ CD ]
Line_52 $$ final DiscoveryNodeFilters excludeFilters-->Line_56 $$ excludeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, excludeMap)[ FD ]
Line_30 $$ for (int i = 0; i < numberOfShards; i++) -->Line_32 $$ filledActiveAllocationIds.put(i, Collections.unmodifiableSet(new HashSet(activeAllocationIds.get(i))))[ FD ]
Line_2 $$ public IndexMetaData build() -->Line_16 $$ int numberOfShards = maybeNumberOfShards[ CD ]
Line_2 $$ public IndexMetaData build() -->Line_44 $$ Map<String, String> includeMap = settings.getByPrefix("index.routing.allocation.include.").getAsMap()[ CD ]
Line_53 $$ if (excludeMap.isEmpty()) -->Line_56 $$ excludeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, excludeMap)[ CD ]
Line_47 $$ includeFilters = null-->Line_49 $$ includeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, includeMap)[ FD ]
Line_2 $$ public IndexMetaData build() -->Line_3 $$ ImmutableOpenMap.Builder<String, AliasMetaData> tmpAliases = aliases[ CD ]
Line_45 $$ final DiscoveryNodeFilters includeFilters-->Line_47 $$ includeFilters = null[ FD ]
Line_44 $$ Map<String, String> includeMap = settings.getByPrefix("index.routing.allocation.include.").getAsMap()-->Line_46 $$ if (includeMap.isEmpty()) [ FD ]
Line_2 $$ public IndexMetaData build() -->Line_24 $$ int numberOfReplicas = maybeNumberOfReplicas[ CD ]
Line_7 $$ MappingMetaData defaultMapping = mappings.get(MapperService.DEFAULT_MAPPING)-->Line_9 $$ cursor.value.updateDefaultMapping(defaultMapping)[ FD ]
Line_2 $$ public IndexMetaData build() -->Line_59 $$ Version indexUpgradedVersion = settings.getAsVersion(IndexMetaData.SETTING_VERSION_UPGRADED, indexCreatedVersion)[ CD ]
Line_31 $$ if (activeAllocationIds.containsKey(i)) -->Line_32 $$ filledActiveAllocationIds.put(i, Collections.unmodifiableSet(new HashSet(activeAllocationIds.get(i))))[ CD ]
Line_52 $$ final DiscoveryNodeFilters excludeFilters-->Line_54 $$ excludeFilters = null[ FD ]
Line_37 $$ Map<String, String> requireMap = settings.getByPrefix("index.routing.allocation.require.").getAsMap()-->Line_42 $$ requireFilters = DiscoveryNodeFilters.buildFromKeyValue(AND, requireMap)[ FD ]
Line_2 $$ public IndexMetaData build() -->Line_12 $$ Integer maybeNumberOfShards = settings.getAsInt(SETTING_NUMBER_OF_SHARDS, null)[ CD ]
Line_51 $$ Map<String, String> excludeMap = settings.getByPrefix("index.routing.allocation.exclude.").getAsMap()-->Line_53 $$ if (excludeMap.isEmpty()) [ FD ]
Line_39 $$ if (requireMap.isEmpty()) -->Line_40 $$ requireFilters = null[ CD ]
Line_61 $$ final org.apache.lucene.util.Version minimumCompatibleLuceneVersion-->Line_69 $$ minimumCompatibleLuceneVersion = null[ FD ]
Line_2 $$ public IndexMetaData build() -->Line_4 $$ Settings tmpSettings = settings[ CD ]
Line_20 $$ Integer maybeNumberOfReplicas = settings.getAsInt(SETTING_NUMBER_OF_REPLICAS, null)-->Line_21 $$ if (maybeNumberOfReplicas == null) [ FD ]
Line_2 $$ public IndexMetaData build() -->Line_51 $$ Map<String, String> excludeMap = settings.getByPrefix("index.routing.allocation.exclude.").getAsMap()[ CD ]
Line_16 $$ int numberOfShards = maybeNumberOfShards-->Line_30 $$ for (int i = 0; i < numberOfShards; i++) [ FD ]
Line_60 $$ String stringLuceneVersion = settings.get(SETTING_VERSION_MINIMUM_COMPATIBLE)-->Line_64 $$ minimumCompatibleLuceneVersion = org.apache.lucene.util.Version.parse(stringLuceneVersion)[ FD ]
Line_45 $$ final DiscoveryNodeFilters includeFilters-->Line_49 $$ includeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, includeMap)[ FD ]
Line_40 $$ requireFilters = null-->Line_42 $$ requireFilters = DiscoveryNodeFilters.buildFromKeyValue(AND, requireMap)[ FD ]
Line_54 $$ excludeFilters = null-->Line_56 $$ excludeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, excludeMap)[ FD ]
Line_2 $$ public IndexMetaData build() -->Line_20 $$ Integer maybeNumberOfReplicas = settings.getAsInt(SETTING_NUMBER_OF_REPLICAS, null)[ CD ]
Line_2 $$ public IndexMetaData build() -->Line_37 $$ Map<String, String> requireMap = settings.getByPrefix("index.routing.allocation.require.").getAsMap()[ CD ]
Line_2 $$ public IndexMetaData build() -->Line_21 $$ if (maybeNumberOfReplicas == null) [ CD ]
Line_38 $$ final DiscoveryNodeFilters requireFilters-->Line_42 $$ requireFilters = DiscoveryNodeFilters.buildFromKeyValue(AND, requireMap)[ FD ]
Line_64 $$ minimumCompatibleLuceneVersion = org.apache.lucene.util.Version.parse(stringLuceneVersion)-->Line_69 $$ minimumCompatibleLuceneVersion = null[ FD ]
Line_24 $$ int numberOfReplicas = maybeNumberOfReplicas-->Line_25 $$ if (numberOfReplicas < 0) [ FD ]
Line_62 $$ if (stringLuceneVersion != null) -->Line_69 $$ minimumCompatibleLuceneVersion = null[ CD ]
Line_39 $$ if (requireMap.isEmpty()) -->Line_42 $$ requireFilters = DiscoveryNodeFilters.buildFromKeyValue(AND, requireMap)[ CD ]
Line_46 $$ if (includeMap.isEmpty()) -->Line_49 $$ includeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, includeMap)[ CD ]
Line_2 $$ public IndexMetaData build() -->Line_58 $$ Version indexCreatedVersion = Version.indexCreated(settings)[ CD ]
Line_2 $$ public IndexMetaData build() -->Line_52 $$ final DiscoveryNodeFilters excludeFilters[ CD ]
Line_3 $$ ImmutableOpenMap.Builder<String, AliasMetaData> tmpAliases = aliases-->Line_71 $$ return new IndexMetaData(index, version, state, numberOfShards, numberOfReplicas, tmpSettings, mappings.build(), tmpAliases.build(), customs.build(), filledActiveAllocationIds.build(), requireFilters, includeFilters, excludeFilters, indexCreatedVersion, indexUpgradedVersion, minimumCompatibleLuceneVersion)[ FD ]
Line_30 $$ for (int i = 0; i < numberOfShards; i++) -->Line_34 $$ filledActiveAllocationIds.put(i, Collections.emptySet())[ FD ]
Line_37 $$ Map<String, String> requireMap = settings.getByPrefix("index.routing.allocation.require.").getAsMap()-->Line_39 $$ if (requireMap.isEmpty()) [ FD ]
Line_51 $$ Map<String, String> excludeMap = settings.getByPrefix("index.routing.allocation.exclude.").getAsMap()-->Line_56 $$ excludeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, excludeMap)[ FD ]
Line_2 $$ public IndexMetaData build() -->Line_39 $$ if (requireMap.isEmpty()) [ CD ]
Line_38 $$ final DiscoveryNodeFilters requireFilters-->Line_40 $$ requireFilters = null[ FD ]
Line_16 $$ int numberOfShards = maybeNumberOfShards-->Line_17 $$ if (numberOfShards <= 0) [ FD ]
Line_2 $$ public IndexMetaData build() -->Line_61 $$ final org.apache.lucene.util.Version minimumCompatibleLuceneVersion[ CD ]
Line_2 $$ public IndexMetaData build() -->Line_17 $$ if (numberOfShards <= 0) [ CD ]
Line_31 $$ if (activeAllocationIds.containsKey(i)) -->Line_34 $$ filledActiveAllocationIds.put(i, Collections.emptySet())[ CD ]
Line_2 $$ public IndexMetaData build() -->Line_30 $$ for (int i = 0; i < numberOfShards; i++) [ CD ]
Line_12 $$ Integer maybeNumberOfShards = settings.getAsInt(SETTING_NUMBER_OF_SHARDS, null)-->Line_13 $$ if (maybeNumberOfShards == null) [ FD ]
Line_2 $$ public IndexMetaData build() -->Line_60 $$ String stringLuceneVersion = settings.get(SETTING_VERSION_MINIMUM_COMPATIBLE)[ CD ]
