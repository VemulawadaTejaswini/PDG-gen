Line_23 $$ final File parentFile = file.getParentFile()-->Line_24 $$ if (parentFile != null) [ FD ]
Line_18 $$ for (File file : sourcePath) -->Line_23 $$ final File parentFile = file.getParentFile()[ FD ]
Line_35 $$ final JavaFileObject source = d.getSource()-->Line_36 $$ final URI uri = source != null ? source.toUri() : null[ FD ]
Line_43 $$ final BinaryContent content = fileObject.getContent()-->Line_44 $$ result.add(new CompiledClass(fileObject.getName(), fileObject.getClassName(), content != null ? content.toByteArray() : null))[ FD ]
Line_34 $$ for (Diagnostic<? extends JavaFileObject> d : diagnostic.getDiagnostics()) -->Line_35 $$ final JavaFileObject source = d.getSource()[ FD ]
Line_24 $$ if (parentFile != null) -->Line_25 $$ sourceRoots.add(parentFile)[ CD ]
Line_6 $$ final Sdk sdk = runtime.getFirst()-->Line_9 $$ javaHome = sdk.getHomePath()[ FD ]
Line_36 $$ final URI uri = source != null ? source.toUri() : null-->Line_37 $$ messages.add(new CompilationException.Message(kindToCategory(d.getKind()), d.getMessage(Locale.US), uri != null ? uri.toURL().toString() : null, (int) d.getLineNumber(), (int) d.getColumnNumber()))[ FD ]
Line_9 $$ javaHome = sdk.getHomePath()-->Line_31 $$ boolean compiledOk = javacManager != null && javacManager.forkJavac(javaHome, -1, Collections.<String>emptyList(), options, platformCp, classpath, sourcePath, files, outs, diagnostic, outputCollector, new JavacCompilerTool(), CanceledStatus.NULL)[ FD ]
Line_18 $$ for (File file : sourcePath) -->Line_19 $$ sourceRoots.add(file)[ FD ]
Line_23 $$ final File parentFile = file.getParentFile()-->Line_25 $$ sourceRoots.add(parentFile)[ FD ]
Line_31 $$ boolean compiledOk = javacManager != null && javacManager.forkJavac(javaHome, -1, Collections.<String>emptyList(), options, platformCp, classpath, sourcePath, files, outs, diagnostic, outputCollector, new JavacCompilerTool(), CanceledStatus.NULL)-->Line_32 $$ if (!compiledOk) [ FD ]
Line_14 $$ final OutputCollector outputCollector = new OutputCollector()-->Line_31 $$ boolean compiledOk = javacManager != null && javacManager.forkJavac(javaHome, -1, Collections.<String>emptyList(), options, platformCp, classpath, sourcePath, files, outs, diagnostic, outputCollector, new JavacCompilerTool(), CanceledStatus.NULL)[ FD ]
Line_4 $$ final Pair<Sdk, JavaSdkVersion> runtime = BuildManager.getBuildProcessRuntimeSdk(myProject)-->Line_6 $$ final Sdk sdk = runtime.getFirst()[ FD ]
Line_15 $$ DiagnosticCollector diagnostic = new DiagnosticCollector()-->Line_31 $$ boolean compiledOk = javacManager != null && javacManager.forkJavac(javaHome, -1, Collections.<String>emptyList(), options, platformCp, classpath, sourcePath, files, outs, diagnostic, outputCollector, new JavacCompilerTool(), CanceledStatus.NULL)[ FD ]
Line_16 $$ final Set<File> sourceRoots = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_19 $$ sourceRoots.add(file)[ FD ]
Line_8 $$ if (type instanceof JavaSdkType) -->Line_9 $$ javaHome = sdk.getHomePath()[ CD ]
Line_42 $$ for (OutputFileObject fileObject : outputCollector.getCompiledClasses()) -->Line_43 $$ final BinaryContent content = fileObject.getContent()[ FD ]
Line_6 $$ final Sdk sdk = runtime.getFirst()-->Line_7 $$ final SdkTypeId type = sdk.getSdkType()[ FD ]
Line_42 $$ for (OutputFileObject fileObject : outputCollector.getCompiledClasses()) -->Line_44 $$ result.add(new CompiledClass(fileObject.getName(), fileObject.getClassName(), content != null ? content.toByteArray() : null))[ FD ]
Line_16 $$ final Set<File> sourceRoots = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_25 $$ sourceRoots.add(parentFile)[ FD ]
Line_5 $$ String javaHome = null-->Line_11 $$ if (javaHome == null) [ FD ]
Line_34 $$ for (Diagnostic<? extends JavaFileObject> d : diagnostic.getDiagnostics()) -->Line_37 $$ messages.add(new CompilationException.Message(kindToCategory(d.getKind()), d.getMessage(Locale.US), uri != null ? uri.toURL().toString() : null, (int) d.getLineNumber(), (int) d.getColumnNumber()))[ FD ]
Line_29 $$ final Map<File, Set<File>> outs = Collections.singletonMap(outputDir, sourceRoots)-->Line_31 $$ boolean compiledOk = javacManager != null && javacManager.forkJavac(javaHome, -1, Collections.<String>emptyList(), options, platformCp, classpath, sourcePath, files, outs, diagnostic, outputCollector, new JavacCompilerTool(), CanceledStatus.NULL)[ FD ]
Line_9 $$ javaHome = sdk.getHomePath()-->Line_11 $$ if (javaHome == null) [ FD ]
Line_41 $$ final List<ClassObject> result = new ArrayList<ClassObject>()-->Line_44 $$ result.add(new CompiledClass(fileObject.getName(), fileObject.getClassName(), content != null ? content.toByteArray() : null))[ FD ]
Line_16 $$ final Set<File> sourceRoots = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_29 $$ final Map<File, Set<File>> outs = Collections.singletonMap(outputDir, sourceRoots)[ FD ]
Line_7 $$ final SdkTypeId type = sdk.getSdkType()-->Line_8 $$ if (type instanceof JavaSdkType) [ FD ]
Line_33 $$ final List<CompilationException.Message> messages = new SmartList<CompilationException.Message>()-->Line_37 $$ messages.add(new CompilationException.Message(kindToCategory(d.getKind()), d.getMessage(Locale.US), uri != null ? uri.toURL().toString() : null, (int) d.getLineNumber(), (int) d.getColumnNumber()))[ FD ]
Line_32 $$ if (!compiledOk) -->Line_33 $$ final List<CompilationException.Message> messages = new SmartList<CompilationException.Message>()[ CD ]
Line_15 $$ DiagnosticCollector diagnostic = new DiagnosticCollector()-->Line_34 $$ for (Diagnostic<? extends JavaFileObject> d : diagnostic.getDiagnostics()) [ FD ]
Line_30 $$ final ExternalJavacManager javacManager = getJavacManager()-->Line_31 $$ boolean compiledOk = javacManager != null && javacManager.forkJavac(javaHome, -1, Collections.<String>emptyList(), options, platformCp, classpath, sourcePath, files, outs, diagnostic, outputCollector, new JavacCompilerTool(), CanceledStatus.NULL)[ FD ]
Line_5 $$ String javaHome = null-->Line_9 $$ javaHome = sdk.getHomePath()[ FD ]
Line_5 $$ String javaHome = null-->Line_31 $$ boolean compiledOk = javacManager != null && javacManager.forkJavac(javaHome, -1, Collections.<String>emptyList(), options, platformCp, classpath, sourcePath, files, outs, diagnostic, outputCollector, new JavacCompilerTool(), CanceledStatus.NULL)[ FD ]
Line_14 $$ final OutputCollector outputCollector = new OutputCollector()-->Line_42 $$ for (OutputFileObject fileObject : outputCollector.getCompiledClasses()) [ FD ]
