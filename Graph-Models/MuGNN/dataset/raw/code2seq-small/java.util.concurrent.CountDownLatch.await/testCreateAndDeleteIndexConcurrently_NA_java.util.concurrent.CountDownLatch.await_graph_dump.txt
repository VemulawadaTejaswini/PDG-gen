Line_8 $$ for (int i = 0; i < numDocs; i++) -->Line_37 $$ for (int i = 0; i < numDocs; i++) [ FD ]
Line_2 $$ public void testCreateAndDeleteIndexConcurrently() throws InterruptedException -->Line_8 $$ for (int i = 0; i < numDocs; i++) [ CD ]
Line_7 $$ int numDocs = randomIntBetween(1, 10)-->Line_8 $$ for (int i = 0; i < numDocs; i++) [ FD ]
Line_4 $$ final AtomicInteger indexVersion = new AtomicInteger(0)-->Line_40 $$ client().prepareIndex("test", "test").setSource("index_version", indexVersion.get()).get()[ FD ]
Line_2 $$ public void testCreateAndDeleteIndexConcurrently() throws InterruptedException -->Line_49 $$ assertEquals(expected + " vs. " + all, expected.getHits().getTotalHits(), all.getHits().getTotalHits())[ CD ]
Line_2 $$ public void testCreateAndDeleteIndexConcurrently() throws InterruptedException -->Line_7 $$ int numDocs = randomIntBetween(1, 10)[ CD ]
Line_2 $$ public void testCreateAndDeleteIndexConcurrently() throws InterruptedException -->Line_48 $$ SearchResponse all = client().prepareSearch("test").setIndicesOptions(IndicesOptions.lenientExpandOpen()).get()[ CD ]
Line_2 $$ public void testCreateAndDeleteIndexConcurrently() throws InterruptedException -->Line_5 $$ final Object indexVersionLock = new Object()[ CD ]
Line_14 $$ client().admin().indices().prepareDelete("test").execute(new ActionListener<DeleteIndexResponse>() -->Line_17 $$ Thread thread = new Thread() [ CD ]
Line_6 $$ final CountDownLatch latch = new CountDownLatch(1)-->Line_26 $$ latch.countDown()[ FD ]
Line_14 $$ client().admin().indices().prepareDelete("test").execute(new ActionListener<DeleteIndexResponse>() -->Line_30 $$ thread.start()[ CD ]
Line_2 $$ public void testCreateAndDeleteIndexConcurrently() throws InterruptedException -->Line_47 $$ SearchResponse expected = client().prepareSearch("test").setIndicesOptions(IndicesOptions.lenientExpandOpen()).setQuery(new RangeQueryBuilder("index_version").from(indexVersion.get(), true)).get()[ CD ]
Line_17 $$ Thread thread = new Thread() -->Line_30 $$ thread.start()[ FD ]
Line_2 $$ public void testCreateAndDeleteIndexConcurrently() throws InterruptedException -->Line_6 $$ final CountDownLatch latch = new CountDownLatch(1)[ CD ]
Line_4 $$ final AtomicInteger indexVersion = new AtomicInteger(0)-->Line_47 $$ SearchResponse expected = client().prepareSearch("test").setIndicesOptions(IndicesOptions.lenientExpandOpen()).setQuery(new RangeQueryBuilder("index_version").from(indexVersion.get(), true)).get()[ FD ]
Line_4 $$ final AtomicInteger indexVersion = new AtomicInteger(0)-->Line_9 $$ client().prepareIndex("test", "test").setSource("index_version", indexVersion.get()).get()[ FD ]
Line_2 $$ public void testCreateAndDeleteIndexConcurrently() throws InterruptedException -->Line_45 $$ latch.await()[ CD ]
Line_2 $$ public void testCreateAndDeleteIndexConcurrently() throws InterruptedException -->Line_14 $$ client().admin().indices().prepareDelete("test").execute(new ActionListener<DeleteIndexResponse>() [ CD ]
Line_4 $$ final AtomicInteger indexVersion = new AtomicInteger(0)-->Line_22 $$ indexVersion.incrementAndGet()[ FD ]
Line_2 $$ public void testCreateAndDeleteIndexConcurrently() throws InterruptedException -->Line_46 $$ refresh()[ CD ]
Line_7 $$ int numDocs = randomIntBetween(1, 10)-->Line_37 $$ for (int i = 0; i < numDocs; i++) [ FD ]
Line_4 $$ final AtomicInteger indexVersion = new AtomicInteger(0)-->Line_20 $$ client().prepareIndex("test", "test").setSource("index_version", indexVersion.get()).get()[ FD ]
Line_2 $$ public void testCreateAndDeleteIndexConcurrently() throws InterruptedException -->Line_50 $$ logger.info("total: [ CD ]
Line_2 $$ public void testCreateAndDeleteIndexConcurrently() throws InterruptedException -->Line_37 $$ for (int i = 0; i < numDocs; i++) [ CD ]
Line_2 $$ public void testCreateAndDeleteIndexConcurrently() throws InterruptedException -->Line_36 $$ numDocs = randomIntBetween(100, 200)[ CD ]
Line_4 $$ final AtomicInteger indexVersion = new AtomicInteger(0)-->Line_12 $$ indexVersion.incrementAndGet()[ FD ]
Line_6 $$ final CountDownLatch latch = new CountDownLatch(1)-->Line_45 $$ latch.await()[ FD ]
Line_2 $$ public void testCreateAndDeleteIndexConcurrently() throws InterruptedException -->Line_4 $$ final AtomicInteger indexVersion = new AtomicInteger(0)[ CD ]
Line_2 $$ public void testCreateAndDeleteIndexConcurrently() throws InterruptedException -->Line_3 $$ createIndex("test")[ CD ]
Line_8 $$ for (int i = 0; i < numDocs; i++) -->Line_9 $$ client().prepareIndex("test", "test").setSource("index_version", indexVersion.get()).get()[ CD ]
