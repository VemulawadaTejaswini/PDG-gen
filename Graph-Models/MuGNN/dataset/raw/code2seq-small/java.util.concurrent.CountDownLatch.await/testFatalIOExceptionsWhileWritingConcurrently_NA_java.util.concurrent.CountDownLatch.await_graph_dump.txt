Line_13 $$ for (int i = 0; i < threadCount; i++) -->Line_73 $$ assertEquals("expected operation" + i + " to be in the previous translog but wasn't", tlog.currentFileGeneration() - 1, writtenOperations.get(i).location.generation)[ FD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_3 $$ Path tempDir = createTempDir()[ CD ]
Line_34 $$ for (int i = 0; i < threadCount; i++) -->Line_73 $$ assertEquals("expected operation" + i + " to be in the previous translog but wasn't", tlog.currentFileGeneration() - 1, writtenOperations.get(i).location.generation)[ FD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_9 $$ final Throwable[] threadExceptions = new Throwable[threadCount][ CD ]
Line_4 $$ final AtomicBoolean fail = new AtomicBoolean(false)-->Line_33 $$ fail.set(true)[ FD ]
Line_12 $$ List<LocationOperation> writtenOperations = Collections.synchronizedList(new ArrayList())-->Line_76 $$ assertEquals(next, writtenOperations.get(i).operation)[ FD ]
Line_7 $$ final int threadCount = randomIntBetween(1, 5)-->Line_34 $$ for (int i = 0; i < threadCount; i++) [ FD ]
Line_72 $$ for (int i = 0; i < writtenOperations.size(); i++) -->Line_75 $$ assertNotNull("operation " + i + " must be non-null", next)[ CD ]
Line_12 $$ List<LocationOperation> writtenOperations = Collections.synchronizedList(new ArrayList())-->Line_71 $$ assertEquals(writtenOperations.size(), snapshot.estimatedTotalOperations())[ FD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_7 $$ final int threadCount = randomIntBetween(1, 5)[ CD ]
Line_66 $$ for (int i = 0; i < threadCount; i++) -->Line_67 $$ if (threadExceptions[i] != null)[ CD ]
Line_13 $$ for (int i = 0; i < threadCount; i++) -->Line_28 $$ threads[i].start()[ CD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_4 $$ final AtomicBoolean fail = new AtomicBoolean(false)[ CD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_12 $$ List<LocationOperation> writtenOperations = Collections.synchronizedList(new ArrayList())[ CD ]
Line_7 $$ final int threadCount = randomIntBetween(1, 5)-->Line_66 $$ for (int i = 0; i < threadCount; i++) [ FD ]
Line_15 $$ threads[i] = new TranslogThread(translog, downLatch, 200, threadId, writtenOperations, threadExceptions) -->Line_19 $$ return add[ CD ]
Line_13 $$ for (int i = 0; i < threadCount; i++) -->Line_66 $$ for (int i = 0; i < threadCount; i++) [ FD ]
Line_5 $$ TranslogConfig config = getTranslogConfig(tempDir)-->Line_6 $$ Translog translog = getFailableTranslog(fail, config)[ FD ]
Line_10 $$ final CountDownLatch downLatch = new CountDownLatch(1)-->Line_30 $$ downLatch.countDown()[ FD ]
Line_66 $$ for (int i = 0; i < threadCount; i++) -->Line_72 $$ for (int i = 0; i < writtenOperations.size(); i++) [ FD ]
Line_13 $$ for (int i = 0; i < threadCount; i++) -->Line_34 $$ for (int i = 0; i < threadCount; i++) [ FD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_6 $$ Translog translog = getFailableTranslog(fail, config)[ CD ]
Line_12 $$ List<LocationOperation> writtenOperations = Collections.synchronizedList(new ArrayList())-->Line_52 $$ Collections.sort(writtenOperations, ( a,  b) -> a.location.compareTo(b.location))[ FD ]
Line_11 $$ final CountDownLatch added = new CountDownLatch(randomIntBetween(10, 100))-->Line_18 $$ added.countDown()[ FD ]
Line_66 $$ for (int i = 0; i < threadCount; i++) -->Line_73 $$ assertEquals("expected operation" + i + " to be in the previous translog but wasn't", tlog.currentFileGeneration() - 1, writtenOperations.get(i).location.generation)[ FD ]
Line_67 $$ if (threadExceptions[i] != null)-->Line_68 $$ threadExceptions[i].printStackTrace()[ CD ]
Line_12 $$ List<LocationOperation> writtenOperations = Collections.synchronizedList(new ArrayList())-->Line_65 $$ if (writtenOperations.size() != snapshot.estimatedTotalOperations()) [ FD ]
Line_22 $$ if (randomBoolean()) -->Line_23 $$ translog.sync()[ CD ]
Line_13 $$ for (int i = 0; i < threadCount; i++) -->Line_27 $$ threads[i].setDaemon(true)[ CD ]
Line_13 $$ for (int i = 0; i < threadCount; i++) -->Line_72 $$ for (int i = 0; i < writtenOperations.size(); i++) [ FD ]
Line_34 $$ for (int i = 0; i < threadCount; i++) -->Line_35 $$ threads[i].join()[ CD ]
Line_15 $$ threads[i] = new TranslogThread(translog, downLatch, 200, threadId, writtenOperations, threadExceptions) -->Line_18 $$ added.countDown()[ CD ]
Line_15 $$ threads[i] = new TranslogThread(translog, downLatch, 200, threadId, writtenOperations, threadExceptions) -->Line_22 $$ if (randomBoolean()) [ CD ]
Line_7 $$ final int threadCount = randomIntBetween(1, 5)-->Line_13 $$ for (int i = 0; i < threadCount; i++) [ FD ]
Line_15 $$ threads[i] = new TranslogThread(translog, downLatch, 200, threadId, writtenOperations, threadExceptions) -->Line_17 $$ Translog.Location add = super.add(op)[ FD ]
Line_6 $$ Translog translog = getFailableTranslog(fail, config)-->Line_62 $$ config.setTranslogGeneration(translog.getGeneration())[ FD ]
Line_13 $$ for (int i = 0; i < threadCount; i++) -->Line_76 $$ assertEquals(next, writtenOperations.get(i).operation)[ FD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_8 $$ Thread[] threads = new Thread[threadCount][ CD ]
Line_6 $$ Translog translog = getFailableTranslog(fail, config)-->Line_53 $$ assertFalse(translog.isOpen())[ FD ]
Line_11 $$ final CountDownLatch added = new CountDownLatch(randomIntBetween(10, 100))-->Line_31 $$ added.await()[ FD ]
Line_72 $$ for (int i = 0; i < writtenOperations.size(); i++) -->Line_76 $$ assertEquals(next, writtenOperations.get(i).operation)[ CD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_30 $$ downLatch.countDown()[ CD ]
Line_34 $$ for (int i = 0; i < threadCount; i++) -->Line_66 $$ for (int i = 0; i < threadCount; i++) [ FD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_13 $$ for (int i = 0; i < threadCount; i++) [ CD ]
Line_34 $$ for (int i = 0; i < threadCount; i++) -->Line_76 $$ assertEquals(next, writtenOperations.get(i).operation)[ FD ]
Line_56 $$ while (iterator.hasNext()) -->Line_58 $$ if (checkpoint.offset < (next.location.translogLocation + next.location.size)) [ CD ]
Line_13 $$ for (int i = 0; i < threadCount; i++) -->Line_15 $$ threads[i] = new TranslogThread(translog, downLatch, 200, threadId, writtenOperations, threadExceptions) [ CD ]
Line_6 $$ Translog translog = getFailableTranslog(fail, config)-->Line_47 $$ translog.close()[ FD ]
Line_57 $$ LocationOperation next = iterator.next()-->Line_76 $$ assertEquals(next, writtenOperations.get(i).operation)[ FD ]
Line_72 $$ for (int i = 0; i < writtenOperations.size(); i++) -->Line_73 $$ assertEquals("expected operation" + i + " to be in the previous translog but wasn't", tlog.currentFileGeneration() - 1, writtenOperations.get(i).location.generation)[ CD ]
Line_12 $$ List<LocationOperation> writtenOperations = Collections.synchronizedList(new ArrayList())-->Line_73 $$ assertEquals("expected operation" + i + " to be in the previous translog but wasn't", tlog.currentFileGeneration() - 1, writtenOperations.get(i).location.generation)[ FD ]
Line_65 $$ if (writtenOperations.size() != snapshot.estimatedTotalOperations()) -->Line_66 $$ for (int i = 0; i < threadCount; i++) [ CD ]
Line_57 $$ LocationOperation next = iterator.next()-->Line_75 $$ assertNotNull("operation " + i + " must be non-null", next)[ FD ]
Line_56 $$ while (iterator.hasNext()) -->Line_57 $$ LocationOperation next = iterator.next()[ CD ]
Line_66 $$ for (int i = 0; i < threadCount; i++) -->Line_76 $$ assertEquals(next, writtenOperations.get(i).operation)[ FD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_10 $$ final CountDownLatch downLatch = new CountDownLatch(1)[ CD ]
Line_5 $$ TranslogConfig config = getTranslogConfig(tempDir)-->Line_54 $$ final Checkpoint checkpoint = Checkpoint.read(config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME))[ FD ]
Line_13 $$ for (int i = 0; i < threadCount; i++) -->Line_14 $$ final int threadId = i[ CD ]
Line_6 $$ Translog translog = getFailableTranslog(fail, config)-->Line_23 $$ translog.sync()[ FD ]
Line_3 $$ Path tempDir = createTempDir()-->Line_5 $$ TranslogConfig config = getTranslogConfig(tempDir)[ FD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_31 $$ added.await()[ CD ]
Line_12 $$ List<LocationOperation> writtenOperations = Collections.synchronizedList(new ArrayList())-->Line_55 $$ Iterator<LocationOperation> iterator = writtenOperations.iterator()[ FD ]
Line_6 $$ Translog translog = getFailableTranslog(fail, config)-->Line_32 $$ try (Translog.View view = translog.newView()) [ FD ]
Line_72 $$ for (int i = 0; i < writtenOperations.size(); i++) -->Line_74 $$ Translog.Operation next = snapshot.next()[ CD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_11 $$ final CountDownLatch added = new CountDownLatch(randomIntBetween(10, 100))[ CD ]
Line_74 $$ Translog.Operation next = snapshot.next()-->Line_76 $$ assertEquals(next, writtenOperations.get(i).operation)[ FD ]
Line_34 $$ for (int i = 0; i < threadCount; i++) -->Line_72 $$ for (int i = 0; i < writtenOperations.size(); i++) [ FD ]
Line_5 $$ TranslogConfig config = getTranslogConfig(tempDir)-->Line_62 $$ config.setTranslogGeneration(translog.getGeneration())[ FD ]
Line_12 $$ List<LocationOperation> writtenOperations = Collections.synchronizedList(new ArrayList())-->Line_72 $$ for (int i = 0; i < writtenOperations.size(); i++) [ FD ]
Line_58 $$ if (checkpoint.offset < (next.location.translogLocation + next.location.size)) -->Line_59 $$ iterator.remove()[ CD ]
Line_6 $$ Translog translog = getFailableTranslog(fail, config)-->Line_46 $$ boolean syncNeeded = translog.syncNeeded()[ FD ]
Line_15 $$ threads[i] = new TranslogThread(translog, downLatch, 200, threadId, writtenOperations, threadExceptions) -->Line_17 $$ Translog.Location add = super.add(op)[ CD ]
Line_72 $$ for (int i = 0; i < writtenOperations.size(); i++) -->Line_73 $$ assertEquals("expected operation" + i + " to be in the previous translog but wasn't", tlog.currentFileGeneration() - 1, writtenOperations.get(i).location.generation)[ FD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_5 $$ TranslogConfig config = getTranslogConfig(tempDir)[ CD ]
Line_4 $$ final AtomicBoolean fail = new AtomicBoolean(false)-->Line_6 $$ Translog translog = getFailableTranslog(fail, config)[ FD ]
Line_72 $$ for (int i = 0; i < writtenOperations.size(); i++) -->Line_76 $$ assertEquals(next, writtenOperations.get(i).operation)[ FD ]
Line_74 $$ Translog.Operation next = snapshot.next()-->Line_75 $$ assertNotNull("operation " + i + " must be non-null", next)[ FD ]
