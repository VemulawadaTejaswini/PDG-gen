Line_4 $$ final CountDownLatch latch = new CountDownLatch(threads)-->Line_30 $$ latch.await(1L, TimeUnit.SECONDS)[ FD ]
Line_28 $$ while (latch.getCount() > 0) -->Line_33 $$ log("%.1f%% complete %s", 100 * count.get() / (double) totalCount, errors.get() > 0 ? ("Errors: " + errors.get()) : "")[ CD ]
Line_4 $$ final CountDownLatch latch = new CountDownLatch(threads)-->Line_28 $$ while (latch.getCount() > 0) [ FD ]
Line_8 $$ for (int t = 0; t < threads; t++) -->Line_9 $$ Runnable runnable = new Runnable() [ CD ]
Line_2 $$ private void testRandomSelection(int perThreadTrees, int perTreeSelections, boolean narrow, boolean mixInNotPresentItems, boolean permitReversal, Consumer<RandomSelection> testRun) throws InterruptedException -->Line_28 $$ while (latch.getCount() > 0) [ CD ]
Line_14 $$ for (int j = 0; j < perTreeSelections; j++) -->Line_15 $$ testRun.accept(tree.select(narrow, mixInNotPresentItems, permitReversal))[ CD ]
Line_4 $$ final CountDownLatch latch = new CountDownLatch(threads)-->Line_23 $$ latch.countDown()[ FD ]
Line_2 $$ private void testRandomSelection(int perThreadTrees, int perTreeSelections, boolean narrow, boolean mixInNotPresentItems, boolean permitReversal, Consumer<RandomSelection> testRun) throws InterruptedException -->Line_3 $$ int threads = Runtime.getRuntime().availableProcessors()[ CD ]
Line_29 $$ for (int i = 0; i < 10L; i++) -->Line_30 $$ latch.await(1L, TimeUnit.SECONDS)[ CD ]
Line_29 $$ for (int i = 0; i < 10L; i++) -->Line_31 $$ Assert.assertEquals(0, errors.get())[ CD ]
Line_2 $$ private void testRandomSelection(int perThreadTrees, int perTreeSelections, boolean narrow, boolean mixInNotPresentItems, boolean permitReversal, Consumer<RandomSelection> testRun) throws InterruptedException -->Line_7 $$ final long totalCount = threads * perThreadTrees * perTreeSelections[ CD ]
Line_13 $$ RandomTree tree = randomTree(minTreeSize, maxTreeSize)-->Line_15 $$ testRun.accept(tree.select(narrow, mixInNotPresentItems, permitReversal))[ FD ]
Line_2 $$ private void testRandomSelection(int perThreadTrees, int perTreeSelections, boolean narrow, boolean mixInNotPresentItems, boolean permitReversal, Consumer<RandomSelection> testRun) throws InterruptedException -->Line_4 $$ final CountDownLatch latch = new CountDownLatch(threads)[ CD ]
Line_6 $$ final AtomicLong count = new AtomicLong()-->Line_33 $$ log("%.1f%% complete %s", 100 * count.get() / (double) totalCount, errors.get() > 0 ? ("Errors: " + errors.get()) : "")[ FD ]
Line_2 $$ private void testRandomSelection(int perThreadTrees, int perTreeSelections, boolean narrow, boolean mixInNotPresentItems, boolean permitReversal, Consumer<RandomSelection> testRun) throws InterruptedException -->Line_12 $$ for (int i = 0; i < perThreadTrees; i++) [ FD ]
Line_14 $$ for (int j = 0; j < perTreeSelections; j++) -->Line_16 $$ count.incrementAndGet()[ CD ]
Line_2 $$ private void testRandomSelection(int perThreadTrees, int perTreeSelections, boolean narrow, boolean mixInNotPresentItems, boolean permitReversal, Consumer<RandomSelection> testRun) throws InterruptedException -->Line_6 $$ final AtomicLong count = new AtomicLong()[ CD ]
Line_28 $$ while (latch.getCount() > 0) -->Line_29 $$ for (int i = 0; i < 10L; i++) [ CD ]
Line_9 $$ Runnable runnable = new Runnable() -->Line_23 $$ latch.countDown()[ CD ]
Line_8 $$ for (int t = 0; t < threads; t++) -->Line_26 $$ MODIFY.execute(runnable)[ CD ]
Line_5 $$ final AtomicLong errors = new AtomicLong()-->Line_31 $$ Assert.assertEquals(0, errors.get())[ FD ]
Line_9 $$ Runnable runnable = new Runnable() -->Line_26 $$ MODIFY.execute(runnable)[ FD ]
Line_2 $$ private void testRandomSelection(int perThreadTrees, int perTreeSelections, boolean narrow, boolean mixInNotPresentItems, boolean permitReversal, Consumer<RandomSelection> testRun) throws InterruptedException -->Line_8 $$ for (int t = 0; t < threads; t++) [ CD ]
Line_8 $$ for (int t = 0; t < threads; t++) -->Line_21 $$ t.printStackTrace()[ FD ]
Line_3 $$ int threads = Runtime.getRuntime().availableProcessors()-->Line_8 $$ for (int t = 0; t < threads; t++) [ FD ]
Line_6 $$ final AtomicLong count = new AtomicLong()-->Line_16 $$ count.incrementAndGet()[ FD ]
Line_5 $$ final AtomicLong errors = new AtomicLong()-->Line_20 $$ errors.incrementAndGet()[ FD ]
Line_2 $$ private void testRandomSelection(int perThreadTrees, int perTreeSelections, boolean narrow, boolean mixInNotPresentItems, boolean permitReversal, Consumer<RandomSelection> testRun) throws InterruptedException -->Line_5 $$ final AtomicLong errors = new AtomicLong()[ CD ]
Line_12 $$ for (int i = 0; i < perThreadTrees; i++) -->Line_29 $$ for (int i = 0; i < 10L; i++) [ FD ]
Line_2 $$ private void testRandomSelection(int perThreadTrees, int perTreeSelections, boolean narrow, boolean mixInNotPresentItems, boolean permitReversal, Consumer<RandomSelection> testRun) throws InterruptedException -->Line_14 $$ for (int j = 0; j < perTreeSelections; j++) [ FD ]
Line_2 $$ private void testRandomSelection(int perThreadTrees, int perTreeSelections, boolean narrow, boolean mixInNotPresentItems, boolean permitReversal, Consumer<RandomSelection> testRun) throws InterruptedException -->Line_15 $$ testRun.accept(tree.select(narrow, mixInNotPresentItems, permitReversal))[ FD ]
Line_12 $$ for (int i = 0; i < perThreadTrees; i++) -->Line_14 $$ for (int j = 0; j < perTreeSelections; j++) [ CD ]
Line_5 $$ final AtomicLong errors = new AtomicLong()-->Line_33 $$ log("%.1f%% complete %s", 100 * count.get() / (double) totalCount, errors.get() > 0 ? ("Errors: " + errors.get()) : "")[ FD ]
Line_12 $$ for (int i = 0; i < perThreadTrees; i++) -->Line_13 $$ RandomTree tree = randomTree(minTreeSize, maxTreeSize)[ CD ]
