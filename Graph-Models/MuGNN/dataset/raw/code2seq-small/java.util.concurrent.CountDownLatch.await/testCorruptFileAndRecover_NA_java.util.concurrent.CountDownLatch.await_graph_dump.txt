Line_43 $$ final IndexEventListener listener = new IndexEventListener() -->Line_45 $$ if (indexShard != null) [ FD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_31 $$ if (health.isTimedOut()) [ CD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_42 $$ final CopyOnWriteArrayList<Throwable> exception = new CopyOnWriteArrayList()[ CD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_37 $$ for (int i = 0; i < numIterations; i++) [ CD ]
Line_38 $$ SearchResponse response = client().prepareSearch().setSize(numDocs).get()-->Line_39 $$ assertHitCount(response, numDocs)[ FD ]
Line_49 $$ if (!Lucene.indexExists(store.directory()) && indexShard.state() == IndexShardState.STARTED) -->Line_50 $$ return[ CD ]
Line_41 $$ final CountDownLatch latch = new CountDownLatch(numShards * 3)-->Line_67 $$ latch.countDown()[ FD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_3 $$ int numDocs = scaledRandomIntBetween(100, 1000)[ CD ]
Line_42 $$ final CopyOnWriteArrayList<Throwable> exception = new CopyOnWriteArrayList()-->Line_78 $$ assertThat(exception, empty())[ FD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_5 $$ if (cluster().numDataNodes() == 3) [ CD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_18 $$ indexRandom(true, builders)[ CD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_14 $$ IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs][ CD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_43 $$ final IndexEventListener listener = new IndexEventListener() [ CD ]
Line_41 $$ final CountDownLatch latch = new CountDownLatch(numShards * 3)-->Line_77 $$ latch.await()[ FD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_26 $$ enableAllocation("test")[ CD ]
Line_42 $$ final CopyOnWriteArrayList<Throwable> exception = new CopyOnWriteArrayList()-->Line_64 $$ exception.add(t)[ FD ]
Line_36 $$ final int numIterations = scaledRandomIntBetween(5, 20)-->Line_37 $$ for (int i = 0; i < numIterations; i++) [ FD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_27 $$ Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "2").build()[ CD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_35 $$ assertThat(health.getStatus(), equalTo(ClusterHealthStatus.GREEN))[ CD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_22 $$ assertHitCount(countResponse, numDocs)[ CD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_28 $$ client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()[ CD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_41 $$ final CountDownLatch latch = new CountDownLatch(numShards * 3)[ CD ]
Line_45 $$ if (indexShard != null) -->Line_47 $$ store.incRef()[ CD ]
Line_46 $$ Store store = indexShard.store()-->Line_66 $$ store.decRef()[ FD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_12 $$ ensureGreen()[ CD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_15 $$ for (int i = 0; i < builders.length; i++) [ CD ]
Line_29 $$ ClusterHealthResponse health = client().admin().cluster().health(Requests.clusterHealthRequest("test").waitForGreenStatus().timeout("5m").waitForRelocatingShards(0)).actionGet()-->Line_35 $$ assertThat(health.getStatus(), equalTo(ClusterHealthStatus.GREEN))[ FD ]
Line_3 $$ int numDocs = scaledRandomIntBetween(100, 1000)-->Line_39 $$ assertHitCount(response, numDocs)[ FD ]
Line_52 $$ try (CheckIndex checkIndex = new CheckIndex(store.directory())) -->Line_57 $$ CheckIndex.Status status = checkIndex.checkIndex()[ FD ]
Line_3 $$ int numDocs = scaledRandomIntBetween(100, 1000)-->Line_22 $$ assertHitCount(countResponse, numDocs)[ FD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_9 $$ assertAcked(prepareCreate("test").setSettings(Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, "1").put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1").put(MergePolicyConfig.INDEX_MERGE_ENABLED, false).put(MockFSIndexStore.CHECK_INDEX_ON_CLOSE, false).put(IndexShard.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE, new ByteSizeValue(1, ByteSizeUnit.PB)).put("indices.recovery.concurrent_streams", 10)))[ CD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_36 $$ final int numIterations = scaledRandomIntBetween(5, 20)[ CD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_23 $$ final int numShards = numShards("test")[ CD ]
Line_46 $$ Store store = indexShard.store()-->Line_52 $$ try (CheckIndex checkIndex = new CheckIndex(store.directory())) [ FD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_20 $$ assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).setWaitIfOngoing(true).execute().actionGet())[ CD ]
Line_15 $$ for (int i = 0; i < builders.length; i++) -->Line_16 $$ builders[i] = client().prepareIndex("test", "type").setSource("field", "value")[ CD ]
Line_29 $$ ClusterHealthResponse health = client().admin().cluster().health(Requests.clusterHealthRequest("test").waitForGreenStatus().timeout("5m").waitForRelocatingShards(0)).actionGet()-->Line_33 $$ assertThat("timed out waiting for green state", health.isTimedOut(), equalTo(false))[ FD ]
Line_14 $$ IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]-->Line_18 $$ indexRandom(true, builders)[ FD ]
Line_31 $$ if (health.isTimedOut()) -->Line_32 $$ logger.info("cluster state:\n[ CD ]
Line_43 $$ final IndexEventListener listener = new IndexEventListener() -->Line_45 $$ if (indexShard != null) [ CD ]
Line_29 $$ ClusterHealthResponse health = client().admin().cluster().health(Requests.clusterHealthRequest("test").waitForGreenStatus().timeout("5m").waitForRelocatingShards(0)).actionGet()-->Line_31 $$ if (health.isTimedOut()) [ FD ]
Line_21 $$ SearchResponse countResponse = client().prepareSearch().setSize(0).get()-->Line_22 $$ assertHitCount(countResponse, numDocs)[ FD ]
Line_52 $$ try (CheckIndex checkIndex = new CheckIndex(store.directory())) -->Line_55 $$ checkIndex.setInfoStream(out)[ FD ]
Line_53 $$ BytesStreamOutput os = new BytesStreamOutput()-->Line_59 $$ logger.warn("check index [failure]\n[ FD ]
Line_43 $$ final IndexEventListener listener = new IndexEventListener() -->Line_73 $$ eventListener.setNewDelegate(listener)[ FD ]
Line_37 $$ for (int i = 0; i < numIterations; i++) -->Line_38 $$ SearchResponse response = client().prepareSearch().setSize(numDocs).get()[ CD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_29 $$ ClusterHealthResponse health = client().admin().cluster().health(Requests.clusterHealthRequest("test").waitForGreenStatus().timeout("5m").waitForRelocatingShards(0)).actionGet()[ CD ]
Line_58 $$ if (!status.clean) -->Line_59 $$ logger.warn("check index [failure]\n[ CD ]
Line_43 $$ final IndexEventListener listener = new IndexEventListener() -->Line_46 $$ Store store = indexShard.store()[ FD ]
Line_3 $$ int numDocs = scaledRandomIntBetween(100, 1000)-->Line_38 $$ SearchResponse response = client().prepareSearch().setSize(numDocs).get()[ FD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_19 $$ ensureGreen()[ CD ]
Line_46 $$ Store store = indexShard.store()-->Line_49 $$ if (!Lucene.indexExists(store.directory()) && indexShard.state() == IndexShardState.STARTED) [ FD ]
Line_15 $$ for (int i = 0; i < builders.length; i++) -->Line_37 $$ for (int i = 0; i < numIterations; i++) [ FD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_13 $$ disableAllocation("test")[ CD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_21 $$ SearchResponse countResponse = client().prepareSearch().setSize(0).get()[ CD ]
Line_31 $$ if (health.isTimedOut()) -->Line_33 $$ assertThat("timed out waiting for green state", health.isTimedOut(), equalTo(false))[ CD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_24 $$ ShardRouting corruptedShardRouting = corruptRandomPrimaryFile()[ CD ]
Line_27 $$ Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "2").build()-->Line_28 $$ client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()[ FD ]
Line_54 $$ PrintStream out = new PrintStream(os, false, StandardCharsets.UTF_8.name())-->Line_55 $$ checkIndex.setInfoStream(out)[ FD ]
Line_54 $$ PrintStream out = new PrintStream(os, false, StandardCharsets.UTF_8.name())-->Line_56 $$ out.flush()[ FD ]
Line_46 $$ Store store = indexShard.store()-->Line_47 $$ store.incRef()[ FD ]
Line_43 $$ final IndexEventListener listener = new IndexEventListener() -->Line_49 $$ if (!Lucene.indexExists(store.directory()) && indexShard.state() == IndexShardState.STARTED) [ FD ]
Line_37 $$ for (int i = 0; i < numIterations; i++) -->Line_39 $$ assertHitCount(response, numDocs)[ CD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_4 $$ internalCluster().ensureAtLeastNumDataNodes(3)[ CD ]
Line_45 $$ if (indexShard != null) -->Line_46 $$ Store store = indexShard.store()[ CD ]
Line_2 $$ public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException -->Line_8 $$ assertThat(cluster().numDataNodes(), greaterThanOrEqualTo(3))[ CD ]
