Line_3 $$ final EntityManager em = getOrCreateEntityManager()-->Line_5 $$ Lock lock = createAndPersistLockInstance(em)[ FD ]
Line_12 $$ if (backGroundThreadCompleted) -->Line_13 $$ boolean backgroundThreadHasReadNewValue = future.get()[ CD ]
Line_5 $$ Lock lock = createAndPersistLockInstance(em)-->Line_23 $$ cleanup(em, isolatedEntityManager, lock)[ FD ]
Line_4 $$ final EntityManager isolatedEntityManager = createIsolatedEntityManager()-->Line_23 $$ cleanup(em, isolatedEntityManager, lock)[ FD ]
Line_9 $$ FutureTask<Boolean> future = inBackgroundThreadStartSecondTransactionAndReadLockInstance(latch, isolatedEntityManager)-->Line_19 $$ boolean backgroundThreadHasReadNewValue = future.get()[ FD ]
Line_13 $$ boolean backgroundThreadHasReadNewValue = future.get()-->Line_20 $$ assertTrue("Background thread should read the new value after being unblocked", backgroundThreadHasReadNewValue)[ FD ]
Line_8 $$ final CountDownLatch latch = new CountDownLatch(1)-->Line_11 $$ boolean backGroundThreadCompleted = latch.await(3, TimeUnit.SECONDS)[ FD ]
Line_5 $$ Lock lock = createAndPersistLockInstance(em)-->Line_7 $$ inFirstTransactionReloadAndModifyLockInstance(em, lock)[ FD ]
Line_3 $$ final EntityManager em = getOrCreateEntityManager()-->Line_7 $$ inFirstTransactionReloadAndModifyLockInstance(em, lock)[ FD ]
Line_12 $$ if (backGroundThreadCompleted) -->Line_15 $$ em.getTransaction().commit()[ CD ]
Line_12 $$ if (backGroundThreadCompleted) -->Line_17 $$ log.debug("The background thread was blocked")[ CD ]
Line_12 $$ if (backGroundThreadCompleted) -->Line_19 $$ boolean backgroundThreadHasReadNewValue = future.get()[ CD ]
Line_4 $$ final EntityManager isolatedEntityManager = createIsolatedEntityManager()-->Line_9 $$ FutureTask<Boolean> future = inBackgroundThreadStartSecondTransactionAndReadLockInstance(latch, isolatedEntityManager)[ FD ]
Line_3 $$ final EntityManager em = getOrCreateEntityManager()-->Line_18 $$ em.getTransaction().commit()[ FD ]
Line_12 $$ if (backGroundThreadCompleted) -->Line_20 $$ assertTrue("Background thread should read the new value after being unblocked", backgroundThreadHasReadNewValue)[ CD ]
Line_3 $$ final EntityManager em = getOrCreateEntityManager()-->Line_15 $$ em.getTransaction().commit()[ FD ]
Line_2 $$ public void testContendedPessimisticLock() throws Exception -->Line_4 $$ final EntityManager isolatedEntityManager = createIsolatedEntityManager()[ CD ]
Line_9 $$ FutureTask<Boolean> future = inBackgroundThreadStartSecondTransactionAndReadLockInstance(latch, isolatedEntityManager)-->Line_13 $$ boolean backgroundThreadHasReadNewValue = future.get()[ FD ]
Line_2 $$ public void testContendedPessimisticLock() throws Exception -->Line_3 $$ final EntityManager em = getOrCreateEntityManager()[ CD ]
Line_12 $$ if (backGroundThreadCompleted) -->Line_18 $$ em.getTransaction().commit()[ CD ]
Line_12 $$ if (backGroundThreadCompleted) -->Line_14 $$ assertFalse("The background thread is not allowed to see the updated value while the first transaction has not committed yet", backgroundThreadHasReadNewValue)[ CD ]
Line_13 $$ boolean backgroundThreadHasReadNewValue = future.get()-->Line_14 $$ assertFalse("The background thread is not allowed to see the updated value while the first transaction has not committed yet", backgroundThreadHasReadNewValue)[ FD ]
Line_8 $$ final CountDownLatch latch = new CountDownLatch(1)-->Line_9 $$ FutureTask<Boolean> future = inBackgroundThreadStartSecondTransactionAndReadLockInstance(latch, isolatedEntityManager)[ FD ]
Line_2 $$ public void testContendedPessimisticLock() throws Exception -->Line_5 $$ Lock lock = createAndPersistLockInstance(em)[ CD ]
Line_3 $$ final EntityManager em = getOrCreateEntityManager()-->Line_23 $$ cleanup(em, isolatedEntityManager, lock)[ FD ]
