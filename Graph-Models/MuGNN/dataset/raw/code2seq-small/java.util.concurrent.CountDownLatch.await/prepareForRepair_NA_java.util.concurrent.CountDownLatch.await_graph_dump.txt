Line_8 $$ IAsyncCallbackWithFailure callback = new IAsyncCallbackWithFailure() -->Line_17 $$ failedNodes.add(from.getHostAddress())[ FD ]
Line_2 $$ public synchronized UUID prepareForRepair(UUID parentRepairSession, Set<InetAddress> endpoints, RepairOption options, List<ColumnFamilyStore> columnFamilyStores) -->Line_41 $$ parentRepairSessions.remove(parentRepairSession)[ FD ]
Line_2 $$ public synchronized UUID prepareForRepair(UUID parentRepairSession, Set<InetAddress> endpoints, RepairOption options, List<ColumnFamilyStore> columnFamilyStores) -->Line_21 $$ List<UUID> cfIds = new ArrayList(columnFamilyStores.size())[ FD ]
Line_2 $$ public synchronized UUID prepareForRepair(UUID parentRepairSession, Set<InetAddress> endpoints, RepairOption options, List<ColumnFamilyStore> columnFamilyStores) -->Line_3 $$ long timestamp = System.currentTimeMillis()[ CD ]
Line_7 $$ final Set<String> failedNodes = Collections.synchronizedSet(new HashSet<String>())-->Line_17 $$ failedNodes.add(from.getHostAddress())[ FD ]
Line_8 $$ IAsyncCallbackWithFailure callback = new IAsyncCallbackWithFailure() -->Line_18 $$ prepareLatch.countDown()[ CD ]
Line_8 $$ IAsyncCallbackWithFailure callback = new IAsyncCallbackWithFailure() -->Line_27 $$ MessagingService.instance().sendRR(msg, neighbour, callback, TimeUnit.HOURS.toMillis(1), true)[ FD ]
Line_3 $$ long timestamp = System.currentTimeMillis()-->Line_4 $$ registerParentRepairSession(parentRepairSession, columnFamilyStores, options.getRanges(), options.isIncremental(), timestamp, options.isGlobal())[ FD ]
Line_40 $$ if (!status.get()) -->Line_41 $$ parentRepairSessions.remove(parentRepairSession)[ CD ]
Line_2 $$ public synchronized UUID prepareForRepair(UUID parentRepairSession, Set<InetAddress> endpoints, RepairOption options, List<ColumnFamilyStore> columnFamilyStores) -->Line_6 $$ final AtomicBoolean status = new AtomicBoolean(true)[ CD ]
Line_5 $$ final CountDownLatch prepareLatch = new CountDownLatch(endpoints.size())-->Line_31 $$ prepareLatch.countDown()[ FD ]
Line_2 $$ public synchronized UUID prepareForRepair(UUID parentRepairSession, Set<InetAddress> endpoints, RepairOption options, List<ColumnFamilyStore> columnFamilyStores) -->Line_37 $$ parentRepairSessions.remove(parentRepairSession)[ FD ]
Line_2 $$ public synchronized UUID prepareForRepair(UUID parentRepairSession, Set<InetAddress> endpoints, RepairOption options, List<ColumnFamilyStore> columnFamilyStores) -->Line_5 $$ final CountDownLatch prepareLatch = new CountDownLatch(endpoints.size())[ FD ]
Line_2 $$ public synchronized UUID prepareForRepair(UUID parentRepairSession, Set<InetAddress> endpoints, RepairOption options, List<ColumnFamilyStore> columnFamilyStores) -->Line_7 $$ final Set<String> failedNodes = Collections.synchronizedSet(new HashSet<String>())[ CD ]
Line_2 $$ public synchronized UUID prepareForRepair(UUID parentRepairSession, Set<InetAddress> endpoints, RepairOption options, List<ColumnFamilyStore> columnFamilyStores) -->Line_4 $$ registerParentRepairSession(parentRepairSession, columnFamilyStores, options.getRanges(), options.isIncremental(), timestamp, options.isGlobal())[ CD ]
Line_2 $$ public synchronized UUID prepareForRepair(UUID parentRepairSession, Set<InetAddress> endpoints, RepairOption options, List<ColumnFamilyStore> columnFamilyStores) -->Line_25 $$ PrepareMessage message = new PrepareMessage(parentRepairSession, cfIds, options.getRanges(), options.isIncremental(), timestamp, options.isGlobal())[ FD ]
Line_5 $$ final CountDownLatch prepareLatch = new CountDownLatch(endpoints.size())-->Line_10 $$ prepareLatch.countDown()[ FD ]
Line_24 $$ if (FailureDetector.instance.isAlive(neighbour)) -->Line_27 $$ MessagingService.instance().sendRR(msg, neighbour, callback, TimeUnit.HOURS.toMillis(1), true)[ CD ]
Line_5 $$ final CountDownLatch prepareLatch = new CountDownLatch(endpoints.size())-->Line_35 $$ prepareLatch.await(1, TimeUnit.HOURS)[ FD ]
Line_2 $$ public synchronized UUID prepareForRepair(UUID parentRepairSession, Set<InetAddress> endpoints, RepairOption options, List<ColumnFamilyStore> columnFamilyStores) -->Line_4 $$ registerParentRepairSession(parentRepairSession, columnFamilyStores, options.getRanges(), options.isIncremental(), timestamp, options.isGlobal())[ FD ]
Line_8 $$ IAsyncCallbackWithFailure callback = new IAsyncCallbackWithFailure() -->Line_16 $$ status.set(false)[ CD ]
Line_2 $$ public synchronized UUID prepareForRepair(UUID parentRepairSession, Set<InetAddress> endpoints, RepairOption options, List<ColumnFamilyStore> columnFamilyStores) -->Line_44 $$ return parentRepairSession[ CD ]
Line_5 $$ final CountDownLatch prepareLatch = new CountDownLatch(endpoints.size())-->Line_18 $$ prepareLatch.countDown()[ FD ]
Line_8 $$ IAsyncCallbackWithFailure callback = new IAsyncCallbackWithFailure() -->Line_13 $$ return false[ CD ]
Line_2 $$ public synchronized UUID prepareForRepair(UUID parentRepairSession, Set<InetAddress> endpoints, RepairOption options, List<ColumnFamilyStore> columnFamilyStores) -->Line_5 $$ final CountDownLatch prepareLatch = new CountDownLatch(endpoints.size())[ CD ]
Line_8 $$ IAsyncCallbackWithFailure callback = new IAsyncCallbackWithFailure() -->Line_10 $$ prepareLatch.countDown()[ CD ]
Line_7 $$ final Set<String> failedNodes = Collections.synchronizedSet(new HashSet<String>())-->Line_42 $$ throw new RuntimeException("Did not get positive replies from all endpoints. List of failed endpoint(s): " + failedNodes.toString())[ FD ]
Line_2 $$ public synchronized UUID prepareForRepair(UUID parentRepairSession, Set<InetAddress> endpoints, RepairOption options, List<ColumnFamilyStore> columnFamilyStores) -->Line_8 $$ IAsyncCallbackWithFailure callback = new IAsyncCallbackWithFailure() [ CD ]
Line_2 $$ public synchronized UUID prepareForRepair(UUID parentRepairSession, Set<InetAddress> endpoints, RepairOption options, List<ColumnFamilyStore> columnFamilyStores) -->Line_40 $$ if (!status.get()) [ CD ]
Line_24 $$ if (FailureDetector.instance.isAlive(neighbour)) -->Line_26 $$ MessageOut<RepairMessage> msg = message.createMessage()[ CD ]
Line_7 $$ final Set<String> failedNodes = Collections.synchronizedSet(new HashSet<String>())-->Line_30 $$ failedNodes.add(neighbour.getHostAddress())[ FD ]
Line_6 $$ final AtomicBoolean status = new AtomicBoolean(true)-->Line_40 $$ if (!status.get()) [ FD ]
Line_8 $$ IAsyncCallbackWithFailure callback = new IAsyncCallbackWithFailure() -->Line_17 $$ failedNodes.add(from.getHostAddress())[ CD ]
Line_24 $$ if (FailureDetector.instance.isAlive(neighbour)) -->Line_31 $$ prepareLatch.countDown()[ CD ]
Line_24 $$ if (FailureDetector.instance.isAlive(neighbour)) -->Line_29 $$ status.set(false)[ CD ]
Line_6 $$ final AtomicBoolean status = new AtomicBoolean(true)-->Line_16 $$ status.set(false)[ FD ]
Line_6 $$ final AtomicBoolean status = new AtomicBoolean(true)-->Line_29 $$ status.set(false)[ FD ]
Line_7 $$ final Set<String> failedNodes = Collections.synchronizedSet(new HashSet<String>())-->Line_38 $$ throw new RuntimeException("Did not get replies from all endpoints. List of failed endpoint(s): " + failedNodes.toString(), e)[ FD ]
Line_24 $$ if (FailureDetector.instance.isAlive(neighbour)) -->Line_30 $$ failedNodes.add(neighbour.getHostAddress())[ CD ]
