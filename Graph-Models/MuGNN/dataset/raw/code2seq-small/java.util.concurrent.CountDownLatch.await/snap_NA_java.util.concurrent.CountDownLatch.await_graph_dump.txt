Line_2 $$ public <E> TimingResult<E> snap(Callable<E> call) throws InterruptedException -->Line_34 $$ TimingIntervals result = new TimingIntervals(intervals)[ CD ]
Line_24 $$ boolean done = true-->Line_35 $$ this.done = done[ FD ]
Line_2 $$ public <E> TimingResult<E> snap(Callable<E> call) throws InterruptedException -->Line_24 $$ boolean done = true[ CD ]
Line_2 $$ public <E> TimingResult<E> snap(Callable<E> call) throws InterruptedException -->Line_36 $$ history = history.merge(result, historySampleCount, history.startNanos())[ CD ]
Line_30 $$ done &= !timer.running()-->Line_35 $$ this.done = done[ FD ]
Line_2 $$ public <E> TimingResult<E> snap(Callable<E> call) throws InterruptedException -->Line_13 $$ E extra[ CD ]
Line_2 $$ public <E> TimingResult<E> snap(Callable<E> call) throws InterruptedException -->Line_7 $$ final CountDownLatch ready = new CountDownLatch(timerCount)[ CD ]
Line_2 $$ public <E> TimingResult<E> snap(Callable<E> call) throws InterruptedException -->Line_21 $$ if (!ready.await(5L, TimeUnit.MINUTES)) [ CD ]
Line_13 $$ E extra-->Line_15 $$ extra = call.call()[ FD ]
Line_2 $$ public <E> TimingResult<E> snap(Callable<E> call) throws InterruptedException -->Line_37 $$ return new TimingResult(extra, result)[ CD ]
Line_2 $$ public <E> TimingResult<E> snap(Callable<E> call) throws InterruptedException -->Line_15 $$ extra = call.call()[ FD ]
Line_25 $$ Map<String, TimingInterval> intervals = new TreeMap()-->Line_32 $$ intervals.put(entry.getKey(), TimingInterval.merge(operationIntervals, reportSampleCount, history.get(entry.getKey()).endNanos()))[ FD ]
Line_7 $$ final CountDownLatch ready = new CountDownLatch(timerCount)-->Line_21 $$ if (!ready.await(5L, TimeUnit.MINUTES)) [ FD ]
Line_2 $$ public <E> TimingResult<E> snap(Callable<E> call) throws InterruptedException -->Line_35 $$ this.done = done[ CD ]
Line_3 $$ int timerCount = 0-->Line_5 $$ timerCount += timersForOperation.size()[ FD ]
Line_26 $$ for (Map.Entry<String, List<Timer>> entry : timers.entrySet()) -->Line_28 $$ for (Timer timer : entry.getValue()) [ FD ]
Line_9 $$ for (Timer timer : timersForOperation) -->Line_30 $$ done &= !timer.running()[ FD ]
Line_27 $$ List<TimingInterval> operationIntervals = new ArrayList()-->Line_32 $$ intervals.put(entry.getKey(), TimingInterval.merge(operationIntervals, reportSampleCount, history.get(entry.getKey()).endNanos()))[ FD ]
Line_2 $$ public <E> TimingResult<E> snap(Callable<E> call) throws InterruptedException -->Line_25 $$ Map<String, TimingInterval> intervals = new TreeMap()[ CD ]
Line_4 $$ for (List<Timer> timersForOperation : timers.values()) -->Line_5 $$ timerCount += timersForOperation.size()[ FD ]
Line_27 $$ List<TimingInterval> operationIntervals = new ArrayList()-->Line_29 $$ operationIntervals.add(timer.report)[ FD ]
Line_34 $$ TimingIntervals result = new TimingIntervals(intervals)-->Line_36 $$ history = history.merge(result, historySampleCount, history.startNanos())[ FD ]
Line_9 $$ for (Timer timer : timersForOperation) -->Line_10 $$ timer.requestReport(ready)[ FD ]
Line_24 $$ boolean done = true-->Line_30 $$ done &= !timer.running()[ FD ]
Line_2 $$ public <E> TimingResult<E> snap(Callable<E> call) throws InterruptedException -->Line_3 $$ int timerCount = 0[ CD ]
Line_26 $$ for (Map.Entry<String, List<Timer>> entry : timers.entrySet()) -->Line_32 $$ intervals.put(entry.getKey(), TimingInterval.merge(operationIntervals, reportSampleCount, history.get(entry.getKey()).endNanos()))[ FD ]
Line_7 $$ final CountDownLatch ready = new CountDownLatch(timerCount)-->Line_10 $$ timer.requestReport(ready)[ FD ]
