Line_2 $$ public void testCanNotPublishWithoutMinMastNodes() throws Exception -->Line_39 $$ partition.stopDisrupting()[ CD ]
Line_18 $$ masterClusterService.submitStateUpdateTask("test", new ClusterStateUpdateTask() -->Line_28 $$ latch.countDown()[ CD ]
Line_2 $$ public void testCanNotPublishWithoutMinMastNodes() throws Exception -->Line_18 $$ masterClusterService.submitStateUpdateTask("test", new ClusterStateUpdateTask() [ CD ]
Line_2 $$ public void testCanNotPublishWithoutMinMastNodes() throws Exception -->Line_10 $$ otherNodes.remove(master)[ CD ]
Line_18 $$ masterClusterService.submitStateUpdateTask("test", new ClusterStateUpdateTask() -->Line_24 $$ return ClusterState.builder(currentState).metaData(metaData).build()[ CD ]
Line_18 $$ masterClusterService.submitStateUpdateTask("test", new ClusterStateUpdateTask() -->Line_23 $$ MetaData.Builder metaData = MetaData.builder(currentState.metaData()).persistentSettings(Settings.builder().put(currentState.metaData().persistentSettings()).put("_SHOULD_NOT_BE_THERE_", true).build())[ FD ]
Line_11 $$ NetworkDelaysPartition partition = new NetworkDelaysPartition(Collections.singleton(master), otherNodes, 60000, random())-->Line_12 $$ internalCluster().setDisruptionScheme(partition)[ FD ]
Line_11 $$ NetworkDelaysPartition partition = new NetworkDelaysPartition(Collections.singleton(master), otherNodes, 60000, random())-->Line_39 $$ partition.stopDisrupting()[ FD ]
Line_8 $$ final String master = internalCluster().getMasterName()-->Line_10 $$ otherNodes.remove(master)[ FD ]
Line_18 $$ masterClusterService.submitStateUpdateTask("test", new ClusterStateUpdateTask() -->Line_27 $$ failure.set(t)[ FD ]
Line_18 $$ masterClusterService.submitStateUpdateTask("test", new ClusterStateUpdateTask() -->Line_23 $$ MetaData.Builder metaData = MetaData.builder(currentState.metaData()).persistentSettings(Settings.builder().put(currentState.metaData().persistentSettings()).put("_SHOULD_NOT_BE_THERE_", true).build())[ CD ]
Line_14 $$ final CountDownLatch latch = new CountDownLatch(1)-->Line_32 $$ latch.await()[ FD ]
Line_2 $$ public void testCanNotPublishWithoutMinMastNodes() throws Exception -->Line_7 $$ ensureGreen()[ CD ]
Line_34 $$ assertBusy(new Runnable() -->Line_36 $$ assertThat(masterClusterService.state().nodes().masterNode(), nullValue())[ CD ]
Line_23 $$ MetaData.Builder metaData = MetaData.builder(currentState.metaData()).persistentSettings(Settings.builder().put(currentState.metaData().persistentSettings()).put("_SHOULD_NOT_BE_THERE_", true).build())-->Line_24 $$ return ClusterState.builder(currentState).metaData(metaData).build()[ FD ]
Line_2 $$ public void testCanNotPublishWithoutMinMastNodes() throws Exception -->Line_8 $$ final String master = internalCluster().getMasterName()[ CD ]
Line_2 $$ public void testCanNotPublishWithoutMinMastNodes() throws Exception -->Line_13 $$ partition.startDisrupting()[ CD ]
Line_11 $$ NetworkDelaysPartition partition = new NetworkDelaysPartition(Collections.singleton(master), otherNodes, 60000, random())-->Line_13 $$ partition.startDisrupting()[ FD ]
Line_2 $$ public void testCanNotPublishWithoutMinMastNodes() throws Exception -->Line_9 $$ Set<String> otherNodes = new HashSet(Arrays.asList(internalCluster().getNodeNames()))[ CD ]
Line_2 $$ public void testCanNotPublishWithoutMinMastNodes() throws Exception -->Line_32 $$ latch.await()[ CD ]
Line_2 $$ public void testCanNotPublishWithoutMinMastNodes() throws Exception -->Line_33 $$ assertThat(failure.get(), instanceOf(Discovery.FailedToCommitClusterStateException.class))[ CD ]
Line_15 $$ final AtomicReference<Throwable> failure = new AtomicReference()-->Line_27 $$ failure.set(t)[ FD ]
Line_17 $$ final ClusterService masterClusterService = internalCluster().clusterService(master)-->Line_36 $$ assertThat(masterClusterService.state().nodes().masterNode(), nullValue())[ FD ]
Line_18 $$ masterClusterService.submitStateUpdateTask("test", new ClusterStateUpdateTask() -->Line_27 $$ failure.set(t)[ CD ]
Line_2 $$ public void testCanNotPublishWithoutMinMastNodes() throws Exception -->Line_6 $$ internalCluster().startNodesAsync(3, settings).get()[ CD ]
Line_9 $$ Set<String> otherNodes = new HashSet(Arrays.asList(internalCluster().getNodeNames()))-->Line_10 $$ otherNodes.remove(master)[ FD ]
Line_17 $$ final ClusterService masterClusterService = internalCluster().clusterService(master)-->Line_18 $$ masterClusterService.submitStateUpdateTask("test", new ClusterStateUpdateTask() [ FD ]
Line_14 $$ final CountDownLatch latch = new CountDownLatch(1)-->Line_28 $$ latch.countDown()[ FD ]
Line_2 $$ public void testCanNotPublishWithoutMinMastNodes() throws Exception -->Line_3 $$ Settings settings = settingsBuilder().put("discovery.type", "zen").put(FaultDetection.SETTING_PING_TIMEOUT, "1h").put(ZenDiscovery.SETTING_PING_TIMEOUT, "200ms").put(ElectMasterService.DISCOVERY_ZEN_MINIMUM_MASTER_NODES_SETTING.getKey(), 2).put(DiscoverySettings.COMMIT_TIMEOUT_SETTING.getKey(), "100ms").build()[ CD ]
Line_18 $$ masterClusterService.submitStateUpdateTask("test", new ClusterStateUpdateTask() -->Line_20 $$ latch.countDown()[ CD ]
Line_2 $$ public void testCanNotPublishWithoutMinMastNodes() throws Exception -->Line_12 $$ internalCluster().setDisruptionScheme(partition)[ CD ]
Line_2 $$ public void testCanNotPublishWithoutMinMastNodes() throws Exception -->Line_14 $$ final CountDownLatch latch = new CountDownLatch(1)[ CD ]
Line_3 $$ Settings settings = settingsBuilder().put("discovery.type", "zen").put(FaultDetection.SETTING_PING_TIMEOUT, "1h").put(ZenDiscovery.SETTING_PING_TIMEOUT, "200ms").put(ElectMasterService.DISCOVERY_ZEN_MINIMUM_MASTER_NODES_SETTING.getKey(), 2).put(DiscoverySettings.COMMIT_TIMEOUT_SETTING.getKey(), "100ms").build()-->Line_6 $$ internalCluster().startNodesAsync(3, settings).get()[ FD ]
Line_2 $$ public void testCanNotPublishWithoutMinMastNodes() throws Exception -->Line_41 $$ assertNoTimeout(client().admin().cluster().prepareHealth().setWaitForNodes("3").setWaitForEvents(Priority.LANGUID))[ CD ]
Line_2 $$ public void testCanNotPublishWithoutMinMastNodes() throws Exception -->Line_34 $$ assertBusy(new Runnable() [ CD ]
Line_2 $$ public void testCanNotPublishWithoutMinMastNodes() throws Exception -->Line_17 $$ final ClusterService masterClusterService = internalCluster().clusterService(master)[ CD ]
Line_2 $$ public void testCanNotPublishWithoutMinMastNodes() throws Exception -->Line_11 $$ NetworkDelaysPartition partition = new NetworkDelaysPartition(Collections.singleton(master), otherNodes, 60000, random())[ CD ]
Line_2 $$ public void testCanNotPublishWithoutMinMastNodes() throws Exception -->Line_15 $$ final AtomicReference<Throwable> failure = new AtomicReference()[ CD ]
Line_18 $$ masterClusterService.submitStateUpdateTask("test", new ClusterStateUpdateTask() -->Line_24 $$ return ClusterState.builder(currentState).metaData(metaData).build()[ FD ]
Line_15 $$ final AtomicReference<Throwable> failure = new AtomicReference()-->Line_33 $$ assertThat(failure.get(), instanceOf(Discovery.FailedToCommitClusterStateException.class))[ FD ]
Line_8 $$ final String master = internalCluster().getMasterName()-->Line_11 $$ NetworkDelaysPartition partition = new NetworkDelaysPartition(Collections.singleton(master), otherNodes, 60000, random())[ FD ]
Line_8 $$ final String master = internalCluster().getMasterName()-->Line_17 $$ final ClusterService masterClusterService = internalCluster().clusterService(master)[ FD ]
Line_14 $$ final CountDownLatch latch = new CountDownLatch(1)-->Line_20 $$ latch.countDown()[ FD ]
