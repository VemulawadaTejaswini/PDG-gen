Line_156 $$ int moveBy = Math.max(size / 4, 1)-->Line_166 $$ index -= moveBy[ FD ]
Line_117 $$ if (size <= BufferPool.CHUNK_SIZE) -->Line_118 $$ allocate(size)[ CD ]
Line_5 $$ final DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss")-->Line_197 $$ System.out.println(String.format("%s - finished.", dateFormat.format(new Date())))[ FD ]
Line_157 $$ int index = size / 2-->Line_159 $$ int baseSampleIndex = sum1toN(index)[ FD ]
Line_95 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_111 $$ allocate(size)[ FD ]
Line_108 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_110 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_62 $$ for (int t = 0; t < threadCount; t++) -->Line_65 $$ ret.add(executorService.submit(new TestUntil(until) [ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_48 $$ executorService.submit(new TestUntil(until) [ CD ]
Line_116 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_118 $$ allocate(size)[ FD ]
Line_189 $$ while (null != (check = queue.poll())) -->Line_191 $$ BufferPool.put(check.buffer)[ CD ]
Line_84 $$ freeingSize = 0-->Line_100 $$ freeingSize += size[ FD ]
Line_48 $$ executorService.submit(new TestUntil(until) -->Line_51 $$ if (buffer == null) [ CD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_78 $$ long currentTargetSize = rand.nextInt(poolSize / 1024) == 0 ? 0 : targetSize[ CD ]
Line_135 $$ BufferCheck check = shareFrom.poll()-->Line_136 $$ if (check == null)[ FD ]
Line_164 $$ index += moveBy-->Line_159 $$ int baseSampleIndex = sum1toN(index)[ FD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_169 $$ index = size - (index + 1)[ FD ]
Line_95 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_143 $$ ByteBuffer buffer = BufferPool.get(size)[ FD ]
Line_153 $$ int size = checks.size()-->Line_154 $$ int sampleRange = sum1toN(size)[ FD ]
Line_158 $$ while (true) -->Line_159 $$ int baseSampleIndex = sum1toN(index)[ CD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_148 $$ check.init()[ CD ]
Line_11 $$ for (int i = 0; i < sharedRecycle.length; i++) -->Line_13 $$ makingProgress[i] = new AtomicBoolean(true)[ CD ]
Line_128 $$ BufferCheck check = checks.get(0)-->Line_138 $$ check.validate()[ FD ]
Line_79 $$ int spinCount = 0-->Line_86 $$ if (++spinCount > 1000 && System.nanoTime() > until)[ FD ]
Line_97 $$ size = 0-->Line_111 $$ allocate(size)[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_194 $$ assertEquals(0, executorService.shutdownNow().size())[ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_18 $$ BufferPool.MEMORY_USAGE_THRESHOLD = poolSize[ CD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_140 $$ return true[ CD ]
Line_97 $$ size = 0-->Line_109 $$ if (size <= BufferPool.CHUNK_SIZE) [ FD ]
Line_24 $$ final CountDownLatch doneAdd = new CountDownLatch(1)-->Line_58 $$ Uninterruptibles.awaitUninterruptibly(doneAdd)[ FD ]
Line_128 $$ BufferCheck check = checks.get(0)-->Line_190 $$ check.validate()[ FD ]
Line_51 $$ if (buffer == null) -->Line_52 $$ Thread.yield()[ CD ]
Line_182 $$ for (AtomicBoolean progress : makingProgress) -->Line_183 $$ assert progress.get()[ FD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_149 $$ check.listnode = checks.append(check)[ CD ]
Line_145 $$ BufferCheck check = new BufferCheck(buffer, rand.nextLong())-->Line_149 $$ check.listnode = checks.append(check)[ FD ]
Line_92 $$ BufferCheck check = sample()-->Line_94 $$ check.validate()[ FD ]
Line_161 $$ if (sampleIndex >= baseSampleIndex) -->Line_162 $$ if (sampleIndex < endOfSampleIndex)[ CD ]
Line_145 $$ BufferCheck check = new BufferCheck(buffer, rand.nextLong())-->Line_190 $$ check.validate()[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_6 $$ System.out.println(String.format("%s - testing %d threads for %dm", dateFormat.format(new Date()), threadCount, TimeUnit.NANOSECONDS.toMinutes(duration)))[ CD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_147 $$ assertEquals(0, buffer.position())[ CD ]
Line_97 $$ size = 0-->Line_113 $$ allocate(size)[ FD ]
Line_80 $$ while (totalSize > currentTargetSize - freeingSize) -->Line_95 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())[ CD ]
Line_25 $$ executorService.submit(new TestUntil(until) -->Line_42 $$ count++[ CD ]
Line_82 $$ if (shareTo.exhausted) -->Line_85 $$ if (!recycleFromNeighbour()) [ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_11 $$ for (int i = 0; i < sharedRecycle.length; i++) [ CD ]
Line_30 $$ count = 0-->Line_42 $$ count++[ FD ]
Line_35 $$ ByteBuffer buffer = BufferPool.tryGet(BufferPool.CHUNK_SIZE)-->Line_40 $$ BufferPool.put(buffer)[ FD ]
Line_16 $$ List<Future<Boolean>> ret = new ArrayList(threadCount)-->Line_65 $$ ret.add(executorService.submit(new TestUntil(until) [ FD ]
Line_25 $$ executorService.submit(new TestUntil(until) -->Line_40 $$ BufferPool.put(buffer)[ CD ]
Line_85 $$ if (!recycleFromNeighbour()) -->Line_86 $$ if (++spinCount > 1000 && System.nanoTime() > until)[ CD ]
Line_98 $$ if (rand.nextBoolean()) -->Line_99 $$ shareTo.add(check)[ CD ]
Line_98 $$ if (rand.nextBoolean()) -->Line_105 $$ totalSize -= size[ CD ]
Line_112 $$ if (rand.nextBoolean()) -->Line_115 $$ while (totalSize < poolSize) [ CD ]
Line_109 $$ if (size <= BufferPool.CHUNK_SIZE) -->Line_111 $$ allocate(size)[ CD ]
Line_159 $$ int baseSampleIndex = sum1toN(index)-->Line_161 $$ if (sampleIndex >= baseSampleIndex) [ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_6 $$ System.out.println(String.format("%s - testing %d threads for %dm", dateFormat.format(new Date()), threadCount, TimeUnit.NANOSECONDS.toMinutes(duration)))[ FD ]
Line_105 $$ totalSize -= size-->Line_115 $$ while (totalSize < poolSize) [ FD ]
Line_95 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_146 $$ assertEquals(size, buffer.capacity())[ FD ]
Line_164 $$ index += moveBy-->Line_170 $$ return checks.get(index)[ FD ]
Line_35 $$ ByteBuffer buffer = BufferPool.tryGet(BufferPool.CHUNK_SIZE)-->Line_36 $$ if (buffer == null) [ FD ]
Line_97 $$ size = 0-->Line_117 $$ if (size <= BufferPool.CHUNK_SIZE) [ FD ]
Line_116 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_119 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_25 $$ executorService.submit(new TestUntil(until) -->Line_28 $$ if (count * BufferPool.CHUNK_SIZE >= poolSize / 10) [ CD ]
Line_28 $$ if (count * BufferPool.CHUNK_SIZE >= poolSize / 10) -->Line_33 $$ return[ CD ]
Line_23 $$ final SPSCQueue<ByteBuffer> burn = new SPSCQueue()-->Line_41 $$ burn.add(buffer)[ FD ]
Line_95 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_117 $$ if (size <= BufferPool.CHUNK_SIZE) [ FD ]
Line_48 $$ executorService.submit(new TestUntil(until) -->Line_50 $$ ByteBuffer buffer = burn.poll()[ CD ]
Line_143 $$ ByteBuffer buffer = BufferPool.get(size)-->Line_144 $$ assertNotNull(buffer)[ FD ]
Line_158 $$ while (true) -->Line_160 $$ int endOfSampleIndex = sum1toN(index + 1)[ CD ]
Line_161 $$ if (sampleIndex >= baseSampleIndex) -->Line_166 $$ index -= moveBy[ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_7 $$ final long until = System.nanoTime() + duration[ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_3 $$ final int avgBufferSize = 16 << 10[ CD ]
Line_108 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_116 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))[ FD ]
Line_80 $$ while (totalSize > currentTargetSize - freeingSize) -->Line_96 $$ if (size > BufferPool.CHUNK_SIZE)[ CD ]
Line_127 $$ while (checks.size() > 0) -->Line_129 $$ BufferPool.put(check.buffer)[ CD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_143 $$ ByteBuffer buffer = BufferPool.get(size)[ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_4 $$ final int stdevBufferSize = 10 << 10[ CD ]
Line_80 $$ while (totalSize > currentTargetSize - freeingSize) -->Line_81 $$ if (checks.size() == 0) [ CD ]
Line_128 $$ BufferCheck check = checks.get(0)-->Line_148 $$ check.init()[ FD ]
Line_83 $$ totalSize -= freeingSize-->Line_119 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_169 $$ index = size - (index + 1)-->Line_170 $$ return checks.get(index)[ FD ]
Line_5 $$ final DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss")-->Line_6 $$ System.out.println(String.format("%s - testing %d threads for %dm", dateFormat.format(new Date()), threadCount, TimeUnit.NANOSECONDS.toMinutes(duration)))[ FD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_146 $$ assertEquals(size, buffer.capacity())[ CD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_157 $$ int index = size / 2[ CD ]
Line_95 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_97 $$ size = 0[ FD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_123 $$ checks.get(rand.nextInt(checks.size())).validate()[ CD ]
Line_189 $$ while (null != (check = queue.poll())) -->Line_190 $$ check.validate()[ CD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_153 $$ int size = checks.size()[ CD ]
Line_119 $$ totalSize += BufferPool.roundUpNormal(size)-->Line_115 $$ while (totalSize < poolSize) [ FD ]
Line_108 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_169 $$ index = size - (index + 1)[ FD ]
Line_105 $$ totalSize -= size-->Line_80 $$ while (totalSize > currentTargetSize - freeingSize) [ FD ]
Line_35 $$ ByteBuffer buffer = BufferPool.tryGet(BufferPool.CHUNK_SIZE)-->Line_41 $$ burn.add(buffer)[ FD ]
Line_105 $$ totalSize -= size-->Line_119 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_36 $$ if (buffer == null) -->Line_38 $$ return[ CD ]
Line_108 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_111 $$ allocate(size)[ FD ]
Line_29 $$ if (burn.exhausted)-->Line_30 $$ count = 0[ CD ]
Line_108 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_117 $$ if (size <= BufferPool.CHUNK_SIZE) [ FD ]
Line_50 $$ ByteBuffer buffer = burn.poll()-->Line_51 $$ if (buffer == null) [ FD ]
Line_15 $$ ExecutorService executorService = Executors.newFixedThreadPool(threadCount + 2)-->Line_48 $$ executorService.submit(new TestUntil(until) [ FD ]
Line_135 $$ BufferCheck check = shareFrom.poll()-->Line_149 $$ check.listnode = checks.append(check)[ FD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_127 $$ while (checks.size() > 0) [ CD ]
Line_24 $$ final CountDownLatch doneAdd = new CountDownLatch(1)-->Line_45 $$ doneAdd.countDown()[ FD ]
Line_35 $$ ByteBuffer buffer = BufferPool.tryGet(BufferPool.CHUNK_SIZE)-->Line_147 $$ assertEquals(0, buffer.position())[ FD ]
Line_116 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_143 $$ ByteBuffer buffer = BufferPool.get(size)[ FD ]
Line_167 $$ moveBy = Math.max(moveBy / 2, 1)-->Line_164 $$ index += moveBy[ FD ]
Line_80 $$ while (totalSize > currentTargetSize - freeingSize) -->Line_98 $$ if (rand.nextBoolean()) [ CD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_138 $$ check.validate()[ CD ]
Line_28 $$ if (count * BufferPool.CHUNK_SIZE >= poolSize / 10) -->Line_29 $$ if (burn.exhausted)[ CD ]
Line_98 $$ if (rand.nextBoolean()) -->Line_100 $$ freeingSize += size[ CD ]
Line_23 $$ final SPSCQueue<ByteBuffer> burn = new SPSCQueue()-->Line_29 $$ if (burn.exhausted)[ FD ]
Line_62 $$ for (int t = 0; t < threadCount; t++) -->Line_63 $$ final int threadIdx = t[ CD ]
Line_92 $$ BufferCheck check = sample()-->Line_103 $$ check.validate()[ FD ]
Line_135 $$ BufferCheck check = shareFrom.poll()-->Line_148 $$ check.init()[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_18 $$ BufferPool.MEMORY_USAGE_THRESHOLD = poolSize[ FD ]
Line_116 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_117 $$ if (size <= BufferPool.CHUNK_SIZE) [ FD ]
Line_95 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_118 $$ allocate(size)[ FD ]
Line_143 $$ ByteBuffer buffer = BufferPool.get(size)-->Line_147 $$ assertEquals(0, buffer.position())[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_62 $$ for (int t = 0; t < threadCount; t++) [ FD ]
Line_97 $$ size = 0-->Line_169 $$ index = size - (index + 1)[ FD ]
Line_97 $$ size = 0-->Line_110 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_5 $$ final DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss")[ CD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_170 $$ return checks.get(index)[ CD ]
Line_100 $$ freeingSize += size-->Line_83 $$ totalSize -= freeingSize[ FD ]
Line_108 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_109 $$ if (size <= BufferPool.CHUNK_SIZE) [ FD ]
Line_92 $$ BufferCheck check = sample()-->Line_149 $$ check.listnode = checks.append(check)[ FD ]
Line_86 $$ if (++spinCount > 1000 && System.nanoTime() > until)-->Line_87 $$ return[ CD ]
Line_95 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_110 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_139 $$ BufferPool.put(check.buffer)[ CD ]
Line_80 $$ while (totalSize > currentTargetSize - freeingSize) -->Line_92 $$ BufferCheck check = sample()[ CD ]
Line_95 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_116 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_62 $$ for (int t = 0; t < threadCount; t++) [ CD ]
Line_135 $$ BufferCheck check = shareFrom.poll()-->Line_138 $$ check.validate()[ FD ]
Line_108 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_118 $$ allocate(size)[ FD ]
Line_95 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_100 $$ freeingSize += size[ FD ]
Line_97 $$ size = 0-->Line_108 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))[ FD ]
Line_128 $$ BufferCheck check = checks.get(0)-->Line_136 $$ if (check == null)[ FD ]
Line_157 $$ int index = size / 2-->Line_164 $$ index += moveBy[ FD ]
Line_15 $$ ExecutorService executorService = Executors.newFixedThreadPool(threadCount + 2)-->Line_65 $$ ret.add(executorService.submit(new TestUntil(until) [ FD ]
Line_110 $$ totalSize += BufferPool.roundUpNormal(size)-->Line_115 $$ while (totalSize < poolSize) [ FD ]
Line_95 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_105 $$ totalSize -= size[ FD ]
Line_83 $$ totalSize -= freeingSize-->Line_115 $$ while (totalSize < poolSize) [ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_115 $$ while (totalSize < poolSize) [ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_24 $$ final CountDownLatch doneAdd = new CountDownLatch(1)[ CD ]
Line_154 $$ int sampleRange = sum1toN(size)-->Line_155 $$ int sampleIndex = rand.nextInt(sampleRange)[ FD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_158 $$ while (true) [ CD ]
Line_155 $$ int sampleIndex = rand.nextInt(sampleRange)-->Line_161 $$ if (sampleIndex >= baseSampleIndex) [ FD ]
Line_156 $$ int moveBy = Math.max(size / 4, 1)-->Line_164 $$ index += moveBy[ FD ]
Line_164 $$ index += moveBy-->Line_166 $$ index -= moveBy[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_9 $$ final SPSCQueue<BufferCheck>[] sharedRecycle = new SPSCQueue[threadCount][ CD ]
Line_25 $$ executorService.submit(new TestUntil(until) -->Line_36 $$ if (buffer == null) [ CD ]
Line_95 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_96 $$ if (size > BufferPool.CHUNK_SIZE)[ FD ]
Line_51 $$ if (buffer == null) -->Line_53 $$ return[ CD ]
Line_115 $$ while (totalSize < poolSize) -->Line_116 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))[ CD ]
Line_20 $$ int targetSizeQuanta = ((threadCount) * (threadCount - 1)) / 2-->Line_21 $$ targetSizeQuanta = (targetSizeQuanta * poolSize) / 64[ FD ]
Line_97 $$ size = 0-->Line_146 $$ assertEquals(size, buffer.capacity())[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_10 $$ final AtomicBoolean[] makingProgress = new AtomicBoolean[threadCount][ CD ]
Line_145 $$ BufferCheck check = new BufferCheck(buffer, rand.nextLong())-->Line_148 $$ check.init()[ FD ]
Line_97 $$ size = 0-->Line_119 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_109 $$ if (size <= BufferPool.CHUNK_SIZE) [ CD ]
Line_92 $$ BufferCheck check = sample()-->Line_138 $$ check.validate()[ FD ]
Line_50 $$ ByteBuffer buffer = burn.poll()-->Line_144 $$ assertNotNull(buffer)[ FD ]
Line_23 $$ final SPSCQueue<ByteBuffer> burn = new SPSCQueue()-->Line_50 $$ ByteBuffer buffer = burn.poll()[ FD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_150 $$ return check[ CD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_155 $$ int sampleIndex = rand.nextInt(sampleRange)[ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_197 $$ System.out.println(String.format("%s - finished.", dateFormat.format(new Date())))[ CD ]
Line_108 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_154 $$ int sampleRange = sum1toN(size)[ FD ]
Line_166 $$ index -= moveBy-->Line_169 $$ index = size - (index + 1)[ FD ]
Line_48 $$ executorService.submit(new TestUntil(until) -->Line_55 $$ BufferPool.put(buffer)[ CD ]
Line_160 $$ int endOfSampleIndex = sum1toN(index + 1)-->Line_162 $$ if (sampleIndex < endOfSampleIndex)[ FD ]
Line_108 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_119 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_11 $$ for (int i = 0; i < sharedRecycle.length; i++) -->Line_12 $$ sharedRecycle[i] = new SPSCQueue()[ CD ]
Line_50 $$ ByteBuffer buffer = burn.poll()-->Line_146 $$ assertEquals(size, buffer.capacity())[ FD ]
Line_62 $$ for (int t = 0; t < threadCount; t++) -->Line_64 $$ final int targetSize = t == 0 ? BufferPool.CHUNK_SIZE : targetSizeQuanta * t[ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_16 $$ List<Future<Boolean>> ret = new ArrayList(threadCount)[ CD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_154 $$ int sampleRange = sum1toN(size)[ FD ]
Line_110 $$ totalSize += BufferPool.roundUpNormal(size)-->Line_119 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_35 $$ ByteBuffer buffer = BufferPool.tryGet(BufferPool.CHUNK_SIZE)-->Line_51 $$ if (buffer == null) [ FD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_144 $$ assertNotNull(buffer)[ CD ]
Line_92 $$ BufferCheck check = sample()-->Line_190 $$ check.validate()[ FD ]
Line_116 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_154 $$ int sampleRange = sum1toN(size)[ FD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_156 $$ int moveBy = Math.max(size / 4, 1)[ CD ]
Line_25 $$ executorService.submit(new TestUntil(until) -->Line_45 $$ doneAdd.countDown()[ CD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_145 $$ BufferCheck check = new BufferCheck(buffer, rand.nextLong())[ CD ]
Line_84 $$ freeingSize = 0-->Line_83 $$ totalSize -= freeingSize[ FD ]
Line_15 $$ ExecutorService executorService = Executors.newFixedThreadPool(threadCount + 2)-->Line_25 $$ executorService.submit(new TestUntil(until) [ FD ]
Line_96 $$ if (size > BufferPool.CHUNK_SIZE)-->Line_97 $$ size = 0[ CD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_80 $$ while (totalSize > currentTargetSize - freeingSize) [ CD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_108 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))[ CD ]
Line_128 $$ BufferCheck check = checks.get(0)-->Line_149 $$ check.listnode = checks.append(check)[ FD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_136 $$ if (check == null)[ CD ]
Line_97 $$ size = 0-->Line_116 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))[ FD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_143 $$ ByteBuffer buffer = BufferPool.get(size)[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_20 $$ int targetSizeQuanta = ((threadCount) * (threadCount - 1)) / 2[ CD ]
Line_29 $$ if (burn.exhausted)-->Line_32 $$ Thread.yield()[ CD ]
Line_108 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_113 $$ allocate(size)[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_8 $$ final CountDownLatch latch = new CountDownLatch(threadCount)[ CD ]
Line_108 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_146 $$ assertEquals(size, buffer.capacity())[ FD ]
Line_95 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_119 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_98 $$ if (rand.nextBoolean()) -->Line_104 $$ BufferPool.put(check.buffer)[ CD ]
Line_109 $$ if (size <= BufferPool.CHUNK_SIZE) -->Line_110 $$ totalSize += BufferPool.roundUpNormal(size)[ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_19 $$ BufferPool.DEBUG = true[ CD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_74 $$ if (!makingProgress[threadIdx].get())[ CD ]
Line_50 $$ ByteBuffer buffer = burn.poll()-->Line_147 $$ assertEquals(0, buffer.position())[ FD ]
Line_179 $$ if (!first)-->Line_180 $$ BufferPool.assertAllRecycled()[ CD ]
Line_83 $$ totalSize -= freeingSize-->Line_105 $$ totalSize -= size[ FD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_79 $$ int spinCount = 0[ CD ]
Line_74 $$ if (!makingProgress[threadIdx].get())-->Line_75 $$ makingProgress[threadIdx].set(true)[ CD ]
Line_116 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_146 $$ assertEquals(size, buffer.capacity())[ FD ]
Line_80 $$ while (totalSize > currentTargetSize - freeingSize) -->Line_93 $$ checks.remove(check.listnode)[ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_21 $$ targetSizeQuanta = (targetSizeQuanta * poolSize) / 64[ CD ]
Line_82 $$ if (shareTo.exhausted) -->Line_84 $$ freeingSize = 0[ CD ]
Line_157 $$ int index = size / 2-->Line_166 $$ index -= moveBy[ FD ]
Line_156 $$ int moveBy = Math.max(size / 4, 1)-->Line_167 $$ moveBy = Math.max(moveBy / 2, 1)[ FD ]
Line_98 $$ if (rand.nextBoolean()) -->Line_101 $$ recycleFromNeighbour()[ CD ]
Line_35 $$ ByteBuffer buffer = BufferPool.tryGet(BufferPool.CHUNK_SIZE)-->Line_55 $$ BufferPool.put(buffer)[ FD ]
Line_25 $$ executorService.submit(new TestUntil(until) -->Line_41 $$ burn.add(buffer)[ CD ]
Line_127 $$ while (checks.size() > 0) -->Line_128 $$ BufferCheck check = checks.get(0)[ CD ]
Line_164 $$ index += moveBy-->Line_169 $$ index = size - (index + 1)[ FD ]
Line_48 $$ executorService.submit(new TestUntil(until) -->Line_58 $$ Uninterruptibles.awaitUninterruptibly(doneAdd)[ CD ]
Line_81 $$ if (checks.size() == 0) -->Line_82 $$ if (shareTo.exhausted) [ CD ]
Line_112 $$ if (rand.nextBoolean()) -->Line_113 $$ allocate(size)[ CD ]
Line_127 $$ while (checks.size() > 0) -->Line_130 $$ checks.remove(check.listnode)[ CD ]
Line_178 $$ while (!latch.await(10L, TimeUnit.SECONDS)) -->Line_179 $$ if (!first)[ CD ]
Line_161 $$ if (sampleIndex >= baseSampleIndex) -->Line_164 $$ index += moveBy[ CD ]
Line_98 $$ if (rand.nextBoolean()) -->Line_103 $$ check.validate()[ CD ]
Line_167 $$ moveBy = Math.max(moveBy / 2, 1)-->Line_166 $$ index -= moveBy[ FD ]
Line_82 $$ if (shareTo.exhausted) -->Line_83 $$ totalSize -= freeingSize[ CD ]
Line_36 $$ if (buffer == null) -->Line_37 $$ Thread.yield()[ CD ]
Line_97 $$ size = 0-->Line_105 $$ totalSize -= size[ FD ]
Line_35 $$ ByteBuffer buffer = BufferPool.tryGet(BufferPool.CHUNK_SIZE)-->Line_146 $$ assertEquals(size, buffer.capacity())[ FD ]
Line_95 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_154 $$ int sampleRange = sum1toN(size)[ FD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_169 $$ index = size - (index + 1)[ CD ]
Line_83 $$ totalSize -= freeingSize-->Line_110 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_25 $$ executorService.submit(new TestUntil(until) -->Line_35 $$ ByteBuffer buffer = BufferPool.tryGet(BufferPool.CHUNK_SIZE)[ CD ]
Line_8 $$ final CountDownLatch latch = new CountDownLatch(threadCount)-->Line_132 $$ latch.countDown()[ FD ]
Line_157 $$ int index = size / 2-->Line_170 $$ return checks.get(index)[ FD ]
Line_97 $$ size = 0-->Line_118 $$ allocate(size)[ FD ]
Line_92 $$ BufferCheck check = sample()-->Line_148 $$ check.init()[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_178 $$ while (!latch.await(10L, TimeUnit.SECONDS)) [ CD ]
Line_50 $$ ByteBuffer buffer = burn.poll()-->Line_55 $$ BufferPool.put(buffer)[ FD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_135 $$ BufferCheck check = shareFrom.poll()[ CD ]
Line_97 $$ size = 0-->Line_143 $$ ByteBuffer buffer = BufferPool.get(size)[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_17 $$ long prevPoolSize = BufferPool.MEMORY_USAGE_THRESHOLD[ CD ]
Line_97 $$ size = 0-->Line_96 $$ if (size > BufferPool.CHUNK_SIZE)[ FD ]
Line_166 $$ index -= moveBy-->Line_170 $$ return checks.get(index)[ FD ]
Line_155 $$ int sampleIndex = rand.nextInt(sampleRange)-->Line_162 $$ if (sampleIndex < endOfSampleIndex)[ FD ]
Line_97 $$ size = 0-->Line_154 $$ int sampleRange = sum1toN(size)[ FD ]
Line_15 $$ ExecutorService executorService = Executors.newFixedThreadPool(threadCount + 2)-->Line_194 $$ assertEquals(0, executorService.shutdownNow().size())[ FD ]
Line_105 $$ totalSize -= size-->Line_110 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_154 $$ int sampleRange = sum1toN(size)[ CD ]
Line_135 $$ BufferCheck check = shareFrom.poll()-->Line_190 $$ check.validate()[ FD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_132 $$ latch.countDown()[ CD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_146 $$ assertEquals(size, buffer.capacity())[ FD ]
Line_182 $$ for (AtomicBoolean progress : makingProgress) -->Line_184 $$ progress.set(false)[ FD ]
Line_83 $$ totalSize -= freeingSize-->Line_80 $$ while (totalSize > currentTargetSize - freeingSize) [ FD ]
Line_80 $$ while (totalSize > currentTargetSize - freeingSize) -->Line_94 $$ check.validate()[ CD ]
Line_108 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_143 $$ ByteBuffer buffer = BufferPool.get(size)[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_25 $$ executorService.submit(new TestUntil(until) [ CD ]
Line_95 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_113 $$ allocate(size)[ FD ]
Line_35 $$ ByteBuffer buffer = BufferPool.tryGet(BufferPool.CHUNK_SIZE)-->Line_144 $$ assertNotNull(buffer)[ FD ]
Line_115 $$ while (totalSize < poolSize) -->Line_117 $$ if (size <= BufferPool.CHUNK_SIZE) [ CD ]
Line_95 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_169 $$ index = size - (index + 1)[ FD ]
Line_8 $$ final CountDownLatch latch = new CountDownLatch(threadCount)-->Line_178 $$ while (!latch.await(10L, TimeUnit.SECONDS)) [ FD ]
Line_92 $$ BufferCheck check = sample()-->Line_99 $$ shareTo.add(check)[ FD ]
Line_85 $$ if (!recycleFromNeighbour()) -->Line_88 $$ Thread.yield()[ CD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_173 $$ return (n * (n + 1)) / 2[ CD ]
Line_116 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_169 $$ index = size - (index + 1)[ FD ]
Line_97 $$ size = 0-->Line_100 $$ freeingSize += size[ FD ]
Line_136 $$ if (check == null)-->Line_137 $$ return false[ CD ]
Line_153 $$ int size = checks.size()-->Line_169 $$ index = size - (index + 1)[ FD ]
Line_95 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_109 $$ if (size <= BufferPool.CHUNK_SIZE) [ FD ]
Line_158 $$ while (true) -->Line_161 $$ if (sampleIndex >= baseSampleIndex) [ CD ]
Line_166 $$ index -= moveBy-->Line_159 $$ int baseSampleIndex = sum1toN(index)[ FD ]
Line_95 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_108 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_15 $$ ExecutorService executorService = Executors.newFixedThreadPool(threadCount + 2)[ CD ]
Line_65 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_124 $$ while (recycleFromNeighbour()) [ CD ]
Line_157 $$ int index = size / 2-->Line_169 $$ index = size - (index + 1)[ FD ]
Line_158 $$ while (true) -->Line_167 $$ moveBy = Math.max(moveBy / 2, 1)[ CD ]
Line_92 $$ BufferCheck check = sample()-->Line_136 $$ if (check == null)[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_23 $$ final SPSCQueue<ByteBuffer> burn = new SPSCQueue()[ CD ]
Line_109 $$ if (size <= BufferPool.CHUNK_SIZE) -->Line_112 $$ if (rand.nextBoolean()) [ CD ]
Line_143 $$ ByteBuffer buffer = BufferPool.get(size)-->Line_146 $$ assertEquals(size, buffer.capacity())[ FD ]
Line_117 $$ if (size <= BufferPool.CHUNK_SIZE) -->Line_119 $$ totalSize += BufferPool.roundUpNormal(size)[ CD ]
