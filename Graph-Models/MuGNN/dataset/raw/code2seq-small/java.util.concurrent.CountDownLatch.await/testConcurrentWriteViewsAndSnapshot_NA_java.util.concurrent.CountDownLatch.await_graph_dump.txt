Line_111 $$ for (int iterations = scaledRandomIntBetween(10, 200); iterations > 0 && errors.isEmpty(); iterations--) -->Line_118 $$ translog.commit()[ CD ]
Line_28 $$ op = new Translog.Delete(newUid("" + id))-->Line_90 $$ final Translog.Location loc = writtenOps.get(op)[ FD ]
Line_129 $$ if (errors.size() > 0) -->Line_130 $$ Throwable e = errors.get(0)[ CD ]
Line_86 $$ if (expectedOps.isEmpty() == false) -->Line_87 $$ StringBuilder missed = new StringBuilder("missed ").append(expectedOps.size()).append(" operations")[ CD ]
Line_7 $$ final AtomicLong idGenerator = new AtomicLong()-->Line_20 $$ long id = idGenerator.incrementAndGet()[ FD ]
Line_52 $$ readers[i] = new Thread(new AbstractRunnable() -->Line_73 $$ int iter = 0[ CD ]
Line_13 $$ for (int i = 0; i < writers.length; i++) -->Line_48 $$ writers[i].start()[ CD ]
Line_21 $$ final Translog.Operation op-->Line_90 $$ final Translog.Location loc = writtenOps.get(op)[ FD ]
Line_73 $$ int iter = 0-->Line_75 $$ if (iter++ % 10 == 0) [ FD ]
Line_50 $$ for (int i = 0; i < readers.length; i++) -->Line_107 $$ readers[i].start()[ CD ]
Line_19 $$ while (run.get()) -->Line_21 $$ final Translog.Operation op[ CD ]
Line_81 $$ Translog.Operation op-->Line_82 $$ while ((op = snapshot.next()) != null) [ FD ]
Line_52 $$ readers[i] = new Thread(new AbstractRunnable() -->Line_58 $$ closeView()[ CD ]
Line_74 $$ while (run.get()) -->Line_79 $$ expectedOps.removeAll(writtenOpsAtView)[ CD ]
Line_13 $$ for (int i = 0; i < writers.length; i++) -->Line_15 $$ writers[i] = new Thread(new AbstractRunnable() [ CD ]
Line_21 $$ final Translog.Operation op-->Line_33 $$ Translog.Location location = translog.add(op)[ FD ]
Line_19 $$ while (run.get()) -->Line_39 $$ counter++[ CD ]
Line_11 $$ final List<Throwable> errors = new CopyOnWriteArrayList()-->Line_131 $$ for (Throwable suppress : errors.subList(1, errors.size())) [ FD ]
Line_11 $$ final List<Throwable> errors = new CopyOnWriteArrayList()-->Line_45 $$ errors.add(t)[ FD ]
Line_28 $$ op = new Translog.Delete(newUid("" + id))-->Line_83 $$ expectedOps.remove(op)[ FD ]
Line_2 $$ public void testConcurrentWriteViewsAndSnapshot() throws Throwable -->Line_109 $$ barrier.await()[ CD ]
Line_6 $$ final AtomicReference<CountDownLatch> writtenOpsLatch = new AtomicReference(new CountDownLatch(0))-->Line_101 $$ writtenOpsLatch.get().await(200, TimeUnit.MILLISECONDS)[ FD ]
Line_10 $$ final AtomicBoolean run = new AtomicBoolean(true)-->Line_121 $$ run.set(false)[ FD ]
Line_19 $$ while (run.get()) -->Line_34 $$ Translog.Location existing = writtenOps.put(op, location)[ CD ]
Line_97 $$ if (failed) -->Line_98 $$ fail(missed.toString())[ CD ]
Line_52 $$ readers[i] = new Thread(new AbstractRunnable() -->Line_57 $$ errors.add(t)[ CD ]
Line_78 $$ Set<Translog.Operation> expectedOps = new HashSet(writtenOps.keySet())-->Line_83 $$ expectedOps.remove(op)[ FD ]
Line_19 $$ while (run.get()) -->Line_35 $$ if (existing != null) [ CD ]
Line_10 $$ final AtomicBoolean run = new AtomicBoolean(true)-->Line_74 $$ while (run.get()) [ FD ]
Line_28 $$ op = new Translog.Delete(newUid("" + id))-->Line_33 $$ Translog.Location location = translog.add(op)[ FD ]
Line_25 $$ op = new Translog.Index("type", "" + id, new byte[] -->Line_34 $$ Translog.Location existing = writtenOps.put(op, location)[ FD ]
Line_9 $$ final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()-->Line_78 $$ Set<Translog.Operation> expectedOps = new HashSet(writtenOps.keySet())[ FD ]
Line_11 $$ final List<Throwable> errors = new CopyOnWriteArrayList()-->Line_111 $$ for (int iterations = scaledRandomIntBetween(10, 200); iterations > 0 && errors.isEmpty(); iterations--) [ FD ]
Line_52 $$ readers[i] = new Thread(new AbstractRunnable() -->Line_57 $$ errors.add(t)[ FD ]
Line_6 $$ final AtomicReference<CountDownLatch> writtenOpsLatch = new AtomicReference(new CountDownLatch(0))-->Line_112 $$ writtenOpsLatch.set(new CountDownLatch(flushEveryOps))[ FD ]
Line_74 $$ while (run.get()) -->Line_75 $$ if (iter++ % 10 == 0) [ CD ]
Line_2 $$ public void testConcurrentWriteViewsAndSnapshot() throws Throwable -->Line_3 $$ final Thread[] writers = new Thread[randomIntBetween(1, 10)][ CD ]
Line_11 $$ final List<Throwable> errors = new CopyOnWriteArrayList()-->Line_114 $$ if (errors.size() > 0) [ FD ]
Line_2 $$ public void testConcurrentWriteViewsAndSnapshot() throws Throwable -->Line_10 $$ final AtomicBoolean run = new AtomicBoolean(true)[ CD ]
Line_21 $$ final Translog.Operation op-->Line_82 $$ while ((op = snapshot.next()) != null) [ FD ]
Line_25 $$ op = new Translog.Index("type", "" + id, new byte[] -->Line_82 $$ while ((op = snapshot.next()) != null) [ FD ]
Line_19 $$ while (run.get()) -->Line_38 $$ writtenOpsLatch.get().countDown()[ CD ]
Line_21 $$ final Translog.Operation op-->Line_83 $$ expectedOps.remove(op)[ FD ]
Line_2 $$ public void testConcurrentWriteViewsAndSnapshot() throws Throwable -->Line_4 $$ final Thread[] readers = new Thread[randomIntBetween(1, 10)][ CD ]
Line_15 $$ writers[i] = new Thread(new AbstractRunnable() -->Line_57 $$ errors.add(t)[ FD ]
Line_21 $$ final Translog.Operation op-->Line_28 $$ op = new Translog.Delete(newUid("" + id))[ FD ]
Line_78 $$ Set<Translog.Operation> expectedOps = new HashSet(writtenOps.keySet())-->Line_86 $$ if (expectedOps.isEmpty() == false) [ FD ]
Line_13 $$ for (int i = 0; i < writers.length; i++) -->Line_50 $$ for (int i = 0; i < readers.length; i++) [ FD ]
Line_2 $$ public void testConcurrentWriteViewsAndSnapshot() throws Throwable -->Line_8 $$ final CyclicBarrier barrier = new CyclicBarrier(writers.length + readers.length + 1)[ CD ]
Line_78 $$ Set<Translog.Operation> expectedOps = new HashSet(writtenOps.keySet())-->Line_79 $$ expectedOps.removeAll(writtenOpsAtView)[ FD ]
Line_8 $$ final CyclicBarrier barrier = new CyclicBarrier(writers.length + readers.length + 1)-->Line_17 $$ barrier.await()[ FD ]
Line_19 $$ while (run.get()) -->Line_33 $$ Translog.Location location = translog.add(op)[ CD ]
Line_81 $$ Translog.Operation op-->Line_83 $$ expectedOps.remove(op)[ FD ]
Line_86 $$ if (expectedOps.isEmpty() == false) -->Line_97 $$ if (failed) [ CD ]
Line_28 $$ op = new Translog.Delete(newUid("" + id))-->Line_34 $$ Translog.Location existing = writtenOps.put(op, location)[ FD ]
Line_82 $$ while ((op = snapshot.next()) != null) -->Line_83 $$ expectedOps.remove(op)[ CD ]
Line_52 $$ readers[i] = new Thread(new AbstractRunnable() -->Line_61 $$ if (view != null) [ CD ]
Line_2 $$ public void testConcurrentWriteViewsAndSnapshot() throws Throwable -->Line_7 $$ final AtomicLong idGenerator = new AtomicLong()[ CD ]
Line_15 $$ writers[i] = new Thread(new AbstractRunnable() -->Line_19 $$ while (run.get()) [ CD ]
Line_75 $$ if (iter++ % 10 == 0) -->Line_76 $$ newView()[ CD ]
Line_18 $$ int counter = 0-->Line_39 $$ counter++[ FD ]
Line_2 $$ public void testConcurrentWriteViewsAndSnapshot() throws Throwable -->Line_5 $$ final int flushEveryOps = randomIntBetween(5, 100)[ CD ]
Line_50 $$ for (int i = 0; i < readers.length; i++) -->Line_52 $$ readers[i] = new Thread(new AbstractRunnable() [ CD ]
Line_52 $$ readers[i] = new Thread(new AbstractRunnable() -->Line_66 $$ closeView()[ CD ]
Line_2 $$ public void testConcurrentWriteViewsAndSnapshot() throws Throwable -->Line_6 $$ final AtomicReference<CountDownLatch> writtenOpsLatch = new AtomicReference(new CountDownLatch(0))[ CD ]
Line_25 $$ op = new Translog.Index("type", "" + id, new byte[] -->Line_33 $$ Translog.Location location = translog.add(op)[ FD ]
Line_2 $$ public void testConcurrentWriteViewsAndSnapshot() throws Throwable -->Line_50 $$ for (int i = 0; i < readers.length; i++) [ CD ]
Line_21 $$ final Translog.Operation op-->Line_25 $$ op = new Translog.Index("type", "" + id, new byte[] [ FD ]
Line_8 $$ final CyclicBarrier barrier = new CyclicBarrier(writers.length + readers.length + 1)-->Line_72 $$ barrier.await()[ FD ]
Line_2 $$ public void testConcurrentWriteViewsAndSnapshot() throws Throwable -->Line_13 $$ for (int i = 0; i < writers.length; i++) [ CD ]
Line_111 $$ for (int iterations = scaledRandomIntBetween(10, 200); iterations > 0 && errors.isEmpty(); iterations--) -->Line_113 $$ while (writtenOpsLatch.get().await(200, TimeUnit.MILLISECONDS) == false) [ CD ]
Line_15 $$ writers[i] = new Thread(new AbstractRunnable() -->Line_45 $$ errors.add(t)[ FD ]
Line_15 $$ writers[i] = new Thread(new AbstractRunnable() -->Line_45 $$ errors.add(t)[ CD ]
Line_9 $$ final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()-->Line_34 $$ Translog.Location existing = writtenOps.put(op, location)[ FD ]
Line_15 $$ writers[i] = new Thread(new AbstractRunnable() -->Line_18 $$ int counter = 0[ CD ]
Line_11 $$ final List<Throwable> errors = new CopyOnWriteArrayList()-->Line_129 $$ if (errors.size() > 0) [ FD ]
Line_34 $$ Translog.Location existing = writtenOps.put(op, location)-->Line_35 $$ if (existing != null) [ FD ]
Line_61 $$ if (view != null) -->Line_62 $$ view.close()[ CD ]
Line_8 $$ final CyclicBarrier barrier = new CyclicBarrier(writers.length + readers.length + 1)-->Line_109 $$ barrier.await()[ FD ]
Line_74 $$ while (run.get()) -->Line_101 $$ writtenOpsLatch.get().await(200, TimeUnit.MILLISECONDS)[ CD ]
Line_52 $$ readers[i] = new Thread(new AbstractRunnable() -->Line_103 $$ closeView()[ CD ]
Line_25 $$ op = new Translog.Index("type", "" + id, new byte[] -->Line_28 $$ op = new Translog.Delete(newUid("" + id))[ FD ]
Line_82 $$ while ((op = snapshot.next()) != null) -->Line_90 $$ final Translog.Location loc = writtenOps.get(op)[ FD ]
Line_82 $$ while ((op = snapshot.next()) != null) -->Line_83 $$ expectedOps.remove(op)[ FD ]
Line_74 $$ while (run.get()) -->Line_78 $$ Set<Translog.Operation> expectedOps = new HashSet(writtenOps.keySet())[ CD ]
Line_10 $$ final AtomicBoolean run = new AtomicBoolean(true)-->Line_19 $$ while (run.get()) [ FD ]
Line_2 $$ public void testConcurrentWriteViewsAndSnapshot() throws Throwable -->Line_9 $$ final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()[ CD ]
Line_2 $$ public void testConcurrentWriteViewsAndSnapshot() throws Throwable -->Line_12 $$ logger.debug("using [[ CD ]
Line_52 $$ readers[i] = new Thread(new AbstractRunnable() -->Line_67 $$ view = translog.newView()[ CD ]
Line_5 $$ final int flushEveryOps = randomIntBetween(5, 100)-->Line_12 $$ logger.debug("using [[ FD ]
Line_113 $$ while (writtenOpsLatch.get().await(200, TimeUnit.MILLISECONDS) == false) -->Line_114 $$ if (errors.size() > 0) [ CD ]
Line_78 $$ Set<Translog.Operation> expectedOps = new HashSet(writtenOps.keySet())-->Line_87 $$ StringBuilder missed = new StringBuilder("missed ").append(expectedOps.size()).append(" operations")[ FD ]
Line_13 $$ for (int i = 0; i < writers.length; i++) -->Line_14 $$ final String threadId = "writer_" + i[ CD ]
Line_35 $$ if (existing != null) -->Line_36 $$ fail("duplicate op [" + op + "], old entry at " + location)[ CD ]
Line_6 $$ final AtomicReference<CountDownLatch> writtenOpsLatch = new AtomicReference(new CountDownLatch(0))-->Line_38 $$ writtenOpsLatch.get().countDown()[ FD ]
Line_80 $$ try (Translog.Snapshot snapshot = view.snapshot()) -->Line_82 $$ while ((op = snapshot.next()) != null) [ FD ]
Line_28 $$ op = new Translog.Delete(newUid("" + id))-->Line_82 $$ while ((op = snapshot.next()) != null) [ FD ]
Line_74 $$ while (run.get()) -->Line_86 $$ if (expectedOps.isEmpty() == false) [ CD ]
Line_111 $$ for (int iterations = scaledRandomIntBetween(10, 200); iterations > 0 && errors.isEmpty(); iterations--) -->Line_112 $$ writtenOpsLatch.set(new CountDownLatch(flushEveryOps))[ CD ]
Line_52 $$ readers[i] = new Thread(new AbstractRunnable() -->Line_74 $$ while (run.get()) [ CD ]
Line_15 $$ writers[i] = new Thread(new AbstractRunnable() -->Line_17 $$ barrier.await()[ CD ]
Line_11 $$ final List<Throwable> errors = new CopyOnWriteArrayList()-->Line_57 $$ errors.add(t)[ FD ]
Line_33 $$ Translog.Location location = translog.add(op)-->Line_34 $$ Translog.Location existing = writtenOps.put(op, location)[ FD ]
Line_2 $$ public void testConcurrentWriteViewsAndSnapshot() throws Throwable -->Line_11 $$ final List<Throwable> errors = new CopyOnWriteArrayList()[ CD ]
Line_9 $$ final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()-->Line_90 $$ final Translog.Location loc = writtenOps.get(op)[ FD ]
Line_25 $$ op = new Translog.Index("type", "" + id, new byte[] -->Line_83 $$ expectedOps.remove(op)[ FD ]
Line_50 $$ for (int i = 0; i < readers.length; i++) -->Line_51 $$ final String threadId = "reader_" + i[ CD ]
Line_19 $$ while (run.get()) -->Line_20 $$ long id = idGenerator.incrementAndGet()[ CD ]
Line_21 $$ final Translog.Operation op-->Line_34 $$ Translog.Location existing = writtenOps.put(op, location)[ FD ]
Line_25 $$ op = new Translog.Index("type", "" + id, new byte[] -->Line_90 $$ final Translog.Location loc = writtenOps.get(op)[ FD ]
Line_81 $$ Translog.Operation op-->Line_90 $$ final Translog.Location loc = writtenOps.get(op)[ FD ]
Line_6 $$ final AtomicReference<CountDownLatch> writtenOpsLatch = new AtomicReference(new CountDownLatch(0))-->Line_113 $$ while (writtenOpsLatch.get().await(200, TimeUnit.MILLISECONDS) == false) [ FD ]
Line_11 $$ final List<Throwable> errors = new CopyOnWriteArrayList()-->Line_130 $$ Throwable e = errors.get(0)[ FD ]
Line_52 $$ readers[i] = new Thread(new AbstractRunnable() -->Line_72 $$ barrier.await()[ CD ]
Line_9 $$ final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()-->Line_68 $$ writtenOpsAtView = new HashSet(writtenOps.keySet())[ FD ]
