Line_10 $$ final AtomicReference<OpOrder.Barrier> barrier = new AtomicReference()-->Line_27 $$ barrier.set(order.newBarrier())[ FD ]
Line_4 $$ final ScheduledExecutorService exec = Executors.newScheduledThreadPool(2)-->Line_59 $$ exec.schedule(markBlocking, 10L, TimeUnit.MILLISECONDS)[ FD ]
Line_2 $$ public void testBookKeeping() throws ExecutionException, InterruptedException -->Line_4 $$ final ScheduledExecutorService exec = Executors.newScheduledThreadPool(2)[ CD ]
Line_18 $$ if (isClean.getCount() > 0) -->Line_20 $$ isClean.countDown()[ CD ]
Line_6 $$ final OpOrder.Group group = order.start()-->Line_60 $$ allocator.allocate(110, group)[ FD ]
Line_2 $$ public void testBookKeeping() throws ExecutionException, InterruptedException -->Line_11 $$ final NativeAllocator allocator = new NativeAllocator(new NativePool(1, 100, 0.75f, new Runnable() [ CD ]
Line_8 $$ final CountDownLatch isClean = new CountDownLatch(1)-->Line_48 $$ Assert.assertEquals(1, isClean.getCount())[ FD ]
Line_5 $$ final OpOrder order = new OpOrder()-->Line_27 $$ barrier.set(order.newBarrier())[ FD ]
Line_32 $$ final Runnable run = new Runnable() -->Line_57 $$ Assert.assertEquals(0, isClean.getCount())[ CD ]
Line_11 $$ final NativeAllocator allocator = new NativeAllocator(new NativePool(1, 100, 0.75f, new Runnable() -->Line_62 $$ Assert.assertEquals(110, allocator.offHeap().owns())[ FD ]
Line_32 $$ final Runnable run = new Runnable() -->Line_34 $$ allocator.allocate(10, group)[ CD ]
Line_32 $$ final Runnable run = new Runnable() -->Line_37 $$ Assert.assertEquals(0, allocator.offHeap().owns())[ CD ]
Line_8 $$ final CountDownLatch isClean = new CountDownLatch(1)-->Line_57 $$ Assert.assertEquals(0, isClean.getCount())[ FD ]
Line_32 $$ final Runnable run = new Runnable() -->Line_59 $$ exec.schedule(markBlocking, 10L, TimeUnit.MILLISECONDS)[ CD ]
Line_11 $$ final NativeAllocator allocator = new NativeAllocator(new NativePool(1, 100, 0.75f, new Runnable() -->Line_36 $$ allocator.offHeap().adjust(-10, group)[ FD ]
Line_11 $$ final NativeAllocator allocator = new NativeAllocator(new NativePool(1, 100, 0.75f, new Runnable() -->Line_37 $$ Assert.assertEquals(0, allocator.offHeap().owns())[ FD ]
Line_7 $$ final CountDownLatch canClean = new CountDownLatch(1)-->Line_14 $$ canClean.await()[ FD ]
Line_11 $$ final NativeAllocator allocator = new NativeAllocator(new NativePool(1, 100, 0.75f, new Runnable() -->Line_42 $$ allocator.offHeap().allocate(-10, group)[ FD ]
Line_9 $$ final AtomicReference<NativeAllocator> allocatorRef = new AtomicReference()-->Line_24 $$ allocatorRef.set(allocator)[ FD ]
Line_32 $$ final Runnable run = new Runnable() -->Line_50 $$ Assert.assertEquals(80, allocator.offHeap().owns())[ CD ]
Line_2 $$ public void testBookKeeping() throws ExecutionException, InterruptedException -->Line_65 $$ exec.submit(run).get()[ CD ]
Line_5 $$ final OpOrder order = new OpOrder()-->Line_6 $$ final OpOrder.Group group = order.start()[ FD ]
Line_9 $$ final AtomicReference<NativeAllocator> allocatorRef = new AtomicReference()-->Line_19 $$ allocatorRef.get().offHeap().released(80)[ FD ]
Line_10 $$ final AtomicReference<OpOrder.Barrier> barrier = new AtomicReference()-->Line_29 $$ barrier.get().markBlocking()[ FD ]
Line_11 $$ final NativeAllocator allocator = new NativeAllocator(new NativePool(1, 100, 0.75f, new Runnable() -->Line_18 $$ if (isClean.getCount() > 0) [ CD ]
Line_32 $$ final Runnable run = new Runnable() -->Line_61 $$ Assert.assertNotNull(barrier.get())[ CD ]
Line_4 $$ final ScheduledExecutorService exec = Executors.newScheduledThreadPool(2)-->Line_65 $$ exec.submit(run).get()[ FD ]
Line_11 $$ final NativeAllocator allocator = new NativeAllocator(new NativePool(1, 100, 0.75f, new Runnable() -->Line_49 $$ allocator.allocate(70, group)[ FD ]
Line_11 $$ final NativeAllocator allocator = new NativeAllocator(new NativePool(1, 100, 0.75f, new Runnable() -->Line_39 $$ Assert.assertEquals(10, allocator.offHeap().owns())[ FD ]
Line_32 $$ final Runnable run = new Runnable() -->Line_51 $$ canClean.countDown()[ CD ]
Line_2 $$ public void testBookKeeping() throws ExecutionException, InterruptedException -->Line_6 $$ final OpOrder.Group group = order.start()[ CD ]
Line_44 $$ success = true-->Line_46 $$ Assert.assertTrue(success)[ FD ]
Line_6 $$ final OpOrder.Group group = order.start()-->Line_38 $$ allocator.offHeap().adjust(10, group)[ FD ]
Line_7 $$ final CountDownLatch canClean = new CountDownLatch(1)-->Line_51 $$ canClean.countDown()[ FD ]
Line_11 $$ final NativeAllocator allocator = new NativeAllocator(new NativePool(1, 100, 0.75f, new Runnable() -->Line_35 $$ Assert.assertEquals(10, allocator.offHeap().owns())[ FD ]
Line_40 $$ boolean success = false-->Line_44 $$ success = true[ FD ]
Line_2 $$ public void testBookKeeping() throws ExecutionException, InterruptedException -->Line_7 $$ final CountDownLatch canClean = new CountDownLatch(1)[ CD ]
Line_2 $$ public void testBookKeeping() throws ExecutionException, InterruptedException -->Line_24 $$ allocatorRef.set(allocator)[ CD ]
Line_25 $$ final Runnable markBlocking = new Runnable() -->Line_27 $$ barrier.set(order.newBarrier())[ CD ]
Line_10 $$ final AtomicReference<OpOrder.Barrier> barrier = new AtomicReference()-->Line_28 $$ barrier.get().issue()[ FD ]
Line_18 $$ if (isClean.getCount() > 0) -->Line_19 $$ allocatorRef.get().offHeap().released(80)[ CD ]
Line_32 $$ final Runnable run = new Runnable() -->Line_36 $$ allocator.offHeap().adjust(-10, group)[ CD ]
Line_32 $$ final Runnable run = new Runnable() -->Line_39 $$ Assert.assertEquals(10, allocator.offHeap().owns())[ CD ]
Line_2 $$ public void testBookKeeping() throws ExecutionException, InterruptedException -->Line_10 $$ final AtomicReference<OpOrder.Barrier> barrier = new AtomicReference()[ CD ]
Line_2 $$ public void testBookKeeping() throws ExecutionException, InterruptedException -->Line_5 $$ final OpOrder order = new OpOrder()[ CD ]
Line_25 $$ final Runnable markBlocking = new Runnable() -->Line_29 $$ barrier.get().markBlocking()[ CD ]
Line_32 $$ final Runnable run = new Runnable() -->Line_38 $$ allocator.offHeap().adjust(10, group)[ CD ]
Line_11 $$ final NativeAllocator allocator = new NativeAllocator(new NativePool(1, 100, 0.75f, new Runnable() -->Line_38 $$ allocator.offHeap().adjust(10, group)[ FD ]
Line_8 $$ final CountDownLatch isClean = new CountDownLatch(1)-->Line_20 $$ isClean.countDown()[ FD ]
Line_32 $$ final Runnable run = new Runnable() -->Line_40 $$ boolean success = false[ CD ]
Line_32 $$ final Runnable run = new Runnable() -->Line_47 $$ Uninterruptibles.sleepUninterruptibly(10L, TimeUnit.MILLISECONDS)[ CD ]
Line_32 $$ final Runnable run = new Runnable() -->Line_46 $$ Assert.assertTrue(success)[ CD ]
Line_32 $$ final Runnable run = new Runnable() -->Line_49 $$ allocator.allocate(70, group)[ CD ]
Line_2 $$ public void testBookKeeping() throws ExecutionException, InterruptedException -->Line_9 $$ final AtomicReference<NativeAllocator> allocatorRef = new AtomicReference()[ CD ]
Line_11 $$ final NativeAllocator allocator = new NativeAllocator(new NativePool(1, 100, 0.75f, new Runnable() -->Line_24 $$ allocatorRef.set(allocator)[ FD ]
Line_6 $$ final OpOrder.Group group = order.start()-->Line_36 $$ allocator.offHeap().adjust(-10, group)[ FD ]
Line_8 $$ final CountDownLatch isClean = new CountDownLatch(1)-->Line_18 $$ if (isClean.getCount() > 0) [ FD ]
Line_8 $$ final CountDownLatch isClean = new CountDownLatch(1)-->Line_53 $$ isClean.await(10L, TimeUnit.MILLISECONDS)[ FD ]
Line_32 $$ final Runnable run = new Runnable() -->Line_60 $$ allocator.allocate(110, group)[ CD ]
Line_10 $$ final AtomicReference<OpOrder.Barrier> barrier = new AtomicReference()-->Line_61 $$ Assert.assertNotNull(barrier.get())[ FD ]
Line_11 $$ final NativeAllocator allocator = new NativeAllocator(new NativePool(1, 100, 0.75f, new Runnable() -->Line_34 $$ allocator.allocate(10, group)[ FD ]
Line_11 $$ final NativeAllocator allocator = new NativeAllocator(new NativePool(1, 100, 0.75f, new Runnable() -->Line_58 $$ Assert.assertEquals(0, allocator.offHeap().owns())[ FD ]
Line_11 $$ final NativeAllocator allocator = new NativeAllocator(new NativePool(1, 100, 0.75f, new Runnable() -->Line_60 $$ allocator.allocate(110, group)[ FD ]
Line_6 $$ final OpOrder.Group group = order.start()-->Line_49 $$ allocator.allocate(70, group)[ FD ]
Line_11 $$ final NativeAllocator allocator = new NativeAllocator(new NativePool(1, 100, 0.75f, new Runnable() -->Line_50 $$ Assert.assertEquals(80, allocator.offHeap().owns())[ FD ]
Line_32 $$ final Runnable run = new Runnable() -->Line_58 $$ Assert.assertEquals(0, allocator.offHeap().owns())[ CD ]
Line_32 $$ final Runnable run = new Runnable() -->Line_35 $$ Assert.assertEquals(10, allocator.offHeap().owns())[ CD ]
Line_32 $$ final Runnable run = new Runnable() -->Line_62 $$ Assert.assertEquals(110, allocator.offHeap().owns())[ CD ]
Line_6 $$ final OpOrder.Group group = order.start()-->Line_34 $$ allocator.allocate(10, group)[ FD ]
Line_25 $$ final Runnable markBlocking = new Runnable() -->Line_28 $$ barrier.get().issue()[ CD ]
Line_40 $$ boolean success = false-->Line_46 $$ Assert.assertTrue(success)[ FD ]
Line_32 $$ final Runnable run = new Runnable() -->Line_48 $$ Assert.assertEquals(1, isClean.getCount())[ CD ]
Line_2 $$ public void testBookKeeping() throws ExecutionException, InterruptedException -->Line_8 $$ final CountDownLatch isClean = new CountDownLatch(1)[ CD ]
Line_6 $$ final OpOrder.Group group = order.start()-->Line_42 $$ allocator.offHeap().allocate(-10, group)[ FD ]
