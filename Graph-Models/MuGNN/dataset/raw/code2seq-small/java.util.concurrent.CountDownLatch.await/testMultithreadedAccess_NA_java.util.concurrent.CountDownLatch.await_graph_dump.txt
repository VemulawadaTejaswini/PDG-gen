Line_22 $$ for (int i = 0; i < 3; i++) -->Line_24 $$ Thread.sleep(250)[ CD ]
Line_18 $$ for (int i = 0; i < 100; i++) -->Line_23 $$ sampler.beginSampling(i)[ FD ]
Line_9 $$ while (running.get()) -->Line_10 $$ insert(sampler)[ CD ]
Line_4 $$ final CountDownLatch latch = new CountDownLatch(1)-->Line_28 $$ latch.await(1, TimeUnit.SECONDS)[ FD ]
Line_30 $$ for (int i = 0; i < 10; i++) -->Line_33 $$ sampler.finishSampling(i)[ FD ]
Line_4 $$ final CountDownLatch latch = new CountDownLatch(1)-->Line_13 $$ latch.countDown()[ FD ]
Line_18 $$ for (int i = 0; i < 100; i++) -->Line_33 $$ sampler.finishSampling(i)[ FD ]
Line_30 $$ for (int i = 0; i < 10; i++) -->Line_31 $$ sampler.beginSampling(i)[ CD ]
Line_5 $$ final TopKSampler<String> sampler = new TopKSampler<String>()-->Line_33 $$ sampler.finishSampling(i)[ FD ]
Line_3 $$ final AtomicBoolean running = new AtomicBoolean(true)-->Line_27 $$ running.set(false)[ FD ]
Line_18 $$ for (int i = 0; i < 100; i++) -->Line_22 $$ for (int i = 0; i < 3; i++) [ FD ]
Line_2 $$ public void testMultithreadedAccess() throws Exception -->Line_4 $$ final CountDownLatch latch = new CountDownLatch(1)[ CD ]
Line_22 $$ for (int i = 0; i < 3; i++) -->Line_25 $$ sampler.finishSampling(i)[ CD ]
Line_18 $$ for (int i = 0; i < 100; i++) -->Line_25 $$ sampler.finishSampling(i)[ FD ]
Line_5 $$ final TopKSampler<String> sampler = new TopKSampler<String>()-->Line_31 $$ sampler.beginSampling(i)[ FD ]
Line_18 $$ for (int i = 0; i < 100; i++) -->Line_19 $$ sampler.beginSampling(i)[ FD ]
Line_22 $$ for (int i = 0; i < 3; i++) -->Line_23 $$ sampler.beginSampling(i)[ CD ]
Line_22 $$ for (int i = 0; i < 3; i++) -->Line_31 $$ sampler.beginSampling(i)[ FD ]
Line_30 $$ for (int i = 0; i < 10; i++) -->Line_33 $$ sampler.finishSampling(i)[ CD ]
Line_18 $$ for (int i = 0; i < 100; i++) -->Line_20 $$ sampler.finishSampling(i)[ FD ]
Line_22 $$ for (int i = 0; i < 3; i++) -->Line_23 $$ sampler.beginSampling(i)[ FD ]
Line_2 $$ public void testMultithreadedAccess() throws Exception -->Line_3 $$ final AtomicBoolean running = new AtomicBoolean(true)[ CD ]
Line_5 $$ final TopKSampler<String> sampler = new TopKSampler<String>()-->Line_23 $$ sampler.beginSampling(i)[ FD ]
Line_2 $$ public void testMultithreadedAccess() throws Exception -->Line_5 $$ final TopKSampler<String> sampler = new TopKSampler<String>()[ CD ]
Line_3 $$ final AtomicBoolean running = new AtomicBoolean(true)-->Line_36 $$ running.set(false)[ FD ]
Line_2 $$ public void testMultithreadedAccess() throws Exception -->Line_6 $$ new Thread(new Runnable() [ CD ]
Line_5 $$ final TopKSampler<String> sampler = new TopKSampler<String>()-->Line_19 $$ sampler.beginSampling(i)[ FD ]
Line_5 $$ final TopKSampler<String> sampler = new TopKSampler<String>()-->Line_25 $$ sampler.finishSampling(i)[ FD ]
Line_18 $$ for (int i = 0; i < 100; i++) -->Line_30 $$ for (int i = 0; i < 10; i++) [ FD ]
Line_30 $$ for (int i = 0; i < 10; i++) -->Line_32 $$ Thread.sleep(i)[ CD ]
Line_18 $$ for (int i = 0; i < 100; i++) -->Line_19 $$ sampler.beginSampling(i)[ CD ]
Line_3 $$ final AtomicBoolean running = new AtomicBoolean(true)-->Line_9 $$ while (running.get()) [ FD ]
Line_22 $$ for (int i = 0; i < 3; i++) -->Line_33 $$ sampler.finishSampling(i)[ FD ]
Line_30 $$ for (int i = 0; i < 10; i++) -->Line_31 $$ sampler.beginSampling(i)[ FD ]
Line_22 $$ for (int i = 0; i < 3; i++) -->Line_30 $$ for (int i = 0; i < 10; i++) [ FD ]
Line_22 $$ for (int i = 0; i < 3; i++) -->Line_25 $$ sampler.finishSampling(i)[ FD ]
Line_5 $$ final TopKSampler<String> sampler = new TopKSampler<String>()-->Line_20 $$ sampler.finishSampling(i)[ FD ]
Line_18 $$ for (int i = 0; i < 100; i++) -->Line_20 $$ sampler.finishSampling(i)[ CD ]
Line_22 $$ for (int i = 0; i < 3; i++) -->Line_32 $$ Thread.sleep(i)[ FD ]
Line_5 $$ final TopKSampler<String> sampler = new TopKSampler<String>()-->Line_10 $$ insert(sampler)[ FD ]
Line_18 $$ for (int i = 0; i < 100; i++) -->Line_31 $$ sampler.beginSampling(i)[ FD ]
Line_18 $$ for (int i = 0; i < 100; i++) -->Line_32 $$ Thread.sleep(i)[ FD ]
Line_30 $$ for (int i = 0; i < 10; i++) -->Line_32 $$ Thread.sleep(i)[ FD ]
