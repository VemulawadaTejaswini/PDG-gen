Line_5 $$ final AtomicReference<Thread> futureThread = new AtomicReference<Thread>()-->Line_22 $$ futureThread.get().interrupt()[ FD ]
Line_6 $$ ExecutorService exec = Executors.newSingleThreadExecutor()-->Line_7 $$ Future<Throwable> future = exec.submit(new Callable<Throwable>() [ FD ]
Line_5 $$ final AtomicReference<Thread> futureThread = new AtomicReference<Thread>()-->Line_9 $$ futureThread.set(Thread.currentThread())[ FD ]
Line_2 $$ public void testRetryInterruptible() throws Throwable -->Line_21 $$ assertTrue(futureThread.get().isAlive())[ CD ]
Line_2 $$ public void testRetryInterruptible() throws Throwable -->Line_26 $$ assertEquals("sleep interrupted", e.getMessage())[ CD ]
Line_2 $$ public void testRetryInterruptible() throws Throwable -->Line_24 $$ assertNotNull(e)[ CD ]
Line_7 $$ Future<Throwable> future = exec.submit(new Callable<Throwable>() -->Line_9 $$ futureThread.set(Thread.currentThread())[ CD ]
Line_2 $$ public void testRetryInterruptible() throws Throwable -->Line_25 $$ assertEquals(InterruptedException.class, e.getClass())[ CD ]
Line_2 $$ public void testRetryInterruptible() throws Throwable -->Line_3 $$ final UnreliableInterface unreliable = (UnreliableInterface) RetryProxy.create(UnreliableInterface.class, unreliableImpl, retryUpToMaximumTimeWithFixedSleep(10, 10, TimeUnit.SECONDS))[ CD ]
Line_3 $$ final UnreliableInterface unreliable = (UnreliableInterface) RetryProxy.create(UnreliableInterface.class, unreliableImpl, retryUpToMaximumTimeWithFixedSleep(10, 10, TimeUnit.SECONDS))-->Line_12 $$ unreliable.alwaysFailsWithFatalException()[ FD ]
Line_2 $$ public void testRetryInterruptible() throws Throwable -->Line_7 $$ Future<Throwable> future = exec.submit(new Callable<Throwable>() [ CD ]
Line_2 $$ public void testRetryInterruptible() throws Throwable -->Line_20 $$ Thread.sleep(1000)[ CD ]
Line_2 $$ public void testRetryInterruptible() throws Throwable -->Line_23 $$ Throwable e = future.get(1, TimeUnit.SECONDS)[ CD ]
Line_2 $$ public void testRetryInterruptible() throws Throwable -->Line_19 $$ latch.await()[ CD ]
Line_7 $$ Future<Throwable> future = exec.submit(new Callable<Throwable>() -->Line_10 $$ latch.countDown()[ CD ]
Line_4 $$ final CountDownLatch latch = new CountDownLatch(1)-->Line_10 $$ latch.countDown()[ FD ]
Line_7 $$ Future<Throwable> future = exec.submit(new Callable<Throwable>() -->Line_23 $$ Throwable e = future.get(1, TimeUnit.SECONDS)[ FD ]
Line_2 $$ public void testRetryInterruptible() throws Throwable -->Line_22 $$ futureThread.get().interrupt()[ CD ]
Line_2 $$ public void testRetryInterruptible() throws Throwable -->Line_6 $$ ExecutorService exec = Executors.newSingleThreadExecutor()[ CD ]
Line_2 $$ public void testRetryInterruptible() throws Throwable -->Line_4 $$ final CountDownLatch latch = new CountDownLatch(1)[ CD ]
Line_4 $$ final CountDownLatch latch = new CountDownLatch(1)-->Line_19 $$ latch.await()[ FD ]
Line_2 $$ public void testRetryInterruptible() throws Throwable -->Line_5 $$ final AtomicReference<Thread> futureThread = new AtomicReference<Thread>()[ CD ]
Line_7 $$ Future<Throwable> future = exec.submit(new Callable<Throwable>() -->Line_16 $$ return null[ CD ]
Line_5 $$ final AtomicReference<Thread> futureThread = new AtomicReference<Thread>()-->Line_21 $$ assertTrue(futureThread.get().isAlive())[ FD ]
