Line_8 $$ final CountDownLatch latch = new CountDownLatch(numberOfUpdates)-->Line_21 $$ latch.await()[ FD ]
Line_2 $$ public void testConcurrentOperationOnSameDoc() throws Exception -->Line_25 $$ Map masterSource = client().prepareGet("test", "type1", "1").execute().actionGet().getSourceAsMap()[ CD ]
Line_2 $$ public void testConcurrentOperationOnSameDoc() throws Exception -->Line_5 $$ logger.info("execute concurrent updates on the same doc")[ CD ]
Line_7 $$ final AtomicReference<Throwable> failure = new AtomicReference()-->Line_22 $$ assertThat(failure.get(), nullValue())[ FD ]
Line_8 $$ final CountDownLatch latch = new CountDownLatch(numberOfUpdates)-->Line_17 $$ latch.countDown()[ FD ]
Line_2 $$ public void testConcurrentOperationOnSameDoc() throws Exception -->Line_22 $$ assertThat(failure.get(), nullValue())[ CD ]
Line_2 $$ public void testConcurrentOperationOnSameDoc() throws Exception -->Line_4 $$ assertAcked(prepareCreate("test").setSettings(settingsBuilder().put(indexSettings()).put("index.number_of_shards", 1)))[ CD ]
Line_2 $$ public void testConcurrentOperationOnSameDoc() throws Exception -->Line_8 $$ final CountDownLatch latch = new CountDownLatch(numberOfUpdates)[ CD ]
Line_2 $$ public void testConcurrentOperationOnSameDoc() throws Exception -->Line_21 $$ latch.await()[ CD ]
Line_2 $$ public void testConcurrentOperationOnSameDoc() throws Exception -->Line_9 $$ for (int i = 0; i < numberOfUpdates; i++) [ CD ]
Line_8 $$ final CountDownLatch latch = new CountDownLatch(numberOfUpdates)-->Line_12 $$ latch.countDown()[ FD ]
Line_2 $$ public void testConcurrentOperationOnSameDoc() throws Exception -->Line_23 $$ client().admin().indices().prepareRefresh().execute().actionGet()[ CD ]
Line_10 $$ client().prepareIndex("test", "type1", "1").setSource("field1", i).execute(new ActionListener<IndexResponse>() -->Line_15 $$ e.printStackTrace()[ FD ]
Line_10 $$ client().prepareIndex("test", "type1", "1").setSource("field1", i).execute(new ActionListener<IndexResponse>() -->Line_17 $$ latch.countDown()[ CD ]
Line_9 $$ for (int i = 0; i < numberOfUpdates; i++) -->Line_10 $$ client().prepareIndex("test", "type1", "1").setSource("field1", i).execute(new ActionListener<IndexResponse>() [ CD ]
Line_9 $$ for (int i = 0; i < numberOfUpdates; i++) -->Line_10 $$ client().prepareIndex("test", "type1", "1").setSource("field1", i).execute(new ActionListener<IndexResponse>() [ FD ]
Line_10 $$ client().prepareIndex("test", "type1", "1").setSource("field1", i).execute(new ActionListener<IndexResponse>() -->Line_16 $$ failure.set(e)[ CD ]
Line_2 $$ public void testConcurrentOperationOnSameDoc() throws Exception -->Line_7 $$ final AtomicReference<Throwable> failure = new AtomicReference()[ CD ]
Line_2 $$ public void testConcurrentOperationOnSameDoc() throws Exception -->Line_26 $$ for (int i = 0; i < (cluster().size() * 5); i++) [ CD ]
Line_10 $$ client().prepareIndex("test", "type1", "1").setSource("field1", i).execute(new ActionListener<IndexResponse>() -->Line_16 $$ failure.set(e)[ FD ]
Line_9 $$ for (int i = 0; i < numberOfUpdates; i++) -->Line_26 $$ for (int i = 0; i < (cluster().size() * 5); i++) [ FD ]
Line_2 $$ public void testConcurrentOperationOnSameDoc() throws Exception -->Line_24 $$ logger.info("done indexing, check all have the same field value")[ CD ]
Line_10 $$ client().prepareIndex("test", "type1", "1").setSource("field1", i).execute(new ActionListener<IndexResponse>() -->Line_12 $$ latch.countDown()[ CD ]
Line_10 $$ client().prepareIndex("test", "type1", "1").setSource("field1", i).execute(new ActionListener<IndexResponse>() -->Line_15 $$ e.printStackTrace()[ CD ]
Line_26 $$ for (int i = 0; i < (cluster().size() * 5); i++) -->Line_27 $$ assertThat(client().prepareGet("test", "type1", "1").execute().actionGet().getSourceAsMap(), equalTo(masterSource))[ CD ]
Line_2 $$ public void testConcurrentOperationOnSameDoc() throws Exception -->Line_6 $$ int numberOfUpdates = 100[ CD ]
Line_7 $$ final AtomicReference<Throwable> failure = new AtomicReference()-->Line_16 $$ failure.set(e)[ FD ]
Line_6 $$ int numberOfUpdates = 100-->Line_9 $$ for (int i = 0; i < numberOfUpdates; i++) [ FD ]
