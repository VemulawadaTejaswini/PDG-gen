Line_19 $$ for (int i = 0; i < threads.length; i++) -->Line_27 $$ for (int i = 0; i < iters; i++) [ FD ]
Line_2 $$ public void testStressShardLock() throws IOException, InterruptedException -->Line_11 $$ for (int i = 0; i < counts.length; i++) [ CD ]
Line_11 $$ for (int i = 0; i < counts.length; i++) -->Line_46 $$ for (int i = 0; i < threads.length; i++) [ FD ]
Line_19 $$ for (int i = 0; i < threads.length; i++) -->Line_20 $$ threads[i] = new Thread() [ CD ]
Line_2 $$ public void testStressShardLock() throws IOException, InterruptedException -->Line_50 $$ for (int i = 0; i < counts.length; i++) [ CD ]
Line_6 $$ final NodeEnvironment env = newNodeEnvironment()-->Line_49 $$ assertTrue("LockedShards: " + env.lockedShards(), env.lockedShards().isEmpty())[ FD ]
Line_50 $$ for (int i = 0; i < counts.length; i++) -->Line_52 $$ assertEquals(flipFlop[i].get(), 0)[ CD ]
Line_2 $$ public void testStressShardLock() throws IOException, InterruptedException -->Line_8 $$ final Int[] counts = new Int[shards][ CD ]
Line_46 $$ for (int i = 0; i < threads.length; i++) -->Line_47 $$ threads[i].join()[ CD ]
Line_6 $$ final NodeEnvironment env = newNodeEnvironment()-->Line_55 $$ env.close()[ FD ]
Line_11 $$ for (int i = 0; i < counts.length; i++) -->Line_14 $$ flipFlop[i] = new AtomicInteger()[ CD ]
Line_19 $$ for (int i = 0; i < threads.length; i++) -->Line_43 $$ threads[i].start()[ CD ]
Line_2 $$ public void testStressShardLock() throws IOException, InterruptedException -->Line_45 $$ latch.countDown()[ CD ]
Line_18 $$ final int iters = scaledRandomIntBetween(10000, 100000)-->Line_27 $$ for (int i = 0; i < iters; i++) [ FD ]
Line_11 $$ for (int i = 0; i < counts.length; i++) -->Line_13 $$ countsAtomic[i] = new AtomicInteger()[ CD ]
Line_50 $$ for (int i = 0; i < counts.length; i++) -->Line_51 $$ assertTrue(counts[i].value > 0)[ CD ]
Line_20 $$ threads[i] = new Thread() -->Line_27 $$ for (int i = 0; i < iters; i++) [ CD ]
Line_11 $$ for (int i = 0; i < counts.length; i++) -->Line_12 $$ counts[i] = new Int()[ CD ]
Line_2 $$ public void testStressShardLock() throws IOException, InterruptedException -->Line_17 $$ final CountDownLatch latch = new CountDownLatch(1)[ CD ]
Line_2 $$ public void testStressShardLock() throws IOException, InterruptedException -->Line_55 $$ env.close()[ CD ]
Line_19 $$ for (int i = 0; i < threads.length; i++) -->Line_46 $$ for (int i = 0; i < threads.length; i++) [ FD ]
Line_27 $$ for (int i = 0; i < iters; i++) -->Line_46 $$ for (int i = 0; i < threads.length; i++) [ FD ]
Line_2 $$ public void testStressShardLock() throws IOException, InterruptedException -->Line_10 $$ final AtomicInteger[] flipFlop = new AtomicInteger[shards][ CD ]
Line_11 $$ for (int i = 0; i < counts.length; i++) -->Line_27 $$ for (int i = 0; i < iters; i++) [ FD ]
Line_19 $$ for (int i = 0; i < threads.length; i++) -->Line_50 $$ for (int i = 0; i < counts.length; i++) [ FD ]
Line_17 $$ final CountDownLatch latch = new CountDownLatch(1)-->Line_23 $$ latch.await()[ FD ]
Line_27 $$ for (int i = 0; i < iters; i++) -->Line_50 $$ for (int i = 0; i < counts.length; i++) [ FD ]
Line_6 $$ final NodeEnvironment env = newNodeEnvironment()-->Line_30 $$ try (ShardLock autoCloses = env.shardLock(new ShardId("foo", shard), scaledRandomIntBetween(0, 10))) [ FD ]
Line_2 $$ public void testStressShardLock() throws IOException, InterruptedException -->Line_19 $$ for (int i = 0; i < threads.length; i++) [ CD ]
Line_2 $$ public void testStressShardLock() throws IOException, InterruptedException -->Line_49 $$ assertTrue("LockedShards: " + env.lockedShards(), env.lockedShards().isEmpty())[ CD ]
Line_2 $$ public void testStressShardLock() throws IOException, InterruptedException -->Line_18 $$ final int iters = scaledRandomIntBetween(10000, 100000)[ CD ]
Line_11 $$ for (int i = 0; i < counts.length; i++) -->Line_19 $$ for (int i = 0; i < threads.length; i++) [ FD ]
Line_2 $$ public void testStressShardLock() throws IOException, InterruptedException -->Line_16 $$ Thread[] threads = new Thread[randomIntBetween(2, 5)][ CD ]
Line_17 $$ final CountDownLatch latch = new CountDownLatch(1)-->Line_45 $$ latch.countDown()[ FD ]
Line_11 $$ for (int i = 0; i < counts.length; i++) -->Line_50 $$ for (int i = 0; i < counts.length; i++) [ FD ]
Line_50 $$ for (int i = 0; i < counts.length; i++) -->Line_53 $$ assertEquals(counts[i].value, countsAtomic[i].get())[ CD ]
Line_27 $$ for (int i = 0; i < iters; i++) -->Line_28 $$ int shard = randomIntBetween(0, counts.length - 1)[ CD ]
Line_2 $$ public void testStressShardLock() throws IOException, InterruptedException -->Line_9 $$ final AtomicInteger[] countsAtomic = new AtomicInteger[shards][ CD ]
Line_2 $$ public void testStressShardLock() throws IOException, InterruptedException -->Line_7 $$ final int shards = randomIntBetween(2, 10)[ CD ]
Line_2 $$ public void testStressShardLock() throws IOException, InterruptedException -->Line_6 $$ final NodeEnvironment env = newNodeEnvironment()[ CD ]
Line_2 $$ public void testStressShardLock() throws IOException, InterruptedException -->Line_46 $$ for (int i = 0; i < threads.length; i++) [ CD ]
Line_46 $$ for (int i = 0; i < threads.length; i++) -->Line_50 $$ for (int i = 0; i < counts.length; i++) [ FD ]
