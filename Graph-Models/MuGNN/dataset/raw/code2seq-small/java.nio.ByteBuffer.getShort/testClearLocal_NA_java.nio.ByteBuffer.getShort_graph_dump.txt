Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_49 $$ assertEquals(Short.MIN_VALUE + 2, cleared.getShort(marked.position() + headerSizeLength + headerEltLength))[ FD ]
Line_14 $$ state = ContextState.allocate(0, 1, 0)-->Line_27 $$ state.writeGlobal(CounterId.fromInt(3), 3L, 3L)[ FD ]
Line_5 $$ ByteBuffer cleared-->Line_53 $$ assertEquals(1L, cleared.getLong(cleared.position() + headerLength + idLength + clockLength))[ FD ]
Line_14 $$ state = ContextState.allocate(0, 1, 0)-->Line_60 $$ state = ContextState.allocate(1, 0, 0)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_63 $$ marked = cc.markLocalToBeCleared(state.context)[ CD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_43 $$ assertEquals(3L, marked.getLong(marked.position() + headerLength + 2 * stepLength + idLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_58 $$ assertEquals(3L, cleared.getLong(cleared.position() + headerLength + 2 * stepLength + idLength))[ CD ]
Line_4 $$ ByteBuffer marked-->Line_45 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_4 $$ ByteBuffer marked-->Line_11 $$ assertSame(state.context, marked)[ FD ]
Line_14 $$ state = ContextState.allocate(0, 1, 0)-->Line_24 $$ state = ContextState.allocate(2, 1, 0)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_45 $$ cleared = cc.clearAllLocal(marked)[ CD ]
Line_2 $$ public void testClearLocal() -->Line_66 $$ cleared = cc.clearAllLocal(marked)[ CD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_34 $$ assertEquals(Short.MIN_VALUE + 2, marked.getShort(marked.position() + headerSizeLength + 2 * headerEltLength))[ FD ]
Line_6 $$ state = ContextState.allocate(0, 0, 1)-->Line_7 $$ state.writeRemote(CounterId.fromInt(1), 1L, 1L)[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_42 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(3), marked, headerLength + 2 * stepLength))[ FD ]
Line_3 $$ ContextState state-->Line_61 $$ state.writeGlobal(CounterId.fromInt(1), 1L, 1L)[ FD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_45 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_24 $$ state = ContextState.allocate(2, 1, 0)-->Line_61 $$ state.writeGlobal(CounterId.fromInt(1), 1L, 1L)[ FD ]
Line_6 $$ state = ContextState.allocate(0, 0, 1)-->Line_60 $$ state = ContextState.allocate(1, 0, 0)[ FD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_67 $$ assertSame(cleared, marked)[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_38 $$ assertEquals(1L, marked.getLong(marked.position() + headerLength + idLength + clockLength))[ FD ]
Line_45 $$ cleared = cc.clearAllLocal(marked)-->Line_59 $$ assertEquals(3L, cleared.getLong(cleared.position() + headerLength + 2 * stepLength + idLength + clockLength))[ FD ]
Line_5 $$ ByteBuffer cleared-->Line_21 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_5 $$ ByteBuffer cleared-->Line_46 $$ assertFalse(cc.shouldClearLocal(cleared))[ FD ]
Line_5 $$ ByteBuffer cleared-->Line_66 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_65 $$ assertSame(state.context, marked)[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_10 $$ assertEquals(0, marked.getShort(marked.position()))[ FD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_33 $$ assertEquals(Short.MIN_VALUE + 1, marked.getShort(marked.position() + headerSizeLength + headerEltLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_61 $$ state.writeGlobal(CounterId.fromInt(1), 1L, 1L)[ CD ]
Line_4 $$ ByteBuffer marked-->Line_37 $$ assertEquals(1L, marked.getLong(marked.position() + headerLength + idLength))[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_36 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(1), marked, headerLength))[ FD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_31 $$ assertEquals(-3, marked.getShort(marked.position()))[ FD ]
Line_5 $$ ByteBuffer cleared-->Line_23 $$ assertEquals(0, cleared.getShort(cleared.position()))[ FD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_48 $$ assertEquals(Short.MIN_VALUE + 1, cleared.getShort(marked.position() + headerEltLength))[ FD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_47 $$ assertEquals(2, cleared.getShort(cleared.position()))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_48 $$ assertEquals(Short.MIN_VALUE + 1, cleared.getShort(marked.position() + headerEltLength))[ CD ]
Line_5 $$ ByteBuffer cleared-->Line_67 $$ assertSame(cleared, marked)[ FD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_49 $$ assertEquals(Short.MIN_VALUE + 2, cleared.getShort(marked.position() + headerSizeLength + headerEltLength))[ FD ]
Line_24 $$ state = ContextState.allocate(2, 1, 0)-->Line_27 $$ state.writeGlobal(CounterId.fromInt(3), 3L, 3L)[ FD ]
Line_4 $$ ByteBuffer marked-->Line_33 $$ assertEquals(Short.MIN_VALUE + 1, marked.getShort(marked.position() + headerSizeLength + headerEltLength))[ FD ]
Line_5 $$ ByteBuffer cleared-->Line_22 $$ assertFalse(cc.shouldClearLocal(cleared))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_29 $$ marked = cc.markLocalToBeCleared(state.context)[ CD ]
Line_2 $$ public void testClearLocal() -->Line_20 $$ assertNotSame(state.context, marked)[ CD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_33 $$ assertEquals(Short.MIN_VALUE + 1, marked.getShort(marked.position() + headerSizeLength + headerEltLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_46 $$ assertFalse(cc.shouldClearLocal(cleared))[ CD ]
Line_2 $$ public void testClearLocal() -->Line_56 $$ assertEquals(2L, cleared.getLong(cleared.position() + headerLength + stepLength + idLength + clockLength))[ CD ]
Line_2 $$ public void testClearLocal() -->Line_44 $$ assertEquals(3L, marked.getLong(marked.position() + headerLength + 2 * stepLength + idLength + clockLength))[ CD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_12 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_30 $$ assertTrue(cc.shouldClearLocal(marked))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_43 $$ assertEquals(3L, marked.getLong(marked.position() + headerLength + 2 * stepLength + idLength))[ CD ]
Line_3 $$ ContextState state-->Line_14 $$ state = ContextState.allocate(0, 1, 0)[ FD ]
Line_3 $$ ContextState state-->Line_26 $$ state.writeGlobal(CounterId.fromInt(2), 2L, 2L)[ FD ]
Line_45 $$ cleared = cc.clearAllLocal(marked)-->Line_66 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_21 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_5 $$ ByteBuffer cleared-->Line_57 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(3), cleared, headerLength + 2 * stepLength))[ FD ]
Line_4 $$ ByteBuffer marked-->Line_29 $$ marked = cc.markLocalToBeCleared(state.context)[ FD ]
Line_45 $$ cleared = cc.clearAllLocal(marked)-->Line_57 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(3), cleared, headerLength + 2 * stepLength))[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_37 $$ assertEquals(1L, marked.getLong(marked.position() + headerLength + idLength))[ FD ]
Line_3 $$ ContextState state-->Line_6 $$ state = ContextState.allocate(0, 0, 1)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_13 $$ assertSame(cleared, marked)[ CD ]
Line_2 $$ public void testClearLocal() -->Line_40 $$ assertEquals(2L, marked.getLong(marked.position() + headerLength + stepLength + idLength))[ CD ]
Line_50 $$ headerLength = headerSizeLength + 2 * headerEltLength-->Line_51 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(1), cleared, headerLength))[ FD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_56 $$ assertEquals(2L, cleared.getLong(cleared.position() + headerLength + stepLength + idLength + clockLength))[ FD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_64 $$ assertEquals(1, marked.getShort(marked.position()))[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_18 $$ assertTrue(cc.shouldClearLocal(marked))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_52 $$ assertEquals(1L, cleared.getLong(cleared.position() + headerLength + idLength))[ CD ]
Line_21 $$ cleared = cc.clearAllLocal(marked)-->Line_52 $$ assertEquals(1L, cleared.getLong(cleared.position() + headerLength + idLength))[ FD ]
Line_63 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_66 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_6 $$ state = ContextState.allocate(0, 0, 1)-->Line_24 $$ state = ContextState.allocate(2, 1, 0)[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_32 $$ assertEquals(0, marked.getShort(marked.position() + headerSizeLength))[ FD ]
Line_5 $$ ByteBuffer cleared-->Line_13 $$ assertSame(cleared, marked)[ FD ]
Line_6 $$ state = ContextState.allocate(0, 0, 1)-->Line_27 $$ state.writeGlobal(CounterId.fromInt(3), 3L, 3L)[ FD ]
Line_6 $$ state = ContextState.allocate(0, 0, 1)-->Line_14 $$ state = ContextState.allocate(0, 1, 0)[ FD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_37 $$ assertEquals(1L, marked.getLong(marked.position() + headerLength + idLength))[ FD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_42 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(3), marked, headerLength + 2 * stepLength))[ FD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_52 $$ assertEquals(1L, cleared.getLong(cleared.position() + headerLength + idLength))[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_65 $$ assertSame(state.context, marked)[ FD ]
Line_4 $$ ByteBuffer marked-->Line_49 $$ assertEquals(Short.MIN_VALUE + 2, cleared.getShort(marked.position() + headerSizeLength + headerEltLength))[ FD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_66 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_54 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(2), cleared, headerLength + stepLength))[ CD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_54 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(2), cleared, headerLength + stepLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_3 $$ ContextState state[ CD ]
Line_4 $$ ByteBuffer marked-->Line_42 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(3), marked, headerLength + 2 * stepLength))[ FD ]
Line_4 $$ ByteBuffer marked-->Line_65 $$ assertSame(state.context, marked)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_35 $$ int headerLength = headerSizeLength + 3 * headerEltLength[ CD ]
Line_21 $$ cleared = cc.clearAllLocal(marked)-->Line_53 $$ assertEquals(1L, cleared.getLong(cleared.position() + headerLength + idLength + clockLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_49 $$ assertEquals(Short.MIN_VALUE + 2, cleared.getShort(marked.position() + headerSizeLength + headerEltLength))[ CD ]
Line_45 $$ cleared = cc.clearAllLocal(marked)-->Line_53 $$ assertEquals(1L, cleared.getLong(cleared.position() + headerLength + idLength + clockLength))[ FD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_23 $$ assertEquals(0, cleared.getShort(cleared.position()))[ FD ]
Line_21 $$ cleared = cc.clearAllLocal(marked)-->Line_51 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(1), cleared, headerLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_32 $$ assertEquals(0, marked.getShort(marked.position() + headerSizeLength))[ CD ]
Line_21 $$ cleared = cc.clearAllLocal(marked)-->Line_55 $$ assertEquals(2L, cleared.getLong(cleared.position() + headerLength + stepLength + idLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_64 $$ assertEquals(1, marked.getShort(marked.position()))[ CD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_32 $$ assertEquals(0, marked.getShort(marked.position() + headerSizeLength))[ FD ]
Line_45 $$ cleared = cc.clearAllLocal(marked)-->Line_51 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(1), cleared, headerLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_27 $$ state.writeGlobal(CounterId.fromInt(3), 3L, 3L)[ CD ]
Line_45 $$ cleared = cc.clearAllLocal(marked)-->Line_54 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(2), cleared, headerLength + stepLength))[ FD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_58 $$ assertEquals(3L, cleared.getLong(cleared.position() + headerLength + 2 * stepLength + idLength))[ FD ]
Line_21 $$ cleared = cc.clearAllLocal(marked)-->Line_46 $$ assertFalse(cc.shouldClearLocal(cleared))[ FD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_48 $$ assertEquals(Short.MIN_VALUE + 1, cleared.getShort(marked.position() + headerEltLength))[ FD ]
Line_6 $$ state = ContextState.allocate(0, 0, 1)-->Line_61 $$ state.writeGlobal(CounterId.fromInt(1), 1L, 1L)[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_63 $$ marked = cc.markLocalToBeCleared(state.context)[ FD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_45 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_39 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(2), marked, headerLength + stepLength))[ CD ]
Line_2 $$ public void testClearLocal() -->Line_15 $$ state.writeLocal(CounterId.fromInt(1), 1L, 1L)[ CD ]
Line_4 $$ ByteBuffer marked-->Line_43 $$ assertEquals(3L, marked.getLong(marked.position() + headerLength + 2 * stepLength + idLength))[ FD ]
Line_21 $$ cleared = cc.clearAllLocal(marked)-->Line_22 $$ assertFalse(cc.shouldClearLocal(cleared))[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_66 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_66 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_33 $$ assertEquals(Short.MIN_VALUE + 1, marked.getShort(marked.position() + headerSizeLength + headerEltLength))[ CD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_39 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(2), marked, headerLength + stepLength))[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_44 $$ assertEquals(3L, marked.getLong(marked.position() + headerLength + 2 * stepLength + idLength + clockLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_12 $$ cleared = cc.clearAllLocal(marked)[ CD ]
Line_35 $$ int headerLength = headerSizeLength + 3 * headerEltLength-->Line_36 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(1), marked, headerLength))[ FD ]
Line_4 $$ ByteBuffer marked-->Line_30 $$ assertTrue(cc.shouldClearLocal(marked))[ FD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_48 $$ assertEquals(Short.MIN_VALUE + 1, cleared.getShort(marked.position() + headerEltLength))[ FD ]
Line_5 $$ ByteBuffer cleared-->Line_55 $$ assertEquals(2L, cleared.getLong(cleared.position() + headerLength + stepLength + idLength))[ FD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_59 $$ assertEquals(3L, cleared.getLong(cleared.position() + headerLength + 2 * stepLength + idLength + clockLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_67 $$ assertSame(cleared, marked)[ CD ]
Line_2 $$ public void testClearLocal() -->Line_26 $$ state.writeGlobal(CounterId.fromInt(2), 2L, 2L)[ CD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_67 $$ assertSame(cleared, marked)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_57 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(3), cleared, headerLength + 2 * stepLength))[ CD ]
Line_45 $$ cleared = cc.clearAllLocal(marked)-->Line_49 $$ assertEquals(Short.MIN_VALUE + 2, cleared.getShort(marked.position() + headerSizeLength + headerEltLength))[ FD ]
Line_4 $$ ByteBuffer marked-->Line_66 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_23 $$ assertEquals(0, cleared.getShort(cleared.position()))[ CD ]
Line_21 $$ cleared = cc.clearAllLocal(marked)-->Line_57 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(3), cleared, headerLength + 2 * stepLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_25 $$ state.writeLocal(CounterId.fromInt(1), 1L, 1L)[ CD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_44 $$ assertEquals(3L, marked.getLong(marked.position() + headerLength + 2 * stepLength + idLength + clockLength))[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_17 $$ marked = cc.markLocalToBeCleared(state.context)[ FD ]
Line_6 $$ state = ContextState.allocate(0, 0, 1)-->Line_26 $$ state.writeGlobal(CounterId.fromInt(2), 2L, 2L)[ FD ]
Line_45 $$ cleared = cc.clearAllLocal(marked)-->Line_46 $$ assertFalse(cc.shouldClearLocal(cleared))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_30 $$ assertTrue(cc.shouldClearLocal(marked))[ CD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_67 $$ assertSame(cleared, marked)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_14 $$ state = ContextState.allocate(0, 1, 0)[ CD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_29 $$ marked = cc.markLocalToBeCleared(state.context)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_24 $$ state = ContextState.allocate(2, 1, 0)[ CD ]
Line_21 $$ cleared = cc.clearAllLocal(marked)-->Line_66 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_45 $$ cleared = cc.clearAllLocal(marked)-->Line_58 $$ assertEquals(3L, cleared.getLong(cleared.position() + headerLength + 2 * stepLength + idLength))[ FD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_31 $$ assertEquals(-3, marked.getShort(marked.position()))[ FD ]
Line_4 $$ ByteBuffer marked-->Line_41 $$ assertEquals(2L, marked.getLong(marked.position() + headerLength + stepLength + idLength + clockLength))[ FD ]
Line_4 $$ ByteBuffer marked-->Line_38 $$ assertEquals(1L, marked.getLong(marked.position() + headerLength + idLength + clockLength))[ FD ]
Line_21 $$ cleared = cc.clearAllLocal(marked)-->Line_49 $$ assertEquals(Short.MIN_VALUE + 2, cleared.getShort(marked.position() + headerSizeLength + headerEltLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_47 $$ assertEquals(2, cleared.getShort(cleared.position()))[ CD ]
Line_2 $$ public void testClearLocal() -->Line_59 $$ assertEquals(3L, cleared.getLong(cleared.position() + headerLength + 2 * stepLength + idLength + clockLength))[ CD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_53 $$ assertEquals(1L, cleared.getLong(cleared.position() + headerLength + idLength + clockLength))[ FD ]
Line_3 $$ ContextState state-->Line_60 $$ state = ContextState.allocate(1, 0, 0)[ FD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_13 $$ assertSame(cleared, marked)[ FD ]
Line_5 $$ ByteBuffer cleared-->Line_56 $$ assertEquals(2L, cleared.getLong(cleared.position() + headerLength + stepLength + idLength + clockLength))[ FD ]
Line_4 $$ ByteBuffer marked-->Line_10 $$ assertEquals(0, marked.getShort(marked.position()))[ FD ]
Line_35 $$ int headerLength = headerSizeLength + 3 * headerEltLength-->Line_51 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(1), cleared, headerLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_41 $$ assertEquals(2L, marked.getLong(marked.position() + headerLength + stepLength + idLength + clockLength))[ CD ]
Line_21 $$ cleared = cc.clearAllLocal(marked)-->Line_59 $$ assertEquals(3L, cleared.getLong(cleared.position() + headerLength + 2 * stepLength + idLength + clockLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_10 $$ assertEquals(0, marked.getShort(marked.position()))[ CD ]
Line_2 $$ public void testClearLocal() -->Line_50 $$ headerLength = headerSizeLength + 2 * headerEltLength[ CD ]
Line_2 $$ public void testClearLocal() -->Line_55 $$ assertEquals(2L, cleared.getLong(cleared.position() + headerLength + stepLength + idLength))[ CD ]
Line_14 $$ state = ContextState.allocate(0, 1, 0)-->Line_25 $$ state.writeLocal(CounterId.fromInt(1), 1L, 1L)[ FD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_33 $$ assertEquals(Short.MIN_VALUE + 1, marked.getShort(marked.position() + headerSizeLength + headerEltLength))[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_49 $$ assertEquals(Short.MIN_VALUE + 2, cleared.getShort(marked.position() + headerSizeLength + headerEltLength))[ FD ]
Line_21 $$ cleared = cc.clearAllLocal(marked)-->Line_58 $$ assertEquals(3L, cleared.getLong(cleared.position() + headerLength + 2 * stepLength + idLength))[ FD ]
Line_4 $$ ByteBuffer marked-->Line_44 $$ assertEquals(3L, marked.getLong(marked.position() + headerLength + 2 * stepLength + idLength + clockLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_11 $$ assertSame(state.context, marked)[ CD ]
Line_3 $$ ContextState state-->Line_27 $$ state.writeGlobal(CounterId.fromInt(3), 3L, 3L)[ FD ]
Line_35 $$ int headerLength = headerSizeLength + 3 * headerEltLength-->Line_50 $$ headerLength = headerSizeLength + 2 * headerEltLength[ FD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_37 $$ assertEquals(1L, marked.getLong(marked.position() + headerLength + idLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_5 $$ ByteBuffer cleared[ CD ]
Line_45 $$ cleared = cc.clearAllLocal(marked)-->Line_52 $$ assertEquals(1L, cleared.getLong(cleared.position() + headerLength + idLength))[ FD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_55 $$ assertEquals(2L, cleared.getLong(cleared.position() + headerLength + stepLength + idLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_65 $$ assertSame(state.context, marked)[ CD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_57 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(3), cleared, headerLength + 2 * stepLength))[ FD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_36 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(1), marked, headerLength))[ FD ]
Line_21 $$ cleared = cc.clearAllLocal(marked)-->Line_48 $$ assertEquals(Short.MIN_VALUE + 1, cleared.getShort(marked.position() + headerEltLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_53 $$ assertEquals(1L, cleared.getLong(cleared.position() + headerLength + idLength + clockLength))[ CD ]
Line_3 $$ ContextState state-->Line_15 $$ state.writeLocal(CounterId.fromInt(1), 1L, 1L)[ FD ]
Line_5 $$ ByteBuffer cleared-->Line_54 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(2), cleared, headerLength + stepLength))[ FD ]
Line_4 $$ ByteBuffer marked-->Line_20 $$ assertNotSame(state.context, marked)[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_20 $$ assertNotSame(state.context, marked)[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_19 $$ assertEquals(-1, marked.getShort(marked.position()))[ FD ]
Line_3 $$ ContextState state-->Line_24 $$ state = ContextState.allocate(2, 1, 0)[ FD ]
Line_4 $$ ByteBuffer marked-->Line_36 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(1), marked, headerLength))[ FD ]
Line_21 $$ cleared = cc.clearAllLocal(marked)-->Line_47 $$ assertEquals(2, cleared.getShort(cleared.position()))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_62 $$ assertFalse(cc.shouldClearLocal(state.context))[ CD ]
Line_4 $$ ByteBuffer marked-->Line_34 $$ assertEquals(Short.MIN_VALUE + 2, marked.getShort(marked.position() + headerSizeLength + 2 * headerEltLength))[ FD ]
Line_6 $$ state = ContextState.allocate(0, 0, 1)-->Line_25 $$ state.writeLocal(CounterId.fromInt(1), 1L, 1L)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_42 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(3), marked, headerLength + 2 * stepLength))[ CD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_41 $$ assertEquals(2L, marked.getLong(marked.position() + headerLength + stepLength + idLength + clockLength))[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_40 $$ assertEquals(2L, marked.getLong(marked.position() + headerLength + stepLength + idLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_18 $$ assertTrue(cc.shouldClearLocal(marked))[ CD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_34 $$ assertEquals(Short.MIN_VALUE + 2, marked.getShort(marked.position() + headerSizeLength + 2 * headerEltLength))[ FD ]
Line_5 $$ ByteBuffer cleared-->Line_52 $$ assertEquals(1L, cleared.getLong(cleared.position() + headerLength + idLength))[ FD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_41 $$ assertEquals(2L, marked.getLong(marked.position() + headerLength + stepLength + idLength + clockLength))[ FD ]
Line_4 $$ ByteBuffer marked-->Line_31 $$ assertEquals(-3, marked.getShort(marked.position()))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_60 $$ state = ContextState.allocate(1, 0, 0)[ CD ]
Line_2 $$ public void testClearLocal() -->Line_37 $$ assertEquals(1L, marked.getLong(marked.position() + headerLength + idLength))[ CD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_64 $$ assertEquals(1, marked.getShort(marked.position()))[ FD ]
Line_63 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_64 $$ assertEquals(1, marked.getShort(marked.position()))[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_45 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_21 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_51 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(1), cleared, headerLength))[ CD ]
Line_2 $$ public void testClearLocal() -->Line_17 $$ marked = cc.markLocalToBeCleared(state.context)[ CD ]
Line_3 $$ ContextState state-->Line_7 $$ state.writeRemote(CounterId.fromInt(1), 1L, 1L)[ FD ]
Line_45 $$ cleared = cc.clearAllLocal(marked)-->Line_67 $$ assertSame(cleared, marked)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_36 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(1), marked, headerLength))[ CD ]
Line_6 $$ state = ContextState.allocate(0, 0, 1)-->Line_15 $$ state.writeLocal(CounterId.fromInt(1), 1L, 1L)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_21 $$ cleared = cc.clearAllLocal(marked)[ CD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_63 $$ marked = cc.markLocalToBeCleared(state.context)[ FD ]
Line_4 $$ ByteBuffer marked-->Line_21 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_4 $$ ByteBuffer marked-->Line_39 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(2), marked, headerLength + stepLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_8 $$ assertFalse(cc.shouldClearLocal(state.context))[ CD ]
Line_4 $$ ByteBuffer marked-->Line_13 $$ assertSame(cleared, marked)[ FD ]
Line_21 $$ cleared = cc.clearAllLocal(marked)-->Line_56 $$ assertEquals(2L, cleared.getLong(cleared.position() + headerLength + stepLength + idLength + clockLength))[ FD ]
Line_4 $$ ByteBuffer marked-->Line_19 $$ assertEquals(-1, marked.getShort(marked.position()))[ FD ]
Line_4 $$ ByteBuffer marked-->Line_64 $$ assertEquals(1, marked.getShort(marked.position()))[ FD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_65 $$ assertSame(state.context, marked)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_9 $$ marked = cc.markLocalToBeCleared(state.context)[ CD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_22 $$ assertFalse(cc.shouldClearLocal(cleared))[ FD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_46 $$ assertFalse(cc.shouldClearLocal(cleared))[ FD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_20 $$ assertNotSame(state.context, marked)[ FD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_67 $$ assertSame(cleared, marked)[ FD ]
Line_14 $$ state = ContextState.allocate(0, 1, 0)-->Line_26 $$ state.writeGlobal(CounterId.fromInt(2), 2L, 2L)[ FD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_21 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_60 $$ state = ContextState.allocate(1, 0, 0)-->Line_61 $$ state.writeGlobal(CounterId.fromInt(1), 1L, 1L)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_6 $$ state = ContextState.allocate(0, 0, 1)[ CD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_34 $$ assertEquals(Short.MIN_VALUE + 2, marked.getShort(marked.position() + headerSizeLength + 2 * headerEltLength))[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_64 $$ assertEquals(1, marked.getShort(marked.position()))[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_13 $$ assertSame(cleared, marked)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_16 $$ assertFalse(cc.shouldClearLocal(state.context))[ CD ]
Line_5 $$ ByteBuffer cleared-->Line_51 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(1), cleared, headerLength))[ FD ]
Line_21 $$ cleared = cc.clearAllLocal(marked)-->Line_54 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(2), cleared, headerLength + stepLength))[ FD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_44 $$ assertEquals(3L, marked.getLong(marked.position() + headerLength + 2 * stepLength + idLength + clockLength))[ FD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_18 $$ assertTrue(cc.shouldClearLocal(marked))[ FD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_43 $$ assertEquals(3L, marked.getLong(marked.position() + headerLength + 2 * stepLength + idLength))[ FD ]
Line_5 $$ ByteBuffer cleared-->Line_48 $$ assertEquals(Short.MIN_VALUE + 1, cleared.getShort(marked.position() + headerEltLength))[ FD ]
Line_14 $$ state = ContextState.allocate(0, 1, 0)-->Line_15 $$ state.writeLocal(CounterId.fromInt(1), 1L, 1L)[ FD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_32 $$ assertEquals(0, marked.getShort(marked.position() + headerSizeLength))[ FD ]
Line_4 $$ ByteBuffer marked-->Line_67 $$ assertSame(cleared, marked)[ FD ]
Line_21 $$ cleared = cc.clearAllLocal(marked)-->Line_23 $$ assertEquals(0, cleared.getShort(cleared.position()))[ FD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_36 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(1), marked, headerLength))[ FD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_63 $$ marked = cc.markLocalToBeCleared(state.context)[ FD ]
Line_5 $$ ByteBuffer cleared-->Line_49 $$ assertEquals(Short.MIN_VALUE + 2, cleared.getShort(marked.position() + headerSizeLength + headerEltLength))[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_31 $$ assertEquals(-3, marked.getShort(marked.position()))[ FD ]
Line_21 $$ cleared = cc.clearAllLocal(marked)-->Line_45 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_24 $$ state = ContextState.allocate(2, 1, 0)-->Line_60 $$ state = ContextState.allocate(1, 0, 0)[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_43 $$ assertEquals(3L, marked.getLong(marked.position() + headerLength + 2 * stepLength + idLength))[ FD ]
Line_45 $$ cleared = cc.clearAllLocal(marked)-->Line_55 $$ assertEquals(2L, cleared.getLong(cleared.position() + headerLength + stepLength + idLength))[ FD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_49 $$ assertEquals(Short.MIN_VALUE + 2, cleared.getShort(marked.position() + headerSizeLength + headerEltLength))[ FD ]
Line_24 $$ state = ContextState.allocate(2, 1, 0)-->Line_26 $$ state.writeGlobal(CounterId.fromInt(2), 2L, 2L)[ FD ]
Line_45 $$ cleared = cc.clearAllLocal(marked)-->Line_56 $$ assertEquals(2L, cleared.getLong(cleared.position() + headerLength + stepLength + idLength + clockLength))[ FD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_38 $$ assertEquals(1L, marked.getLong(marked.position() + headerLength + idLength + clockLength))[ FD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_45 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_19 $$ assertEquals(-1, marked.getShort(marked.position()))[ FD ]
Line_5 $$ ByteBuffer cleared-->Line_47 $$ assertEquals(2, cleared.getShort(cleared.position()))[ FD ]
Line_4 $$ ByteBuffer marked-->Line_12 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_4 $$ ByteBuffer marked-->Line_48 $$ assertEquals(Short.MIN_VALUE + 1, cleared.getShort(marked.position() + headerEltLength))[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_39 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(2), marked, headerLength + stepLength))[ FD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_40 $$ assertEquals(2L, marked.getLong(marked.position() + headerLength + stepLength + idLength))[ FD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_42 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(3), marked, headerLength + 2 * stepLength))[ FD ]
Line_5 $$ ByteBuffer cleared-->Line_58 $$ assertEquals(3L, cleared.getLong(cleared.position() + headerLength + 2 * stepLength + idLength))[ FD ]
Line_24 $$ state = ContextState.allocate(2, 1, 0)-->Line_25 $$ state.writeLocal(CounterId.fromInt(1), 1L, 1L)[ FD ]
Line_4 $$ ByteBuffer marked-->Line_63 $$ marked = cc.markLocalToBeCleared(state.context)[ FD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_66 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_3 $$ ContextState state-->Line_25 $$ state.writeLocal(CounterId.fromInt(1), 1L, 1L)[ FD ]
Line_63 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_67 $$ assertSame(cleared, marked)[ FD ]
Line_66 $$ cleared = cc.clearAllLocal(marked)-->Line_67 $$ assertSame(cleared, marked)[ FD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_30 $$ assertTrue(cc.shouldClearLocal(marked))[ FD ]
Line_14 $$ state = ContextState.allocate(0, 1, 0)-->Line_61 $$ state.writeGlobal(CounterId.fromInt(1), 1L, 1L)[ FD ]
Line_12 $$ cleared = cc.clearAllLocal(marked)-->Line_51 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(1), cleared, headerLength))[ FD ]
Line_29 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_39 $$ assertTrue(Util.equalsCounterId(CounterId.fromInt(2), marked, headerLength + stepLength))[ FD ]
Line_21 $$ cleared = cc.clearAllLocal(marked)-->Line_67 $$ assertSame(cleared, marked)[ FD ]
Line_4 $$ ByteBuffer marked-->Line_18 $$ assertTrue(cc.shouldClearLocal(marked))[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_29 $$ marked = cc.markLocalToBeCleared(state.context)[ FD ]
Line_4 $$ ByteBuffer marked-->Line_32 $$ assertEquals(0, marked.getShort(marked.position() + headerSizeLength))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_34 $$ assertEquals(Short.MIN_VALUE + 2, marked.getShort(marked.position() + headerSizeLength + 2 * headerEltLength))[ CD ]
Line_2 $$ public void testClearLocal() -->Line_4 $$ ByteBuffer marked[ CD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_48 $$ assertEquals(Short.MIN_VALUE + 1, cleared.getShort(marked.position() + headerEltLength))[ FD ]
Line_4 $$ ByteBuffer marked-->Line_40 $$ assertEquals(2L, marked.getLong(marked.position() + headerLength + stepLength + idLength))[ FD ]
Line_45 $$ cleared = cc.clearAllLocal(marked)-->Line_47 $$ assertEquals(2, cleared.getShort(cleared.position()))[ FD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_38 $$ assertEquals(1L, marked.getLong(marked.position() + headerLength + idLength + clockLength))[ FD ]
Line_45 $$ cleared = cc.clearAllLocal(marked)-->Line_48 $$ assertEquals(Short.MIN_VALUE + 1, cleared.getShort(marked.position() + headerEltLength))[ FD ]
Line_63 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_65 $$ assertSame(state.context, marked)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_7 $$ state.writeRemote(CounterId.fromInt(1), 1L, 1L)[ CD ]
Line_5 $$ ByteBuffer cleared-->Line_12 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_38 $$ assertEquals(1L, marked.getLong(marked.position() + headerLength + idLength + clockLength))[ CD ]
Line_4 $$ ByteBuffer marked-->Line_17 $$ marked = cc.markLocalToBeCleared(state.context)[ FD ]
Line_5 $$ ByteBuffer cleared-->Line_45 $$ cleared = cc.clearAllLocal(marked)[ FD ]
Line_4 $$ ByteBuffer marked-->Line_9 $$ marked = cc.markLocalToBeCleared(state.context)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_28 $$ assertFalse(cc.shouldClearLocal(state.context))[ CD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_40 $$ assertEquals(2L, marked.getLong(marked.position() + headerLength + stepLength + idLength))[ FD ]
Line_5 $$ ByteBuffer cleared-->Line_59 $$ assertEquals(3L, cleared.getLong(cleared.position() + headerLength + 2 * stepLength + idLength + clockLength))[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_41 $$ assertEquals(2L, marked.getLong(marked.position() + headerLength + stepLength + idLength + clockLength))[ FD ]
Line_9 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_11 $$ assertSame(state.context, marked)[ FD ]
Line_2 $$ public void testClearLocal() -->Line_31 $$ assertEquals(-3, marked.getShort(marked.position()))[ CD ]
Line_17 $$ marked = cc.markLocalToBeCleared(state.context)-->Line_30 $$ assertTrue(cc.shouldClearLocal(marked))[ FD ]
Line_2 $$ public void testClearLocal() -->Line_22 $$ assertFalse(cc.shouldClearLocal(cleared))[ CD ]
Line_2 $$ public void testClearLocal() -->Line_19 $$ assertEquals(-1, marked.getShort(marked.position()))[ CD ]
