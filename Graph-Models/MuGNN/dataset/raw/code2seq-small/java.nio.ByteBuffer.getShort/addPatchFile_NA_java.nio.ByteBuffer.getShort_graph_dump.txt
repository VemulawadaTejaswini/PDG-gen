Line_56 $$ byte[] tempBuf = new byte[0xffff]-->Line_69 $$ directoryMap.get(tempBuf, 0, fileNameLen)[ FD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_6 $$ if (fileLength < kEOCDLen) [ CD ]
Line_4 $$ RandomAccessFile f = new RandomAccessFile(file, "r")-->Line_54 $$ MappedByteBuffer directoryMap = f.getChannel().map(FileChannel.MapMode.READ_ONLY, dirOffset, dirSize)[ FD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_77 $$ ze.mWhenModified = directoryMap.getInt(currentOffset + kCDEModWhen) & 0xffffffffL[ CD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_66 $$ int extraLen = directoryMap.getShort(currentOffset + kCDEExtraLen) & 0xffff[ CD ]
Line_42 $$ long dirOffset = bbuf.getInt(eocdIdx + kEOCDFileOffset) & 0xffffffffL-->Line_54 $$ MappedByteBuffer directoryMap = f.getChannel().map(FileChannel.MapMode.READ_ONLY, dirOffset, dirSize)[ FD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_75 $$ ZipEntryRO ze = new ZipEntryRO(zipFileName, file, str)[ CD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_79 $$ ze.mCompressedLength = directoryMap.getLong(currentOffset + kCDECompLen) & 0xffffffffL[ CD ]
Line_11 $$ if (readAmount > fileLength)-->Line_12 $$ readAmount = fileLength[ CD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_80 $$ ze.mUncompressedLength = directoryMap.getLong(currentOffset + kCDEUncompLen) & 0xffffffffL[ CD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_59 $$ buf.order(ByteOrder.LITTLE_ENDIAN)[ CD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_61 $$ if (directoryMap.getInt(currentOffset) != kCDESignature) [ CD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_55 $$ directoryMap.order(ByteOrder.LITTLE_ENDIAN)[ CD ]
Line_5 $$ long fileLength = f.length()-->Line_6 $$ if (fileLength < kEOCDLen) [ FD ]
Line_54 $$ MappedByteBuffer directoryMap = f.getChannel().map(FileChannel.MapMode.READ_ONLY, dirOffset, dirSize)-->Line_66 $$ int extraLen = directoryMap.getShort(currentOffset + kCDEExtraLen) & 0xffff[ FD ]
Line_54 $$ MappedByteBuffer directoryMap = f.getChannel().map(FileChannel.MapMode.READ_ONLY, dirOffset, dirSize)-->Line_67 $$ int commentLen = directoryMap.getShort(currentOffset + kCDECommentLen) & 0xffff[ FD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_60 $$ for (int i = 0; i < numEntries; i++) [ CD ]
Line_47 $$ if (numEntries == 0) -->Line_48 $$ Log.w(LOG_TAG, "empty archive?")[ CD ]
Line_15 $$ if (header == kEOCDSignature) -->Line_16 $$ Log.i(LOG_TAG, "Found Zip archive, but it looks empty")[ CD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_76 $$ ze.mMethod = directoryMap.getShort(currentOffset + kCDEMethod) & 0xffff[ CD ]
Line_75 $$ ZipEntryRO ze = new ZipEntryRO(zipFileName, file, str)-->Line_83 $$ ze.setOffsetFromFile(f, buf)[ FD ]
Line_54 $$ MappedByteBuffer directoryMap = f.getChannel().map(FileChannel.MapMode.READ_ONLY, dirOffset, dirSize)-->Line_81 $$ ze.mLocalHdrOffset = directoryMap.getInt(currentOffset + kCDELocalOffset) & 0xffffffffL[ FD ]
Line_4 $$ RandomAccessFile f = new RandomAccessFile(file, "r")-->Line_5 $$ long fileLength = f.length()[ FD ]
Line_51 $$ if (LOGV) -->Line_52 $$ Log.v(LOG_TAG, "+++ numEntries=" + numEntries + " dirSize=" + dirSize + " dirOffset=" + dirOffset)[ CD ]
Line_54 $$ MappedByteBuffer directoryMap = f.getChannel().map(FileChannel.MapMode.READ_ONLY, dirOffset, dirSize)-->Line_78 $$ ze.mCRC32 = directoryMap.getLong(currentOffset + kCDECRC) & 0xffffffffL[ FD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_24 $$ ByteBuffer bbuf = ByteBuffer.allocate((int) readAmount)[ CD ]
Line_54 $$ MappedByteBuffer directoryMap = f.getChannel().map(FileChannel.MapMode.READ_ONLY, dirOffset, dirSize)-->Line_65 $$ int fileNameLen = directoryMap.getShort(currentOffset + kCDENameLen) & 0xffff[ FD ]
Line_54 $$ MappedByteBuffer directoryMap = f.getChannel().map(FileChannel.MapMode.READ_ONLY, dirOffset, dirSize)-->Line_55 $$ directoryMap.order(ByteOrder.LITTLE_ENDIAN)[ FD ]
Line_29 $$ for (eocdIdx = buffer.length - kEOCDLen; eocdIdx >= 0; eocdIdx--) -->Line_30 $$ if (buffer[eocdIdx] == 0x50 && bbuf.getInt(eocdIdx) == kEOCDSignature) [ CD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_23 $$ f.seek(searchStart)[ CD ]
Line_61 $$ if (directoryMap.getInt(currentOffset) != kCDESignature) -->Line_62 $$ Log.w(LOG_TAG, "Missed a central dir sig (at " + currentOffset + ")")[ CD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_51 $$ if (LOGV) [ CD ]
Line_31 $$ if (LOGV) -->Line_32 $$ Log.v(LOG_TAG, "+++ Found EOCD at index: " + eocdIdx)[ CD ]
Line_24 $$ ByteBuffer bbuf = ByteBuffer.allocate((int) readAmount)-->Line_41 $$ long dirSize = bbuf.getInt(eocdIdx + kEOCDSize) & 0xffffffffL[ FD ]
Line_54 $$ MappedByteBuffer directoryMap = f.getChannel().map(FileChannel.MapMode.READ_ONLY, dirOffset, dirSize)-->Line_76 $$ ze.mMethod = directoryMap.getShort(currentOffset + kCDEMethod) & 0xffff[ FD ]
Line_29 $$ for (eocdIdx = buffer.length - kEOCDLen; eocdIdx >= 0; eocdIdx--) -->Line_30 $$ if (buffer[eocdIdx] == 0x50 && bbuf.getInt(eocdIdx) == kEOCDSignature) [ FD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_83 $$ ze.setOffsetFromFile(f, buf)[ CD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_68 $$ directoryMap.position(currentOffset + kCDELen)[ CD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_47 $$ if (numEntries == 0) [ CD ]
Line_87 $$ if (LOGV) -->Line_88 $$ Log.v(LOG_TAG, "+++ zip good scan " + numEntries + " entries")[ CD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_78 $$ ze.mCRC32 = directoryMap.getLong(currentOffset + kCDECRC) & 0xffffffffL[ CD ]
Line_58 $$ ByteBuffer buf = ByteBuffer.allocate(kLFHLen)-->Line_83 $$ ze.setOffsetFromFile(f, buf)[ FD ]
Line_40 $$ int numEntries = bbuf.getShort(eocdIdx + kEOCDNumEntries)-->Line_60 $$ for (int i = 0; i < numEntries; i++) [ FD ]
Line_10 $$ long readAmount = kMaxEOCDSearch-->Line_11 $$ if (readAmount > fileLength)[ FD ]
Line_75 $$ ZipEntryRO ze = new ZipEntryRO(zipFileName, file, str)-->Line_84 $$ mHashMap.put(str, ze)[ FD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_57 $$ int currentOffset = 0[ CD ]
Line_58 $$ ByteBuffer buf = ByteBuffer.allocate(kLFHLen)-->Line_59 $$ buf.order(ByteOrder.LITTLE_ENDIAN)[ FD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_5 $$ long fileLength = f.length()[ CD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_13 $$ f.seek(0)[ CD ]
Line_5 $$ long fileLength = f.length()-->Line_43 $$ if (dirOffset + dirSize > fileLength) [ FD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_67 $$ int commentLen = directoryMap.getShort(currentOffset + kCDECommentLen) & 0xffff[ CD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_10 $$ long readAmount = kMaxEOCDSearch[ CD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_85 $$ currentOffset += kCDELen + fileNameLen + extraLen + commentLen[ CD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_54 $$ MappedByteBuffer directoryMap = f.getChannel().map(FileChannel.MapMode.READ_ONLY, dirOffset, dirSize)[ CD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_82 $$ buf.clear()[ CD ]
Line_71 $$ String str = new String(tempBuf, 0, fileNameLen)-->Line_84 $$ mHashMap.put(str, ze)[ FD ]
Line_15 $$ if (header == kEOCDSignature) -->Line_18 $$ if (header != kLFHSignature) [ CD ]
Line_65 $$ int fileNameLen = directoryMap.getShort(currentOffset + kCDENameLen) & 0xffff-->Line_69 $$ directoryMap.get(tempBuf, 0, fileNameLen)[ FD ]
Line_54 $$ MappedByteBuffer directoryMap = f.getChannel().map(FileChannel.MapMode.READ_ONLY, dirOffset, dirSize)-->Line_77 $$ ze.mWhenModified = directoryMap.getInt(currentOffset + kCDEModWhen) & 0xffffffffL[ FD ]
Line_54 $$ MappedByteBuffer directoryMap = f.getChannel().map(FileChannel.MapMode.READ_ONLY, dirOffset, dirSize)-->Line_70 $$ directoryMap.position(0)[ FD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_84 $$ mHashMap.put(str, ze)[ CD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_70 $$ directoryMap.position(0)[ CD ]
Line_37 $$ if (eocdIdx < 0) -->Line_38 $$ Log.d(LOG_TAG, "Zip: EOCD not found, " + zipFileName + " is not zip")[ CD ]
Line_24 $$ ByteBuffer bbuf = ByteBuffer.allocate((int) readAmount)-->Line_25 $$ byte[] buffer = bbuf.array()[ FD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_58 $$ ByteBuffer buf = ByteBuffer.allocate(kLFHLen)[ CD ]
Line_28 $$ int eocdIdx-->Line_37 $$ if (eocdIdx < 0) [ FD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_71 $$ String str = new String(tempBuf, 0, fileNameLen)[ CD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_41 $$ long dirSize = bbuf.getInt(eocdIdx + kEOCDSize) & 0xffffffffL[ CD ]
Line_67 $$ int commentLen = directoryMap.getShort(currentOffset + kCDECommentLen) & 0xffff-->Line_85 $$ currentOffset += kCDELen + fileNameLen + extraLen + commentLen[ FD ]
Line_58 $$ ByteBuffer buf = ByteBuffer.allocate(kLFHLen)-->Line_82 $$ buf.clear()[ FD ]
Line_10 $$ long readAmount = kMaxEOCDSearch-->Line_12 $$ readAmount = fileLength[ FD ]
Line_72 $$ if (LOGV) -->Line_73 $$ Log.v(LOG_TAG, "Filename: " + str)[ CD ]
Line_29 $$ for (eocdIdx = buffer.length - kEOCDLen; eocdIdx >= 0; eocdIdx--) -->Line_37 $$ if (eocdIdx < 0) [ FD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_56 $$ byte[] tempBuf = new byte[0xffff][ CD ]
Line_4 $$ RandomAccessFile f = new RandomAccessFile(file, "r")-->Line_7 $$ f.close()[ FD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_11 $$ if (readAmount > fileLength)[ CD ]
Line_14 $$ int header = read4LE(f)-->Line_15 $$ if (header == kEOCDSignature) [ FD ]
Line_30 $$ if (buffer[eocdIdx] == 0x50 && bbuf.getInt(eocdIdx) == kEOCDSignature) -->Line_31 $$ if (LOGV) [ CD ]
Line_4 $$ RandomAccessFile f = new RandomAccessFile(file, "r")-->Line_14 $$ int header = read4LE(f)[ FD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_27 $$ bbuf.order(ByteOrder.LITTLE_ENDIAN)[ CD ]
Line_85 $$ currentOffset += kCDELen + fileNameLen + extraLen + commentLen-->Line_61 $$ if (directoryMap.getInt(currentOffset) != kCDESignature) [ FD ]
Line_4 $$ RandomAccessFile f = new RandomAccessFile(file, "r")-->Line_26 $$ f.readFully(buffer)[ FD ]
Line_25 $$ byte[] buffer = bbuf.array()-->Line_26 $$ f.readFully(buffer)[ FD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_72 $$ if (LOGV) [ CD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_65 $$ int fileNameLen = directoryMap.getShort(currentOffset + kCDENameLen) & 0xffff[ CD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_42 $$ long dirOffset = bbuf.getInt(eocdIdx + kEOCDFileOffset) & 0xffffffffL[ CD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_81 $$ ze.mLocalHdrOffset = directoryMap.getInt(currentOffset + kCDELocalOffset) & 0xffffffffL[ CD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_29 $$ for (eocdIdx = buffer.length - kEOCDLen; eocdIdx >= 0; eocdIdx--) [ CD ]
Line_54 $$ MappedByteBuffer directoryMap = f.getChannel().map(FileChannel.MapMode.READ_ONLY, dirOffset, dirSize)-->Line_61 $$ if (directoryMap.getInt(currentOffset) != kCDESignature) [ FD ]
Line_54 $$ MappedByteBuffer directoryMap = f.getChannel().map(FileChannel.MapMode.READ_ONLY, dirOffset, dirSize)-->Line_80 $$ ze.mUncompressedLength = directoryMap.getLong(currentOffset + kCDEUncompLen) & 0xffffffffL[ FD ]
Line_18 $$ if (header != kLFHSignature) -->Line_19 $$ Log.v(LOG_TAG, "Not a Zip archive")[ CD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_87 $$ if (LOGV) [ CD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_43 $$ if (dirOffset + dirSize > fileLength) [ CD ]
Line_24 $$ ByteBuffer bbuf = ByteBuffer.allocate((int) readAmount)-->Line_42 $$ long dirOffset = bbuf.getInt(eocdIdx + kEOCDFileOffset) & 0xffffffffL[ FD ]
Line_54 $$ MappedByteBuffer directoryMap = f.getChannel().map(FileChannel.MapMode.READ_ONLY, dirOffset, dirSize)-->Line_69 $$ directoryMap.get(tempBuf, 0, fileNameLen)[ FD ]
Line_60 $$ for (int i = 0; i < numEntries; i++) -->Line_69 $$ directoryMap.get(tempBuf, 0, fileNameLen)[ CD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_28 $$ int eocdIdx[ CD ]
Line_4 $$ RandomAccessFile f = new RandomAccessFile(file, "r")-->Line_13 $$ f.seek(0)[ FD ]
Line_24 $$ ByteBuffer bbuf = ByteBuffer.allocate((int) readAmount)-->Line_27 $$ bbuf.order(ByteOrder.LITTLE_ENDIAN)[ FD ]
Line_28 $$ int eocdIdx-->Line_30 $$ if (buffer[eocdIdx] == 0x50 && bbuf.getInt(eocdIdx) == kEOCDSignature) [ FD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_15 $$ if (header == kEOCDSignature) [ CD ]
Line_57 $$ int currentOffset = 0-->Line_85 $$ currentOffset += kCDELen + fileNameLen + extraLen + commentLen[ FD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_25 $$ byte[] buffer = bbuf.array()[ CD ]
Line_41 $$ long dirSize = bbuf.getInt(eocdIdx + kEOCDSize) & 0xffffffffL-->Line_54 $$ MappedByteBuffer directoryMap = f.getChannel().map(FileChannel.MapMode.READ_ONLY, dirOffset, dirSize)[ FD ]
Line_57 $$ int currentOffset = 0-->Line_61 $$ if (directoryMap.getInt(currentOffset) != kCDESignature) [ FD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_3 $$ File file = new File(zipFileName)[ CD ]
Line_54 $$ MappedByteBuffer directoryMap = f.getChannel().map(FileChannel.MapMode.READ_ONLY, dirOffset, dirSize)-->Line_68 $$ directoryMap.position(currentOffset + kCDELen)[ FD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_22 $$ long searchStart = fileLength - readAmount[ CD ]
Line_4 $$ RandomAccessFile f = new RandomAccessFile(file, "r")-->Line_83 $$ ze.setOffsetFromFile(f, buf)[ FD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_4 $$ RandomAccessFile f = new RandomAccessFile(file, "r")[ CD ]
Line_5 $$ long fileLength = f.length()-->Line_11 $$ if (readAmount > fileLength)[ FD ]
Line_14 $$ int header = read4LE(f)-->Line_18 $$ if (header != kLFHSignature) [ FD ]
Line_24 $$ ByteBuffer bbuf = ByteBuffer.allocate((int) readAmount)-->Line_40 $$ int numEntries = bbuf.getShort(eocdIdx + kEOCDNumEntries)[ FD ]
Line_40 $$ int numEntries = bbuf.getShort(eocdIdx + kEOCDNumEntries)-->Line_47 $$ if (numEntries == 0) [ FD ]
Line_22 $$ long searchStart = fileLength - readAmount-->Line_23 $$ f.seek(searchStart)[ FD ]
Line_28 $$ int eocdIdx-->Line_29 $$ for (eocdIdx = buffer.length - kEOCDLen; eocdIdx >= 0; eocdIdx--) [ FD ]
Line_5 $$ long fileLength = f.length()-->Line_12 $$ readAmount = fileLength[ FD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_40 $$ int numEntries = bbuf.getShort(eocdIdx + kEOCDNumEntries)[ CD ]
Line_6 $$ if (fileLength < kEOCDLen) -->Line_7 $$ f.close()[ CD ]
Line_54 $$ MappedByteBuffer directoryMap = f.getChannel().map(FileChannel.MapMode.READ_ONLY, dirOffset, dirSize)-->Line_79 $$ ze.mCompressedLength = directoryMap.getLong(currentOffset + kCDECompLen) & 0xffffffffL[ FD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_26 $$ f.readFully(buffer)[ CD ]
Line_24 $$ ByteBuffer bbuf = ByteBuffer.allocate((int) readAmount)-->Line_30 $$ if (buffer[eocdIdx] == 0x50 && bbuf.getInt(eocdIdx) == kEOCDSignature) [ FD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_37 $$ if (eocdIdx < 0) [ CD ]
Line_2 $$ void addPatchFile(String zipFileName) throws IOException -->Line_14 $$ int header = read4LE(f)[ CD ]
Line_4 $$ RandomAccessFile f = new RandomAccessFile(file, "r")-->Line_23 $$ f.seek(searchStart)[ FD ]
Line_43 $$ if (dirOffset + dirSize > fileLength) -->Line_44 $$ Log.w(LOG_TAG, "bad offsets (dir " + dirOffset + ", size " + dirSize + ", eocd " + eocdIdx + ")")[ CD ]
