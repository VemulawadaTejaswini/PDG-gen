Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_57 $$ emitNewInstanceCallback(e)[ FD ]
Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_28 $$ e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, null)[ FD ]
Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_21 $$ e.begin_class(Constants.V1_2, Constants.ACC_PUBLIC, getClassName(), Type.getType(sc), (useFactory ? TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) : TypeUtils.getTypes(interfaces)), Constants.SOURCE_FILE)[ FD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_24 $$ if (!interceptDuringConstruction) [ CD ]
Line_14 $$ for (final Method method : aClass.getDeclaredMethods()) -->Line_44 $$ if (covariantMethods.containsKey(method)) [ FD ]
Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_59 $$ emitGetCallback(e, keys)[ FD ]
Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_52 $$ emitSetStaticCallbacks(e)[ FD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_11 $$ final Map<Method, Method> covariantMethods = new HashMap<Method, Method>()[ CD ]
Line_35 $$ final Map<Method, MethodInfo> methodInfoMap = new HashMap<Method, MethodInfo>()-->Line_47 $$ methodInfoMap.put(method, ReflectUtils.getMethodInfo(method, modifiers))[ FD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_52 $$ emitSetStaticCallbacks(e)[ CD ]
Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_58 $$ emitNewInstanceMultiarg(e, constructorInfo)[ FD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_49 $$ emitMethods(e, methodInfoMap, covariantMethods)[ CD ]
Line_10 $$ List<Method> actualMethods = new ArrayList<Method>()-->Line_12 $$ getMethods(sc, interfaces, actualMethods, new ArrayList<Method>(), forcePublic)[ FD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_51 $$ emitSetThreadCallbacks(e)[ CD ]
Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_50 $$ emitConstructors(e, constructorInfo)[ FD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_22 $$ List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance())[ CD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_3 $$ Class sc = (superclass == null) ? Object.class : superclass[ CD ]
Line_55 $$ int[] keys = getCallbackKeys()-->Line_59 $$ emitGetCallback(e, keys)[ FD ]
Line_14 $$ for (final Method method : aClass.getDeclaredMethods()) -->Line_47 $$ methodInfoMap.put(method, ReflectUtils.getMethodInfo(method, modifiers))[ FD ]
Line_14 $$ for (final Method method : aClass.getDeclaredMethods()) -->Line_15 $$ if (actualMethods.contains(method)) [ FD ]
Line_14 $$ for (final Method method : aClass.getDeclaredMethods()) -->Line_37 $$ if (isJdk8DefaultMethod(method)) [ FD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_29 $$ if (serialVersionUID != null) [ CD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_64 $$ e.end_class()[ CD ]
Line_32 $$ for (int i = 0; i < callbackTypes.length; i++) -->Line_33 $$ e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], null)[ FD ]
Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_49 $$ emitMethods(e, methodInfoMap, covariantMethods)[ FD ]
Line_44 $$ if (covariantMethods.containsKey(method)) -->Line_45 $$ modifiers = modifiers | Constants.ACC_BRIDGE[ CD ]
Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_25 $$ e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, null)[ FD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_32 $$ for (int i = 0; i < callbackTypes.length; i++) [ CD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_54 $$ if (useFactory) [ CD ]
Line_10 $$ List<Method> actualMethods = new ArrayList<Method>()-->Line_16 $$ removeAllCovariantMethods(actualMethods, method, covariantMethods)[ FD ]
Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_51 $$ emitSetThreadCallbacks(e)[ FD ]
Line_3 $$ Class sc = (superclass == null) ? Object.class : superclass-->Line_21 $$ e.begin_class(Constants.V1_2, Constants.ACC_PUBLIC, getClassName(), Type.getType(sc), (useFactory ? TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) : TypeUtils.getTypes(interfaces)), Constants.SOURCE_FILE)[ FD ]
Line_3 $$ Class sc = (superclass == null) ? Object.class : superclass-->Line_8 $$ filterConstructors(sc, constructors)[ FD ]
Line_11 $$ final Map<Method, Method> covariantMethods = new HashMap<Method, Method>()-->Line_44 $$ if (covariantMethods.containsKey(method)) [ FD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_35 $$ final Map<Method, MethodInfo> methodInfoMap = new HashMap<Method, MethodInfo>()[ CD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_8 $$ filterConstructors(sc, constructors)[ CD ]
Line_11 $$ final Map<Method, Method> covariantMethods = new HashMap<Method, Method>()-->Line_16 $$ removeAllCovariantMethods(actualMethods, method, covariantMethods)[ FD ]
Line_9 $$ final Set forcePublic = new HashSet()-->Line_41 $$ if (forcePublic.contains(MethodWrapper.create(method))) [ FD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_7 $$ List<Constructor> constructors = new ArrayList<Constructor>(Arrays.asList(sc.getDeclaredConstructors()))[ CD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_10 $$ List<Method> actualMethods = new ArrayList<Method>()[ CD ]
Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_33 $$ e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], null)[ FD ]
Line_54 $$ if (useFactory) -->Line_61 $$ emitGetCallbacks(e)[ CD ]
Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_64 $$ e.end_class()[ FD ]
Line_54 $$ if (useFactory) -->Line_62 $$ emitSetCallbacks(e)[ CD ]
Line_24 $$ if (!interceptDuringConstruction) -->Line_25 $$ e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, null)[ CD ]
Line_14 $$ for (final Method method : aClass.getDeclaredMethods()) -->Line_16 $$ removeAllCovariantMethods(actualMethods, method, covariantMethods)[ FD ]
Line_54 $$ if (useFactory) -->Line_56 $$ emitNewInstanceCallbacks(e)[ CD ]
Line_54 $$ if (useFactory) -->Line_58 $$ emitNewInstanceMultiarg(e, constructorInfo)[ CD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_21 $$ e.begin_class(Constants.V1_2, Constants.ACC_PUBLIC, getClassName(), Type.getType(sc), (useFactory ? TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) : TypeUtils.getTypes(interfaces)), Constants.SOURCE_FILE)[ CD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_9 $$ final Set forcePublic = new HashSet()[ CD ]
Line_54 $$ if (useFactory) -->Line_55 $$ int[] keys = getCallbackKeys()[ CD ]
Line_42 $$ modifiers = (modifiers & ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC-->Line_47 $$ methodInfoMap.put(method, ReflectUtils.getMethodInfo(method, modifiers))[ FD ]
Line_55 $$ int[] keys = getCallbackKeys()-->Line_60 $$ emitSetCallback(e, keys)[ FD ]
Line_7 $$ List<Constructor> constructors = new ArrayList<Constructor>(Arrays.asList(sc.getDeclaredConstructors()))-->Line_8 $$ filterConstructors(sc, constructors)[ FD ]
Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_53 $$ emitBindCallbacks(e)[ FD ]
Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_56 $$ emitNewInstanceCallbacks(e)[ FD ]
Line_54 $$ if (useFactory) -->Line_57 $$ emitNewInstanceCallback(e)[ CD ]
Line_32 $$ for (int i = 0; i < callbackTypes.length; i++) -->Line_33 $$ e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], null)[ CD ]
Line_40 $$ int modifiers = Constants.ACC_FINAL | (method.getModifiers() & ~Constants.ACC_ABSTRACT & ~Constants.ACC_NATIVE & ~Constants.ACC_SYNCHRONIZED)-->Line_45 $$ modifiers = modifiers | Constants.ACC_BRIDGE[ FD ]
Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_61 $$ emitGetCallbacks(e)[ FD ]
Line_29 $$ if (serialVersionUID != null) -->Line_30 $$ e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID)[ CD ]
Line_36 $$ for (Method method : actualMethods) -->Line_44 $$ if (covariantMethods.containsKey(method)) [ FD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_50 $$ emitConstructors(e, constructorInfo)[ CD ]
Line_3 $$ Class sc = (superclass == null) ? Object.class : superclass-->Line_4 $$ if (TypeUtils.isFinal(sc.getModifiers())) [ FD ]
Line_22 $$ List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance())-->Line_58 $$ emitNewInstanceMultiarg(e, constructorInfo)[ FD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_28 $$ e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, null)[ CD ]
Line_36 $$ for (Method method : actualMethods) -->Line_37 $$ if (isJdk8DefaultMethod(method)) [ FD ]
Line_45 $$ modifiers = modifiers | Constants.ACC_BRIDGE-->Line_47 $$ methodInfoMap.put(method, ReflectUtils.getMethodInfo(method, modifiers))[ FD ]
Line_13 $$ for (Class aClass = sc; aClass != null; aClass = aClass.getSuperclass()) -->Line_14 $$ for (final Method method : aClass.getDeclaredMethods()) [ FD ]
Line_54 $$ if (useFactory) -->Line_59 $$ emitGetCallback(e, keys)[ CD ]
Line_11 $$ final Map<Method, Method> covariantMethods = new HashMap<Method, Method>()-->Line_49 $$ emitMethods(e, methodInfoMap, covariantMethods)[ FD ]
Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_62 $$ emitSetCallbacks(e)[ FD ]
Line_40 $$ int modifiers = Constants.ACC_FINAL | (method.getModifiers() & ~Constants.ACC_ABSTRACT & ~Constants.ACC_NATIVE & ~Constants.ACC_SYNCHRONIZED)-->Line_42 $$ modifiers = (modifiers & ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC[ FD ]
Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_27 $$ e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null)[ FD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_20 $$ ClassEmitter e = new ClassEmitter(v)[ CD ]
Line_36 $$ for (Method method : actualMethods) -->Line_40 $$ int modifiers = Constants.ACC_FINAL | (method.getModifiers() & ~Constants.ACC_ABSTRACT & ~Constants.ACC_NATIVE & ~Constants.ACC_SYNCHRONIZED)[ FD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_4 $$ if (TypeUtils.isFinal(sc.getModifiers())) [ CD ]
Line_36 $$ for (Method method : actualMethods) -->Line_47 $$ methodInfoMap.put(method, ReflectUtils.getMethodInfo(method, modifiers))[ FD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_53 $$ emitBindCallbacks(e)[ CD ]
Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_30 $$ e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID)[ FD ]
Line_14 $$ for (final Method method : aClass.getDeclaredMethods()) -->Line_41 $$ if (forcePublic.contains(MethodWrapper.create(method))) [ FD ]
Line_36 $$ for (Method method : actualMethods) -->Line_41 $$ if (forcePublic.contains(MethodWrapper.create(method))) [ FD ]
Line_40 $$ int modifiers = Constants.ACC_FINAL | (method.getModifiers() & ~Constants.ACC_ABSTRACT & ~Constants.ACC_NATIVE & ~Constants.ACC_SYNCHRONIZED)-->Line_47 $$ methodInfoMap.put(method, ReflectUtils.getMethodInfo(method, modifiers))[ FD ]
Line_35 $$ final Map<Method, MethodInfo> methodInfoMap = new HashMap<Method, MethodInfo>()-->Line_49 $$ emitMethods(e, methodInfoMap, covariantMethods)[ FD ]
Line_15 $$ if (actualMethods.contains(method)) -->Line_16 $$ removeAllCovariantMethods(actualMethods, method, covariantMethods)[ CD ]
Line_10 $$ List<Method> actualMethods = new ArrayList<Method>()-->Line_15 $$ if (actualMethods.contains(method)) [ FD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_12 $$ getMethods(sc, interfaces, actualMethods, new ArrayList<Method>(), forcePublic)[ CD ]
Line_3 $$ Class sc = (superclass == null) ? Object.class : superclass-->Line_12 $$ getMethods(sc, interfaces, actualMethods, new ArrayList<Method>(), forcePublic)[ FD ]
Line_3 $$ Class sc = (superclass == null) ? Object.class : superclass-->Line_7 $$ List<Constructor> constructors = new ArrayList<Constructor>(Arrays.asList(sc.getDeclaredConstructors()))[ FD ]
Line_7 $$ List<Constructor> constructors = new ArrayList<Constructor>(Arrays.asList(sc.getDeclaredConstructors()))-->Line_22 $$ List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance())[ FD ]
Line_54 $$ if (useFactory) -->Line_60 $$ emitSetCallback(e, keys)[ CD ]
Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_60 $$ emitSetCallback(e, keys)[ FD ]
Line_9 $$ final Set forcePublic = new HashSet()-->Line_12 $$ getMethods(sc, interfaces, actualMethods, new ArrayList<Method>(), forcePublic)[ FD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_13 $$ for (Class aClass = sc; aClass != null; aClass = aClass.getSuperclass()) [ CD ]
Line_41 $$ if (forcePublic.contains(MethodWrapper.create(method))) -->Line_42 $$ modifiers = (modifiers & ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC[ CD ]
Line_22 $$ List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance())-->Line_50 $$ emitConstructors(e, constructorInfo)[ FD ]
Line_14 $$ for (final Method method : aClass.getDeclaredMethods()) -->Line_40 $$ int modifiers = Constants.ACC_FINAL | (method.getModifiers() & ~Constants.ACC_ABSTRACT & ~Constants.ACC_NATIVE & ~Constants.ACC_SYNCHRONIZED)[ FD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_23 $$ e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, null)[ CD ]
Line_2 $$ public void generateClass(ClassVisitor v) throws Exception -->Line_27 $$ e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null)[ CD ]
Line_42 $$ modifiers = (modifiers & ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC-->Line_45 $$ modifiers = modifiers | Constants.ACC_BRIDGE[ FD ]
Line_20 $$ ClassEmitter e = new ClassEmitter(v)-->Line_23 $$ e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, null)[ FD ]
