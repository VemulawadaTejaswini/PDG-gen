Line_8 $$ oIn = new ObjectInputStream(new ByteArrayInputStream(myRawData)) -->Line_22 $$ return doResolveProxyClass(interfaces, loader)[ FD ]
Line_32 $$ for (int i = 0; i < interfaces.length; i++) -->Line_34 $$ if ((cl.getModifiers() & Modifier.PUBLIC) == 0) [ CD ]
Line_8 $$ oIn = new ObjectInputStream(new ByteArrayInputStream(myRawData)) -->Line_29 $$ ClassLoader nonPublicLoader = null[ CD ]
Line_40 $$ nonPublicLoader = cl.getClassLoader()-->Line_36 $$ if (nonPublicLoader != cl.getClassLoader()) [ FD ]
Line_34 $$ if ((cl.getModifiers() & Modifier.PUBLIC) == 0) -->Line_35 $$ if (hasNonPublicInterface) [ CD ]
Line_8 $$ oIn = new ObjectInputStream(new ByteArrayInputStream(myRawData)) -->Line_53 $$ myData = (T) oIn.readObject()[ FD ]
Line_8 $$ oIn = new ObjectInputStream(new ByteArrayInputStream(myRawData)) -->Line_10 $$ String name = desc.getName()[ CD ]
Line_33 $$ Class cl = Class.forName(interfaces[i], false, loader)-->Line_34 $$ if ((cl.getModifiers() & Modifier.PUBLIC) == 0) [ FD ]
Line_8 $$ oIn = new ObjectInputStream(new ByteArrayInputStream(myRawData)) -->Line_32 $$ for (int i = 0; i < interfaces.length; i++) [ CD ]
Line_10 $$ String name = desc.getName()-->Line_13 $$ return Class.forName(name, false, loader)[ FD ]
Line_8 $$ oIn = new ObjectInputStream(new ByteArrayInputStream(myRawData)) -->Line_17 $$ return super.resolveClass(desc)[ FD ]
Line_6 $$ ObjectInputStream oIn = null-->Line_53 $$ myData = (T) oIn.readObject()[ FD ]
Line_8 $$ oIn = new ObjectInputStream(new ByteArrayInputStream(myRawData)) -->Line_26 $$ return super.resolveProxyClass(interfaces)[ CD ]
Line_35 $$ if (hasNonPublicInterface) -->Line_40 $$ nonPublicLoader = cl.getClassLoader()[ CD ]
Line_30 $$ boolean hasNonPublicInterface = false-->Line_41 $$ hasNonPublicInterface = true[ FD ]
Line_8 $$ oIn = new ObjectInputStream(new ByteArrayInputStream(myRawData)) -->Line_10 $$ String name = desc.getName()[ FD ]
Line_35 $$ if (hasNonPublicInterface) -->Line_41 $$ hasNonPublicInterface = true[ CD ]
Line_33 $$ Class cl = Class.forName(interfaces[i], false, loader)-->Line_36 $$ if (nonPublicLoader != cl.getClassLoader()) [ FD ]
Line_6 $$ ObjectInputStream oIn = null-->Line_61 $$ StreamUtil.closeStream(oIn)[ FD ]
Line_32 $$ for (int i = 0; i < interfaces.length; i++) -->Line_44 $$ classObjs[i] = cl[ CD ]
Line_33 $$ Class cl = Class.forName(interfaces[i], false, loader)-->Line_44 $$ classObjs[i] = cl[ FD ]
Line_33 $$ Class cl = Class.forName(interfaces[i], false, loader)-->Line_40 $$ nonPublicLoader = cl.getClassLoader()[ FD ]
Line_8 $$ oIn = new ObjectInputStream(new ByteArrayInputStream(myRawData)) -->Line_30 $$ boolean hasNonPublicInterface = false[ CD ]
Line_2 $$ public void prepareData(@NotNull final ClassLoader... loaders) -->Line_6 $$ ObjectInputStream oIn = null[ CD ]
Line_31 $$ Class[] classObjs = new Class[interfaces.length]-->Line_47 $$ return Proxy.getProxyClass(hasNonPublicInterface ? nonPublicLoader : loader, classObjs)[ FD ]
Line_11 $$ for (ClassLoader loader : loaders) -->Line_13 $$ return Class.forName(name, false, loader)[ FD ]
Line_11 $$ for (ClassLoader loader : loaders) -->Line_33 $$ Class cl = Class.forName(interfaces[i], false, loader)[ FD ]
Line_11 $$ for (ClassLoader loader : loaders) -->Line_22 $$ return doResolveProxyClass(interfaces, loader)[ FD ]
Line_29 $$ ClassLoader nonPublicLoader = null-->Line_40 $$ nonPublicLoader = cl.getClassLoader()[ FD ]
Line_29 $$ ClassLoader nonPublicLoader = null-->Line_36 $$ if (nonPublicLoader != cl.getClassLoader()) [ FD ]
Line_35 $$ if (hasNonPublicInterface) -->Line_36 $$ if (nonPublicLoader != cl.getClassLoader()) [ CD ]
Line_2 $$ public void prepareData(@NotNull final ClassLoader... loaders) -->Line_3 $$ if (myData != null) [ CD ]
Line_8 $$ oIn = new ObjectInputStream(new ByteArrayInputStream(myRawData)) -->Line_26 $$ return super.resolveProxyClass(interfaces)[ FD ]
Line_2 $$ public void prepareData(@NotNull final ClassLoader... loaders) -->Line_59 $$ throw new IllegalStateException(String.format("Can't deserialize target data of key '%s'. Given class loaders: %s", myKey, Arrays.toString(loaders)), e)[ FD ]
Line_8 $$ oIn = new ObjectInputStream(new ByteArrayInputStream(myRawData)) -->Line_17 $$ return super.resolveClass(desc)[ CD ]
Line_2 $$ public void prepareData(@NotNull final ClassLoader... loaders) -->Line_57 $$ throw new IllegalStateException(String.format("Can't deserialize target data of key '%s'. Given class loaders: %s", myKey, Arrays.toString(loaders)), e)[ FD ]
Line_20 $$ for (ClassLoader loader : loaders) -->Line_33 $$ Class cl = Class.forName(interfaces[i], false, loader)[ FD ]
Line_32 $$ for (int i = 0; i < interfaces.length; i++) -->Line_33 $$ Class cl = Class.forName(interfaces[i], false, loader)[ CD ]
Line_8 $$ oIn = new ObjectInputStream(new ByteArrayInputStream(myRawData)) -->Line_61 $$ StreamUtil.closeStream(oIn)[ FD ]
Line_8 $$ oIn = new ObjectInputStream(new ByteArrayInputStream(myRawData)) -->Line_31 $$ Class[] classObjs = new Class[interfaces.length][ CD ]
Line_20 $$ for (ClassLoader loader : loaders) -->Line_22 $$ return doResolveProxyClass(interfaces, loader)[ FD ]
Line_8 $$ oIn = new ObjectInputStream(new ByteArrayInputStream(myRawData)) -->Line_33 $$ Class cl = Class.forName(interfaces[i], false, loader)[ FD ]
Line_6 $$ ObjectInputStream oIn = null-->Line_8 $$ oIn = new ObjectInputStream(new ByteArrayInputStream(myRawData)) [ FD ]
Line_3 $$ if (myData != null) -->Line_4 $$ return[ CD ]
