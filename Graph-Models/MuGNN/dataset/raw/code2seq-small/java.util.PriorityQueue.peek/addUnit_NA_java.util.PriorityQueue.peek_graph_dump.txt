Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_7 $$ if (numTokens > sortedTokens.size())[ FD ]
Line_34 $$ do -->Line_36 $$ improvements.add(new Weighted(impr, candidate))[ CD ]
Line_41 $$ for (int vn = 1; ; ++vn) -->Line_44 $$ if (vn == numTokens)[ CD ]
Line_46 $$ while (true) -->Line_51 $$ double impr = evaluateImprovement(bestToken, optTokenOwnership, (vn + 1.0) / numTokens)[ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_34 $$ do [ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_41 $$ for (int vn = 1; ; ++vn) [ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_12 $$ Map<Object, GroupInfo> groups = Maps.newHashMap()[ CD ]
Line_34 $$ do -->Line_35 $$ double impr = evaluateImprovement(candidate, optTokenOwnership, 1.0 / numTokens)[ CD ]
Line_37 $$ candidate = candidate.next-->Line_35 $$ double impr = evaluateImprovement(candidate, optTokenOwnership, 1.0 / numTokens)[ FD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_14 $$ if (groups.size() < replicas) [ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_4 $$ if (unitCount() < replicas)[ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_33 $$ CandidateInfo<Unit> candidate = candidates[ CD ]
Line_34 $$ do -->Line_37 $$ candidate = candidate.next[ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_3 $$ assert !unitToTokens.containsKey(newUnit)[ FD ]
Line_12 $$ Map<Object, GroupInfo> groups = Maps.newHashMap()-->Line_13 $$ Map<Unit, UnitInfo<Unit>> unitInfos = createUnitInfos(groups)[ FD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_44 $$ if (vn == numTokens)[ FD ]
Line_33 $$ CandidateInfo<Unit> candidate = candidates-->Line_35 $$ double impr = evaluateImprovement(candidate, optTokenOwnership, 1.0 / numTokens)[ FD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_60 $$ return ImmutableList.copyOf(unitToTokens.get(newUnit))[ FD ]
Line_46 $$ while (true) -->Line_52 $$ Weighted<CandidateInfo<Unit>> next = improvements.peek()[ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_13 $$ Map<Unit, UnitInfo<Unit>> unitInfos = createUnitInfos(groups)[ CD ]
Line_33 $$ CandidateInfo<Unit> candidate = candidates-->Line_37 $$ candidate = candidate.next[ FD ]
Line_41 $$ for (int vn = 1; ; ++vn) -->Line_43 $$ confirmCandidate(bestToken)[ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_60 $$ return ImmutableList.copyOf(unitToTokens.get(newUnit))[ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_26 $$ newUnitInfo.tokenCount = numTokens[ CD ]
Line_33 $$ CandidateInfo<Unit> candidate = candidates-->Line_34 $$ do [ FD ]
Line_46 $$ while (true) -->Line_57 $$ improvements.add(new Weighted(impr, bestToken))[ CD ]
Line_37 $$ candidate = candidate.next-->Line_34 $$ do [ FD ]
Line_41 $$ for (int vn = 1; ; ++vn) -->Line_46 $$ while (true) [ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_7 $$ if (numTokens > sortedTokens.size())[ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_26 $$ newUnitInfo.tokenCount = numTokens[ FD ]
Line_12 $$ Map<Object, GroupInfo> groups = Maps.newHashMap()-->Line_14 $$ if (groups.size() < replicas) [ FD ]
Line_41 $$ for (int vn = 1; ; ++vn) -->Line_42 $$ candidates = bestToken.removeFrom(candidates)[ CD ]
Line_41 $$ for (int vn = 1; ; ++vn) -->Line_44 $$ if (vn == numTokens)[ FD ]
