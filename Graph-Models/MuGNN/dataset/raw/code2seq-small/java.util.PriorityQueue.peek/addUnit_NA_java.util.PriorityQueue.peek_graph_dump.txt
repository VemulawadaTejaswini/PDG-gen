Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_3 $$ assert !unitToTokens.containsKey(newUnit)[ FD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_17 $$ CandidateInfo<Unit> candidates = createCandidates(tokens, newUnitInfo, optTokenOwnership)[ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_20 $$ do [ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_6 $$ if (numTokens > sortedTokens.size())[ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_8 $$ double optTokenOwnership = optimalTokenOwnership(numTokens)[ CD ]
Line_17 $$ CandidateInfo<Unit> candidates = createCandidates(tokens, newUnitInfo, optTokenOwnership)-->Line_27 $$ candidates = bestToken.removeFrom(candidates)[ FD ]
Line_31 $$ while (true) -->Line_32 $$ bestToken = improvements.remove().value[ CD ]
Line_19 $$ CandidateInfo<Unit> candidate = candidates-->Line_20 $$ do [ FD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_7 $$ return generateRandomTokens(newUnit, numTokens)[ FD ]
Line_15 $$ TokenInfo<Unit> tokens = createTokenInfos(unitInfos, newUnitInfo.group)-->Line_17 $$ CandidateInfo<Unit> candidates = createCandidates(tokens, newUnitInfo, optTokenOwnership)[ FD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_5 $$ return generateRandomTokens(newUnit, numTokens)[ FD ]
Line_25 $$ CandidateInfo<Unit> bestToken = improvements.remove().value-->Line_32 $$ bestToken = improvements.remove().value[ FD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_40 $$ return ImmutableList.copyOf(unitToTokens.get(newUnit))[ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_29 $$ if (vn == numTokens)[ FD ]
Line_19 $$ CandidateInfo<Unit> candidate = candidates-->Line_23 $$ candidate = candidate.next[ FD ]
Line_26 $$ for (int vn = 1; ; ++vn) -->Line_29 $$ if (vn == numTokens)[ FD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_16 $$ newUnitInfo.tokenCount = numTokens[ FD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_11 $$ if (groups.size() < replicas) [ CD ]
Line_18 $$ PriorityQueue<Weighted<CandidateInfo<Unit>>> improvements = new PriorityQueue(sortedTokens.size())-->Line_37 $$ improvements.add(new Weighted(impr, bestToken))[ FD ]
Line_9 $$ Map<Object, GroupInfo> groups = Maps.newHashMap()-->Line_11 $$ if (groups.size() < replicas) [ FD ]
Line_26 $$ for (int vn = 1; ; ++vn) -->Line_31 $$ while (true) [ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_6 $$ if (numTokens > sortedTokens.size())[ FD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_4 $$ if (unitCount() < replicas)[ CD ]
Line_20 $$ do -->Line_23 $$ candidate = candidate.next[ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_26 $$ for (int vn = 1; ; ++vn) [ CD ]
Line_6 $$ if (numTokens > sortedTokens.size())-->Line_7 $$ return generateRandomTokens(newUnit, numTokens)[ CD ]
Line_25 $$ CandidateInfo<Unit> bestToken = improvements.remove().value-->Line_28 $$ confirmCandidate(bestToken)[ FD ]
Line_32 $$ bestToken = improvements.remove().value-->Line_33 $$ double impr = evaluateImprovement(bestToken, optTokenOwnership, (vn + 1.0) / numTokens)[ FD ]
Line_25 $$ CandidateInfo<Unit> bestToken = improvements.remove().value-->Line_27 $$ candidates = bestToken.removeFrom(candidates)[ FD ]
Line_9 $$ Map<Object, GroupInfo> groups = Maps.newHashMap()-->Line_10 $$ Map<Unit, UnitInfo<Unit>> unitInfos = createUnitInfos(groups)[ FD ]
Line_31 $$ while (true) -->Line_37 $$ improvements.add(new Weighted(impr, bestToken))[ CD ]
Line_18 $$ PriorityQueue<Weighted<CandidateInfo<Unit>>> improvements = new PriorityQueue(sortedTokens.size())-->Line_25 $$ CandidateInfo<Unit> bestToken = improvements.remove().value[ FD ]
Line_23 $$ candidate = candidate.next-->Line_21 $$ double impr = evaluateImprovement(candidate, optTokenOwnership, 1.0 / numTokens)[ FD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_16 $$ newUnitInfo.tokenCount = numTokens[ CD ]
Line_14 $$ UnitInfo<Unit> newUnitInfo = new UnitInfo(newUnit, numTokens * optTokenOwnership, groups, strategy)-->Line_17 $$ CandidateInfo<Unit> candidates = createCandidates(tokens, newUnitInfo, optTokenOwnership)[ FD ]
Line_25 $$ CandidateInfo<Unit> bestToken = improvements.remove().value-->Line_33 $$ double impr = evaluateImprovement(bestToken, optTokenOwnership, (vn + 1.0) / numTokens)[ FD ]
Line_18 $$ PriorityQueue<Weighted<CandidateInfo<Unit>>> improvements = new PriorityQueue(sortedTokens.size())-->Line_32 $$ bestToken = improvements.remove().value[ FD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_25 $$ CandidateInfo<Unit> bestToken = improvements.remove().value[ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_12 $$ return generateRandomTokens(newUnit, numTokens)[ FD ]
Line_8 $$ double optTokenOwnership = optimalTokenOwnership(numTokens)-->Line_21 $$ double impr = evaluateImprovement(candidate, optTokenOwnership, 1.0 / numTokens)[ FD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_40 $$ return ImmutableList.copyOf(unitToTokens.get(newUnit))[ FD ]
Line_26 $$ for (int vn = 1; ; ++vn) -->Line_27 $$ candidates = bestToken.removeFrom(candidates)[ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_9 $$ Map<Object, GroupInfo> groups = Maps.newHashMap()[ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_10 $$ Map<Unit, UnitInfo<Unit>> unitInfos = createUnitInfos(groups)[ CD ]
Line_20 $$ do -->Line_22 $$ improvements.add(new Weighted(impr, candidate))[ CD ]
Line_17 $$ CandidateInfo<Unit> candidates = createCandidates(tokens, newUnitInfo, optTokenOwnership)-->Line_20 $$ do [ FD ]
Line_31 $$ while (true) -->Line_33 $$ double impr = evaluateImprovement(bestToken, optTokenOwnership, (vn + 1.0) / numTokens)[ CD ]
Line_18 $$ PriorityQueue<Weighted<CandidateInfo<Unit>>> improvements = new PriorityQueue(sortedTokens.size())-->Line_34 $$ Weighted<CandidateInfo<Unit>> next = improvements.peek()[ FD ]
Line_31 $$ while (true) -->Line_35 $$ if (next == null || impr >= next.weight)[ CD ]
Line_19 $$ CandidateInfo<Unit> candidate = candidates-->Line_21 $$ double impr = evaluateImprovement(candidate, optTokenOwnership, 1.0 / numTokens)[ FD ]
Line_8 $$ double optTokenOwnership = optimalTokenOwnership(numTokens)-->Line_17 $$ CandidateInfo<Unit> candidates = createCandidates(tokens, newUnitInfo, optTokenOwnership)[ FD ]
Line_8 $$ double optTokenOwnership = optimalTokenOwnership(numTokens)-->Line_33 $$ double impr = evaluateImprovement(bestToken, optTokenOwnership, (vn + 1.0) / numTokens)[ FD ]
Line_31 $$ while (true) -->Line_34 $$ Weighted<CandidateInfo<Unit>> next = improvements.peek()[ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_8 $$ double optTokenOwnership = optimalTokenOwnership(numTokens)[ FD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_18 $$ PriorityQueue<Weighted<CandidateInfo<Unit>>> improvements = new PriorityQueue(sortedTokens.size())[ CD ]
Line_4 $$ if (unitCount() < replicas)-->Line_5 $$ return generateRandomTokens(newUnit, numTokens)[ CD ]
Line_20 $$ do -->Line_21 $$ double impr = evaluateImprovement(candidate, optTokenOwnership, 1.0 / numTokens)[ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_19 $$ CandidateInfo<Unit> candidate = candidates[ CD ]
Line_26 $$ for (int vn = 1; ; ++vn) -->Line_28 $$ confirmCandidate(bestToken)[ CD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_15 $$ TokenInfo<Unit> tokens = createTokenInfos(unitInfos, newUnitInfo.group)[ CD ]
Line_23 $$ candidate = candidate.next-->Line_20 $$ do [ FD ]
Line_2 $$ public Collection<Token> addUnit(Unit newUnit, int numTokens) -->Line_14 $$ UnitInfo<Unit> newUnitInfo = new UnitInfo(newUnit, numTokens * optTokenOwnership, groups, strategy)[ CD ]
Line_26 $$ for (int vn = 1; ; ++vn) -->Line_29 $$ if (vn == numTokens)[ CD ]
Line_10 $$ Map<Unit, UnitInfo<Unit>> unitInfos = createUnitInfos(groups)-->Line_15 $$ TokenInfo<Unit> tokens = createTokenInfos(unitInfos, newUnitInfo.group)[ FD ]
Line_11 $$ if (groups.size() < replicas) -->Line_12 $$ return generateRandomTokens(newUnit, numTokens)[ CD ]
Line_18 $$ PriorityQueue<Weighted<CandidateInfo<Unit>>> improvements = new PriorityQueue(sortedTokens.size())-->Line_22 $$ improvements.add(new Weighted(impr, candidate))[ FD ]
