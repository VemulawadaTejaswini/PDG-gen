Line_24 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_112 $$ subclass = builder.generate()[ FD ]
Line_46 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_93 $$ if (Iterable.class.isAssignableFrom(property.getType())) [ FD ]
Line_23 $$ ClassMetaData classMetaData = inspectType(type)-->Line_61 $$ if (classMetaData.isExtensible()) [ FD ]
Line_42 $$ noMappingClass = c-->Line_63 $$ if (!Modifier.isFinal(getter.getModifiers()) && !getter.getDeclaringClass().isAssignableFrom(noMappingClass)) [ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_11 $$ Class<?> generatedClass = cache.get(type)[ CD ]
Line_45 $$ Set<PropertyMetaData> conventionProperties = new HashSet<PropertyMetaData>()-->Line_70 $$ conventionProperties.add(property)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_19 $$ throw new GradleException(String.format("Cannot create a proxy class for abstract class '%s'.", type.getSimpleName()))[ FD ]
Line_26 $$ if (!DynamicObjectAware.class.isAssignableFrom(type)) -->Line_30 $$ builder.mixInDynamicAware()[ CD ]
Line_24 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_51 $$ builder.addInjectorProperty(property)[ FD ]
Line_52 $$ for (Method getter : property.getters) -->Line_53 $$ builder.applyServiceInjectionToGetter(property, getter)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_117 $$ cache.put(subclass, subclass)[ CD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_23 $$ ClassMetaData classMetaData = inspectType(type)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_3 $$ Map<Class<?>, Class<?>> cache = GENERATED_CLASSES.get(getClass())[ CD ]
Line_55 $$ for (Method setter : property.setters) -->Line_79 $$ builder.applyConventionMappingToSetter(property, setter)[ FD ]
Line_24 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_86 $$ builder.addActionMethod(method)[ FD ]
Line_46 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_51 $$ builder.addInjectorProperty(property)[ FD ]
Line_39 $$ Class noMappingClass = Object.class-->Line_42 $$ noMappingClass = c[ FD ]
Line_24 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_25 $$ builder.startClass()[ FD ]
Line_46 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_73 $$ builder.applyConventionMappingToGetter(property, getter)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_26 $$ if (!DynamicObjectAware.class.isAssignableFrom(type)) [ FD ]
Line_112 $$ subclass = builder.generate()-->Line_117 $$ cache.put(subclass, subclass)[ FD ]
Line_4 $$ if (cache == null) -->Line_9 $$ GENERATED_CLASSES.put(getClass(), cache)[ CD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_13 $$ return generatedClass.asSubclass(type)[ FD ]
Line_26 $$ if (!DynamicObjectAware.class.isAssignableFrom(type)) -->Line_27 $$ if (ExtensionAware.class.isAssignableFrom(type)) [ CD ]
Line_46 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_50 $$ if (property.injector) [ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_118 $$ return subclass[ CD ]
Line_52 $$ for (Method getter : property.getters) -->Line_73 $$ builder.applyConventionMappingToGetter(property, getter)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_15 $$ if (Modifier.isPrivate(type.getModifiers())) [ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_16 $$ throw new GradleException(String.format("Cannot create a proxy class for private class '%s'.", type.getSimpleName()))[ FD ]
Line_40 $$ for (Class<?> c = type; c != null && noMappingClass == Object.class; c = c.getSuperclass()) -->Line_41 $$ if (c.getAnnotation(NoConventionMapping.class) != null) [ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_32 $$ if (!GroovyObject.class.isAssignableFrom(type)) [ FD ]
Line_24 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_103 $$ builder.applyConventionMappingToSetMethod(property, setMethod)[ FD ]
Line_24 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_56 $$ builder.applyServiceInjectionToSetter(property, setter)[ FD ]
Line_55 $$ for (Method setter : property.setters) -->Line_78 $$ if (!Modifier.isFinal(setter.getModifiers())) [ FD ]
Line_107 $$ for (Constructor<?> constructor : type.getConstructors()) -->Line_109 $$ builder.addConstructor(constructor)[ FD ]
Line_3 $$ Map<Class<?>, Class<?>> cache = GENERATED_CLASSES.get(getClass())-->Line_11 $$ Class<?> generatedClass = cache.get(type)[ FD ]
Line_11 $$ Class<?> generatedClass = cache.get(type)-->Line_13 $$ return generatedClass.asSubclass(type)[ FD ]
Line_21 $$ Class<? extends T> subclass-->Line_117 $$ cache.put(subclass, subclass)[ FD ]
Line_39 $$ Class noMappingClass = Object.class-->Line_63 $$ if (!Modifier.isFinal(getter.getModifiers()) && !getter.getDeclaringClass().isAssignableFrom(noMappingClass)) [ FD ]
Line_24 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_35 $$ builder.addDynamicMethods()[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_107 $$ for (Constructor<?> constructor : type.getConstructors()) [ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_116 $$ cache.put(type, subclass)[ FD ]
Line_46 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_103 $$ builder.applyConventionMappingToSetMethod(property, setMethod)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_27 $$ if (ExtensionAware.class.isAssignableFrom(type)) [ FD ]
Line_46 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_70 $$ conventionProperties.add(property)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_24 $$ ClassBuilder<T> builder = start(type, classMetaData)[ FD ]
Line_45 $$ Set<PropertyMetaData> conventionProperties = new HashSet<PropertyMetaData>()-->Line_101 $$ if (conventionProperties.contains(property)) [ FD ]
Line_12 $$ if (generatedClass != null) -->Line_13 $$ return generatedClass.asSubclass(type)[ CD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_116 $$ cache.put(type, subclass)[ CD ]
Line_3 $$ Map<Class<?>, Class<?>> cache = GENERATED_CLASSES.get(getClass())-->Line_9 $$ GENERATED_CLASSES.put(getClass(), cache)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_18 $$ if (Modifier.isAbstract(type.getModifiers())) [ CD ]
Line_24 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_73 $$ builder.applyConventionMappingToGetter(property, getter)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_36 $$ if (classMetaData.conventionAware && !IConventionAware.class.isAssignableFrom(type)) [ FD ]
Line_46 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_56 $$ builder.applyServiceInjectionToSetter(property, setter)[ FD ]
Line_69 $$ if (needsConventionMapping) -->Line_70 $$ conventionProperties.add(property)[ CD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_15 $$ if (Modifier.isPrivate(type.getModifiers())) [ CD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_18 $$ if (Modifier.isAbstract(type.getModifiers())) [ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_11 $$ Class<?> generatedClass = cache.get(type)[ FD ]
Line_46 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_101 $$ if (conventionProperties.contains(property)) [ FD ]
Line_40 $$ for (Class<?> c = type; c != null && noMappingClass == Object.class; c = c.getSuperclass()) -->Line_42 $$ noMappingClass = c[ FD ]
Line_24 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_99 $$ builder.addSetMethod(property, setter)[ FD ]
Line_24 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_37 $$ builder.mixInConventionAware()[ FD ]
Line_97 $$ if (property.setMethods.isEmpty()) -->Line_101 $$ if (conventionProperties.contains(property)) [ CD ]
Line_46 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_99 $$ builder.addSetMethod(property, setter)[ FD ]
Line_60 $$ boolean needsConventionMapping = false-->Line_64 $$ needsConventionMapping = true[ FD ]
Line_24 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_53 $$ builder.applyServiceInjectionToGetter(property, getter)[ FD ]
Line_78 $$ if (!Modifier.isFinal(setter.getModifiers())) -->Line_79 $$ builder.applyConventionMappingToSetter(property, setter)[ CD ]
Line_50 $$ if (property.injector) -->Line_51 $$ builder.addInjectorProperty(property)[ CD ]
Line_32 $$ if (!GroovyObject.class.isAssignableFrom(type)) -->Line_33 $$ builder.mixInGroovyObject()[ CD ]
Line_24 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_109 $$ builder.addConstructor(constructor)[ FD ]
Line_40 $$ for (Class<?> c = type; c != null && noMappingClass == Object.class; c = c.getSuperclass()) -->Line_41 $$ if (c.getAnnotation(NoConventionMapping.class) != null) [ CD ]
Line_24 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_71 $$ builder.addConventionProperty(property)[ FD ]
Line_46 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_71 $$ builder.addConventionProperty(property)[ FD ]
Line_3 $$ Map<Class<?>, Class<?>> cache = GENERATED_CLASSES.get(getClass())-->Line_116 $$ cache.put(type, subclass)[ FD ]
Line_23 $$ ClassMetaData classMetaData = inspectType(type)-->Line_24 $$ ClassBuilder<T> builder = start(type, classMetaData)[ FD ]
Line_3 $$ Map<Class<?>, Class<?>> cache = GENERATED_CLASSES.get(getClass())-->Line_4 $$ if (cache == null) [ FD ]
Line_85 $$ for (Method method : actionMethods) -->Line_86 $$ builder.addActionMethod(method)[ FD ]
Line_46 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_53 $$ builder.applyServiceInjectionToGetter(property, getter)[ FD ]
Line_52 $$ for (Method getter : property.getters) -->Line_63 $$ if (!Modifier.isFinal(getter.getModifiers()) && !getter.getDeclaringClass().isAssignableFrom(noMappingClass)) [ FD ]
Line_24 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_33 $$ builder.mixInGroovyObject()[ FD ]
Line_24 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_30 $$ builder.mixInDynamicAware()[ FD ]
Line_55 $$ for (Method setter : property.setters) -->Line_56 $$ builder.applyServiceInjectionToSetter(property, setter)[ FD ]
Line_69 $$ if (needsConventionMapping) -->Line_71 $$ builder.addConventionProperty(property)[ CD ]
Line_55 $$ for (Method setter : property.setters) -->Line_99 $$ builder.addSetMethod(property, setter)[ FD ]
Line_36 $$ if (classMetaData.conventionAware && !IConventionAware.class.isAssignableFrom(type)) -->Line_37 $$ builder.mixInConventionAware()[ CD ]
Line_11 $$ Class<?> generatedClass = cache.get(type)-->Line_12 $$ if (generatedClass != null) [ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_12 $$ if (generatedClass != null) [ CD ]
Line_102 $$ for (Method setMethod : property.setMethods) -->Line_103 $$ builder.applyConventionMappingToSetMethod(property, setMethod)[ FD ]
Line_41 $$ if (c.getAnnotation(NoConventionMapping.class) != null) -->Line_42 $$ noMappingClass = c[ CD ]
Line_46 $$ for (PropertyMetaData property : classMetaData.properties.values()) -->Line_79 $$ builder.applyConventionMappingToSetter(property, setter)[ FD ]
Line_21 $$ Class<? extends T> subclass-->Line_116 $$ cache.put(type, subclass)[ FD ]
Line_108 $$ if (Modifier.isPublic(constructor.getModifiers())) -->Line_109 $$ builder.addConstructor(constructor)[ CD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_114 $$ throw new GradleException(String.format("Could not generate a proxy class for class %s.", type.getName()), e)[ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_21 $$ Class<? extends T> subclass[ CD ]
Line_112 $$ subclass = builder.generate()-->Line_116 $$ cache.put(type, subclass)[ FD ]
Line_107 $$ for (Constructor<?> constructor : type.getConstructors()) -->Line_108 $$ if (Modifier.isPublic(constructor.getModifiers())) [ FD ]
Line_2 $$ private <T> Class<? extends T> generateUnderLock(Class<T> type) -->Line_4 $$ if (cache == null) [ CD ]
Line_24 $$ ClassBuilder<T> builder = start(type, classMetaData)-->Line_79 $$ builder.applyConventionMappingToSetter(property, setter)[ FD ]
Line_63 $$ if (!Modifier.isFinal(getter.getModifiers()) && !getter.getDeclaringClass().isAssignableFrom(noMappingClass)) -->Line_64 $$ needsConventionMapping = true[ CD ]
Line_21 $$ Class<? extends T> subclass-->Line_112 $$ subclass = builder.generate()[ FD ]
Line_3 $$ Map<Class<?>, Class<?>> cache = GENERATED_CLASSES.get(getClass())-->Line_117 $$ cache.put(subclass, subclass)[ FD ]
