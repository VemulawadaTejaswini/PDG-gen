Line_48 $$ if (value instanceof Float) -->Line_49 $$ final float v = ((Float) value).floatValue()[ CD ]
Line_37 $$ if (Double.isNaN(v)) -->Line_38 $$ newExpressionText.append("java.lang.Double.NaN")[ CD ]
Line_26 $$ if (token == currentToken) -->Line_64 $$ prevOperand = null[ CD ]
Line_26 $$ if (token == currentToken) -->Line_33 $$ if (value instanceof Long) [ CD ]
Line_40 $$ if (v > 0.0) -->Line_43 $$ newExpressionText.append("java.lang.Double.NEGATIVE_INFINITY")[ CD ]
Line_24 $$ for (PsiExpression operand : operands) -->Line_25 $$ final PsiJavaToken currentToken = polyadicExpression.getTokenBeforeOperand(operand)[ FD ]
Line_20 $$ final StringBuilder newExpressionText = new StringBuilder()-->Line_28 $$ newExpressionText.append(prevToken.getText())[ FD ]
Line_36 $$ final double v = ((Double) value).doubleValue()-->Line_37 $$ if (Double.isNaN(v)) [ FD ]
Line_20 $$ final StringBuilder newExpressionText = new StringBuilder()-->Line_41 $$ newExpressionText.append("java.lang.Double.POSITIVE_INFINITY")[ FD ]
Line_40 $$ if (v > 0.0) -->Line_41 $$ newExpressionText.append("java.lang.Double.POSITIVE_INFINITY")[ CD ]
Line_20 $$ final StringBuilder newExpressionText = new StringBuilder()-->Line_38 $$ newExpressionText.append("java.lang.Double.NaN")[ FD ]
Line_3 $$ final PsiJavaToken token-->Line_15 $$ final PsiPolyadicExpression subexpression = ConstantSubexpressionPredicate.getSubexpression(polyadicExpression, token)[ FD ]
Line_9 $$ token = (PsiJavaToken) prevSibling-->Line_26 $$ if (token == currentToken) [ FD ]
Line_22 $$ PsiExpression prevOperand = null-->Line_64 $$ prevOperand = null[ FD ]
Line_2 $$ public void processIntention(@NotNull PsiElement element) throws IncorrectOperationException -->Line_23 $$ PsiJavaToken prevToken = null[ CD ]
Line_23 $$ PsiJavaToken prevToken = null-->Line_68 $$ newExpressionText.append(prevToken.getText())[ FD ]
Line_64 $$ prevOperand = null-->Line_73 $$ prevOperand = operand[ FD ]
Line_37 $$ if (Double.isNaN(v)) -->Line_39 $$ if (Double.isInfinite(v)) [ CD ]
Line_3 $$ final PsiJavaToken token-->Line_5 $$ token = (PsiJavaToken) element[ FD ]
Line_77 $$ if (prevToken != null) -->Line_78 $$ newExpressionText.append(prevToken.getText())[ CD ]
Line_23 $$ PsiJavaToken prevToken = null-->Line_28 $$ newExpressionText.append(prevToken.getText())[ FD ]
Line_64 $$ prevOperand = null-->Line_70 $$ if (prevOperand != null) [ FD ]
Line_27 $$ if (prevToken != null) -->Line_28 $$ newExpressionText.append(prevToken.getText())[ CD ]
Line_19 $$ final Object value = ExpressionUtils.computeConstantExpression(subexpression)-->Line_35 $$ if (value instanceof Double) [ FD ]
Line_53 $$ if (v > 0.0F) -->Line_54 $$ newExpressionText.append("java.lang.Float.POSITIVE_INFINITY")[ CD ]
Line_35 $$ if (value instanceof Double) -->Line_36 $$ final double v = ((Double) value).doubleValue()[ CD ]
Line_80 $$ if (prevOperand != null) -->Line_81 $$ newExpressionText.append(prevOperand.getText())[ CD ]
Line_26 $$ if (token == currentToken) -->Line_65 $$ prevToken = null[ CD ]
Line_67 $$ if (prevToken != null) -->Line_68 $$ newExpressionText.append(prevToken.getText())[ CD ]
Line_22 $$ PsiExpression prevOperand = null-->Line_73 $$ prevOperand = operand[ FD ]
Line_65 $$ prevToken = null-->Line_77 $$ if (prevToken != null) [ FD ]
Line_36 $$ final double v = ((Double) value).doubleValue()-->Line_52 $$ if (Float.isInfinite(v)) [ FD ]
Line_20 $$ final StringBuilder newExpressionText = new StringBuilder()-->Line_83 $$ PsiReplacementUtil.replaceExpression(polyadicExpression, newExpressionText.toString())[ FD ]
Line_26 $$ if (token == currentToken) -->Line_73 $$ prevOperand = operand[ CD ]
Line_2 $$ public void processIntention(@NotNull PsiElement element) throws IncorrectOperationException -->Line_14 $$ final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression) element.getParent()[ FD ]
Line_26 $$ if (token == currentToken) -->Line_67 $$ if (prevToken != null) [ CD ]
Line_4 $$ if (element instanceof PsiJavaToken) -->Line_5 $$ token = (PsiJavaToken) element[ CD ]
Line_16 $$ if (subexpression == null) -->Line_17 $$ return[ CD ]
Line_36 $$ final double v = ((Double) value).doubleValue()-->Line_40 $$ if (v > 0.0) [ FD ]
Line_30 $$ if (newExpressionText.length() > 0) -->Line_31 $$ newExpressionText.append(' ')[ CD ]
Line_39 $$ if (Double.isInfinite(v)) -->Line_46 $$ newExpressionText.append(Double.toString(v))[ CD ]
Line_74 $$ prevToken = currentToken-->Line_77 $$ if (prevToken != null) [ FD ]
Line_20 $$ final StringBuilder newExpressionText = new StringBuilder()-->Line_31 $$ newExpressionText.append(' ')[ FD ]
Line_19 $$ final Object value = ExpressionUtils.computeConstantExpression(subexpression)-->Line_34 $$ newExpressionText.append(value).append('L')[ FD ]
Line_22 $$ PsiExpression prevOperand = null-->Line_81 $$ newExpressionText.append(prevOperand.getText())[ FD ]
Line_73 $$ prevOperand = operand-->Line_80 $$ if (prevOperand != null) [ FD ]
Line_24 $$ for (PsiExpression operand : operands) -->Line_73 $$ prevOperand = operand[ FD ]
Line_26 $$ if (token == currentToken) -->Line_27 $$ if (prevToken != null) [ CD ]
Line_73 $$ prevOperand = operand-->Line_81 $$ newExpressionText.append(prevOperand.getText())[ FD ]
Line_22 $$ PsiExpression prevOperand = null-->Line_80 $$ if (prevOperand != null) [ FD ]
Line_9 $$ token = (PsiJavaToken) prevSibling-->Line_15 $$ final PsiPolyadicExpression subexpression = ConstantSubexpressionPredicate.getSubexpression(polyadicExpression, token)[ FD ]
Line_50 $$ if (Float.isNaN(v)) -->Line_51 $$ newExpressionText.append("java.lang.Float.NaN")[ CD ]
Line_2 $$ public void processIntention(@NotNull PsiElement element) throws IncorrectOperationException -->Line_21 $$ final PsiExpression[] operands = polyadicExpression.getOperands()[ CD ]
Line_64 $$ prevOperand = null-->Line_81 $$ newExpressionText.append(prevOperand.getText())[ FD ]
Line_2 $$ public void processIntention(@NotNull PsiElement element) throws IncorrectOperationException -->Line_80 $$ if (prevOperand != null) [ CD ]
Line_2 $$ public void processIntention(@NotNull PsiElement element) throws IncorrectOperationException -->Line_14 $$ final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression) element.getParent()[ CD ]
Line_33 $$ if (value instanceof Long) -->Line_35 $$ if (value instanceof Double) [ CD ]
Line_65 $$ prevToken = null-->Line_68 $$ newExpressionText.append(prevToken.getText())[ FD ]
Line_52 $$ if (Float.isInfinite(v)) -->Line_53 $$ if (v > 0.0F) [ CD ]
Line_50 $$ if (Float.isNaN(v)) -->Line_52 $$ if (Float.isInfinite(v)) [ CD ]
Line_33 $$ if (value instanceof Long) -->Line_34 $$ newExpressionText.append(value).append('L')[ CD ]
Line_15 $$ final PsiPolyadicExpression subexpression = ConstantSubexpressionPredicate.getSubexpression(polyadicExpression, token)-->Line_16 $$ if (subexpression == null) [ FD ]
Line_5 $$ token = (PsiJavaToken) element-->Line_9 $$ token = (PsiJavaToken) prevSibling[ FD ]
Line_14 $$ final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression) element.getParent()-->Line_21 $$ final PsiExpression[] operands = polyadicExpression.getOperands()[ FD ]
Line_26 $$ if (token == currentToken) -->Line_70 $$ if (prevOperand != null) [ CD ]
Line_39 $$ if (Double.isInfinite(v)) -->Line_40 $$ if (v > 0.0) [ CD ]
Line_23 $$ PsiJavaToken prevToken = null-->Line_77 $$ if (prevToken != null) [ FD ]
Line_23 $$ PsiJavaToken prevToken = null-->Line_27 $$ if (prevToken != null) [ FD ]
Line_65 $$ prevToken = null-->Line_78 $$ newExpressionText.append(prevToken.getText())[ FD ]
Line_20 $$ final StringBuilder newExpressionText = new StringBuilder()-->Line_71 $$ newExpressionText.append(prevOperand.getText())[ FD ]
Line_64 $$ prevOperand = null-->Line_80 $$ if (prevOperand != null) [ FD ]
Line_20 $$ final StringBuilder newExpressionText = new StringBuilder()-->Line_46 $$ newExpressionText.append(Double.toString(v))[ FD ]
Line_2 $$ public void processIntention(@NotNull PsiElement element) throws IncorrectOperationException -->Line_20 $$ final StringBuilder newExpressionText = new StringBuilder()[ CD ]
Line_2 $$ public void processIntention(@NotNull PsiElement element) throws IncorrectOperationException -->Line_19 $$ final Object value = ExpressionUtils.computeConstantExpression(subexpression)[ CD ]
Line_3 $$ final PsiJavaToken token-->Line_26 $$ if (token == currentToken) [ FD ]
Line_20 $$ final StringBuilder newExpressionText = new StringBuilder()-->Line_43 $$ newExpressionText.append("java.lang.Double.NEGATIVE_INFINITY")[ FD ]
Line_64 $$ prevOperand = null-->Line_71 $$ newExpressionText.append(prevOperand.getText())[ FD ]
Line_36 $$ final double v = ((Double) value).doubleValue()-->Line_53 $$ if (v > 0.0F) [ FD ]
Line_20 $$ final StringBuilder newExpressionText = new StringBuilder()-->Line_68 $$ newExpressionText.append(prevToken.getText())[ FD ]
Line_2 $$ public void processIntention(@NotNull PsiElement element) throws IncorrectOperationException -->Line_4 $$ if (element instanceof PsiJavaToken) [ CD ]
Line_74 $$ prevToken = currentToken-->Line_78 $$ newExpressionText.append(prevToken.getText())[ FD ]
Line_23 $$ PsiJavaToken prevToken = null-->Line_74 $$ prevToken = currentToken[ FD ]
Line_2 $$ public void processIntention(@NotNull PsiElement element) throws IncorrectOperationException -->Line_4 $$ if (element instanceof PsiJavaToken) [ FD ]
Line_36 $$ final double v = ((Double) value).doubleValue()-->Line_46 $$ newExpressionText.append(Double.toString(v))[ FD ]
Line_36 $$ final double v = ((Double) value).doubleValue()-->Line_59 $$ newExpressionText.append(Float.toString(v)).append('f')[ FD ]
Line_20 $$ final StringBuilder newExpressionText = new StringBuilder()-->Line_59 $$ newExpressionText.append(Float.toString(v)).append('f')[ FD ]
Line_48 $$ if (value instanceof Float) -->Line_62 $$ newExpressionText.append(value)[ CD ]
Line_52 $$ if (Float.isInfinite(v)) -->Line_59 $$ newExpressionText.append(Float.toString(v)).append('f')[ CD ]
Line_70 $$ if (prevOperand != null) -->Line_71 $$ newExpressionText.append(prevOperand.getText())[ CD ]
Line_2 $$ public void processIntention(@NotNull PsiElement element) throws IncorrectOperationException -->Line_83 $$ PsiReplacementUtil.replaceExpression(polyadicExpression, newExpressionText.toString())[ CD ]
Line_23 $$ PsiJavaToken prevToken = null-->Line_78 $$ newExpressionText.append(prevToken.getText())[ FD ]
Line_25 $$ final PsiJavaToken currentToken = polyadicExpression.getTokenBeforeOperand(operand)-->Line_26 $$ if (token == currentToken) [ FD ]
Line_20 $$ final StringBuilder newExpressionText = new StringBuilder()-->Line_51 $$ newExpressionText.append("java.lang.Float.NaN")[ FD ]
Line_5 $$ token = (PsiJavaToken) element-->Line_15 $$ final PsiPolyadicExpression subexpression = ConstantSubexpressionPredicate.getSubexpression(polyadicExpression, token)[ FD ]
Line_4 $$ if (element instanceof PsiJavaToken) -->Line_8 $$ if (prevSibling instanceof PsiJavaToken) [ CD ]
Line_20 $$ final StringBuilder newExpressionText = new StringBuilder()-->Line_34 $$ newExpressionText.append(value).append('L')[ FD ]
Line_20 $$ final StringBuilder newExpressionText = new StringBuilder()-->Line_62 $$ newExpressionText.append(value)[ FD ]
Line_20 $$ final StringBuilder newExpressionText = new StringBuilder()-->Line_30 $$ if (newExpressionText.length() > 0) [ FD ]
Line_19 $$ final Object value = ExpressionUtils.computeConstantExpression(subexpression)-->Line_48 $$ if (value instanceof Float) [ FD ]
Line_23 $$ PsiJavaToken prevToken = null-->Line_65 $$ prevToken = null[ FD ]
Line_48 $$ if (value instanceof Float) -->Line_50 $$ if (Float.isNaN(v)) [ CD ]
Line_2 $$ public void processIntention(@NotNull PsiElement element) throws IncorrectOperationException -->Line_7 $$ final PsiElement prevSibling = element.getPrevSibling()[ FD ]
Line_2 $$ public void processIntention(@NotNull PsiElement element) throws IncorrectOperationException -->Line_3 $$ final PsiJavaToken token[ CD ]
Line_19 $$ final Object value = ExpressionUtils.computeConstantExpression(subexpression)-->Line_33 $$ if (value instanceof Long) [ FD ]
Line_26 $$ if (token == currentToken) -->Line_30 $$ if (newExpressionText.length() > 0) [ CD ]
Line_8 $$ if (prevSibling instanceof PsiJavaToken) -->Line_9 $$ token = (PsiJavaToken) prevSibling[ CD ]
Line_3 $$ final PsiJavaToken token-->Line_9 $$ token = (PsiJavaToken) prevSibling[ FD ]
Line_53 $$ if (v > 0.0F) -->Line_56 $$ newExpressionText.append("java.lang.Float.NEGATIVE_INFINITY")[ CD ]
Line_14 $$ final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression) element.getParent()-->Line_15 $$ final PsiPolyadicExpression subexpression = ConstantSubexpressionPredicate.getSubexpression(polyadicExpression, token)[ FD ]
Line_25 $$ final PsiJavaToken currentToken = polyadicExpression.getTokenBeforeOperand(operand)-->Line_74 $$ prevToken = currentToken[ FD ]
Line_23 $$ PsiJavaToken prevToken = null-->Line_67 $$ if (prevToken != null) [ FD ]
Line_20 $$ final StringBuilder newExpressionText = new StringBuilder()-->Line_81 $$ newExpressionText.append(prevOperand.getText())[ FD ]
Line_19 $$ final Object value = ExpressionUtils.computeConstantExpression(subexpression)-->Line_62 $$ newExpressionText.append(value)[ FD ]
Line_20 $$ final StringBuilder newExpressionText = new StringBuilder()-->Line_56 $$ newExpressionText.append("java.lang.Float.NEGATIVE_INFINITY")[ FD ]
Line_5 $$ token = (PsiJavaToken) element-->Line_26 $$ if (token == currentToken) [ FD ]
Line_2 $$ public void processIntention(@NotNull PsiElement element) throws IncorrectOperationException -->Line_16 $$ if (subexpression == null) [ CD ]
Line_2 $$ public void processIntention(@NotNull PsiElement element) throws IncorrectOperationException -->Line_15 $$ final PsiPolyadicExpression subexpression = ConstantSubexpressionPredicate.getSubexpression(polyadicExpression, token)[ CD ]
Line_2 $$ public void processIntention(@NotNull PsiElement element) throws IncorrectOperationException -->Line_77 $$ if (prevToken != null) [ CD ]
Line_22 $$ PsiExpression prevOperand = null-->Line_70 $$ if (prevOperand != null) [ FD ]
Line_22 $$ PsiExpression prevOperand = null-->Line_71 $$ newExpressionText.append(prevOperand.getText())[ FD ]
Line_2 $$ public void processIntention(@NotNull PsiElement element) throws IncorrectOperationException -->Line_22 $$ PsiExpression prevOperand = null[ CD ]
Line_14 $$ final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression) element.getParent()-->Line_83 $$ PsiReplacementUtil.replaceExpression(polyadicExpression, newExpressionText.toString())[ FD ]
Line_20 $$ final StringBuilder newExpressionText = new StringBuilder()-->Line_54 $$ newExpressionText.append("java.lang.Float.POSITIVE_INFINITY")[ FD ]
Line_15 $$ final PsiPolyadicExpression subexpression = ConstantSubexpressionPredicate.getSubexpression(polyadicExpression, token)-->Line_19 $$ final Object value = ExpressionUtils.computeConstantExpression(subexpression)[ FD ]
Line_65 $$ prevToken = null-->Line_67 $$ if (prevToken != null) [ FD ]
Line_35 $$ if (value instanceof Double) -->Line_48 $$ if (value instanceof Float) [ CD ]
Line_35 $$ if (value instanceof Double) -->Line_37 $$ if (Double.isNaN(v)) [ CD ]
Line_20 $$ final StringBuilder newExpressionText = new StringBuilder()-->Line_78 $$ newExpressionText.append(prevToken.getText())[ FD ]
Line_4 $$ if (element instanceof PsiJavaToken) -->Line_7 $$ final PsiElement prevSibling = element.getPrevSibling()[ CD ]
Line_36 $$ final double v = ((Double) value).doubleValue()-->Line_39 $$ if (Double.isInfinite(v)) [ FD ]
Line_36 $$ final double v = ((Double) value).doubleValue()-->Line_50 $$ if (Float.isNaN(v)) [ FD ]
Line_26 $$ if (token == currentToken) -->Line_74 $$ prevToken = currentToken[ CD ]
Line_65 $$ prevToken = null-->Line_74 $$ prevToken = currentToken[ FD ]
Line_7 $$ final PsiElement prevSibling = element.getPrevSibling()-->Line_8 $$ if (prevSibling instanceof PsiJavaToken) [ FD ]
Line_14 $$ final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression) element.getParent()-->Line_25 $$ final PsiJavaToken currentToken = polyadicExpression.getTokenBeforeOperand(operand)[ FD ]
