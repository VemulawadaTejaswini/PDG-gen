Line_19 $$ offset = i-->Line_11 $$ part = Arrays.copyOfRange(coordinates, offset, i + 1)[ FD ]
Line_3 $$ int offset = 0-->Line_26 $$ if (offset < coordinates.length - 1) [ FD ]
Line_11 $$ part = Arrays.copyOfRange(coordinates, offset, i + 1)-->Line_28 $$ parts.add(shift(shift, part))[ FD ]
Line_9 $$ Coordinate[] part-->Line_28 $$ parts.add(shift(shift, part))[ FD ]
Line_2 $$ private static Coordinate[][] decompose(double dateline, Coordinate[] coordinates) -->Line_18 $$ part = shift(shift, Arrays.copyOfRange(coordinates, offset, i + 1))[ FD ]
Line_11 $$ part = Arrays.copyOfRange(coordinates, offset, i + 1)-->Line_21 $$ parts.add(part)[ FD ]
Line_18 $$ part = shift(shift, Arrays.copyOfRange(coordinates, offset, i + 1))-->Line_28 $$ parts.add(shift(shift, part))[ FD ]
Line_5 $$ double shift = coordinates[0].x > DATELINE ? DATELINE : (coordinates[0].x < -DATELINE ? -DATELINE : 0)-->Line_28 $$ parts.add(shift(shift, part))[ FD ]
Line_2 $$ private static Coordinate[][] decompose(double dateline, Coordinate[] coordinates) -->Line_3 $$ int offset = 0[ CD ]
Line_5 $$ double shift = coordinates[0].x > DATELINE ? DATELINE : (coordinates[0].x < -DATELINE ? -DATELINE : 0)-->Line_18 $$ part = shift(shift, Arrays.copyOfRange(coordinates, offset, i + 1))[ FD ]
Line_16 $$ shift = coordinates[i].x > DATELINE ? DATELINE : (coordinates[i].x < -DATELINE ? -DATELINE : 0)-->Line_14 $$ shift(shift, part)[ FD ]
Line_8 $$ if (!Double.isNaN(t)) -->Line_10 $$ if (t < 1) [ CD ]
Line_10 $$ if (t < 1) -->Line_11 $$ part = Arrays.copyOfRange(coordinates, offset, i + 1)[ CD ]
Line_6 $$ for (int i = 1; i < coordinates.length; i++) -->Line_7 $$ double t = intersection(coordinates[i - 1], coordinates[i], dateline)[ CD ]
Line_4 $$ ArrayList<Coordinate[]> parts = new ArrayList()-->Line_25 $$ parts.add(shift(shift, coordinates))[ FD ]
Line_19 $$ offset = i-->Line_18 $$ part = shift(shift, Arrays.copyOfRange(coordinates, offset, i + 1))[ FD ]
Line_2 $$ private static Coordinate[][] decompose(double dateline, Coordinate[] coordinates) -->Line_27 $$ Coordinate[] part = Arrays.copyOfRange(coordinates, offset, coordinates.length)[ FD ]
Line_7 $$ double t = intersection(coordinates[i - 1], coordinates[i], dateline)-->Line_10 $$ if (t < 1) [ FD ]
Line_2 $$ private static Coordinate[][] decompose(double dateline, Coordinate[] coordinates) -->Line_5 $$ double shift = coordinates[0].x > DATELINE ? DATELINE : (coordinates[0].x < -DATELINE ? -DATELINE : 0)[ CD ]
Line_3 $$ int offset = 0-->Line_18 $$ part = shift(shift, Arrays.copyOfRange(coordinates, offset, i + 1))[ FD ]
Line_2 $$ private static Coordinate[][] decompose(double dateline, Coordinate[] coordinates) -->Line_7 $$ double t = intersection(coordinates[i - 1], coordinates[i], dateline)[ FD ]
Line_2 $$ private static Coordinate[][] decompose(double dateline, Coordinate[] coordinates) -->Line_25 $$ parts.add(shift(shift, coordinates))[ FD ]
Line_6 $$ for (int i = 1; i < coordinates.length; i++) -->Line_19 $$ offset = i[ FD ]
Line_9 $$ Coordinate[] part-->Line_18 $$ part = shift(shift, Arrays.copyOfRange(coordinates, offset, i + 1))[ FD ]
Line_2 $$ private static Coordinate[][] decompose(double dateline, Coordinate[] coordinates) -->Line_6 $$ for (int i = 1; i < coordinates.length; i++) [ CD ]
Line_26 $$ if (offset < coordinates.length - 1) -->Line_27 $$ Coordinate[] part = Arrays.copyOfRange(coordinates, offset, coordinates.length)[ CD ]
Line_7 $$ double t = intersection(coordinates[i - 1], coordinates[i], dateline)-->Line_13 $$ coordinates[offset + i - 1] = Edge.position(coordinates[i - 1], coordinates[i], t)[ FD ]
Line_8 $$ if (!Double.isNaN(t)) -->Line_21 $$ parts.add(part)[ CD ]
Line_24 $$ if (offset == 0) -->Line_25 $$ parts.add(shift(shift, coordinates))[ CD ]
Line_5 $$ double shift = coordinates[0].x > DATELINE ? DATELINE : (coordinates[0].x < -DATELINE ? -DATELINE : 0)-->Line_25 $$ parts.add(shift(shift, coordinates))[ FD ]
Line_15 $$ offset = i - 1-->Line_19 $$ offset = i[ FD ]
Line_10 $$ if (t < 1) -->Line_15 $$ offset = i - 1[ CD ]
Line_16 $$ shift = coordinates[i].x > DATELINE ? DATELINE : (coordinates[i].x < -DATELINE ? -DATELINE : 0)-->Line_18 $$ part = shift(shift, Arrays.copyOfRange(coordinates, offset, i + 1))[ FD ]
Line_8 $$ if (!Double.isNaN(t)) -->Line_9 $$ Coordinate[] part[ CD ]
Line_10 $$ if (t < 1) -->Line_12 $$ part[part.length - 1] = Edge.position(coordinates[i - 1], coordinates[i], t)[ CD ]
Line_27 $$ Coordinate[] part = Arrays.copyOfRange(coordinates, offset, coordinates.length)-->Line_28 $$ parts.add(shift(shift, part))[ FD ]
Line_3 $$ int offset = 0-->Line_19 $$ offset = i[ FD ]
Line_15 $$ offset = i - 1-->Line_24 $$ if (offset == 0) [ FD ]
Line_2 $$ private static Coordinate[][] decompose(double dateline, Coordinate[] coordinates) -->Line_4 $$ ArrayList<Coordinate[]> parts = new ArrayList()[ CD ]
Line_7 $$ double t = intersection(coordinates[i - 1], coordinates[i], dateline)-->Line_8 $$ if (!Double.isNaN(t)) [ FD ]
Line_9 $$ Coordinate[] part-->Line_11 $$ part = Arrays.copyOfRange(coordinates, offset, i + 1)[ FD ]
Line_4 $$ ArrayList<Coordinate[]> parts = new ArrayList()-->Line_28 $$ parts.add(shift(shift, part))[ FD ]
Line_18 $$ part = shift(shift, Arrays.copyOfRange(coordinates, offset, i + 1))-->Line_14 $$ shift(shift, part)[ FD ]
Line_10 $$ if (t < 1) -->Line_14 $$ shift(shift, part)[ CD ]
Line_10 $$ if (t < 1) -->Line_19 $$ offset = i[ CD ]
Line_10 $$ if (t < 1) -->Line_16 $$ shift = coordinates[i].x > DATELINE ? DATELINE : (coordinates[i].x < -DATELINE ? -DATELINE : 0)[ CD ]
Line_2 $$ private static Coordinate[][] decompose(double dateline, Coordinate[] coordinates) -->Line_30 $$ return parts.toArray(new Coordinate[parts.size()][])[ CD ]
Line_15 $$ offset = i - 1-->Line_18 $$ part = shift(shift, Arrays.copyOfRange(coordinates, offset, i + 1))[ FD ]
Line_9 $$ Coordinate[] part-->Line_14 $$ shift(shift, part)[ FD ]
Line_5 $$ double shift = coordinates[0].x > DATELINE ? DATELINE : (coordinates[0].x < -DATELINE ? -DATELINE : 0)-->Line_16 $$ shift = coordinates[i].x > DATELINE ? DATELINE : (coordinates[i].x < -DATELINE ? -DATELINE : 0)[ FD ]
Line_16 $$ shift = coordinates[i].x > DATELINE ? DATELINE : (coordinates[i].x < -DATELINE ? -DATELINE : 0)-->Line_25 $$ parts.add(shift(shift, coordinates))[ FD ]
Line_3 $$ int offset = 0-->Line_11 $$ part = Arrays.copyOfRange(coordinates, offset, i + 1)[ FD ]
Line_15 $$ offset = i - 1-->Line_11 $$ part = Arrays.copyOfRange(coordinates, offset, i + 1)[ FD ]
Line_4 $$ ArrayList<Coordinate[]> parts = new ArrayList()-->Line_21 $$ parts.add(part)[ FD ]
Line_11 $$ part = Arrays.copyOfRange(coordinates, offset, i + 1)-->Line_18 $$ part = shift(shift, Arrays.copyOfRange(coordinates, offset, i + 1))[ FD ]
Line_10 $$ if (t < 1) -->Line_18 $$ part = shift(shift, Arrays.copyOfRange(coordinates, offset, i + 1))[ CD ]
Line_5 $$ double shift = coordinates[0].x > DATELINE ? DATELINE : (coordinates[0].x < -DATELINE ? -DATELINE : 0)-->Line_14 $$ shift(shift, part)[ FD ]
Line_2 $$ private static Coordinate[][] decompose(double dateline, Coordinate[] coordinates) -->Line_11 $$ part = Arrays.copyOfRange(coordinates, offset, i + 1)[ FD ]
Line_26 $$ if (offset < coordinates.length - 1) -->Line_28 $$ parts.add(shift(shift, part))[ CD ]
Line_19 $$ offset = i-->Line_26 $$ if (offset < coordinates.length - 1) [ FD ]
Line_18 $$ part = shift(shift, Arrays.copyOfRange(coordinates, offset, i + 1))-->Line_21 $$ parts.add(part)[ FD ]
Line_15 $$ offset = i - 1-->Line_27 $$ Coordinate[] part = Arrays.copyOfRange(coordinates, offset, coordinates.length)[ FD ]
Line_6 $$ for (int i = 1; i < coordinates.length; i++) -->Line_8 $$ if (!Double.isNaN(t)) [ CD ]
Line_7 $$ double t = intersection(coordinates[i - 1], coordinates[i], dateline)-->Line_12 $$ part[part.length - 1] = Edge.position(coordinates[i - 1], coordinates[i], t)[ FD ]
Line_24 $$ if (offset == 0) -->Line_26 $$ if (offset < coordinates.length - 1) [ CD ]
Line_19 $$ offset = i-->Line_27 $$ Coordinate[] part = Arrays.copyOfRange(coordinates, offset, coordinates.length)[ FD ]
Line_9 $$ Coordinate[] part-->Line_21 $$ parts.add(part)[ FD ]
Line_3 $$ int offset = 0-->Line_27 $$ Coordinate[] part = Arrays.copyOfRange(coordinates, offset, coordinates.length)[ FD ]
Line_10 $$ if (t < 1) -->Line_13 $$ coordinates[offset + i - 1] = Edge.position(coordinates[i - 1], coordinates[i], t)[ CD ]
Line_2 $$ private static Coordinate[][] decompose(double dateline, Coordinate[] coordinates) -->Line_24 $$ if (offset == 0) [ CD ]
Line_3 $$ int offset = 0-->Line_24 $$ if (offset == 0) [ FD ]
Line_16 $$ shift = coordinates[i].x > DATELINE ? DATELINE : (coordinates[i].x < -DATELINE ? -DATELINE : 0)-->Line_28 $$ parts.add(shift(shift, part))[ FD ]
Line_11 $$ part = Arrays.copyOfRange(coordinates, offset, i + 1)-->Line_14 $$ shift(shift, part)[ FD ]
Line_15 $$ offset = i - 1-->Line_26 $$ if (offset < coordinates.length - 1) [ FD ]
Line_19 $$ offset = i-->Line_24 $$ if (offset == 0) [ FD ]
Line_3 $$ int offset = 0-->Line_15 $$ offset = i - 1[ FD ]
Line_4 $$ ArrayList<Coordinate[]> parts = new ArrayList()-->Line_30 $$ return parts.toArray(new Coordinate[parts.size()][])[ FD ]
Line_6 $$ for (int i = 1; i < coordinates.length; i++) -->Line_15 $$ offset = i - 1[ FD ]
