Line_34 $$ RecordReader<Text, Text> reader = format.getRecordReader(splits[j], job, reporter)-->Line_49 $$ LOG.warn("conflict with " + v + " in split " + j + " at position " + reader.getPos())[ FD ]
Line_15 $$ for (int i = 0; i < length; i++) -->Line_16 $$ writer.write(Integer.toString(i * 2))[ CD ]
Line_38 $$ Class keyClass = key.getClass()-->Line_41 $$ assertEquals("Key class is Text.", Text.class, keyClass)[ FD ]
Line_13 $$ Writer writer = new OutputStreamWriter(localFs.create(file))-->Line_16 $$ writer.write(Integer.toString(i * 2))[ FD ]
Line_40 $$ Class valueClass = value.getClass()-->Line_42 $$ assertEquals("Value class is Text.", Text.class, valueClass)[ FD ]
Line_15 $$ for (int i = 0; i < length; i++) -->Line_26 $$ for (int i = 0; i < 3; i++) [ FD ]
Line_32 $$ for (int j = 0; j < splits.length; j++) -->Line_37 $$ Text key = reader.createKey()[ CD ]
Line_45 $$ while (reader.next(key, value)) -->Line_51 $$ assertFalse("Key in multiple partitions.", bits.get(v))[ CD ]
Line_39 $$ Text value = reader.createValue()-->Line_40 $$ Class valueClass = value.getClass()[ FD ]
Line_34 $$ RecordReader<Text, Text> reader = format.getRecordReader(splits[j], job, reporter)-->Line_35 $$ Class readerClass = reader.getClass()[ FD ]
Line_32 $$ for (int j = 0; j < splits.length; j++) -->Line_33 $$ LOG.debug("split[" + j + "]= " + splits[j])[ CD ]
Line_34 $$ RecordReader<Text, Text> reader = format.getRecordReader(splits[j], job, reporter)-->Line_39 $$ Text value = reader.createValue()[ FD ]
Line_4 $$ Path file = new Path(workDir, "test.txt")-->Line_13 $$ Writer writer = new OutputStreamWriter(localFs.create(file))[ FD ]
Line_13 $$ Writer writer = new OutputStreamWriter(localFs.create(file))-->Line_19 $$ writer.write("\n")[ FD ]
Line_11 $$ for (int length = 0; length < MAX_LENGTH; length += random.nextInt(MAX_LENGTH / 10) + 1) -->Line_60 $$ assertEquals("Some keys in no partition.", length, bits.cardinality())[ FD ]
Line_3 $$ JobConf job = new JobConf()-->Line_34 $$ RecordReader<Text, Text> reader = format.getRecordReader(splits[j], job, reporter)[ FD ]
Line_2 $$ public void testFormat() throws Exception -->Line_10 $$ FileInputFormat.setInputPaths(job, workDir)[ CD ]
Line_46 $$ int v = Integer.parseInt(value.toString())-->Line_52 $$ bits.set(v)[ FD ]
Line_2 $$ public void testFormat() throws Exception -->Line_9 $$ localFs.delete(workDir, true)[ CD ]
Line_2 $$ public void testFormat() throws Exception -->Line_5 $$ Reporter reporter = Reporter.NULL[ CD ]
Line_45 $$ while (reader.next(key, value)) -->Line_52 $$ bits.set(v)[ CD ]
Line_31 $$ BitSet bits = new BitSet(length)-->Line_52 $$ bits.set(v)[ FD ]
Line_26 $$ for (int i = 0; i < 3; i++) -->Line_27 $$ int numSplits = random.nextInt(MAX_LENGTH / 20) + 1[ CD ]
Line_15 $$ for (int i = 0; i < length; i++) -->Line_18 $$ writer.write(Integer.toString(i))[ FD ]
Line_35 $$ Class readerClass = reader.getClass()-->Line_36 $$ assertEquals("reader class is KeyValueLineRecordReader.", KeyValueLineRecordReader.class, readerClass)[ FD ]
Line_32 $$ for (int j = 0; j < splits.length; j++) -->Line_38 $$ Class keyClass = key.getClass()[ CD ]
Line_44 $$ int count = 0-->Line_53 $$ count++[ FD ]
Line_31 $$ BitSet bits = new BitSet(length)-->Line_48 $$ if (bits.get(v)) [ FD ]
Line_46 $$ int v = Integer.parseInt(value.toString())-->Line_48 $$ if (bits.get(v)) [ FD ]
Line_26 $$ for (int i = 0; i < 3; i++) -->Line_31 $$ BitSet bits = new BitSet(length)[ CD ]
Line_45 $$ while (reader.next(key, value)) -->Line_48 $$ if (bits.get(v)) [ CD ]
Line_11 $$ for (int length = 0; length < MAX_LENGTH; length += random.nextInt(MAX_LENGTH / 10) + 1) -->Line_12 $$ LOG.debug("creating; entries = " + length)[ CD ]
Line_32 $$ for (int j = 0; j < splits.length; j++) -->Line_34 $$ RecordReader<Text, Text> reader = format.getRecordReader(splits[j], job, reporter)[ CD ]
Line_8 $$ Random random = new Random(seed)-->Line_27 $$ int numSplits = random.nextInt(MAX_LENGTH / 20) + 1[ FD ]
Line_48 $$ if (bits.get(v)) -->Line_49 $$ LOG.warn("conflict with " + v + " in split " + j + " at position " + reader.getPos())[ CD ]
Line_2 $$ public void testFormat() throws Exception -->Line_7 $$ LOG.info("seed = " + seed)[ CD ]
Line_46 $$ int v = Integer.parseInt(value.toString())-->Line_51 $$ assertFalse("Key in multiple partitions.", bits.get(v))[ FD ]
Line_13 $$ Writer writer = new OutputStreamWriter(localFs.create(file))-->Line_17 $$ writer.write("\t")[ FD ]
Line_32 $$ for (int j = 0; j < splits.length; j++) -->Line_40 $$ Class valueClass = value.getClass()[ CD ]
Line_45 $$ while (reader.next(key, value)) -->Line_47 $$ LOG.debug("read " + v)[ CD ]
Line_31 $$ BitSet bits = new BitSet(length)-->Line_60 $$ assertEquals("Some keys in no partition.", length, bits.cardinality())[ FD ]
Line_34 $$ RecordReader<Text, Text> reader = format.getRecordReader(splits[j], job, reporter)-->Line_57 $$ reader.close()[ FD ]
Line_39 $$ Text value = reader.createValue()-->Line_45 $$ while (reader.next(key, value)) [ FD ]
Line_32 $$ for (int j = 0; j < splits.length; j++) -->Line_41 $$ assertEquals("Key class is Text.", Text.class, keyClass)[ CD ]
Line_2 $$ public void testFormat() throws Exception -->Line_6 $$ int seed = new Random().nextInt()[ CD ]
Line_15 $$ for (int i = 0; i < length; i++) -->Line_19 $$ writer.write("\n")[ CD ]
Line_11 $$ for (int length = 0; length < MAX_LENGTH; length += random.nextInt(MAX_LENGTH / 10) + 1) -->Line_15 $$ for (int i = 0; i < length; i++) [ FD ]
Line_2 $$ public void testFormat() throws Exception -->Line_8 $$ Random random = new Random(seed)[ CD ]
Line_26 $$ for (int i = 0; i < 3; i++) -->Line_29 $$ InputSplit[] splits = format.getSplits(job, numSplits)[ CD ]
Line_3 $$ JobConf job = new JobConf()-->Line_25 $$ format.configure(job)[ FD ]
Line_37 $$ Text key = reader.createKey()-->Line_45 $$ while (reader.next(key, value)) [ FD ]
Line_15 $$ for (int i = 0; i < length; i++) -->Line_17 $$ writer.write("\t")[ CD ]
Line_8 $$ Random random = new Random(seed)-->Line_11 $$ for (int length = 0; length < MAX_LENGTH; length += random.nextInt(MAX_LENGTH / 10) + 1) [ FD ]
Line_2 $$ public void testFormat() throws Exception -->Line_11 $$ for (int length = 0; length < MAX_LENGTH; length += random.nextInt(MAX_LENGTH / 10) + 1) [ CD ]
Line_3 $$ JobConf job = new JobConf()-->Line_29 $$ InputSplit[] splits = format.getSplits(job, numSplits)[ FD ]
Line_45 $$ while (reader.next(key, value)) -->Line_46 $$ int v = Integer.parseInt(value.toString())[ CD ]
Line_11 $$ for (int length = 0; length < MAX_LENGTH; length += random.nextInt(MAX_LENGTH / 10) + 1) -->Line_13 $$ Writer writer = new OutputStreamWriter(localFs.create(file))[ CD ]
Line_11 $$ for (int length = 0; length < MAX_LENGTH; length += random.nextInt(MAX_LENGTH / 10) + 1) -->Line_25 $$ format.configure(job)[ CD ]
Line_13 $$ Writer writer = new OutputStreamWriter(localFs.create(file))-->Line_22 $$ writer.close()[ FD ]
Line_13 $$ Writer writer = new OutputStreamWriter(localFs.create(file))-->Line_18 $$ writer.write(Integer.toString(i))[ FD ]
Line_31 $$ BitSet bits = new BitSet(length)-->Line_51 $$ assertFalse("Key in multiple partitions.", bits.get(v))[ FD ]
Line_5 $$ Reporter reporter = Reporter.NULL-->Line_34 $$ RecordReader<Text, Text> reader = format.getRecordReader(splits[j], job, reporter)[ FD ]
Line_2 $$ public void testFormat() throws Exception -->Line_3 $$ JobConf job = new JobConf()[ CD ]
Line_32 $$ for (int j = 0; j < splits.length; j++) -->Line_42 $$ assertEquals("Value class is Text.", Text.class, valueClass)[ CD ]
Line_3 $$ JobConf job = new JobConf()-->Line_10 $$ FileInputFormat.setInputPaths(job, workDir)[ FD ]
Line_26 $$ for (int i = 0; i < 3; i++) -->Line_32 $$ for (int j = 0; j < splits.length; j++) [ CD ]
Line_32 $$ for (int j = 0; j < splits.length; j++) -->Line_36 $$ assertEquals("reader class is KeyValueLineRecordReader.", KeyValueLineRecordReader.class, readerClass)[ CD ]
Line_37 $$ Text key = reader.createKey()-->Line_38 $$ Class keyClass = key.getClass()[ FD ]
Line_26 $$ for (int i = 0; i < 3; i++) -->Line_60 $$ assertEquals("Some keys in no partition.", length, bits.cardinality())[ CD ]
Line_11 $$ for (int length = 0; length < MAX_LENGTH; length += random.nextInt(MAX_LENGTH / 10) + 1) -->Line_26 $$ for (int i = 0; i < 3; i++) [ CD ]
Line_34 $$ RecordReader<Text, Text> reader = format.getRecordReader(splits[j], job, reporter)-->Line_37 $$ Text key = reader.createKey()[ FD ]
Line_26 $$ for (int i = 0; i < 3; i++) -->Line_28 $$ LOG.debug("splitting: requesting = " + numSplits)[ CD ]
Line_32 $$ for (int j = 0; j < splits.length; j++) -->Line_35 $$ Class readerClass = reader.getClass()[ CD ]
Line_27 $$ int numSplits = random.nextInt(MAX_LENGTH / 20) + 1-->Line_29 $$ InputSplit[] splits = format.getSplits(job, numSplits)[ FD ]
Line_45 $$ while (reader.next(key, value)) -->Line_53 $$ count++[ CD ]
Line_2 $$ public void testFormat() throws Exception -->Line_4 $$ Path file = new Path(workDir, "test.txt")[ CD ]
Line_39 $$ Text value = reader.createValue()-->Line_46 $$ int v = Integer.parseInt(value.toString())[ FD ]
Line_15 $$ for (int i = 0; i < length; i++) -->Line_18 $$ writer.write(Integer.toString(i))[ CD ]
Line_32 $$ for (int j = 0; j < splits.length; j++) -->Line_39 $$ Text value = reader.createValue()[ CD ]
Line_26 $$ for (int i = 0; i < 3; i++) -->Line_30 $$ LOG.debug("splitting: got =        " + splits.length)[ CD ]
Line_34 $$ RecordReader<Text, Text> reader = format.getRecordReader(splits[j], job, reporter)-->Line_45 $$ while (reader.next(key, value)) [ FD ]
