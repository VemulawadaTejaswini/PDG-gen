Line_36 $$ raf = new RandomAccessFile(sstable.getFilename(), "rw")-->Line_38 $$ assertTrue(raf.length() > corruptionSize)[ FD ]
Line_14 $$ for (int j = 0; j < SSTABLES; j++) -->Line_22 $$ cfs.forceBlockingFlush()[ CD ]
Line_6 $$ final int ROWS_PER_SSTABLE = 10-->Line_15 $$ for (int i = 0; i < ROWS_PER_SSTABLE; i++) [ FD ]
Line_16 $$ DecoratedKey key = Util.dk(String.valueOf(i))-->Line_18 $$ new RowUpdateBuilder(cfs.metadata, timestamp, key.getKey()).clustering("cols" + "i").add("val", "val" + i).build().applyUnsafe()[ FD ]
Line_36 $$ raf = new RandomAccessFile(sstable.getFilename(), "rw")-->Line_44 $$ raf.write(corruption)[ FD ]
Line_5 $$ final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("Standard1")-->Line_26 $$ Collection<SSTableReader> sstables = cfs.getLiveSSTables()[ FD ]
Line_5 $$ final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("Standard1")-->Line_54 $$ cfs.forceMajorCompaction()[ FD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_6 $$ final int ROWS_PER_SSTABLE = 10[ CD ]
Line_33 $$ RandomAccessFile raf = null-->Line_44 $$ raf.write(corruption)[ FD ]
Line_17 $$ long timestamp = j * ROWS_PER_SSTABLE + i-->Line_19 $$ maxTimestampExpected = Math.max(timestamp, maxTimestampExpected)[ FD ]
Line_33 $$ RandomAccessFile raf = null-->Line_38 $$ assertTrue(raf.length() > corruptionSize)[ FD ]
Line_15 $$ for (int i = 0; i < ROWS_PER_SSTABLE; i++) -->Line_20 $$ inserted.add(key)[ CD ]
Line_14 $$ for (int j = 0; j < SSTABLES; j++) -->Line_23 $$ CompactionsTest.assertMaxTimestamp(cfs, maxTimestampExpected)[ CD ]
Line_15 $$ for (int i = 0; i < ROWS_PER_SSTABLE; i++) -->Line_16 $$ DecoratedKey key = Util.dk(String.valueOf(i))[ FD ]
Line_5 $$ final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("Standard1")-->Line_24 $$ assertEquals(inserted.toString(), inserted.size(), Util.getAll(Util.cmd(cfs).build()).size())[ FD ]
Line_16 $$ DecoratedKey key = Util.dk(String.valueOf(i))-->Line_20 $$ inserted.add(key)[ FD ]
Line_5 $$ final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("Standard1")-->Line_64 $$ cfs.truncateBlocking()[ FD ]
Line_15 $$ for (int i = 0; i < ROWS_PER_SSTABLE; i++) -->Line_16 $$ DecoratedKey key = Util.dk(String.valueOf(i))[ CD ]
Line_7 $$ final int SSTABLES = cfs.metadata.params.minIndexInterval * 2 / ROWS_PER_SSTABLE-->Line_14 $$ for (int j = 0; j < SSTABLES; j++) [ FD ]
Line_13 $$ Set<DecoratedKey> inserted = new HashSet()-->Line_20 $$ inserted.add(key)[ FD ]
Line_27 $$ int currentSSTable = 0-->Line_48 $$ currentSSTable++[ FD ]
Line_15 $$ for (int i = 0; i < ROWS_PER_SSTABLE; i++) -->Line_18 $$ new RowUpdateBuilder(cfs.metadata, timestamp, key.getKey()).clustering("cols" + "i").add("val", "val" + i).build().applyUnsafe()[ CD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_26 $$ Collection<SSTableReader> sstables = cfs.getLiveSSTables()[ CD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_7 $$ final int SSTABLES = cfs.metadata.params.minIndexInterval * 2 / ROWS_PER_SSTABLE[ CD ]
Line_5 $$ final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("Standard1")-->Line_22 $$ cfs.forceBlockingFlush()[ FD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_5 $$ final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("Standard1")[ CD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_50 $$ int failures = 0[ CD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_28 $$ int sstablesToCorrupt = 8[ CD ]
Line_36 $$ raf = new RandomAccessFile(sstable.getFilename(), "rw")-->Line_37 $$ assertNotNull(raf)[ FD ]
Line_15 $$ for (int i = 0; i < ROWS_PER_SSTABLE; i++) -->Line_17 $$ long timestamp = j * ROWS_PER_SSTABLE + i[ CD ]
Line_19 $$ maxTimestampExpected = Math.max(timestamp, maxTimestampExpected)-->Line_23 $$ CompactionsTest.assertMaxTimestamp(cfs, maxTimestampExpected)[ FD ]
Line_13 $$ Set<DecoratedKey> inserted = new HashSet()-->Line_24 $$ assertEquals(inserted.toString(), inserted.size(), Util.getAll(Util.cmd(cfs).build()).size())[ FD ]
Line_36 $$ raf = new RandomAccessFile(sstable.getFilename(), "rw")-->Line_39 $$ raf.seek(new Random().nextInt((int) (raf.length() - corruptionSize)))[ FD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_65 $$ assertEquals(sstablesToCorrupt, failures)[ CD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_13 $$ Set<DecoratedKey> inserted = new HashSet()[ CD ]
Line_36 $$ raf = new RandomAccessFile(sstable.getFilename(), "rw")-->Line_46 $$ FileUtils.closeQuietly(raf)[ FD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_64 $$ cfs.truncateBlocking()[ CD ]
Line_5 $$ final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("Standard1")-->Line_23 $$ CompactionsTest.assertMaxTimestamp(cfs, maxTimestampExpected)[ FD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_27 $$ int currentSSTable = 0[ CD ]
Line_33 $$ RandomAccessFile raf = null-->Line_39 $$ raf.seek(new Random().nextInt((int) (raf.length() - corruptionSize)))[ FD ]
Line_28 $$ int sstablesToCorrupt = 8-->Line_31 $$ if (currentSSTable + 1 > sstablesToCorrupt)[ FD ]
Line_50 $$ int failures = 0-->Line_65 $$ assertEquals(sstablesToCorrupt, failures)[ FD ]
Line_14 $$ for (int j = 0; j < SSTABLES; j++) -->Line_15 $$ for (int i = 0; i < ROWS_PER_SSTABLE; i++) [ CD ]
Line_33 $$ RandomAccessFile raf = null-->Line_37 $$ assertNotNull(raf)[ FD ]
Line_33 $$ RandomAccessFile raf = null-->Line_46 $$ FileUtils.closeQuietly(raf)[ FD ]
Line_33 $$ RandomAccessFile raf = null-->Line_36 $$ raf = new RandomAccessFile(sstable.getFilename(), "rw")[ FD ]
Line_14 $$ for (int j = 0; j < SSTABLES; j++) -->Line_24 $$ assertEquals(inserted.toString(), inserted.size(), Util.getAll(Util.cmd(cfs).build()).size())[ CD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_14 $$ for (int j = 0; j < SSTABLES; j++) [ CD ]
Line_50 $$ int failures = 0-->Line_59 $$ failures++[ FD ]
Line_28 $$ int sstablesToCorrupt = 8-->Line_65 $$ assertEquals(sstablesToCorrupt, failures)[ FD ]
Line_15 $$ for (int i = 0; i < ROWS_PER_SSTABLE; i++) -->Line_19 $$ maxTimestampExpected = Math.max(timestamp, maxTimestampExpected)[ CD ]
