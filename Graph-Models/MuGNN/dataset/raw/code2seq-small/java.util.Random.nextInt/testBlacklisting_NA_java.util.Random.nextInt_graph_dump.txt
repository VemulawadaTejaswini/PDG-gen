Line_10 $$ for (int j = 0; j < SSTABLES; j++) -->Line_11 $$ for (int i = 0; i < ROWS_PER_SSTABLE; i++) [ CD ]
Line_24 $$ int sstablesToCorrupt = 8-->Line_26 $$ if (currentSSTable + 1 > sstablesToCorrupt)[ FD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_3 $$ Keyspace keyspace = Keyspace.open(KEYSPACE1)[ CD ]
Line_10 $$ for (int j = 0; j < SSTABLES; j++) -->Line_18 $$ cfs.forceBlockingFlush()[ CD ]
Line_15 $$ maxTimestampExpected = Math.max(timestamp, maxTimestampExpected)-->Line_19 $$ CompactionsTest.assertMaxTimestamp(cfs, maxTimestampExpected)[ FD ]
Line_35 $$ byte[] corruption = new byte[corruptionSize]-->Line_36 $$ Arrays.fill(corruption, (byte) 0xFF)[ FD ]
Line_12 $$ DecoratedKey key = Util.dk(String.valueOf(i))-->Line_14 $$ new RowUpdateBuilder(cfs.metadata, timestamp, key.getKey()).clustering("cols" + "i").add("val", "val" + i).build().applyUnsafe()[ FD ]
Line_11 $$ for (int i = 0; i < ROWS_PER_SSTABLE; i++) -->Line_12 $$ DecoratedKey key = Util.dk(String.valueOf(i))[ FD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_23 $$ int currentSSTable = 0[ CD ]
Line_23 $$ int currentSSTable = 0-->Line_41 $$ currentSSTable++[ FD ]
Line_6 $$ final int SSTABLES = cfs.metadata.params.minIndexInterval * 2 / ROWS_PER_SSTABLE-->Line_10 $$ for (int j = 0; j < SSTABLES; j++) [ FD ]
Line_11 $$ for (int i = 0; i < ROWS_PER_SSTABLE; i++) -->Line_44 $$ for (int i = 0; i < sstables.size(); i++) [ FD ]
Line_31 $$ raf = new RandomAccessFile(sstable.getFilename(), "rw")-->Line_39 $$ FileUtils.closeQuietly(raf)[ FD ]
Line_28 $$ RandomAccessFile raf = null-->Line_33 $$ assertTrue(raf.length() > corruptionSize)[ FD ]
Line_4 $$ final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("Standard1")-->Line_53 $$ cfs.truncateBlocking()[ FD ]
Line_12 $$ DecoratedKey key = Util.dk(String.valueOf(i))-->Line_16 $$ inserted.add(key)[ FD ]
Line_9 $$ Set<DecoratedKey> inserted = new HashSet()-->Line_20 $$ assertEquals(inserted.toString(), inserted.size(), Util.getAll(Util.cmd(cfs).build()).size())[ FD ]
Line_11 $$ for (int i = 0; i < ROWS_PER_SSTABLE; i++) -->Line_16 $$ inserted.add(key)[ CD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_54 $$ assertEquals(sstablesToCorrupt, failures)[ CD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_8 $$ long maxTimestampExpected = Long.MIN_VALUE[ CD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_43 $$ int failures = 0[ CD ]
Line_4 $$ final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("Standard1")-->Line_46 $$ cfs.forceMajorCompaction()[ FD ]
Line_8 $$ long maxTimestampExpected = Long.MIN_VALUE-->Line_15 $$ maxTimestampExpected = Math.max(timestamp, maxTimestampExpected)[ FD ]
Line_25 $$ for (SSTableReader sstable : sstables) -->Line_31 $$ raf = new RandomAccessFile(sstable.getFilename(), "rw")[ FD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_53 $$ cfs.truncateBlocking()[ CD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_4 $$ final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("Standard1")[ CD ]
Line_10 $$ for (int j = 0; j < SSTABLES; j++) -->Line_19 $$ CompactionsTest.assertMaxTimestamp(cfs, maxTimestampExpected)[ CD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_6 $$ final int SSTABLES = cfs.metadata.params.minIndexInterval * 2 / ROWS_PER_SSTABLE[ CD ]
Line_28 $$ RandomAccessFile raf = null-->Line_32 $$ assertNotNull(raf)[ FD ]
Line_31 $$ raf = new RandomAccessFile(sstable.getFilename(), "rw")-->Line_37 $$ raf.write(corruption)[ FD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_9 $$ Set<DecoratedKey> inserted = new HashSet()[ CD ]
Line_9 $$ Set<DecoratedKey> inserted = new HashSet()-->Line_16 $$ inserted.add(key)[ FD ]
Line_31 $$ raf = new RandomAccessFile(sstable.getFilename(), "rw")-->Line_32 $$ assertNotNull(raf)[ FD ]
Line_43 $$ int failures = 0-->Line_48 $$ failures++[ FD ]
Line_11 $$ for (int i = 0; i < ROWS_PER_SSTABLE; i++) -->Line_15 $$ maxTimestampExpected = Math.max(timestamp, maxTimestampExpected)[ CD ]
Line_28 $$ RandomAccessFile raf = null-->Line_31 $$ raf = new RandomAccessFile(sstable.getFilename(), "rw")[ FD ]
Line_11 $$ for (int i = 0; i < ROWS_PER_SSTABLE; i++) -->Line_14 $$ new RowUpdateBuilder(cfs.metadata, timestamp, key.getKey()).clustering("cols" + "i").add("val", "val" + i).build().applyUnsafe()[ CD ]
Line_31 $$ raf = new RandomAccessFile(sstable.getFilename(), "rw")-->Line_34 $$ raf.seek(new Random().nextInt((int) (raf.length() - corruptionSize)))[ FD ]
Line_5 $$ final int ROWS_PER_SSTABLE = 10-->Line_11 $$ for (int i = 0; i < ROWS_PER_SSTABLE; i++) [ FD ]
Line_4 $$ final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("Standard1")-->Line_20 $$ assertEquals(inserted.toString(), inserted.size(), Util.getAll(Util.cmd(cfs).build()).size())[ FD ]
Line_43 $$ int failures = 0-->Line_54 $$ assertEquals(sstablesToCorrupt, failures)[ FD ]
Line_4 $$ final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("Standard1")-->Line_7 $$ cfs.disableAutoCompaction()[ FD ]
Line_8 $$ long maxTimestampExpected = Long.MIN_VALUE-->Line_19 $$ CompactionsTest.assertMaxTimestamp(cfs, maxTimestampExpected)[ FD ]
Line_31 $$ raf = new RandomAccessFile(sstable.getFilename(), "rw")-->Line_33 $$ assertTrue(raf.length() > corruptionSize)[ FD ]
Line_3 $$ Keyspace keyspace = Keyspace.open(KEYSPACE1)-->Line_4 $$ final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("Standard1")[ FD ]
Line_11 $$ for (int i = 0; i < ROWS_PER_SSTABLE; i++) -->Line_13 $$ long timestamp = j * ROWS_PER_SSTABLE + i[ CD ]
Line_24 $$ int sstablesToCorrupt = 8-->Line_54 $$ assertEquals(sstablesToCorrupt, failures)[ FD ]
Line_22 $$ Collection<SSTableReader> sstables = cfs.getLiveSSTables()-->Line_44 $$ for (int i = 0; i < sstables.size(); i++) [ FD ]
Line_13 $$ long timestamp = j * ROWS_PER_SSTABLE + i-->Line_15 $$ maxTimestampExpected = Math.max(timestamp, maxTimestampExpected)[ FD ]
Line_10 $$ for (int j = 0; j < SSTABLES; j++) -->Line_20 $$ assertEquals(inserted.toString(), inserted.size(), Util.getAll(Util.cmd(cfs).build()).size())[ CD ]
Line_35 $$ byte[] corruption = new byte[corruptionSize]-->Line_37 $$ raf.write(corruption)[ FD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_22 $$ Collection<SSTableReader> sstables = cfs.getLiveSSTables()[ CD ]
Line_4 $$ final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("Standard1")-->Line_19 $$ CompactionsTest.assertMaxTimestamp(cfs, maxTimestampExpected)[ FD ]
Line_11 $$ for (int i = 0; i < ROWS_PER_SSTABLE; i++) -->Line_12 $$ DecoratedKey key = Util.dk(String.valueOf(i))[ CD ]
Line_4 $$ final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("Standard1")-->Line_22 $$ Collection<SSTableReader> sstables = cfs.getLiveSSTables()[ FD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_24 $$ int sstablesToCorrupt = 8[ CD ]
Line_28 $$ RandomAccessFile raf = null-->Line_39 $$ FileUtils.closeQuietly(raf)[ FD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_44 $$ for (int i = 0; i < sstables.size(); i++) [ CD ]
Line_28 $$ RandomAccessFile raf = null-->Line_34 $$ raf.seek(new Random().nextInt((int) (raf.length() - corruptionSize)))[ FD ]
Line_4 $$ final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("Standard1")-->Line_18 $$ cfs.forceBlockingFlush()[ FD ]
Line_28 $$ RandomAccessFile raf = null-->Line_37 $$ raf.write(corruption)[ FD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_10 $$ for (int j = 0; j < SSTABLES; j++) [ CD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_5 $$ final int ROWS_PER_SSTABLE = 10[ CD ]
Line_2 $$ public void testBlacklisting(String compactionStrategy) throws Exception -->Line_7 $$ cfs.disableAutoCompaction()[ CD ]
