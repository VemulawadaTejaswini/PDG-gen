Line_35 $$ for (int j = 0; j < numPoints; ++j) -->Line_37 $$ double lng = (360d * random.nextDouble()) - 180d[ CD ]
Line_7 $$ List<IndexRequestBuilder> cities = new ArrayList()-->Line_50 $$ indexRandom(true, cities)[ FD ]
Line_13 $$ double lng = (360d * random.nextDouble()) - 180d-->Line_41 $$ final String geoHash = GeoHashUtils.stringEncode(lng, lat, precision)[ FD ]
Line_37 $$ double lng = (360d * random.nextDouble()) - 180d-->Line_41 $$ final String geoHash = GeoHashUtils.stringEncode(lng, lat, precision)[ FD ]
Line_35 $$ for (int j = 0; j < numPoints; ++j) -->Line_36 $$ double lat = (180d * random.nextDouble()) - 90d[ CD ]
Line_31 $$ for (int i = 0; i < numDocs; i++) -->Line_34 $$ Set<String> geoHashes = new HashSet()[ CD ]
Line_13 $$ double lng = (360d * random.nextDouble()) - 180d-->Line_14 $$ String randomGeoHash = GeoHashUtils.stringEncode(lng, lat, GeoHashUtils.PRECISION)[ FD ]
Line_5 $$ Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build()-->Line_28 $$ assertAcked(prepareCreate("multi_valued_idx").setSettings(settings).addMapping("type", "location", "type=geo_point", "city", "type=string,index=not_analyzed"))[ FD ]
Line_7 $$ List<IndexRequestBuilder> cities = new ArrayList()-->Line_29 $$ cities = new ArrayList()[ FD ]
Line_8 $$ Random random = getRandom()-->Line_13 $$ double lng = (360d * random.nextDouble()) - 180d[ FD ]
Line_10 $$ for (int i = 0; i < numDocs; i++) -->Line_14 $$ String randomGeoHash = GeoHashUtils.stringEncode(lng, lat, GeoHashUtils.PRECISION)[ CD ]
Line_41 $$ final String geoHash = GeoHashUtils.stringEncode(lng, lat, precision)-->Line_42 $$ geoHashes.add(geoHash)[ FD ]
Line_20 $$ String hash = GeoHashUtils.stringEncode(lng, lat, precision)-->Line_21 $$ if ((smallestGeoHash == null) || (hash.length() < smallestGeoHash.length())) [ FD ]
Line_31 $$ for (int i = 0; i < numDocs; i++) -->Line_32 $$ final int numPoints = random.nextInt(4)[ CD ]
Line_33 $$ List<String> points = new ArrayList()-->Line_38 $$ points.add(lat + "," + lng)[ FD ]
Line_35 $$ for (int j = 0; j < numPoints; ++j) -->Line_38 $$ points.add(lat + "," + lng)[ CD ]
Line_10 $$ for (int i = 0; i < numDocs; i++) -->Line_31 $$ for (int i = 0; i < numDocs; i++) [ FD ]
Line_20 $$ String hash = GeoHashUtils.stringEncode(lng, lat, precision)-->Line_47 $$ multiValuedExpectedDocCountsForGeoHash.put(hash, multiValuedExpectedDocCountsForGeoHash.getOrDefault(hash, 0) + 1)[ FD ]
Line_8 $$ Random random = getRandom()-->Line_32 $$ final int numPoints = random.nextInt(4)[ FD ]
Line_32 $$ final int numPoints = random.nextInt(4)-->Line_35 $$ for (int j = 0; j < numPoints; ++j) [ FD ]
Line_29 $$ cities = new ArrayList()-->Line_50 $$ indexRandom(true, cities)[ FD ]
Line_29 $$ cities = new ArrayList()-->Line_45 $$ cities.add(indexCity("multi_valued_idx", Integer.toString(i), points))[ FD ]
Line_7 $$ List<IndexRequestBuilder> cities = new ArrayList()-->Line_45 $$ cities.add(indexCity("multi_valued_idx", Integer.toString(i), points))[ FD ]
Line_10 $$ for (int i = 0; i < numDocs; i++) -->Line_17 $$ expectedDocCountsForGeoHash.put(randomGeoHash, expectedDocCountsForGeoHash.getOrDefault(randomGeoHash, 0) + 1)[ CD ]
Line_8 $$ Random random = getRandom()-->Line_36 $$ double lat = (180d * random.nextDouble()) - 90d[ FD ]
Line_5 $$ Settings settings = Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, version).build()-->Line_6 $$ assertAcked(prepareCreate("idx").setSettings(settings).addMapping("type", "location", "type=geo_point", "city", "type=string,index=not_analyzed"))[ FD ]
Line_7 $$ List<IndexRequestBuilder> cities = new ArrayList()-->Line_27 $$ indexRandom(true, cities)[ FD ]
Line_31 $$ for (int i = 0; i < numDocs; i++) -->Line_45 $$ cities.add(indexCity("multi_valued_idx", Integer.toString(i), points))[ CD ]
Line_10 $$ for (int i = 0; i < numDocs; i++) -->Line_13 $$ double lng = (360d * random.nextDouble()) - 180d[ CD ]
Line_31 $$ for (int i = 0; i < numDocs; i++) -->Line_33 $$ List<String> points = new ArrayList()[ CD ]
Line_8 $$ Random random = getRandom()-->Line_37 $$ double lng = (360d * random.nextDouble()) - 180d[ FD ]
Line_14 $$ String randomGeoHash = GeoHashUtils.stringEncode(lng, lat, GeoHashUtils.PRECISION)-->Line_17 $$ expectedDocCountsForGeoHash.put(randomGeoHash, expectedDocCountsForGeoHash.getOrDefault(randomGeoHash, 0) + 1)[ FD ]
Line_31 $$ for (int i = 0; i < numDocs; i++) -->Line_45 $$ cities.add(indexCity("multi_valued_idx", Integer.toString(i), points))[ FD ]
Line_33 $$ List<String> points = new ArrayList()-->Line_45 $$ cities.add(indexCity("multi_valued_idx", Integer.toString(i), points))[ FD ]
Line_36 $$ double lat = (180d * random.nextDouble()) - 90d-->Line_41 $$ final String geoHash = GeoHashUtils.stringEncode(lng, lat, precision)[ FD ]
Line_20 $$ String hash = GeoHashUtils.stringEncode(lng, lat, precision)-->Line_24 $$ expectedDocCountsForGeoHash.put(hash, expectedDocCountsForGeoHash.getOrDefault(hash, 0) + 1)[ FD ]
Line_34 $$ Set<String> geoHashes = new HashSet()-->Line_42 $$ geoHashes.add(geoHash)[ FD ]
Line_10 $$ for (int i = 0; i < numDocs; i++) -->Line_45 $$ cities.add(indexCity("multi_valued_idx", Integer.toString(i), points))[ FD ]
Line_31 $$ for (int i = 0; i < numDocs; i++) -->Line_35 $$ for (int j = 0; j < numPoints; ++j) [ CD ]
Line_13 $$ double lng = (360d * random.nextDouble()) - 180d-->Line_20 $$ String hash = GeoHashUtils.stringEncode(lng, lat, precision)[ FD ]
