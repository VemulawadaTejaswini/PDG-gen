Line_28 $$ for (int i = 0; i < pendingToBeMerged.size(); ++i) -->Line_29 $$ List<CompressAwarePath> inputs = pendingToBeMerged.get(i)[ FD ]
Line_28 $$ for (int i = 0; i < pendingToBeMerged.size(); ++i) -->Line_29 $$ List<CompressAwarePath> inputs = pendingToBeMerged.get(i)[ CD ]
Line_29 $$ List<CompressAwarePath> inputs = pendingToBeMerged.get(i)-->Line_32 $$ assertTrue("Inputs to be merged were not sorted according to size: ", inputs.get(j).getCompressedSize() >= inputs.get(j - 1).getCompressedSize())[ FD ]
Line_30 $$ for (int j = 1; j < inputs.size(); ++j) -->Line_31 $$ assertTrue("Not enough / too many inputs were going to be merged", inputs.size() > 0 && inputs.size() <= SORT_FACTOR)[ CD ]
Line_20 $$ for (int i = 0; i < 2 * SORT_FACTOR; ++i) -->Line_23 $$ manager.closeOnDiskFile(cap)[ CD ]
Line_20 $$ for (int i = 0; i < 2 * SORT_FACTOR; ++i) -->Line_21 $$ Path path = new Path("somePath")[ CD ]
Line_22 $$ CompressAwarePath cap = new CompressAwarePath(path, 1l, rand.nextInt())-->Line_23 $$ manager.closeOnDiskFile(cap)[ FD ]
Line_20 $$ for (int i = 0; i < 2 * SORT_FACTOR; ++i) -->Line_28 $$ for (int i = 0; i < pendingToBeMerged.size(); ++i) [ FD ]
Line_20 $$ for (int i = 0; i < 2 * SORT_FACTOR; ++i) -->Line_29 $$ List<CompressAwarePath> inputs = pendingToBeMerged.get(i)[ FD ]
Line_6 $$ final int SORT_FACTOR = 5-->Line_7 $$ jobConf.setInt(MRJobConfig.IO_SORT_FACTOR, SORT_FACTOR)[ FD ]
Line_30 $$ for (int j = 1; j < inputs.size(); ++j) -->Line_32 $$ assertTrue("Inputs to be merged were not sorted according to size: ", inputs.get(j).getCompressedSize() >= inputs.get(j - 1).getCompressedSize())[ FD ]
Line_29 $$ List<CompressAwarePath> inputs = pendingToBeMerged.get(i)-->Line_31 $$ assertTrue("Not enough / too many inputs were going to be merged", inputs.size() > 0 && inputs.size() <= SORT_FACTOR)[ FD ]
Line_11 $$ MergeThread<MapOutput<IntWritable, IntWritable>, IntWritable, IntWritable> onDiskMerger = (MergeThread<MapOutput<IntWritable, IntWritable>, IntWritable, IntWritable>) Whitebox.getInternalState(manager, "onDiskMerger")-->Line_12 $$ int mergeFactor = (Integer) Whitebox.getInternalState(onDiskMerger, "mergeFactor")[ FD ]
Line_10 $$ MergeManagerImpl<IntWritable, IntWritable> manager = new MergeManagerImpl<IntWritable, IntWritable>(null, jobConf, fs, null, null, null, null, null, null, null, null, null, null, mapOutputFile)-->Line_11 $$ MergeThread<MapOutput<IntWritable, IntWritable>, IntWritable, IntWritable> onDiskMerger = (MergeThread<MapOutput<IntWritable, IntWritable>, IntWritable, IntWritable>) Whitebox.getInternalState(manager, "onDiskMerger")[ FD ]
Line_5 $$ JobConf jobConf = new JobConf()-->Line_9 $$ FileSystem fs = FileSystem.getLocal(jobConf)[ FD ]
Line_30 $$ for (int j = 1; j < inputs.size(); ++j) -->Line_32 $$ assertTrue("Inputs to be merged were not sorted according to size: ", inputs.get(j).getCompressedSize() >= inputs.get(j - 1).getCompressedSize())[ CD ]
Line_10 $$ MergeManagerImpl<IntWritable, IntWritable> manager = new MergeManagerImpl<IntWritable, IntWritable>(null, jobConf, fs, null, null, null, null, null, null, null, null, null, null, mapOutputFile)-->Line_23 $$ manager.closeOnDiskFile(cap)[ FD ]
Line_28 $$ for (int i = 0; i < pendingToBeMerged.size(); ++i) -->Line_30 $$ for (int j = 1; j < inputs.size(); ++j) [ CD ]
Line_5 $$ JobConf jobConf = new JobConf()-->Line_7 $$ jobConf.setInt(MRJobConfig.IO_SORT_FACTOR, SORT_FACTOR)[ FD ]
Line_20 $$ for (int i = 0; i < 2 * SORT_FACTOR; ++i) -->Line_22 $$ CompressAwarePath cap = new CompressAwarePath(path, 1l, rand.nextInt())[ CD ]
Line_29 $$ List<CompressAwarePath> inputs = pendingToBeMerged.get(i)-->Line_30 $$ for (int j = 1; j < inputs.size(); ++j) [ FD ]
