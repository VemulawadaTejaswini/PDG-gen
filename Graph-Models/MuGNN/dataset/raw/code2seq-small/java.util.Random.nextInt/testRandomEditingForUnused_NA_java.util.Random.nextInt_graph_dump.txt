Line_14 $$ PsiClass aClass = classes[0]-->Line_27 $$ usages.append("/**/ " + aClass.getName() + " var" + v + " = null; var" + v + ".toString();\n")[ FD ]
Line_41 $$ for (int i = 0; i < 100; i++) -->Line_50 $$ if (next == '/') [ CD ]
Line_8 $$ int v = 0-->Line_29 $$ v++[ FD ]
Line_40 $$ int unused = 0-->Line_76 $$ if (unused != warns.size()) [ FD ]
Line_50 $$ if (next == '/') -->Line_53 $$ unused--[ CD ]
Line_41 $$ for (int i = 0; i < 100; i++) -->Line_63 $$ getFile().accept(new PsiRecursiveElementVisitor() [ CD ]
Line_45 $$ offset = random.nextInt(s.length())-->Line_46 $$ if (CharArrayUtil.regionMatches(s, offset, "/**/") || CharArrayUtil.regionMatches(s, offset, "//"))[ FD ]
Line_14 $$ PsiClass aClass = classes[0]-->Line_19 $$ PsiClassType[] superTypes = aClass.getSuperTypes()[ FD ]
Line_10 $$ for (String name : names) -->Line_11 $$ PsiClass[] classes = cache.getClassesByName(name, GlobalSearchScope.allScope(getProject()))[ FD ]
Line_41 $$ for (int i = 0; i < 100; i++) -->Line_43 $$ int offset[ CD ]
Line_41 $$ for (int i = 0; i < 100; i++) -->Line_44 $$ while (true) [ CD ]
Line_42 $$ String s = myFile.getText()-->Line_45 $$ offset = random.nextInt(s.length())[ FD ]
Line_41 $$ for (int i = 0; i < 100; i++) -->Line_73 $$ errors = DaemonAnalyzerTestCase.filter(infos, HighlightSeverity.ERROR)[ CD ]
Line_50 $$ if (next == '/') -->Line_54 $$ if (next == '*') [ CD ]
Line_54 $$ if (next == '*') -->Line_55 $$ myEditor.getCaretModel().moveToOffset(offset + 1)[ CD ]
Line_37 $$ List<HighlightInfo> errors = DaemonAnalyzerTestCase.filter(doHighlighting(), HighlightSeverity.WARNING)-->Line_74 $$ assertEmpty(errors)[ FD ]
Line_43 $$ int offset-->Line_46 $$ if (CharArrayUtil.regionMatches(s, offset, "/**/") || CharArrayUtil.regionMatches(s, offset, "//"))[ FD ]
Line_50 $$ if (next == '/') -->Line_51 $$ myEditor.getCaretModel().moveToOffset(offset + 1)[ CD ]
Line_4 $$ PsiShortNamesCache cache = PsiShortNamesCache.getInstance(getProject())-->Line_5 $$ String[] names = cache.getAllClassNames()[ FD ]
Line_63 $$ getFile().accept(new PsiRecursiveElementVisitor() -->Line_68 $$ super.visitElement(element)[ CD ]
Line_2 $$ public void testRandomEditingForUnused() throws Exception -->Line_8 $$ int v = 0[ CD ]
Line_2 $$ public void testRandomEditingForUnused() throws Exception -->Line_33 $$ final String text = imports + "\n class X [ CD ]
Line_14 $$ PsiClass aClass = classes[0]-->Line_15 $$ if (!aClass.hasModifierProperty(PsiModifier.PUBLIC))[ FD ]
Line_2 $$ public void testRandomEditingForUnused() throws Exception -->Line_80 $$ FileEditorManagerEx.getInstanceEx(getProject()).closeAllFiles()[ CD ]
Line_40 $$ int unused = 0-->Line_53 $$ unused--[ FD ]
Line_41 $$ for (int i = 0; i < 100; i++) -->Line_72 $$ List<HighlightInfo> infos = doHighlighting()[ CD ]
Line_8 $$ int v = 0-->Line_30 $$ if (v > 100)[ FD ]
Line_41 $$ for (int i = 0; i < 100; i++) -->Line_62 $$ PsiDocumentManager.getInstance(getProject()).commitAllDocuments()[ CD ]
Line_2 $$ public void testRandomEditingForUnused() throws Exception -->Line_5 $$ String[] names = cache.getAllClassNames()[ CD ]
Line_33 $$ final String text = imports + "\n class X -->Line_35 $$ getEditor().getDocument().setText(text)[ FD ]
Line_2 $$ public void testRandomEditingForUnused() throws Exception -->Line_9 $$ List<PsiClass> aclasses = new ArrayList()[ CD ]
Line_39 $$ Random random = new Random()-->Line_45 $$ offset = random.nextInt(s.length())[ FD ]
Line_44 $$ while (true) -->Line_46 $$ if (CharArrayUtil.regionMatches(s, offset, "/**/") || CharArrayUtil.regionMatches(s, offset, "//"))[ CD ]
Line_54 $$ if (next == '*') -->Line_58 $$ unused++[ CD ]
Line_2 $$ public void testRandomEditingForUnused() throws Exception -->Line_6 $$ final StringBuilder imports = new StringBuilder()[ CD ]
Line_2 $$ public void testRandomEditingForUnused() throws Exception -->Line_38 $$ assertEmpty(errors)[ CD ]
Line_41 $$ for (int i = 0; i < 100; i++) -->Line_76 $$ if (unused != warns.size()) [ CD ]
Line_2 $$ public void testRandomEditingForUnused() throws Exception -->Line_40 $$ int unused = 0[ CD ]
Line_14 $$ PsiClass aClass = classes[0]-->Line_28 $$ aclasses.add(aClass)[ FD ]
Line_9 $$ List<PsiClass> aclasses = new ArrayList()-->Line_28 $$ aclasses.add(aClass)[ FD ]
Line_7 $$ final StringBuilder usages = new StringBuilder()-->Line_27 $$ usages.append("/**/ " + aClass.getName() + " var" + v + " = null; var" + v + ".toString();\n")[ FD ]
Line_4 $$ PsiShortNamesCache cache = PsiShortNamesCache.getInstance(getProject())-->Line_11 $$ PsiClass[] classes = cache.getClassesByName(name, GlobalSearchScope.allScope(getProject()))[ FD ]
Line_44 $$ while (true) -->Line_45 $$ offset = random.nextInt(s.length())[ CD ]
Line_41 $$ for (int i = 0; i < 100; i++) -->Line_71 $$ System.out.println("i = " + i + " " + next + " at " + offset)[ CD ]
Line_2 $$ public void testRandomEditingForUnused() throws Exception -->Line_7 $$ final StringBuilder usages = new StringBuilder()[ CD ]
Line_50 $$ if (next == '/') -->Line_52 $$ type("**")[ CD ]
Line_54 $$ if (next == '*') -->Line_57 $$ delete()[ CD ]
Line_41 $$ for (int i = 0; i < 100; i++) -->Line_75 $$ List<HighlightInfo> warns = DaemonAnalyzerTestCase.filter(infos, HighlightSeverity.WARNING)[ CD ]
Line_40 $$ int unused = 0-->Line_77 $$ assertEquals(warns.toString(), unused, warns.size())[ FD ]
Line_76 $$ if (unused != warns.size()) -->Line_77 $$ assertEquals(warns.toString(), unused, warns.size())[ CD ]
Line_42 $$ String s = myFile.getText()-->Line_49 $$ char next = offset < s.length() - 1 ? s.charAt(offset + 1) : 0[ FD ]
Line_63 $$ getFile().accept(new PsiRecursiveElementVisitor() -->Line_68 $$ super.visitElement(element)[ FD ]
Line_63 $$ getFile().accept(new PsiRecursiveElementVisitor() -->Line_67 $$ assertTrue(element.toString(), element.isValid())[ FD ]
Line_2 $$ public void testRandomEditingForUnused() throws Exception -->Line_41 $$ for (int i = 0; i < 100; i++) [ CD ]
Line_41 $$ for (int i = 0; i < 100; i++) -->Line_74 $$ assertEmpty(errors)[ CD ]
Line_41 $$ for (int i = 0; i < 100; i++) -->Line_42 $$ String s = myFile.getText()[ CD ]
Line_6 $$ final StringBuilder imports = new StringBuilder()-->Line_26 $$ imports.append("import " + qualifiedName + ";\n")[ FD ]
Line_63 $$ getFile().accept(new PsiRecursiveElementVisitor() -->Line_67 $$ assertTrue(element.toString(), element.isValid())[ CD ]
Line_42 $$ String s = myFile.getText()-->Line_46 $$ if (CharArrayUtil.regionMatches(s, offset, "/**/") || CharArrayUtil.regionMatches(s, offset, "//"))[ FD ]
Line_14 $$ PsiClass aClass = classes[0]-->Line_17 $$ if (aClass.getSuperClass() == null)[ FD ]
Line_2 $$ public void testRandomEditingForUnused() throws Exception -->Line_4 $$ PsiShortNamesCache cache = PsiShortNamesCache.getInstance(getProject())[ CD ]
Line_14 $$ PsiClass aClass = classes[0]-->Line_22 $$ String qualifiedName = aClass.getQualifiedName()[ FD ]
Line_2 $$ public void testRandomEditingForUnused() throws Exception -->Line_3 $$ configureFromFileText("Stress.java", "class X [ CD ]
Line_37 $$ List<HighlightInfo> errors = DaemonAnalyzerTestCase.filter(doHighlighting(), HighlightSeverity.WARNING)-->Line_38 $$ assertEmpty(errors)[ FD ]
Line_2 $$ public void testRandomEditingForUnused() throws Exception -->Line_34 $$ WriteCommandAction.runWriteCommandAction(null, () -> [ CD ]
Line_2 $$ public void testRandomEditingForUnused() throws Exception -->Line_39 $$ Random random = new Random()[ CD ]
Line_54 $$ if (next == '*') -->Line_56 $$ delete()[ CD ]
Line_43 $$ int offset-->Line_45 $$ offset = random.nextInt(s.length())[ FD ]
Line_2 $$ public void testRandomEditingForUnused() throws Exception -->Line_37 $$ List<HighlightInfo> errors = DaemonAnalyzerTestCase.filter(doHighlighting(), HighlightSeverity.WARNING)[ CD ]
Line_40 $$ int unused = 0-->Line_58 $$ unused++[ FD ]
