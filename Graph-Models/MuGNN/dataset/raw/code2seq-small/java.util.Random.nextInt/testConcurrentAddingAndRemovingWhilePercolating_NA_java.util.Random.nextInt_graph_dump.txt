Line_24 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) -->Line_41 $$ assertThat(response.getId(), equalTo(id))[ CD ]
Line_25 $$ String id-->Line_30 $$ id = Integer.toString(randomInt(idGen.get()))[ FD ]
Line_9 $$ final Set<String> liveIds = ConcurrentCollections.newConcurrentSet()-->Line_26 $$ do [ FD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_12 $$ final Semaphore semaphore = new Semaphore(numIndexThreads, true)[ CD ]
Line_10 $$ final AtomicBoolean run = new AtomicBoolean(true)-->Line_49 $$ run.set(false)[ FD ]
Line_5 $$ final int numIndexThreads = scaledRandomIntBetween(1, 3)-->Line_63 $$ semaphore.acquire(numIndexThreads)[ FD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_7 $$ final AtomicReference<Throwable> exceptionHolder = new AtomicReference(null)[ CD ]
Line_24 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) -->Line_34 $$ assertThat("doc[" + id + "] should have been deleted, but isn't", response.isFound(), equalTo(true))[ CD ]
Line_9 $$ final Set<String> liveIds = ConcurrentCollections.newConcurrentSet()-->Line_24 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) [ FD ]
Line_8 $$ final AtomicInteger idGen = new AtomicInteger(0)-->Line_30 $$ id = Integer.toString(randomInt(idGen.get()))[ FD ]
Line_61 $$ for (int counter = 0; counter < numberPercolateOperation; counter++) -->Line_62 $$ Thread.sleep(5)[ CD ]
Line_26 $$ do -->Line_30 $$ id = Integer.toString(randomInt(idGen.get()))[ CD ]
Line_69 $$ PercolateResponse response = client().preparePercolate().setIndices("index").setDocumentType("type").setSource(percolateDoc).execute().actionGet()-->Line_71 $$ assertThat(response.getSuccessfulShards(), equalTo(response.getTotalShards()))[ FD ]
Line_7 $$ final AtomicReference<Throwable> exceptionHolder = new AtomicReference(null)-->Line_81 $$ assertThat("exceptionHolder should have been empty, but holds: " + exceptionHolder.toString(), exceptionHolder.get(), nullValue())[ FD ]
Line_13 $$ for (int i = 0; i < indexThreads.length; i++) -->Line_58 $$ indexThreads[i].start()[ CD ]
Line_24 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) -->Line_36 $$ String id = Integer.toString(idGen.getAndIncrement())[ CD ]
Line_13 $$ for (int i = 0; i < indexThreads.length; i++) -->Line_15 $$ Runnable r = new Runnable() [ CD ]
Line_10 $$ final AtomicBoolean run = new AtomicBoolean(true)-->Line_51 $$ run.set(false)[ FD ]
Line_30 $$ id = Integer.toString(randomInt(idGen.get()))-->Line_41 $$ assertThat(response.getId(), equalTo(id))[ FD ]
Line_12 $$ final Semaphore semaphore = new Semaphore(numIndexThreads, true)-->Line_44 $$ semaphore.release()[ FD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_60 $$ XContentBuilder percolateDoc = XContentFactory.jsonBuilder().startObject().startObject("doc").field("field1", "value").endObject().endObject()[ CD ]
Line_24 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) -->Line_26 $$ do [ CD ]
Line_69 $$ PercolateResponse response = client().preparePercolate().setIndices("index").setDocumentType("type").setSource(percolateDoc).execute().actionGet()-->Line_70 $$ assertThat(response.getShardFailures(), emptyArray())[ FD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_13 $$ for (int i = 0; i < indexThreads.length; i++) [ CD ]
Line_7 $$ final AtomicReference<Throwable> exceptionHolder = new AtomicReference(null)-->Line_52 $$ exceptionHolder.set(t)[ FD ]
Line_24 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) -->Line_37 $$ IndexResponse response = client().prepareIndex("index", PercolatorService.TYPE_NAME, id).setSource(doc).execute().actionGet()[ CD ]
Line_25 $$ String id-->Line_41 $$ assertThat(response.getId(), equalTo(id))[ FD ]
Line_10 $$ final AtomicBoolean run = new AtomicBoolean(true)-->Line_77 $$ run.set(false)[ FD ]
Line_30 $$ id = Integer.toString(randomInt(idGen.get()))-->Line_37 $$ IndexResponse response = client().prepareIndex("index", PercolatorService.TYPE_NAME, id).setSource(doc).execute().actionGet()[ FD ]
Line_6 $$ final int numberPercolateOperation = scaledRandomIntBetween(10, 100)-->Line_61 $$ for (int counter = 0; counter < numberPercolateOperation; counter++) [ FD ]
Line_24 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) -->Line_25 $$ String id[ CD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_11 $$ Thread[] indexThreads = new Thread[numIndexThreads][ CD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_8 $$ final AtomicInteger idGen = new AtomicInteger(0)[ CD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_5 $$ final int numIndexThreads = scaledRandomIntBetween(1, 3)[ CD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_3 $$ assertAcked(prepareCreate("index").addMapping("type", "field1", "type=string"))[ CD ]
Line_9 $$ final Set<String> liveIds = ConcurrentCollections.newConcurrentSet()-->Line_68 $$ int atLeastExpected = liveIds.size()[ FD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_6 $$ final int numberPercolateOperation = scaledRandomIntBetween(10, 100)[ CD ]
Line_24 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) -->Line_32 $$ DeleteResponse response = client().prepareDelete("index", PercolatorService.TYPE_NAME, id).execute().actionGet()[ CD ]
Line_68 $$ int atLeastExpected = liveIds.size()-->Line_72 $$ assertThat(response.getMatches().length, equalTo(atLeastExpected))[ FD ]
Line_12 $$ final Semaphore semaphore = new Semaphore(numIndexThreads, true)-->Line_74 $$ semaphore.release(numIndexThreads)[ FD ]
Line_9 $$ final Set<String> liveIds = ConcurrentCollections.newConcurrentSet()-->Line_38 $$ liveIds.add(id)[ FD ]
Line_8 $$ final AtomicInteger idGen = new AtomicInteger(0)-->Line_36 $$ String id = Integer.toString(idGen.getAndIncrement())[ FD ]
Line_5 $$ final int numIndexThreads = scaledRandomIntBetween(1, 3)-->Line_74 $$ semaphore.release(numIndexThreads)[ FD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_81 $$ assertThat("exceptionHolder should have been empty, but holds: " + exceptionHolder.toString(), exceptionHolder.get(), nullValue())[ CD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_77 $$ run.set(false)[ CD ]
Line_14 $$ final Random rand = new Random(getRandom().nextLong())-->Line_24 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) [ FD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_9 $$ final Set<String> liveIds = ConcurrentCollections.newConcurrentSet()[ CD ]
Line_21 $$ while (run.get()) -->Line_22 $$ semaphore.acquire()[ CD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_4 $$ ensureGreen()[ CD ]
Line_24 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) -->Line_33 $$ assertThat(response.getId(), equalTo(id))[ CD ]
Line_69 $$ PercolateResponse response = client().preparePercolate().setIndices("index").setDocumentType("type").setSource(percolateDoc).execute().actionGet()-->Line_72 $$ assertThat(response.getMatches().length, equalTo(atLeastExpected))[ FD ]
Line_13 $$ for (int i = 0; i < indexThreads.length; i++) -->Line_57 $$ indexThreads[i] = new Thread(r)[ CD ]
Line_26 $$ do -->Line_27 $$ if (liveIds.isEmpty()) [ CD ]
Line_30 $$ id = Integer.toString(randomInt(idGen.get()))-->Line_26 $$ do [ FD ]
Line_13 $$ for (int i = 0; i < indexThreads.length; i++) -->Line_14 $$ final Random rand = new Random(getRandom().nextLong())[ CD ]
Line_25 $$ String id-->Line_37 $$ IndexResponse response = client().prepareIndex("index", PercolatorService.TYPE_NAME, id).setSource(doc).execute().actionGet()[ FD ]
Line_25 $$ String id-->Line_26 $$ do [ FD ]
Line_10 $$ final AtomicBoolean run = new AtomicBoolean(true)-->Line_65 $$ if (!run.get()) [ FD ]
Line_9 $$ final Set<String> liveIds = ConcurrentCollections.newConcurrentSet()-->Line_27 $$ if (liveIds.isEmpty()) [ FD ]
Line_30 $$ id = Integer.toString(randomInt(idGen.get()))-->Line_38 $$ liveIds.add(id)[ FD ]
Line_25 $$ String id-->Line_33 $$ assertThat(response.getId(), equalTo(id))[ FD ]
Line_12 $$ final Semaphore semaphore = new Semaphore(numIndexThreads, true)-->Line_63 $$ semaphore.acquire(numIndexThreads)[ FD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_10 $$ final AtomicBoolean run = new AtomicBoolean(true)[ CD ]
Line_24 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) -->Line_38 $$ liveIds.add(id)[ CD ]
Line_61 $$ for (int counter = 0; counter < numberPercolateOperation; counter++) -->Line_63 $$ semaphore.acquire(numIndexThreads)[ CD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_61 $$ for (int counter = 0; counter < numberPercolateOperation; counter++) [ CD ]
Line_30 $$ id = Integer.toString(randomInt(idGen.get()))-->Line_32 $$ DeleteResponse response = client().prepareDelete("index", PercolatorService.TYPE_NAME, id).execute().actionGet()[ FD ]
Line_12 $$ final Semaphore semaphore = new Semaphore(numIndexThreads, true)-->Line_22 $$ semaphore.acquire()[ FD ]
Line_20 $$ XContentBuilder doc = XContentFactory.jsonBuilder().startObject().field("query", termQuery("field1", "value")).endObject()-->Line_37 $$ IndexResponse response = client().prepareIndex("index", PercolatorService.TYPE_NAME, id).setSource(doc).execute().actionGet()[ FD ]
Line_10 $$ final AtomicBoolean run = new AtomicBoolean(true)-->Line_21 $$ while (run.get()) [ FD ]
Line_25 $$ String id-->Line_38 $$ liveIds.add(id)[ FD ]
Line_25 $$ String id-->Line_32 $$ DeleteResponse response = client().prepareDelete("index", PercolatorService.TYPE_NAME, id).execute().actionGet()[ FD ]
Line_30 $$ id = Integer.toString(randomInt(idGen.get()))-->Line_33 $$ assertThat(response.getId(), equalTo(id))[ FD ]
