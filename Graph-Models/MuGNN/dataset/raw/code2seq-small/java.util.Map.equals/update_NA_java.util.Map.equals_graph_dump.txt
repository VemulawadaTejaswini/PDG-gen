Line_7 $$ boolean skippedReadingPersistentDataButMayHaveIt = false-->Line_27 $$ skippedReadingPersistentDataButMayHaveIt = true[ FD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_75 $$ if (content instanceof FileContent) [ FD ]
Line_6 $$ Integer hashId = null-->Line_44 $$ myIndexingTrace.put(hashId, ((FileContentImpl) fileContent).getCharset() + "," + fileContent.getFileType().getName() + "," + fileContent.getFile().getPath() + "," + ExceptionUtil.getThrowableText(new Throwable()))[ FD ]
Line_38 $$ if (hashId != null && !havePersistentData) -->Line_40 $$ if (DebugAssertions.EXTRA_SANITY_CHECKS) [ CD ]
Line_136 $$ return new Computable<Boolean>() -->Line_149 $$ if (nestedException != null) [ CD ]
Line_108 $$ if (oldKeys == null) -->Line_109 $$ return keysForGivenInputId.compute()[ CD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_4 $$ Map<Key, Value> data = null[ CD ]
Line_62 $$ if (currentHashId != null) -->Line_66 $$ currentKeys = Collections.emptyList()[ CD ]
Line_27 $$ skippedReadingPersistentDataButMayHaveIt = true-->Line_39 $$ boolean saved = savePersistentData(data, hashId, skippedReadingPersistentDataButMayHaveIt)[ FD ]
Line_6 $$ Integer hashId = null-->Line_14 $$ ByteSequence bytes = myContents.get(hashId)[ FD ]
Line_38 $$ if (hashId != null && !havePersistentData) -->Line_39 $$ boolean saved = savePersistentData(data, hashId, skippedReadingPersistentDataButMayHaveIt)[ CD ]
Line_10 $$ FileContent fileContent = (FileContent) content-->Line_11 $$ hashId = getHashOfContent(fileContent)[ FD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_36 $$ if (data == null)[ CD ]
Line_11 $$ hashId = getHashOfContent(fileContent)-->Line_39 $$ boolean saved = savePersistentData(data, hashId, skippedReadingPersistentDataButMayHaveIt)[ FD ]
Line_54 $$ final int savedInputId-->Line_99 $$ myInputsSnapshotMapping.put(inputId, savedInputId)[ FD ]
Line_89 $$ Map<Key, Value> currentValue-->Line_92 $$ currentValue = byteSequence != null ? deserializeSavedPersistentData(byteSequence) : Collections.<Key, Value>emptyMap()[ FD ]
Line_14 $$ ByteSequence bytes = myContents.get(hashId)-->Line_15 $$ if (bytes != null) [ FD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_136 $$ return new Computable<Boolean>() [ CD ]
Line_89 $$ Map<Key, Value> currentValue-->Line_94 $$ currentValue = Collections.emptyMap()[ FD ]
Line_11 $$ hashId = getHashOfContent(fileContent)-->Line_44 $$ myIndexingTrace.put(hashId, ((FileContentImpl) fileContent).getCharset() + "," + fileContent.getFileType().getName() + "," + fileContent.getFile().getPath() + "," + ExceptionUtil.getThrowableText(new Throwable()))[ FD ]
Line_62 $$ if (currentHashId != null) -->Line_64 $$ currentKeys = byteSequence != null ? deserializeSavedPersistentData(byteSequence).keySet() : Collections.<Key>emptyList()[ CD ]
Line_136 $$ return new Computable<Boolean>() -->Line_154 $$ return Boolean.TRUE[ CD ]
Line_83 $$ optimizedUpdateData = new MapDiffUpdateData<Key, Value>(myIndexId) -->Line_126 $$ Collection<Key> oldKeys = myInputsIndex.get(inputId)[ FD ]
Line_60 $$ Integer currentHashId = myInputsSnapshotMapping.get(inputId)-->Line_62 $$ if (currentHashId != null) [ FD ]
Line_4 $$ Map<Key, Value> data = null-->Line_20 $$ boolean sameValueForSavedIndexedResultAndCurrentOne = contentData.equals(data)[ FD ]
Line_18 $$ if (DebugAssertions.EXTRA_SANITY_CHECKS) -->Line_21 $$ if (!sameValueForSavedIndexedResultAndCurrentOne) [ CD ]
Line_63 $$ ByteSequence byteSequence = myContents.get(currentHashId)-->Line_92 $$ currentValue = byteSequence != null ? deserializeSavedPersistentData(byteSequence) : Collections.<Key, Value>emptyMap()[ FD ]
Line_15 $$ if (bytes != null) -->Line_16 $$ data = deserializeSavedPersistentData(bytes)[ CD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_7 $$ boolean skippedReadingPersistentDataButMayHaveIt = false[ CD ]
Line_4 $$ Map<Key, Value> data = null-->Line_16 $$ data = deserializeSavedPersistentData(bytes)[ FD ]
Line_10 $$ FileContent fileContent = (FileContent) content-->Line_44 $$ myIndexingTrace.put(hashId, ((FileContentImpl) fileContent).getCharset() + "," + fileContent.getFileType().getName() + "," + fileContent.getFile().getPath() + "," + ExceptionUtil.getThrowableText(new Throwable()))[ FD ]
Line_136 $$ return new Computable<Boolean>() -->Line_139 $$ ProgressManager.getInstance().executeNonCancelableSection(new Runnable() [ CD ]
Line_60 $$ Integer currentHashId = myInputsSnapshotMapping.get(inputId)-->Line_90 $$ if (currentHashId != null) [ FD ]
Line_61 $$ Collection<Key> currentKeys-->Line_64 $$ currentKeys = byteSequence != null ? deserializeSavedPersistentData(byteSequence).keySet() : Collections.<Key>emptyList()[ FD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_53 $$ final NotNullComputable<Collection<Key>> oldKeysGetter[ CD ]
Line_83 $$ optimizedUpdateData = new MapDiffUpdateData<Key, Value>(myIndexId) -->Line_85 $$ return newValue[ CD ]
Line_13 $$ if (!myContents.isBusyReading() || DebugAssertions.EXTRA_SANITY_CHECKS) -->Line_27 $$ skippedReadingPersistentDataButMayHaveIt = true[ CD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_19 $$ Map<Key, Value> contentData = myIndexer.map(content)[ FD ]
Line_6 $$ Integer hashId = null-->Line_39 $$ boolean saved = savePersistentData(data, hashId, skippedReadingPersistentDataButMayHaveIt)[ FD ]
Line_4 $$ Map<Key, Value> data = null-->Line_37 $$ data = content != null ? myIndexer.map(content) : Collections.<Key, Value>emptyMap()[ FD ]
Line_12 $$ if (doReadSavedPersistentData) -->Line_13 $$ if (!myContents.isBusyReading() || DebugAssertions.EXTRA_SANITY_CHECKS) [ CD ]
Line_5 $$ boolean havePersistentData = false-->Line_38 $$ if (hashId != null && !havePersistentData) [ FD ]
Line_4 $$ Map<Key, Value> data = null-->Line_39 $$ boolean saved = savePersistentData(data, hashId, skippedReadingPersistentDataButMayHaveIt)[ FD ]
Line_83 $$ optimizedUpdateData = new MapDiffUpdateData<Key, Value>(myIndexId) -->Line_107 $$ Collection<Key> oldKeys = myInputsIndex.get(inputId)[ FD ]
Line_83 $$ optimizedUpdateData = new MapDiffUpdateData<Key, Value>(myIndexId) -->Line_99 $$ myInputsSnapshotMapping.put(inputId, savedInputId)[ FD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_8 $$ if (myContents != null && weProcessPhysicalContent && content != null) [ CD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_126 $$ Collection<Key> oldKeys = myInputsIndex.get(inputId)[ FD ]
Line_83 $$ optimizedUpdateData = new MapDiffUpdateData<Key, Value>(myIndexId) -->Line_96 $$ return currentValue[ CD ]
Line_136 $$ return new Computable<Boolean>() -->Line_148 $$ StorageException nestedException = exRef.get()[ CD ]
Line_11 $$ hashId = getHashOfContent(fileContent)-->Line_30 $$ havePersistentData = myContents.containsMapping(hashId)[ FD ]
Line_6 $$ Integer hashId = null-->Line_11 $$ hashId = getHashOfContent(fileContent)[ FD ]
Line_4 $$ Map<Key, Value> data = null-->Line_22 $$ DebugAssertions.error("Unexpected difference in indexing of %s by index %s, file type %s, charset %s\ndiff %s\nprevious indexed info %s", fileContent.getFile(), myIndexId, fileContent.getFileType().getName(), ((FileContentImpl) fileContent).getCharset(), buildDiff(data, contentData), myIndexingTrace.get(hashId))[ FD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_52 $$ UpdateData<Key, Value> optimizedUpdateData = null[ CD ]
Line_149 $$ if (nestedException != null) -->Line_150 $$ LOG.info("Exception during updateWithMap:" + nestedException)[ CD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_88 $$ Integer currentHashId = myInputsSnapshotMapping.get(inputId)[ FD ]
Line_60 $$ Integer currentHashId = myInputsSnapshotMapping.get(inputId)-->Line_91 $$ ByteSequence byteSequence = myContents.get(currentHashId)[ FD ]
Line_16 $$ data = deserializeSavedPersistentData(bytes)-->Line_20 $$ boolean sameValueForSavedIndexedResultAndCurrentOne = contentData.equals(data)[ FD ]
Line_138 $$ final Ref<StorageException> exRef = new Ref<StorageException>(null)-->Line_148 $$ StorageException nestedException = exRef.get()[ FD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_51 $$ ProgressManager.checkCanceled()[ CD ]
Line_88 $$ Integer currentHashId = myInputsSnapshotMapping.get(inputId)-->Line_90 $$ if (currentHashId != null) [ FD ]
Line_90 $$ if (currentHashId != null) -->Line_91 $$ ByteSequence byteSequence = myContents.get(currentHashId)[ CD ]
Line_15 $$ if (bytes != null) -->Line_18 $$ if (DebugAssertions.EXTRA_SANITY_CHECKS) [ CD ]
Line_83 $$ optimizedUpdateData = new MapDiffUpdateData<Key, Value>(myIndexId) -->Line_142 $$ updateWithMap(inputId, updateData)[ FD ]
Line_11 $$ hashId = getHashOfContent(fileContent)-->Line_14 $$ ByteSequence bytes = myContents.get(hashId)[ FD ]
Line_16 $$ data = deserializeSavedPersistentData(bytes)-->Line_37 $$ data = content != null ? myIndexer.map(content) : Collections.<Key, Value>emptyMap()[ FD ]
Line_149 $$ if (nestedException != null) -->Line_152 $$ return Boolean.FALSE[ CD ]
Line_64 $$ currentKeys = byteSequence != null ? deserializeSavedPersistentData(byteSequence).keySet() : Collections.<Key>emptyList()-->Line_66 $$ currentKeys = Collections.emptyList()[ FD ]
Line_83 $$ optimizedUpdateData = new MapDiffUpdateData<Key, Value>(myIndexId) -->Line_99 $$ myInputsSnapshotMapping.put(inputId, savedInputId)[ CD ]
Line_107 $$ Collection<Key> oldKeys = myInputsIndex.get(inputId)-->Line_108 $$ if (oldKeys == null) [ FD ]
Line_40 $$ if (DebugAssertions.EXTRA_SANITY_CHECKS) -->Line_41 $$ if (saved) [ CD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_54 $$ final int savedInputId[ CD ]
Line_62 $$ if (currentHashId != null) -->Line_63 $$ ByteSequence byteSequence = myContents.get(currentHashId)[ CD ]
Line_19 $$ Map<Key, Value> contentData = myIndexer.map(content)-->Line_20 $$ boolean sameValueForSavedIndexedResultAndCurrentOne = contentData.equals(data)[ FD ]
Line_92 $$ currentValue = byteSequence != null ? deserializeSavedPersistentData(byteSequence) : Collections.<Key, Value>emptyMap()-->Line_94 $$ currentValue = Collections.emptyMap()[ FD ]
Line_18 $$ if (DebugAssertions.EXTRA_SANITY_CHECKS) -->Line_19 $$ Map<Key, Value> contentData = myIndexer.map(content)[ CD ]
Line_20 $$ boolean sameValueForSavedIndexedResultAndCurrentOne = contentData.equals(data)-->Line_21 $$ if (!sameValueForSavedIndexedResultAndCurrentOne) [ FD ]
Line_149 $$ if (nestedException != null) -->Line_151 $$ FileBasedIndex.getInstance().requestRebuild(myIndexId, nestedException)[ CD ]
Line_91 $$ ByteSequence byteSequence = myContents.get(currentHashId)-->Line_92 $$ currentValue = byteSequence != null ? deserializeSavedPersistentData(byteSequence) : Collections.<Key, Value>emptyMap()[ FD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_38 $$ if (hashId != null && !havePersistentData) [ CD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_60 $$ Integer currentHashId = myInputsSnapshotMapping.get(inputId)[ FD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_55 $$ if (myHasSnapshotMapping) [ CD ]
Line_17 $$ havePersistentData = true-->Line_38 $$ if (hashId != null && !havePersistentData) [ FD ]
Line_37 $$ data = content != null ? myIndexer.map(content) : Collections.<Key, Value>emptyMap()-->Line_39 $$ boolean saved = savePersistentData(data, hashId, skippedReadingPersistentDataButMayHaveIt)[ FD ]
Line_60 $$ Integer currentHashId = myInputsSnapshotMapping.get(inputId)-->Line_63 $$ ByteSequence byteSequence = myContents.get(currentHashId)[ FD ]
Line_90 $$ if (currentHashId != null) -->Line_92 $$ currentValue = byteSequence != null ? deserializeSavedPersistentData(byteSequence) : Collections.<Key, Value>emptyMap()[ CD ]
Line_57 $$ final NotNullComputable<Collection<Key>> keysForGivenInputId = new NotNullComputable<Collection<Key>>() -->Line_109 $$ return keysForGivenInputId.compute()[ FD ]
Line_5 $$ boolean havePersistentData = false-->Line_17 $$ havePersistentData = true[ FD ]
Line_10 $$ FileContent fileContent = (FileContent) content-->Line_22 $$ DebugAssertions.error("Unexpected difference in indexing of %s by index %s, file type %s, charset %s\ndiff %s\nprevious indexed info %s", fileContent.getFile(), myIndexId, fileContent.getFileType().getName(), ((FileContentImpl) fileContent).getCharset(), buildDiff(data, contentData), myIndexingTrace.get(hashId))[ FD ]
Line_83 $$ optimizedUpdateData = new MapDiffUpdateData<Key, Value>(myIndexId) -->Line_89 $$ Map<Key, Value> currentValue[ CD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_99 $$ myInputsSnapshotMapping.put(inputId, savedInputId)[ FD ]
Line_90 $$ if (currentHashId != null) -->Line_94 $$ currentValue = Collections.emptyMap()[ CD ]
Line_16 $$ data = deserializeSavedPersistentData(bytes)-->Line_39 $$ boolean saved = savePersistentData(data, hashId, skippedReadingPersistentDataButMayHaveIt)[ FD ]
Line_4 $$ Map<Key, Value> data = null-->Line_36 $$ if (data == null)[ FD ]
Line_6 $$ Integer hashId = null-->Line_30 $$ havePersistentData = myContents.containsMapping(hashId)[ FD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_107 $$ Collection<Key> oldKeys = myInputsIndex.get(inputId)[ FD ]
Line_18 $$ if (DebugAssertions.EXTRA_SANITY_CHECKS) -->Line_20 $$ boolean sameValueForSavedIndexedResultAndCurrentOne = contentData.equals(data)[ CD ]
Line_74 $$ if (weProcessPhysicalContent) -->Line_81 $$ if (MapDiffUpdateData.ourDiffUpdateEnabled) [ CD ]
Line_16 $$ data = deserializeSavedPersistentData(bytes)-->Line_22 $$ DebugAssertions.error("Unexpected difference in indexing of %s by index %s, file type %s, charset %s\ndiff %s\nprevious indexed info %s", fileContent.getFile(), myIndexId, fileContent.getFileType().getName(), ((FileContentImpl) fileContent).getCharset(), buildDiff(data, contentData), myIndexingTrace.get(hashId))[ FD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_5 $$ boolean havePersistentData = false[ CD ]
Line_12 $$ if (doReadSavedPersistentData) -->Line_30 $$ havePersistentData = myContents.containsMapping(hashId)[ CD ]
Line_21 $$ if (!sameValueForSavedIndexedResultAndCurrentOne) -->Line_22 $$ DebugAssertions.error("Unexpected difference in indexing of %s by index %s, file type %s, charset %s\ndiff %s\nprevious indexed info %s", fileContent.getFile(), myIndexId, fileContent.getFileType().getName(), ((FileContentImpl) fileContent).getCharset(), buildDiff(data, contentData), myIndexingTrace.get(hashId))[ CD ]
Line_138 $$ final Ref<StorageException> exRef = new Ref<StorageException>(null)-->Line_144 $$ exRef.set(ex)[ FD ]
Line_17 $$ havePersistentData = true-->Line_30 $$ havePersistentData = myContents.containsMapping(hashId)[ FD ]
Line_74 $$ if (weProcessPhysicalContent) -->Line_75 $$ if (content instanceof FileContent) [ CD ]
Line_6 $$ Integer hashId = null-->Line_22 $$ DebugAssertions.error("Unexpected difference in indexing of %s by index %s, file type %s, charset %s\ndiff %s\nprevious indexed info %s", fileContent.getFile(), myIndexId, fileContent.getFileType().getName(), ((FileContentImpl) fileContent).getCharset(), buildDiff(data, contentData), myIndexingTrace.get(hashId))[ FD ]
Line_61 $$ Collection<Key> currentKeys-->Line_66 $$ currentKeys = Collections.emptyList()[ FD ]
Line_7 $$ boolean skippedReadingPersistentDataButMayHaveIt = false-->Line_39 $$ boolean saved = savePersistentData(data, hashId, skippedReadingPersistentDataButMayHaveIt)[ FD ]
Line_88 $$ Integer currentHashId = myInputsSnapshotMapping.get(inputId)-->Line_91 $$ ByteSequence byteSequence = myContents.get(currentHashId)[ FD ]
Line_30 $$ havePersistentData = myContents.containsMapping(hashId)-->Line_38 $$ if (hashId != null && !havePersistentData) [ FD ]
Line_136 $$ return new Computable<Boolean>() -->Line_138 $$ final Ref<StorageException> exRef = new Ref<StorageException>(null)[ CD ]
Line_13 $$ if (!myContents.isBusyReading() || DebugAssertions.EXTRA_SANITY_CHECKS) -->Line_15 $$ if (bytes != null) [ CD ]
Line_16 $$ data = deserializeSavedPersistentData(bytes)-->Line_36 $$ if (data == null)[ FD ]
Line_19 $$ Map<Key, Value> contentData = myIndexer.map(content)-->Line_22 $$ DebugAssertions.error("Unexpected difference in indexing of %s by index %s, file type %s, charset %s\ndiff %s\nprevious indexed info %s", fileContent.getFile(), myIndexId, fileContent.getFileType().getName(), ((FileContentImpl) fileContent).getCharset(), buildDiff(data, contentData), myIndexingTrace.get(hashId))[ FD ]
Line_15 $$ if (bytes != null) -->Line_17 $$ havePersistentData = true[ CD ]
Line_5 $$ boolean havePersistentData = false-->Line_30 $$ havePersistentData = myContents.containsMapping(hashId)[ FD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_142 $$ updateWithMap(inputId, updateData)[ FD ]
Line_14 $$ ByteSequence bytes = myContents.get(hashId)-->Line_16 $$ data = deserializeSavedPersistentData(bytes)[ FD ]
Line_83 $$ optimizedUpdateData = new MapDiffUpdateData<Key, Value>(myIndexId) -->Line_90 $$ if (currentHashId != null) [ CD ]
Line_11 $$ hashId = getHashOfContent(fileContent)-->Line_22 $$ DebugAssertions.error("Unexpected difference in indexing of %s by index %s, file type %s, charset %s\ndiff %s\nprevious indexed info %s", fileContent.getFile(), myIndexId, fileContent.getFileType().getName(), ((FileContentImpl) fileContent).getCharset(), buildDiff(data, contentData), myIndexingTrace.get(hashId))[ FD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_6 $$ Integer hashId = null[ CD ]
Line_36 $$ if (data == null)-->Line_37 $$ data = content != null ? myIndexer.map(content) : Collections.<Key, Value>emptyMap()[ CD ]
Line_83 $$ optimizedUpdateData = new MapDiffUpdateData<Key, Value>(myIndexId) -->Line_88 $$ Integer currentHashId = myInputsSnapshotMapping.get(inputId)[ CD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_3 $$ final boolean weProcessPhysicalContent = content == null || (content instanceof UserDataHolder && FileBasedIndexImpl.ourPhysicalContentKey.get((UserDataHolder) content, Boolean.FALSE))[ CD ]
Line_13 $$ if (!myContents.isBusyReading() || DebugAssertions.EXTRA_SANITY_CHECKS) -->Line_14 $$ ByteSequence bytes = myContents.get(hashId)[ CD ]
Line_2 $$ public final Computable<Boolean> update(final int inputId, @Nullable Input content) -->Line_37 $$ data = content != null ? myIndexer.map(content) : Collections.<Key, Value>emptyMap()[ FD ]
Line_75 $$ if (content instanceof FileContent) -->Line_76 $$ savedInputId = getHashOfContent((FileContent) content)[ CD ]
Line_63 $$ ByteSequence byteSequence = myContents.get(currentHashId)-->Line_64 $$ currentKeys = byteSequence != null ? deserializeSavedPersistentData(byteSequence).keySet() : Collections.<Key>emptyList()[ FD ]
