Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_51 $$ throw new PrestoException(FUNCTION_IMPLEMENTATION_MISSING, format("%s not found", signature))[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_5 $$ Iterable<SqlFunction> candidates = functions.get(QualifiedName.of(signature.getName()))[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_45 $$ SqlFunction fieldReference = getRowFieldReference(signature.getName(), signature.getArgumentTypes().get(0))[ FD ]
Line_8 $$ List<Type> argumentTypes = resolveTypes(signature.getArgumentTypes(), typeManager)-->Line_10 $$ Map<String, Type> boundTypeParameters = operator.getSignature().bindTypeParameters(returnType, argumentTypes, false, typeManager)[ FD ]
Line_29 $$ Type parameterType = typeManager.getType(parameterTypes.get(0))-->Line_40 $$ checkArgument(methodHandle != null, "Expected type %s to use (or can be converted into) Java type %s, but Java type is %s", type, parameterType.getJavaType(), type.getJavaType())[ FD ]
Line_45 $$ SqlFunction fieldReference = getRowFieldReference(signature.getName(), signature.getArgumentTypes().get(0))-->Line_47 $$ Map<String, Type> boundTypeParameters = fieldReference.getSignature().bindTypeParameters(returnType, argumentTypes, false, typeManager)[ FD ]
Line_10 $$ Map<String, Type> boundTypeParameters = operator.getSignature().bindTypeParameters(returnType, argumentTypes, false, typeManager)-->Line_11 $$ if (boundTypeParameters != null) [ FD ]
Line_46 $$ if (fieldReference != null) -->Line_47 $$ Map<String, Type> boundTypeParameters = fieldReference.getSignature().bindTypeParameters(returnType, argumentTypes, false, typeManager)[ CD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_3 $$ checkArgument(signature.getKind() == SCALAR, "%s is not a scalar function", signature)[ CD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_48 $$ return specializedScalarCache.getUnchecked(new SpecializedFunctionKey(fieldReference, boundTypeParameters, signature.getArgumentTypes().size()))[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_8 $$ List<Type> argumentTypes = resolveTypes(signature.getArgumentTypes(), typeManager)[ CD ]
Line_29 $$ Type parameterType = typeManager.getType(parameterTypes.get(0))-->Line_32 $$ if (parameterType.getJavaType() == type.getJavaType()) [ FD ]
Line_29 $$ Type parameterType = typeManager.getType(parameterTypes.get(0))-->Line_30 $$ requireNonNull(parameterType, format("Type %s not found", parameterTypes.get(0)))[ FD ]
Line_9 $$ for (SqlFunction operator : candidates) -->Line_10 $$ Map<String, Type> boundTypeParameters = operator.getSignature().bindTypeParameters(returnType, argumentTypes, false, typeManager)[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_4 $$ checkArgument(signature.getTypeParameters().isEmpty(), "%s has unbound type parameters", signature)[ FD ]
Line_36 $$ if (type.getJavaType() == Block.class) -->Line_37 $$ methodHandle = BlockSerdeUtil.READ_BLOCK.bindTo(blockEncodingSerde)[ CD ]
Line_32 $$ if (parameterType.getJavaType() == type.getJavaType()) -->Line_33 $$ methodHandle = MethodHandles.identity(parameterType.getJavaType())[ CD ]
Line_33 $$ methodHandle = MethodHandles.identity(parameterType.getJavaType())-->Line_37 $$ methodHandle = BlockSerdeUtil.READ_BLOCK.bindTo(blockEncodingSerde)[ FD ]
Line_31 $$ MethodHandle methodHandle = null-->Line_37 $$ methodHandle = BlockSerdeUtil.READ_BLOCK.bindTo(blockEncodingSerde)[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_5 $$ Iterable<SqlFunction> candidates = functions.get(QualifiedName.of(signature.getName()))[ CD ]
Line_29 $$ Type parameterType = typeManager.getType(parameterTypes.get(0))-->Line_33 $$ methodHandle = MethodHandles.identity(parameterType.getJavaType())[ FD ]
Line_8 $$ List<Type> argumentTypes = resolveTypes(signature.getArgumentTypes(), typeManager)-->Line_47 $$ Map<String, Type> boundTypeParameters = fieldReference.getSignature().bindTypeParameters(returnType, argumentTypes, false, typeManager)[ FD ]
Line_46 $$ if (fieldReference != null) -->Line_48 $$ return specializedScalarCache.getUnchecked(new SpecializedFunctionKey(fieldReference, boundTypeParameters, signature.getArgumentTypes().size()))[ CD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_13 $$ return specializedScalarCache.getUnchecked(new SpecializedFunctionKey(operator, boundTypeParameters, signature.getArgumentTypes().size()))[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_4 $$ checkArgument(signature.getTypeParameters().isEmpty(), "%s has unbound type parameters", signature)[ CD ]
Line_29 $$ Type parameterType = typeManager.getType(parameterTypes.get(0))-->Line_35 $$ if (parameterType.getJavaType() == Slice.class) [ FD ]
Line_45 $$ SqlFunction fieldReference = getRowFieldReference(signature.getName(), signature.getArgumentTypes().get(0))-->Line_46 $$ if (fieldReference != null) [ FD ]
Line_31 $$ MethodHandle methodHandle = null-->Line_33 $$ methodHandle = MethodHandles.identity(parameterType.getJavaType())[ FD ]
Line_21 $$ List<TypeSignature> parameterTypes = signature.getArgumentTypes()-->Line_29 $$ Type parameterType = typeManager.getType(parameterTypes.get(0))[ FD ]
Line_21 $$ List<TypeSignature> parameterTypes = signature.getArgumentTypes()-->Line_30 $$ requireNonNull(parameterType, format("Type %s not found", parameterTypes.get(0)))[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_8 $$ List<Type> argumentTypes = resolveTypes(signature.getArgumentTypes(), typeManager)[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_3 $$ checkArgument(signature.getKind() == SCALAR, "%s is not a scalar function", signature)[ FD ]
Line_35 $$ if (parameterType.getJavaType() == Slice.class) -->Line_36 $$ if (type.getJavaType() == Block.class) [ CD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_21 $$ List<TypeSignature> parameterTypes = signature.getArgumentTypes()[ FD ]
