Line_24 $$ Type parameterType = typeManager.getType(parameterTypes.get(0))-->Line_25 $$ requireNonNull(parameterType, format("Type %s not found", parameterTypes.get(0)))[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_5 $$ Iterable<SqlFunction> candidates = functions.get(QualifiedName.of(signature.getName()))[ CD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_38 $$ if (!signature.getArgumentTypes().isEmpty() && signature.getArgumentTypes().get(0).getBase().equals(StandardTypes.ROW)) [ CD ]
Line_18 $$ if (signature.getName().startsWith(MAGIC_LITERAL_FUNCTION_PREFIX)) -->Line_24 $$ Type parameterType = typeManager.getType(parameterTypes.get(0))[ CD ]
Line_9 $$ Map<String, Type> boundTypeParameters = operator.getSignature().bindTypeParameters(returnType, argumentTypes, false, typeManager)-->Line_10 $$ if (boundTypeParameters != null) [ FD ]
Line_24 $$ Type parameterType = typeManager.getType(parameterTypes.get(0))-->Line_27 $$ if (parameterType.getJavaType() == type.getJavaType()) [ FD ]
Line_21 $$ Type type = typeManager.getType(parseTypeSignature(typeName))-->Line_31 $$ if (type.getJavaType() == Block.class) [ FD ]
Line_18 $$ if (signature.getName().startsWith(MAGIC_LITERAL_FUNCTION_PREFIX)) -->Line_30 $$ if (parameterType.getJavaType() == Slice.class) [ CD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_18 $$ if (signature.getName().startsWith(MAGIC_LITERAL_FUNCTION_PREFIX)) [ FD ]
Line_18 $$ if (signature.getName().startsWith(MAGIC_LITERAL_FUNCTION_PREFIX)) -->Line_20 $$ String typeName = signature.getName().substring(MAGIC_LITERAL_FUNCTION_PREFIX.length())[ CD ]
Line_18 $$ if (signature.getName().startsWith(MAGIC_LITERAL_FUNCTION_PREFIX)) -->Line_19 $$ List<TypeSignature> parameterTypes = signature.getArgumentTypes()[ CD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_7 $$ List<Type> argumentTypes = resolveTypes(signature.getArgumentTypes(), typeManager)[ CD ]
Line_18 $$ if (signature.getName().startsWith(MAGIC_LITERAL_FUNCTION_PREFIX)) -->Line_35 $$ checkArgument(methodHandle != null, "Expected type %s to use (or can be converted into) Java type %s, but Java type is %s", type, parameterType.getJavaType(), type.getJavaType())[ CD ]
Line_39 $$ SqlFunction fieldReference = getRowFieldReference(signature.getName(), signature.getArgumentTypes().get(0))-->Line_41 $$ Map<String, Type> boundTypeParameters = fieldReference.getSignature().bindTypeParameters(returnType, argumentTypes, false, typeManager)[ FD ]
Line_27 $$ if (parameterType.getJavaType() == type.getJavaType()) -->Line_28 $$ methodHandle = MethodHandles.identity(parameterType.getJavaType())[ CD ]
Line_38 $$ if (!signature.getArgumentTypes().isEmpty() && signature.getArgumentTypes().get(0).getBase().equals(StandardTypes.ROW)) -->Line_40 $$ if (fieldReference != null) [ CD ]
Line_21 $$ Type type = typeManager.getType(parseTypeSignature(typeName))-->Line_35 $$ checkArgument(methodHandle != null, "Expected type %s to use (or can be converted into) Java type %s, but Java type is %s", type, parameterType.getJavaType(), type.getJavaType())[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_6 $$ Type returnType = typeManager.getType(signature.getReturnType())[ FD ]
Line_24 $$ Type parameterType = typeManager.getType(parameterTypes.get(0))-->Line_35 $$ checkArgument(methodHandle != null, "Expected type %s to use (or can be converted into) Java type %s, but Java type is %s", type, parameterType.getJavaType(), type.getJavaType())[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_45 $$ throw new PrestoException(FUNCTION_IMPLEMENTATION_MISSING, format("%s not found", signature))[ FD ]
Line_6 $$ Type returnType = typeManager.getType(signature.getReturnType())-->Line_41 $$ Map<String, Type> boundTypeParameters = fieldReference.getSignature().bindTypeParameters(returnType, argumentTypes, false, typeManager)[ FD ]
Line_40 $$ if (fieldReference != null) -->Line_42 $$ return specializedScalarCache.getUnchecked(new SpecializedFunctionKey(fieldReference, boundTypeParameters, signature.getArgumentTypes().size()))[ CD ]
Line_30 $$ if (parameterType.getJavaType() == Slice.class) -->Line_31 $$ if (type.getJavaType() == Block.class) [ CD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_3 $$ checkArgument(signature.getKind() == SCALAR, "%s is not a scalar function", signature)[ CD ]
Line_20 $$ String typeName = signature.getName().substring(MAGIC_LITERAL_FUNCTION_PREFIX.length())-->Line_21 $$ Type type = typeManager.getType(parseTypeSignature(typeName))[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_12 $$ return specializedScalarCache.getUnchecked(new SpecializedFunctionKey(operator, boundTypeParameters, signature.getArgumentTypes().size()))[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_20 $$ String typeName = signature.getName().substring(MAGIC_LITERAL_FUNCTION_PREFIX.length())[ FD ]
Line_19 $$ List<TypeSignature> parameterTypes = signature.getArgumentTypes()-->Line_24 $$ Type parameterType = typeManager.getType(parameterTypes.get(0))[ FD ]
Line_19 $$ List<TypeSignature> parameterTypes = signature.getArgumentTypes()-->Line_25 $$ requireNonNull(parameterType, format("Type %s not found", parameterTypes.get(0)))[ FD ]
Line_24 $$ Type parameterType = typeManager.getType(parameterTypes.get(0))-->Line_30 $$ if (parameterType.getJavaType() == Slice.class) [ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_6 $$ Type returnType = typeManager.getType(signature.getReturnType())[ CD ]
Line_21 $$ Type type = typeManager.getType(parseTypeSignature(typeName))-->Line_27 $$ if (parameterType.getJavaType() == type.getJavaType()) [ FD ]
Line_18 $$ if (signature.getName().startsWith(MAGIC_LITERAL_FUNCTION_PREFIX)) -->Line_27 $$ if (parameterType.getJavaType() == type.getJavaType()) [ CD ]
Line_8 $$ for (SqlFunction operator : candidates) -->Line_9 $$ Map<String, Type> boundTypeParameters = operator.getSignature().bindTypeParameters(returnType, argumentTypes, false, typeManager)[ FD ]
Line_18 $$ if (signature.getName().startsWith(MAGIC_LITERAL_FUNCTION_PREFIX)) -->Line_22 $$ requireNonNull(type, format("Type %s not registered", typeName))[ CD ]
Line_18 $$ if (signature.getName().startsWith(MAGIC_LITERAL_FUNCTION_PREFIX)) -->Line_26 $$ MethodHandle methodHandle = null[ CD ]
Line_38 $$ if (!signature.getArgumentTypes().isEmpty() && signature.getArgumentTypes().get(0).getBase().equals(StandardTypes.ROW)) -->Line_39 $$ SqlFunction fieldReference = getRowFieldReference(signature.getName(), signature.getArgumentTypes().get(0))[ CD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_5 $$ Iterable<SqlFunction> candidates = functions.get(QualifiedName.of(signature.getName()))[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_42 $$ return specializedScalarCache.getUnchecked(new SpecializedFunctionKey(fieldReference, boundTypeParameters, signature.getArgumentTypes().size()))[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_4 $$ checkArgument(signature.getTypeParameters().isEmpty(), "%s has unbound type parameters", signature)[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_18 $$ if (signature.getName().startsWith(MAGIC_LITERAL_FUNCTION_PREFIX)) [ CD ]
Line_18 $$ if (signature.getName().startsWith(MAGIC_LITERAL_FUNCTION_PREFIX)) -->Line_25 $$ requireNonNull(parameterType, format("Type %s not found", parameterTypes.get(0)))[ CD ]
Line_19 $$ List<TypeSignature> parameterTypes = signature.getArgumentTypes()-->Line_23 $$ checkArgument(parameterTypes.size() == 1, "Expected one argument to literal function, but got %s", parameterTypes)[ FD ]
Line_31 $$ if (type.getJavaType() == Block.class) -->Line_32 $$ methodHandle = BlockSerdeUtil.READ_BLOCK.bindTo(blockEncodingSerde)[ CD ]
Line_20 $$ String typeName = signature.getName().substring(MAGIC_LITERAL_FUNCTION_PREFIX.length())-->Line_22 $$ requireNonNull(type, format("Type %s not registered", typeName))[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_4 $$ checkArgument(signature.getTypeParameters().isEmpty(), "%s has unbound type parameters", signature)[ CD ]
Line_26 $$ MethodHandle methodHandle = null-->Line_32 $$ methodHandle = BlockSerdeUtil.READ_BLOCK.bindTo(blockEncodingSerde)[ FD ]
Line_40 $$ if (fieldReference != null) -->Line_41 $$ Map<String, Type> boundTypeParameters = fieldReference.getSignature().bindTypeParameters(returnType, argumentTypes, false, typeManager)[ CD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_38 $$ if (!signature.getArgumentTypes().isEmpty() && signature.getArgumentTypes().get(0).getBase().equals(StandardTypes.ROW)) [ FD ]
Line_26 $$ MethodHandle methodHandle = null-->Line_28 $$ methodHandle = MethodHandles.identity(parameterType.getJavaType())[ FD ]
Line_21 $$ Type type = typeManager.getType(parseTypeSignature(typeName))-->Line_22 $$ requireNonNull(type, format("Type %s not registered", typeName))[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_7 $$ List<Type> argumentTypes = resolveTypes(signature.getArgumentTypes(), typeManager)[ FD ]
Line_18 $$ if (signature.getName().startsWith(MAGIC_LITERAL_FUNCTION_PREFIX)) -->Line_21 $$ Type type = typeManager.getType(parseTypeSignature(typeName))[ CD ]
Line_24 $$ Type parameterType = typeManager.getType(parameterTypes.get(0))-->Line_28 $$ methodHandle = MethodHandles.identity(parameterType.getJavaType())[ FD ]
Line_6 $$ Type returnType = typeManager.getType(signature.getReturnType())-->Line_9 $$ Map<String, Type> boundTypeParameters = operator.getSignature().bindTypeParameters(returnType, argumentTypes, false, typeManager)[ FD ]
Line_28 $$ methodHandle = MethodHandles.identity(parameterType.getJavaType())-->Line_32 $$ methodHandle = BlockSerdeUtil.READ_BLOCK.bindTo(blockEncodingSerde)[ FD ]
Line_18 $$ if (signature.getName().startsWith(MAGIC_LITERAL_FUNCTION_PREFIX)) -->Line_36 $$ return new ScalarFunctionImplementation(false, ImmutableList.of(false), methodHandle, true)[ CD ]
Line_18 $$ if (signature.getName().startsWith(MAGIC_LITERAL_FUNCTION_PREFIX)) -->Line_23 $$ checkArgument(parameterTypes.size() == 1, "Expected one argument to literal function, but got %s", parameterTypes)[ CD ]
Line_39 $$ SqlFunction fieldReference = getRowFieldReference(signature.getName(), signature.getArgumentTypes().get(0))-->Line_40 $$ if (fieldReference != null) [ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_3 $$ checkArgument(signature.getKind() == SCALAR, "%s is not a scalar function", signature)[ FD ]
Line_7 $$ List<Type> argumentTypes = resolveTypes(signature.getArgumentTypes(), typeManager)-->Line_9 $$ Map<String, Type> boundTypeParameters = operator.getSignature().bindTypeParameters(returnType, argumentTypes, false, typeManager)[ FD ]
Line_7 $$ List<Type> argumentTypes = resolveTypes(signature.getArgumentTypes(), typeManager)-->Line_41 $$ Map<String, Type> boundTypeParameters = fieldReference.getSignature().bindTypeParameters(returnType, argumentTypes, false, typeManager)[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_19 $$ List<TypeSignature> parameterTypes = signature.getArgumentTypes()[ FD ]
Line_2 $$ public ScalarFunctionImplementation getScalarFunctionImplementation(Signature signature) -->Line_39 $$ SqlFunction fieldReference = getRowFieldReference(signature.getName(), signature.getArgumentTypes().get(0))[ FD ]
