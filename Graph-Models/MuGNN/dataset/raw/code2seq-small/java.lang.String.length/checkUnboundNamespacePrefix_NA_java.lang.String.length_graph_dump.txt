Line_36 $$ if (element instanceof XmlAttribute) -->Line_39 $$ holder.registerProblem(attribute.getNameElement(), localizedMessage, highlightType, range, fix)[ CD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_14 $$ if (!HighlightingLevelManager.getInstance(containingFile.getProject()).shouldInspect(containingFile))[ CD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_32 $$ final ProblemHighlightType highlightType = infoType == HighlightInfoType.ERROR ? ProblemHighlightType.ERROR : ProblemHighlightType.LIKE_UNKNOWN_SYMBOL[ CD ]
Line_24 $$ LocalQuickFix fix = isOnTheFly ? XmlQuickFixFactory.getInstance().createNSDeclarationIntentionFix(context, namespacePrefix, token) : null-->Line_39 $$ holder.registerProblem(attribute.getNameElement(), localizedMessage, highlightType, range, fix)[ FD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_3 $$ if (namespacePrefix.isEmpty() && (!(element instanceof XmlTag) || !(element.getParent() instanceof XmlDocument)) || XML.equals(namespacePrefix)) [ FD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_10 $$ PsiFile psiFile = context.getContainingFile()[ FD ]
Line_3 $$ if (namespacePrefix.isEmpty() && (!(element instanceof XmlTag) || !(element.getParent() instanceof XmlDocument)) || XML.equals(namespacePrefix)) -->Line_4 $$ return[ CD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_31 $$ final HighlightInfoType infoType = extension.getHighlightInfoType(containingFile)[ CD ]
Line_30 $$ final TextRange range = new TextRange(0, prefixLength)-->Line_35 $$ reportTagProblem(element, localizedMessage, range, highlightType, fix, holder)[ FD ]
Line_13 $$ final XmlFile containingFile = (XmlFile) psiFile-->Line_31 $$ final HighlightInfoType infoType = extension.getHighlightInfoType(containingFile)[ FD ]
Line_36 $$ if (element instanceof XmlAttribute) -->Line_38 $$ XmlAttribute attribute = (XmlAttribute) element[ CD ]
Line_21 $$ if (namespacePrefix.isEmpty()) -->Line_22 $$ final XmlTag tag = (XmlTag) element[ CD ]
Line_20 $$ final String localizedMessage = isOnTheFly ? XmlErrorMessages.message("unbound.namespace", namespacePrefix) : XmlErrorMessages.message("unbound.namespace.no.param")-->Line_41 $$ holder.registerProblem(element, localizedMessage, highlightType, range)[ FD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_17 $$ if (extension.getPrefixDeclaration(context, namespacePrefix) != null) [ CD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_24 $$ LocalQuickFix fix = isOnTheFly ? XmlQuickFixFactory.getInstance().createNSDeclarationIntentionFix(context, namespacePrefix, token) : null[ FD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_21 $$ if (namespacePrefix.isEmpty()) [ CD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_39 $$ holder.registerProblem(attribute.getNameElement(), localizedMessage, highlightType, range, fix)[ FD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_34 $$ LocalQuickFix fix = isOnTheFly ? XmlQuickFixFactory.getInstance().createNSDeclarationIntentionFix(context, namespacePrefix, token) : null[ FD ]
Line_24 $$ LocalQuickFix fix = isOnTheFly ? XmlQuickFixFactory.getInstance().createNSDeclarationIntentionFix(context, namespacePrefix, token) : null-->Line_25 $$ reportTagProblem(tag, localizedMessage, null, ProblemHighlightType.INFORMATION, fix, holder)[ FD ]
Line_11 $$ if (!(psiFile instanceof XmlFile))-->Line_12 $$ return[ CD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_10 $$ PsiFile psiFile = context.getContainingFile()[ CD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_20 $$ final String localizedMessage = isOnTheFly ? XmlErrorMessages.message("unbound.namespace", namespacePrefix) : XmlErrorMessages.message("unbound.namespace.no.param")[ FD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_35 $$ reportTagProblem(element, localizedMessage, range, highlightType, fix, holder)[ FD ]
Line_23 $$ if (!XmlUtil.JSP_URI.equals(tag.getNamespace())) -->Line_25 $$ reportTagProblem(tag, localizedMessage, null, ProblemHighlightType.INFORMATION, fix, holder)[ CD ]
Line_32 $$ final ProblemHighlightType highlightType = infoType == HighlightInfoType.ERROR ? ProblemHighlightType.ERROR : ProblemHighlightType.LIKE_UNKNOWN_SYMBOL-->Line_35 $$ reportTagProblem(element, localizedMessage, range, highlightType, fix, holder)[ FD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_11 $$ if (!(psiFile instanceof XmlFile))[ CD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_21 $$ if (namespacePrefix.isEmpty()) [ FD ]
Line_38 $$ XmlAttribute attribute = (XmlAttribute) element-->Line_39 $$ holder.registerProblem(attribute.getNameElement(), localizedMessage, highlightType, range, fix)[ FD ]
Line_30 $$ final TextRange range = new TextRange(0, prefixLength)-->Line_39 $$ holder.registerProblem(attribute.getNameElement(), localizedMessage, highlightType, range, fix)[ FD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_6 $$ final String namespaceByPrefix = context.getNamespaceByPrefix(namespacePrefix)[ FD ]
Line_33 $$ if (element instanceof XmlTag) -->Line_35 $$ reportTagProblem(element, localizedMessage, range, highlightType, fix, holder)[ CD ]
Line_22 $$ final XmlTag tag = (XmlTag) element-->Line_25 $$ reportTagProblem(tag, localizedMessage, null, ProblemHighlightType.INFORMATION, fix, holder)[ FD ]
Line_16 $$ final XmlExtension extension = XmlExtension.getExtension(containingFile)-->Line_17 $$ if (extension.getPrefixDeclaration(context, namespacePrefix) != null) [ FD ]
Line_20 $$ final String localizedMessage = isOnTheFly ? XmlErrorMessages.message("unbound.namespace", namespacePrefix) : XmlErrorMessages.message("unbound.namespace.no.param")-->Line_35 $$ reportTagProblem(element, localizedMessage, range, highlightType, fix, holder)[ FD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_6 $$ final String namespaceByPrefix = context.getNamespaceByPrefix(namespacePrefix)[ CD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_33 $$ if (element instanceof XmlTag) [ CD ]
Line_14 $$ if (!HighlightingLevelManager.getInstance(containingFile.getProject()).shouldInspect(containingFile))-->Line_15 $$ return[ CD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_36 $$ if (element instanceof XmlAttribute) [ FD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_25 $$ reportTagProblem(tag, localizedMessage, null, ProblemHighlightType.INFORMATION, fix, holder)[ FD ]
Line_17 $$ if (extension.getPrefixDeclaration(context, namespacePrefix) != null) -->Line_18 $$ return[ CD ]
Line_16 $$ final XmlExtension extension = XmlExtension.getExtension(containingFile)-->Line_31 $$ final HighlightInfoType infoType = extension.getHighlightInfoType(containingFile)[ FD ]
Line_20 $$ final String localizedMessage = isOnTheFly ? XmlErrorMessages.message("unbound.namespace", namespacePrefix) : XmlErrorMessages.message("unbound.namespace.no.param")-->Line_39 $$ holder.registerProblem(attribute.getNameElement(), localizedMessage, highlightType, range, fix)[ FD ]
Line_24 $$ LocalQuickFix fix = isOnTheFly ? XmlQuickFixFactory.getInstance().createNSDeclarationIntentionFix(context, namespacePrefix, token) : null-->Line_35 $$ reportTagProblem(element, localizedMessage, range, highlightType, fix, holder)[ FD ]
Line_20 $$ final String localizedMessage = isOnTheFly ? XmlErrorMessages.message("unbound.namespace", namespacePrefix) : XmlErrorMessages.message("unbound.namespace.no.param")-->Line_25 $$ reportTagProblem(tag, localizedMessage, null, ProblemHighlightType.INFORMATION, fix, holder)[ FD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_41 $$ holder.registerProblem(element, localizedMessage, highlightType, range)[ FD ]
Line_13 $$ final XmlFile containingFile = (XmlFile) psiFile-->Line_16 $$ final XmlExtension extension = XmlExtension.getExtension(containingFile)[ FD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_7 $$ if (!namespaceByPrefix.isEmpty()) [ CD ]
Line_7 $$ if (!namespaceByPrefix.isEmpty()) -->Line_8 $$ return[ CD ]
Line_6 $$ final String namespaceByPrefix = context.getNamespaceByPrefix(namespacePrefix)-->Line_7 $$ if (!namespaceByPrefix.isEmpty()) [ FD ]
Line_21 $$ if (namespacePrefix.isEmpty()) -->Line_23 $$ if (!XmlUtil.JSP_URI.equals(tag.getNamespace())) [ CD ]
Line_21 $$ if (namespacePrefix.isEmpty()) -->Line_27 $$ return[ CD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_29 $$ final int prefixLength = namespacePrefix.length()[ FD ]
Line_23 $$ if (!XmlUtil.JSP_URI.equals(tag.getNamespace())) -->Line_24 $$ LocalQuickFix fix = isOnTheFly ? XmlQuickFixFactory.getInstance().createNSDeclarationIntentionFix(context, namespacePrefix, token) : null[ CD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_37 $$ LocalQuickFix fix = isOnTheFly ? XmlQuickFixFactory.getInstance().createNSDeclarationIntentionFix(element, namespacePrefix, token) : null[ FD ]
Line_13 $$ final XmlFile containingFile = (XmlFile) psiFile-->Line_14 $$ if (!HighlightingLevelManager.getInstance(containingFile.getProject()).shouldInspect(containingFile))[ FD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_13 $$ final XmlFile containingFile = (XmlFile) psiFile[ CD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_33 $$ if (element instanceof XmlTag) [ FD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_20 $$ final String localizedMessage = isOnTheFly ? XmlErrorMessages.message("unbound.namespace", namespacePrefix) : XmlErrorMessages.message("unbound.namespace.no.param")[ CD ]
Line_36 $$ if (element instanceof XmlAttribute) -->Line_41 $$ holder.registerProblem(element, localizedMessage, highlightType, range)[ CD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_3 $$ if (namespacePrefix.isEmpty() && (!(element instanceof XmlTag) || !(element.getParent() instanceof XmlDocument)) || XML.equals(namespacePrefix)) [ CD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_16 $$ final XmlExtension extension = XmlExtension.getExtension(containingFile)[ CD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_29 $$ final int prefixLength = namespacePrefix.length()[ CD ]
Line_22 $$ final XmlTag tag = (XmlTag) element-->Line_23 $$ if (!XmlUtil.JSP_URI.equals(tag.getNamespace())) [ FD ]
Line_33 $$ if (element instanceof XmlTag) -->Line_36 $$ if (element instanceof XmlAttribute) [ CD ]
Line_32 $$ final ProblemHighlightType highlightType = infoType == HighlightInfoType.ERROR ? ProblemHighlightType.ERROR : ProblemHighlightType.LIKE_UNKNOWN_SYMBOL-->Line_39 $$ holder.registerProblem(attribute.getNameElement(), localizedMessage, highlightType, range, fix)[ FD ]
Line_32 $$ final ProblemHighlightType highlightType = infoType == HighlightInfoType.ERROR ? ProblemHighlightType.ERROR : ProblemHighlightType.LIKE_UNKNOWN_SYMBOL-->Line_41 $$ holder.registerProblem(element, localizedMessage, highlightType, range)[ FD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_30 $$ final TextRange range = new TextRange(0, prefixLength)[ CD ]
Line_30 $$ final TextRange range = new TextRange(0, prefixLength)-->Line_41 $$ holder.registerProblem(element, localizedMessage, highlightType, range)[ FD ]
Line_2 $$ private static void checkUnboundNamespacePrefix(final XmlElement element, final XmlTag context, String namespacePrefix, final XmlToken token, final ProblemsHolder holder, boolean isOnTheFly) -->Line_17 $$ if (extension.getPrefixDeclaration(context, namespacePrefix) != null) [ FD ]
