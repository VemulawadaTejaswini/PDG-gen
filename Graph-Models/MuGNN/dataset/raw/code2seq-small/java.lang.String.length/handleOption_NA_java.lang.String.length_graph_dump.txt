Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_47 $$ argument = argument.substring(1)[ FD ]
Line_10 $$ if (option.equalsIgnoreCase(READ)) -->Line_15 $$ if (option.equalsIgnoreCase(WRITE)) [ CD ]
Line_23 $$ if (argument.charAt(0) == '*') -->Line_25 $$ constraint.setWithinHierarchy(true)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_48 $$ constraint.setFormalArgTypeWithinHierarchy(true)[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_59 $$ if (option.equalsIgnoreCase(CONTAINS)) [ FD ]
Line_20 $$ if (option.equalsIgnoreCase(REGEX) || option.equalsIgnoreCase(REGEXW)) -->Line_33 $$ if (option.equalsIgnoreCase(EXPRTYPE)) [ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_45 $$ throw new MalformedPatternException(SSRBundle.message("error.regular.expression.argument.expected", option))[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_46 $$ if (argument.charAt(0) == '*') [ FD ]
Line_46 $$ if (argument.charAt(0) == '*') -->Line_47 $$ argument = argument.substring(1)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_60 $$ if (argument.length() == 0)[ FD ]
Line_53 $$ if (option.equalsIgnoreCase(SCRIPT)) -->Line_59 $$ if (option.equalsIgnoreCase(CONTAINS)) [ CD ]
Line_59 $$ if (option.equalsIgnoreCase(CONTAINS)) -->Line_64 $$ if (option.equalsIgnoreCase(WITHIN)) [ CD ]
Line_64 $$ if (option.equalsIgnoreCase(WITHIN)) -->Line_67 $$ if (argument.length() == 0)[ CD ]
Line_64 $$ if (option.equalsIgnoreCase(WITHIN)) -->Line_69 $$ constraint.setWithinConstraint(argument)[ CD ]
Line_10 $$ if (option.equalsIgnoreCase(READ)) -->Line_14 $$ constraint.setInvertReadAccess(invert)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_30 $$ if (option.equalsIgnoreCase(REGEXW)) [ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_22 $$ throw new MalformedPatternException(SSRBundle.message("error.regular.expression.argument.expected", option))[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_53 $$ if (option.equalsIgnoreCase(SCRIPT)) [ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_52 $$ constraint.setInvertFormalType(invert)[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_69 $$ constraint.setWithinConstraint(argument)[ FD ]
Line_43 $$ if (option.equalsIgnoreCase(FORMAL)) -->Line_51 $$ constraint.setNameOfFormalArgType(argument)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_24 $$ argument = argument.substring(1)[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_3 $$ argument = argument.trim()[ FD ]
Line_10 $$ if (option.equalsIgnoreCase(READ)) -->Line_11 $$ if (argument.length() != 0)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_12 $$ throw new MalformedPatternException(SSRBundle.message("error.no.argument.expected", option))[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_40 $$ checkRegex(argument)[ FD ]
Line_53 $$ if (option.equalsIgnoreCase(SCRIPT)) -->Line_58 $$ constraint.setScriptCodeConstraint(argument)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_13 $$ constraint.setReadAccess(true)[ FD ]
Line_10 $$ if (option.equalsIgnoreCase(READ)) -->Line_13 $$ constraint.setReadAccess(true)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_64 $$ if (option.equalsIgnoreCase(WITHIN)) [ FD ]
Line_43 $$ if (option.equalsIgnoreCase(FORMAL)) -->Line_53 $$ if (option.equalsIgnoreCase(SCRIPT)) [ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_70 $$ constraint.setInvertWithinConstraint(invert)[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_19 $$ constraint.setInvertWriteAccess(invert)[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_11 $$ if (argument.length() != 0)[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_72 $$ throw new UnsupportedPatternException(SSRBundle.message("option.is.not.recognized.error.message", option))[ FD ]
Line_59 $$ if (option.equalsIgnoreCase(CONTAINS)) -->Line_60 $$ if (argument.length() == 0)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_18 $$ constraint.setWriteAccess(true)[ FD ]
Line_4 $$ if (option.equalsIgnoreCase(REF)) -->Line_6 $$ constraint.setInvertReference(invert)[ CD ]
Line_43 $$ if (option.equalsIgnoreCase(FORMAL)) -->Line_50 $$ checkRegex(argument)[ CD ]
Line_33 $$ if (option.equalsIgnoreCase(EXPRTYPE)) -->Line_36 $$ if (argument.charAt(0) == '*') [ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_63 $$ constraint.setInvertContainsConstraint(invert)[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_66 $$ throw new MalformedPatternException(SSRBundle.message("error.only.applicable.to.complete.match", option))[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_29 $$ constraint.setInvertRegExp(invert)[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_17 $$ throw new MalformedPatternException(SSRBundle.message("error.no.argument.expected", option))[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_25 $$ constraint.setWithinHierarchy(true)[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_23 $$ if (argument.charAt(0) == '*') [ FD ]
Line_4 $$ if (option.equalsIgnoreCase(REF)) -->Line_9 $$ constraint.setNameOfReferenceVar(argument.substring(1))[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_28 $$ constraint.setRegExp(argument)[ FD ]
Line_43 $$ if (option.equalsIgnoreCase(FORMAL)) -->Line_46 $$ if (argument.charAt(0) == '*') [ CD ]
Line_46 $$ if (argument.charAt(0) == '*') -->Line_48 $$ constraint.setFormalArgTypeWithinHierarchy(true)[ CD ]
Line_33 $$ if (option.equalsIgnoreCase(EXPRTYPE)) -->Line_42 $$ constraint.setInvertExprType(invert)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_57 $$ throw new MalformedPatternException(SSRBundle.message("error.cannot.invert", option))[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_68 $$ throw new MalformedPatternException(SSRBundle.message("error.pattern.argument.expected", option))[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_51 $$ constraint.setNameOfFormalArgType(argument)[ FD ]
Line_15 $$ if (option.equalsIgnoreCase(WRITE)) -->Line_19 $$ constraint.setInvertWriteAccess(invert)[ CD ]
Line_20 $$ if (option.equalsIgnoreCase(REGEX) || option.equalsIgnoreCase(REGEXW)) -->Line_23 $$ if (argument.charAt(0) == '*') [ CD ]
Line_20 $$ if (option.equalsIgnoreCase(REGEX) || option.equalsIgnoreCase(REGEXW)) -->Line_21 $$ if (argument.length() == 0)[ CD ]
Line_33 $$ if (option.equalsIgnoreCase(EXPRTYPE)) -->Line_41 $$ constraint.setNameOfExprType(argument)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_55 $$ throw new MalformedPatternException(SSRBundle.message("error.script.argument.expected", option))[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_54 $$ if (argument.length() == 0)[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_6 $$ constraint.setInvertReference(invert)[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_8 $$ throw new MalformedPatternException(SSRBundle.message("error.reference.variable.name.expected", option))[ FD ]
Line_23 $$ if (argument.charAt(0) == '*') -->Line_24 $$ argument = argument.substring(1)[ CD ]
Line_64 $$ if (option.equalsIgnoreCase(WITHIN)) -->Line_70 $$ constraint.setInvertWithinConstraint(invert)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_4 $$ if (option.equalsIgnoreCase(REF)) [ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_65 $$ if (!Configuration.CONTEXT_VAR_NAME.equals(constraint.getName()))[ FD ]
Line_20 $$ if (option.equalsIgnoreCase(REGEX) || option.equalsIgnoreCase(REGEXW)) -->Line_30 $$ if (option.equalsIgnoreCase(REGEXW)) [ CD ]
Line_33 $$ if (option.equalsIgnoreCase(EXPRTYPE)) -->Line_34 $$ if (argument.length() == 0)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_34 $$ if (argument.length() == 0)[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_10 $$ if (option.equalsIgnoreCase(READ)) [ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_27 $$ checkRegex(argument)[ FD ]
Line_20 $$ if (option.equalsIgnoreCase(REGEX) || option.equalsIgnoreCase(REGEXW)) -->Line_28 $$ constraint.setRegExp(argument)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_35 $$ throw new MalformedPatternException(SSRBundle.message("error.regular.expression.argument.expected", option))[ FD ]
Line_64 $$ if (option.equalsIgnoreCase(WITHIN)) -->Line_65 $$ if (!Configuration.CONTEXT_VAR_NAME.equals(constraint.getName()))[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_41 $$ constraint.setNameOfExprType(argument)[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_58 $$ constraint.setScriptCodeConstraint(argument)[ FD ]
Line_43 $$ if (option.equalsIgnoreCase(FORMAL)) -->Line_44 $$ if (argument.length() == 0)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_43 $$ if (option.equalsIgnoreCase(FORMAL)) [ FD ]
Line_30 $$ if (option.equalsIgnoreCase(REGEXW)) -->Line_31 $$ constraint.setWholeWordsOnly(true)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_37 $$ argument = argument.substring(1)[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_7 $$ if (argument.length() == 0 || argument.charAt(0) != '\'')[ FD ]
Line_53 $$ if (option.equalsIgnoreCase(SCRIPT)) -->Line_56 $$ if (invert)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_31 $$ constraint.setWholeWordsOnly(true)[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_50 $$ checkRegex(argument)[ FD ]
Line_43 $$ if (option.equalsIgnoreCase(FORMAL)) -->Line_52 $$ constraint.setInvertFormalType(invert)[ CD ]
Line_36 $$ if (argument.charAt(0) == '*') -->Line_38 $$ constraint.setExprTypeWithinHierarchy(true)[ CD ]
Line_4 $$ if (option.equalsIgnoreCase(REF)) -->Line_7 $$ if (argument.length() == 0 || argument.charAt(0) != '\'')[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_4 $$ if (option.equalsIgnoreCase(REF)) [ FD ]
Line_53 $$ if (option.equalsIgnoreCase(SCRIPT)) -->Line_54 $$ if (argument.length() == 0)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_44 $$ if (argument.length() == 0)[ FD ]
Line_33 $$ if (option.equalsIgnoreCase(EXPRTYPE)) -->Line_40 $$ checkRegex(argument)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_61 $$ throw new MalformedPatternException(SSRBundle.message("error.pattern.argument.expected", option))[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_3 $$ argument = argument.trim()[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_9 $$ constraint.setNameOfReferenceVar(argument.substring(1))[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_14 $$ constraint.setInvertReadAccess(invert)[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_38 $$ constraint.setExprTypeWithinHierarchy(true)[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_15 $$ if (option.equalsIgnoreCase(WRITE)) [ FD ]
Line_20 $$ if (option.equalsIgnoreCase(REGEX) || option.equalsIgnoreCase(REGEXW)) -->Line_27 $$ checkRegex(argument)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_42 $$ constraint.setInvertExprType(invert)[ FD ]
Line_59 $$ if (option.equalsIgnoreCase(CONTAINS)) -->Line_63 $$ constraint.setInvertContainsConstraint(invert)[ CD ]
Line_33 $$ if (option.equalsIgnoreCase(EXPRTYPE)) -->Line_43 $$ if (option.equalsIgnoreCase(FORMAL)) [ CD ]
Line_20 $$ if (option.equalsIgnoreCase(REGEX) || option.equalsIgnoreCase(REGEXW)) -->Line_29 $$ constraint.setInvertRegExp(invert)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_33 $$ if (option.equalsIgnoreCase(EXPRTYPE)) [ FD ]
Line_36 $$ if (argument.charAt(0) == '*') -->Line_37 $$ argument = argument.substring(1)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_62 $$ constraint.setContainsConstraint(argument)[ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_67 $$ if (argument.length() == 0)[ FD ]
Line_4 $$ if (option.equalsIgnoreCase(REF)) -->Line_5 $$ constraint.setReference(true)[ CD ]
Line_15 $$ if (option.equalsIgnoreCase(WRITE)) -->Line_20 $$ if (option.equalsIgnoreCase(REGEX) || option.equalsIgnoreCase(REGEXW)) [ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_20 $$ if (option.equalsIgnoreCase(REGEX) || option.equalsIgnoreCase(REGEXW)) [ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_36 $$ if (argument.charAt(0) == '*') [ FD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_16 $$ if (argument.length() != 0)[ FD ]
Line_4 $$ if (option.equalsIgnoreCase(REF)) -->Line_10 $$ if (option.equalsIgnoreCase(READ)) [ CD ]
Line_15 $$ if (option.equalsIgnoreCase(WRITE)) -->Line_18 $$ constraint.setWriteAccess(true)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_21 $$ if (argument.length() == 0)[ FD ]
Line_15 $$ if (option.equalsIgnoreCase(WRITE)) -->Line_16 $$ if (argument.length() != 0)[ CD ]
Line_59 $$ if (option.equalsIgnoreCase(CONTAINS)) -->Line_62 $$ constraint.setContainsConstraint(argument)[ CD ]
Line_2 $$ private static void handleOption(@NotNull MatchVariableConstraint constraint, @NotNull String option, @NotNull String argument, boolean invert) -->Line_5 $$ constraint.setReference(true)[ FD ]
