Line_6 $$ TaskManager taskManager = TaskManager.getManager(myProject)-->Line_7 $$ List<Task> allCachedAndLocalTasks = ContainerUtil.concat(taskManager.getCachedIssues(), taskManager.getLocalTasks())[ FD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_8 $$ List<Task> filteredCachedAndLocalTasks = TaskSearchSupport.getLocalAndCachedTasks(taskManager, pattern, everywhere)[ CD ]
Line_50 $$ if (cause instanceof ProcessCanceledException) -->Line_52 $$ if (cause instanceof RuntimeException) [ CD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_3 $$ GotoTaskAction.CREATE_NEW_TASK_ACTION.setTaskName(pattern)[ CD ]
Line_9 $$ if (!processTasks(filteredCachedAndLocalTasks, consumer, cancelled))-->Line_10 $$ return false[ CD ]
Line_24 $$ if (myAlarm.isDisposed()) -->Line_25 $$ return false[ CD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_27 $$ myAlarm.addRequest(future, oldFuture == null && pattern.length() > 5 ? 0 : DELAY_PERIOD)[ FD ]
Line_14 $$ FutureTask<List<Task>> future = new FutureTask<List<Task>>(new Callable<List<Task>>() -->Line_16 $$ return fetchFromServer(pattern, everywhere, cancelled)[ CD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_11 $$ if (filteredCachedAndLocalTasks.size() >= base.getMaximumListSizeLimit()) [ FD ]
Line_36 $$ if (base.hasPostponedAction()) -->Line_38 $$ return true[ CD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_27 $$ myAlarm.addRequest(future, oldFuture == null && pattern.length() > 5 ? 0 : DELAY_PERIOD)[ CD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_9 $$ if (!processTasks(filteredCachedAndLocalTasks, consumer, cancelled))[ CD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_16 $$ return fetchFromServer(pattern, everywhere, cancelled)[ FD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_60 $$ return false[ CD ]
Line_14 $$ FutureTask<List<Task>> future = new FutureTask<List<Task>>(new Callable<List<Task>>() -->Line_41 $$ myFutureReference.compareAndSet(future, null)[ FD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_6 $$ TaskManager taskManager = TaskManager.getManager(myProject)[ CD ]
Line_14 $$ FutureTask<List<Task>> future = new FutureTask<List<Task>>(new Callable<List<Task>>() -->Line_32 $$ tasks = future.get(10, TimeUnit.MILLISECONDS)[ FD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_4 $$ if (!consumer.process(GotoTaskAction.CREATE_NEW_TASK_ACTION))[ CD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_3 $$ GotoTaskAction.CREATE_NEW_TASK_ACTION.setTaskName(pattern)[ FD ]
Line_8 $$ List<Task> filteredCachedAndLocalTasks = TaskSearchSupport.getLocalAndCachedTasks(taskManager, pattern, everywhere)-->Line_9 $$ if (!processTasks(filteredCachedAndLocalTasks, consumer, cancelled))[ FD ]
Line_4 $$ if (!consumer.process(GotoTaskAction.CREATE_NEW_TASK_ACTION))-->Line_5 $$ return false[ CD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_4 $$ if (!consumer.process(GotoTaskAction.CREATE_NEW_TASK_ACTION))[ FD ]
Line_36 $$ if (base.hasPostponedAction()) -->Line_37 $$ future.cancel(true)[ CD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_36 $$ if (base.hasPostponedAction()) [ FD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_24 $$ if (myAlarm.isDisposed()) [ CD ]
Line_8 $$ List<Task> filteredCachedAndLocalTasks = TaskSearchSupport.getLocalAndCachedTasks(taskManager, pattern, everywhere)-->Line_11 $$ if (filteredCachedAndLocalTasks.size() >= base.getMaximumListSizeLimit()) [ FD ]
Line_30 $$ while (true) -->Line_36 $$ if (base.hasPostponedAction()) [ CD ]
Line_14 $$ FutureTask<List<Task>> future = new FutureTask<List<Task>>(new Callable<List<Task>>() -->Line_37 $$ future.cancel(true)[ FD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_19 $$ Future<List<Task>> oldFuture = myFutureReference.getAndSet(future)[ CD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_20 $$ if (oldFuture != null) [ CD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_9 $$ if (!processTasks(filteredCachedAndLocalTasks, consumer, cancelled))[ FD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_43 $$ return processTasks(tasks, consumer, cancelled)[ FD ]
Line_7 $$ List<Task> allCachedAndLocalTasks = ContainerUtil.concat(taskManager.getCachedIssues(), taskManager.getLocalTasks())-->Line_42 $$ tasks.removeAll(allCachedAndLocalTasks)[ FD ]
Line_52 $$ if (cause instanceof RuntimeException) -->Line_54 $$ if (cause instanceof Error) [ CD ]
Line_6 $$ TaskManager taskManager = TaskManager.getManager(myProject)-->Line_8 $$ List<Task> filteredCachedAndLocalTasks = TaskSearchSupport.getLocalAndCachedTasks(taskManager, pattern, everywhere)[ FD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_11 $$ if (filteredCachedAndLocalTasks.size() >= base.getMaximumListSizeLimit()) [ CD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_7 $$ List<Task> allCachedAndLocalTasks = ContainerUtil.concat(taskManager.getCachedIssues(), taskManager.getLocalTasks())[ CD ]
Line_50 $$ if (cause instanceof ProcessCanceledException) -->Line_51 $$ LOG.debug("Task cancelled via progress indicator")[ CD ]
Line_11 $$ if (filteredCachedAndLocalTasks.size() >= base.getMaximumListSizeLimit()) -->Line_12 $$ return true[ CD ]
Line_14 $$ FutureTask<List<Task>> future = new FutureTask<List<Task>>(new Callable<List<Task>>() -->Line_19 $$ Future<List<Task>> oldFuture = myFutureReference.getAndSet(future)[ FD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_14 $$ FutureTask<List<Task>> future = new FutureTask<List<Task>>(new Callable<List<Task>>() [ CD ]
Line_14 $$ FutureTask<List<Task>> future = new FutureTask<List<Task>>(new Callable<List<Task>>() -->Line_27 $$ myAlarm.addRequest(future, oldFuture == null && pattern.length() > 5 ? 0 : DELAY_PERIOD)[ FD ]
Line_20 $$ if (oldFuture != null) -->Line_22 $$ oldFuture.cancel(true)[ CD ]
Line_20 $$ if (oldFuture != null) -->Line_21 $$ LOG.debug("Cancelling existing task")[ CD ]
Line_2 $$ public boolean filterElements(@NotNull ChooseByNameBase base, @NotNull final String pattern, final boolean everywhere, @NotNull final ProgressIndicator cancelled, @NotNull Processor<Object> consumer) -->Line_8 $$ List<Task> filteredCachedAndLocalTasks = TaskSearchSupport.getLocalAndCachedTasks(taskManager, pattern, everywhere)[ FD ]
