Line_133 $$ ProblemHighlightType hl_type-->Line_135 $$ hl_type = ProblemHighlightType.GENERIC_ERROR_OR_WARNING[ FD ]
Line_94 $$ if (qualifier != null) -->Line_95 $$ PyType type = myTypeEvalContext.getType(qualifier)[ CD ]
Line_77 $$ description = PyBundle.message("INSP.module.$0.not.found", refText)-->Line_113 $$ description = PyBundle.message("INSP.unresolved.ref.$0.for.class.$1", refText, type.getName())[ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_152 $$ addPluginQuickFixes(reference, actions)[ CD ]
Line_10 $$ String refText = text-->Line_100 $$ addCreateMemberFromUsageFixes(type, reference, refText, actions)[ FD ]
Line_116 $$ if (isHasCustomMember(refName, type)) -->Line_120 $$ markedQualified = true[ CD ]
Line_120 $$ markedQualified = true-->Line_125 $$ if (!markedQualified) [ FD ]
Line_11 $$ if (rangeInElement.getStartOffset() > 0 && rangeInElement.getEndOffset() > 0) -->Line_12 $$ refText = rangeInElement.substring(text)[ CD ]
Line_155 $$ final List<String> components = qname.getComponents()-->Line_156 $$ if (!components.isEmpty()) [ FD ]
Line_20 $$ for (QualifiedName name : qualifiedNames) -->Line_21 $$ final String canonicalName = name.toString()[ FD ]
Line_77 $$ description = PyBundle.message("INSP.module.$0.not.found", refText)-->Line_81 $$ description = ((PsiReferenceEx) reference).getUnresolvedDescription()[ FD ]
Line_93 $$ final PyExpression qualifier = expr.getQualifier()-->Line_95 $$ PyType type = myTypeEvalContext.getType(qualifier)[ FD ]
Line_37 $$ PyReferenceExpression expr = (PyReferenceExpression) element-->Line_41 $$ if (expr.isQualified()) [ FD ]
Line_6 $$ String description = null-->Line_113 $$ description = PyBundle.message("INSP.unresolved.ref.$0.for.class.$1", refText, type.getName())[ FD ]
Line_41 $$ if (expr.isQualified()) -->Line_70 $$ actions.add(new PyRenameUnresolvedRefQuickFix())[ CD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_75 $$ if ((PsiTreeUtil.getParentOfType(PsiTreeUtil.getParentOfType(node, PyImportElement.class), PyTryExceptStatement.class, PyIfStatement.class) != null)) [ FD ]
Line_77 $$ description = PyBundle.message("INSP.module.$0.not.found", refText)-->Line_111 $$ description = PyBundle.message("INSP.unresolved.operator.ref", className, refName, ((PyOperatorReference) reference).getReadableOperatorName())[ FD ]
Line_33 $$ if (myIgnoredIdentifiers.contains(refName)) -->Line_34 $$ return[ CD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_11 $$ if (rangeInElement.getStartOffset() > 0 && rangeInElement.getEndOffset() > 0) [ CD ]
Line_8 $$ final String text = element.getText()-->Line_12 $$ refText = rangeInElement.substring(text)[ FD ]
Line_36 $$ if (element instanceof PyReferenceExpression) -->Line_37 $$ PyReferenceExpression expr = (PyReferenceExpression) element[ CD ]
Line_7 $$ PsiElement element = reference.getElement()-->Line_86 $$ if ("__qualname__".equals(refText) && LanguageLevel.forElement(element).isAtLeast(LanguageLevel.PYTHON33)) [ FD ]
Line_6 $$ String description = null-->Line_77 $$ description = PyBundle.message("INSP.module.$0.not.found", refText)[ FD ]
Line_37 $$ PyReferenceExpression expr = (PyReferenceExpression) element-->Line_47 $$ if (PyUnreachableCodeInspection.hasAnyInterruptedControlFlowPaths(expr)) [ FD ]
Line_94 $$ if (qualifier != null) -->Line_96 $$ if (type != null) [ CD ]
Line_9 $$ TextRange rangeInElement = reference.getRangeInElement()-->Line_12 $$ refText = rangeInElement.substring(text)[ FD ]
Line_81 $$ description = ((PsiReferenceEx) reference).getUnresolvedDescription()-->Line_126 $$ description = PyBundle.message("INSP.unresolved.ref.$0", refText)[ FD ]
Line_119 $$ description = PyBundle.message("INSP.cannot.find.$0.in.$1", refText, type.getName())-->Line_126 $$ description = PyBundle.message("INSP.unresolved.ref.$0", refText)[ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_42 $$ final PyClassTypeImpl object_type = (PyClassTypeImpl) PyBuiltinCache.getInstance(node).getObjectType()[ FD ]
Line_41 $$ if (expr.isQualified()) -->Line_47 $$ if (PyUnreachableCodeInspection.hasAnyInterruptedControlFlowPaths(expr)) [ CD ]
Line_14 $$ final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2)-->Line_100 $$ addCreateMemberFromUsageFixes(type, reference, refText, actions)[ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_141 $$ PyImportStatementBase importStatementBase = PsiTreeUtil.getParentOfType(element, PyImportStatementBase.class)[ CD ]
Line_141 $$ PyImportStatementBase importStatementBase = PsiTreeUtil.getParentOfType(element, PyImportStatementBase.class)-->Line_142 $$ if ((importStatementBase != null) && GenerateBinaryStubsFix.isApplicable(importStatementBase)) [ FD ]
Line_157 $$ final String packageName = components.get(0)-->Line_161 $$ if (PyPIPackageUtil.INSTANCE.isInPyPI(packageName)) [ FD ]
Line_10 $$ String refText = text-->Line_119 $$ description = PyBundle.message("INSP.cannot.find.$0.in.$1", refText, type.getName())[ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_128 $$ addAutoImportFix(node, reference, actions)[ FD ]
Line_113 $$ description = PyBundle.message("INSP.unresolved.ref.$0.for.class.$1", refText, type.getName())-->Line_172 $$ registerProblem(node, description, hl_type, null, rangeInElement, actions.toArray(new LocalQuickFix[actions.size()]))[ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_172 $$ registerProblem(node, description, hl_type, null, rangeInElement, actions.toArray(new LocalQuickFix[actions.size()]))[ FD ]
Line_28 $$ if (canonicalName.equals(ignored)) -->Line_29 $$ return[ CD ]
Line_115 $$ markedQualified = true-->Line_125 $$ if (!markedQualified) [ FD ]
Line_139 $$ hl_type = ProblemHighlightType.LIKE_UNKNOWN_SYMBOL-->Line_172 $$ registerProblem(node, description, hl_type, null, rangeInElement, actions.toArray(new LocalQuickFix[actions.size()]))[ FD ]
Line_95 $$ PyType type = myTypeEvalContext.getType(qualifier)-->Line_119 $$ description = PyBundle.message("INSP.cannot.find.$0.in.$1", refText, type.getName())[ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_58 $$ addAddSelfFix(node, expr, actions)[ FD ]
Line_10 $$ String refText = text-->Line_126 $$ description = PyBundle.message("INSP.unresolved.ref.$0", refText)[ FD ]
Line_136 $$ if (severity == HighlightSeverity.ERROR) -->Line_137 $$ hl_type = ProblemHighlightType.GENERIC_ERROR[ CD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_142 $$ if ((importStatementBase != null) && GenerateBinaryStubsFix.isApplicable(importStatementBase)) [ CD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_10 $$ String refText = text[ CD ]
Line_41 $$ if (expr.isQualified()) -->Line_64 $$ final PyDecorator decorator = PsiTreeUtil.getParentOfType(element, PyDecorator.class)[ CD ]
Line_136 $$ if (severity == HighlightSeverity.ERROR) -->Line_139 $$ hl_type = ProblemHighlightType.LIKE_UNKNOWN_SYMBOL[ CD ]
Line_14 $$ final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2)-->Line_147 $$ actions.add(new AddIgnoredIdentifierQuickFix(qualifiedName, false))[ FD ]
Line_10 $$ String refText = text-->Line_77 $$ description = PyBundle.message("INSP.module.$0.not.found", refText)[ FD ]
Line_15 $$ final String refName = (element instanceof PyQualifiedExpression) ? ((PyQualifiedExpression) element).getReferencedName() : refText-->Line_154 $$ final QualifiedName qname = QualifiedName.fromDottedString(refName)[ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_19 $$ final List<QualifiedName> qualifiedNames = getCanonicalNames(reference, myTypeEvalContext)[ CD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_97 $$ if (ignoreUnresolvedMemberForType(type, reference, refName)) [ FD ]
Line_116 $$ if (isHasCustomMember(refName, type)) -->Line_119 $$ description = PyBundle.message("INSP.cannot.find.$0.in.$1", refText, type.getName())[ CD ]
Line_106 $$ final PyClassLikeType metaClassType = classType.getMetaClassType(myTypeEvalContext, true)-->Line_107 $$ if (metaClassType != null) [ FD ]
Line_7 $$ PsiElement element = reference.getElement()-->Line_141 $$ PyImportStatementBase importStatementBase = PsiTreeUtil.getParentOfType(element, PyImportStatementBase.class)[ FD ]
Line_7 $$ PsiElement element = reference.getElement()-->Line_36 $$ if (element instanceof PyReferenceExpression) [ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_3 $$ if (reference instanceof DocStringTypeReference) [ FD ]
Line_15 $$ final String refName = (element instanceof PyQualifiedExpression) ? ((PyQualifiedExpression) element).getReferencedName() : refText-->Line_43 $$ if ((object_type != null) && object_type.getPossibleInstanceMembers().contains(refName)) [ FD ]
Line_85 $$ if (element instanceof PyQualifiedExpression) -->Line_90 $$ if (PyNames.COMPARISON_OPERATORS.contains(expr.getReferencedName())) [ CD ]
Line_41 $$ if (expr.isQualified()) -->Line_42 $$ final PyClassTypeImpl object_type = (PyClassTypeImpl) PyBuiltinCache.getInstance(node).getObjectType()[ CD ]
Line_148 $$ if (qualifiedName.getComponentCount() > 1) -->Line_149 $$ actions.add(new AddIgnoredIdentifierQuickFix(qualifiedName.removeLastComponent(), true))[ CD ]
Line_41 $$ if (expr.isQualified()) -->Line_65 $$ final PyAnnotation annotation = PsiTreeUtil.getParentOfType(element, PyAnnotation.class)[ CD ]
Line_145 $$ if (qualifiedNames.size() == 1) -->Line_146 $$ final QualifiedName qualifiedName = qualifiedNames.get(0)[ CD ]
Line_153 $$ if (reference instanceof PyImportReference) -->Line_156 $$ if (!components.isEmpty()) [ CD ]
Line_156 $$ if (!components.isEmpty()) -->Line_159 $$ final Sdk sdk = PythonSdkType.findPythonSdk(module)[ CD ]
Line_119 $$ description = PyBundle.message("INSP.cannot.find.$0.in.$1", refText, type.getName())-->Line_172 $$ registerProblem(node, description, hl_type, null, rangeInElement, actions.toArray(new LocalQuickFix[actions.size()]))[ FD ]
Line_81 $$ description = ((PsiReferenceEx) reference).getUnresolvedDescription()-->Line_111 $$ description = PyBundle.message("INSP.unresolved.operator.ref", className, refName, ((PyOperatorReference) reference).getReadableOperatorName())[ FD ]
Line_90 $$ if (PyNames.COMPARISON_OPERATORS.contains(expr.getReferencedName())) -->Line_91 $$ return[ CD ]
Line_95 $$ PyType type = myTypeEvalContext.getType(qualifier)-->Line_101 $$ if (type instanceof PyClassType) [ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_100 $$ addCreateMemberFromUsageFixes(type, reference, refText, actions)[ FD ]
Line_127 $$ if (PythonReferenceImporter.isImportable(element)) -->Line_128 $$ addAutoImportFix(node, reference, actions)[ CD ]
Line_19 $$ final List<QualifiedName> qualifiedNames = getCanonicalNames(reference, myTypeEvalContext)-->Line_145 $$ if (qualifiedNames.size() == 1) [ FD ]
Line_95 $$ PyType type = myTypeEvalContext.getType(qualifier)-->Line_97 $$ if (ignoreUnresolvedMemberForType(type, reference, refName)) [ FD ]
Line_160 $$ if (module != null && sdk != null && PyPackageUtil.packageManagementEnabled(sdk)) -->Line_161 $$ if (PyPIPackageUtil.INSTANCE.isInPyPI(packageName)) [ CD ]
Line_96 $$ if (type != null) -->Line_100 $$ addCreateMemberFromUsageFixes(type, reference, refText, actions)[ CD ]
Line_7 $$ PsiElement element = reference.getElement()-->Line_130 $$ addCreateClassFix(refText, element, actions)[ FD ]
Line_10 $$ String refText = text-->Line_12 $$ refText = rangeInElement.substring(text)[ FD ]
Line_157 $$ final String packageName = components.get(0)-->Line_162 $$ addInstallPackageAction(actions, packageName, module, sdk)[ FD ]
Line_41 $$ if (expr.isQualified()) -->Line_43 $$ if ((object_type != null) && object_type.getPossibleInstanceMembers().contains(refName)) [ CD ]
Line_157 $$ final String packageName = components.get(0)-->Line_165 $$ final String suggestedPackage = PyPIPackageUtil.PACKAGES_TOPLEVEL.get(packageName)[ FD ]
Line_133 $$ ProblemHighlightType hl_type-->Line_172 $$ registerProblem(node, description, hl_type, null, rangeInElement, actions.toArray(new LocalQuickFix[actions.size()]))[ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_9 $$ TextRange rangeInElement = reference.getRangeInElement()[ FD ]
Line_42 $$ final PyClassTypeImpl object_type = (PyClassTypeImpl) PyBuiltinCache.getInstance(node).getObjectType()-->Line_43 $$ if ((object_type != null) && object_type.getPossibleInstanceMembers().contains(refName)) [ FD ]
Line_75 $$ if ((PsiTreeUtil.getParentOfType(PsiTreeUtil.getParentOfType(node, PyImportElement.class), PyTryExceptStatement.class, PyIfStatement.class) != null)) -->Line_77 $$ description = PyBundle.message("INSP.module.$0.not.found", refText)[ CD ]
Line_95 $$ PyType type = myTypeEvalContext.getType(qualifier)-->Line_116 $$ if (isHasCustomMember(refName, type)) [ FD ]
Line_9 $$ TextRange rangeInElement = reference.getRangeInElement()-->Line_11 $$ if (rangeInElement.getStartOffset() > 0 && rangeInElement.getEndOffset() > 0) [ FD ]
Line_104 $$ final PyClassType classType = (PyClassType) type-->Line_105 $$ if (classType.isDefinition()) [ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_158 $$ final Module module = ModuleUtilCore.findModuleForPsiElement(node)[ FD ]
Line_95 $$ PyType type = myTypeEvalContext.getType(qualifier)-->Line_113 $$ description = PyBundle.message("INSP.unresolved.ref.$0.for.class.$1", refText, type.getName())[ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_50 $$ if (LanguageLevel.forElement(node).isOlderThan(LanguageLevel.PYTHON26)) [ FD ]
Line_134 $$ if (severity == HighlightSeverity.WARNING) -->Line_136 $$ if (severity == HighlightSeverity.ERROR) [ CD ]
Line_15 $$ final String refName = (element instanceof PyQualifiedExpression) ? ((PyQualifiedExpression) element).getReferencedName() : refText-->Line_38 $$ if (PyNames.COMPARISON_OPERATORS.contains(refName)) [ FD ]
Line_12 $$ refText = rangeInElement.substring(text)-->Line_77 $$ description = PyBundle.message("INSP.module.$0.not.found", refText)[ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_36 $$ if (element instanceof PyReferenceExpression) [ CD ]
Line_12 $$ refText = rangeInElement.substring(text)-->Line_100 $$ addCreateMemberFromUsageFixes(type, reference, refText, actions)[ FD ]
Line_60 $$ if (callExpression != null && (!(callExpression.getCallee() instanceof PyQualifiedExpression) || ((PyQualifiedExpression) callExpression.getCallee()).getQualifier() == null)) -->Line_61 $$ actions.add(new UnresolvedRefCreateFunctionQuickFix(callExpression, expr))[ CD ]
Line_15 $$ final String refName = (element instanceof PyQualifiedExpression) ? ((PyQualifiedExpression) element).getReferencedName() : refText-->Line_97 $$ if (ignoreUnresolvedMemberForType(type, reference, refName)) [ FD ]
Line_23 $$ if (ignored.endsWith(END_WILDCARD)) -->Line_28 $$ if (canonicalName.equals(ignored)) [ CD ]
Line_95 $$ PyType type = myTypeEvalContext.getType(qualifier)-->Line_96 $$ if (type != null) [ FD ]
Line_15 $$ final String refName = (element instanceof PyQualifiedExpression) ? ((PyQualifiedExpression) element).getReferencedName() : refText-->Line_16 $$ if (refName == null || refName.length() <= 0) [ FD ]
Line_101 $$ if (type instanceof PyClassType) -->Line_116 $$ if (isHasCustomMember(refName, type)) [ CD ]
Line_116 $$ if (isHasCustomMember(refName, type)) -->Line_117 $$ return[ CD ]
Line_47 $$ if (PyUnreachableCodeInspection.hasAnyInterruptedControlFlowPaths(expr)) -->Line_48 $$ return[ CD ]
Line_134 $$ if (severity == HighlightSeverity.WARNING) -->Line_135 $$ hl_type = ProblemHighlightType.GENERIC_ERROR_OR_WARNING[ CD ]
Line_137 $$ hl_type = ProblemHighlightType.GENERIC_ERROR-->Line_139 $$ hl_type = ProblemHighlightType.LIKE_UNKNOWN_SYMBOL[ FD ]
Line_159 $$ final Sdk sdk = PythonSdkType.findPythonSdk(module)-->Line_160 $$ if (module != null && sdk != null && PyPackageUtil.packageManagementEnabled(sdk)) [ FD ]
Line_14 $$ final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2)-->Line_162 $$ addInstallPackageAction(actions, packageName, module, sdk)[ FD ]
Line_22 $$ for (String ignored : myIgnoredIdentifiers) -->Line_28 $$ if (canonicalName.equals(ignored)) [ FD ]
Line_41 $$ if (expr.isQualified()) -->Line_67 $$ if (parentFunction != null && decorator == null && annotation == null && importStatement == null) [ CD ]
Line_77 $$ description = PyBundle.message("INSP.module.$0.not.found", refText)-->Line_172 $$ registerProblem(node, description, hl_type, null, rangeInElement, actions.toArray(new LocalQuickFix[actions.size()]))[ FD ]
Line_77 $$ description = PyBundle.message("INSP.module.$0.not.found", refText)-->Line_126 $$ description = PyBundle.message("INSP.unresolved.ref.$0", refText)[ FD ]
Line_6 $$ String description = null-->Line_126 $$ description = PyBundle.message("INSP.unresolved.ref.$0", refText)[ FD ]
Line_145 $$ if (qualifiedNames.size() == 1) -->Line_148 $$ if (qualifiedName.getComponentCount() > 1) [ CD ]
Line_137 $$ hl_type = ProblemHighlightType.GENERIC_ERROR-->Line_172 $$ registerProblem(node, description, hl_type, null, rangeInElement, actions.toArray(new LocalQuickFix[actions.size()]))[ FD ]
Line_115 $$ markedQualified = true-->Line_120 $$ markedQualified = true[ FD ]
Line_12 $$ refText = rangeInElement.substring(text)-->Line_55 $$ if (refText.equals("true") || refText.equals("false")) [ FD ]
Line_12 $$ refText = rangeInElement.substring(text)-->Line_126 $$ description = PyBundle.message("INSP.unresolved.ref.$0", refText)[ FD ]
Line_154 $$ final QualifiedName qname = QualifiedName.fromDottedString(refName)-->Line_155 $$ final List<String> components = qname.getComponents()[ FD ]
Line_14 $$ final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2)-->Line_70 $$ actions.add(new PyRenameUnresolvedRefQuickFix())[ FD ]
Line_41 $$ if (expr.isQualified()) -->Line_58 $$ addAddSelfFix(node, expr, actions)[ CD ]
Line_25 $$ if (canonicalName.startsWith(prefix)) -->Line_26 $$ return[ CD ]
Line_6 $$ String description = null-->Line_81 $$ description = ((PsiReferenceEx) reference).getUnresolvedDescription()[ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_153 $$ if (reference instanceof PyImportReference) [ FD ]
Line_158 $$ final Module module = ModuleUtilCore.findModuleForPsiElement(node)-->Line_162 $$ addInstallPackageAction(actions, packageName, module, sdk)[ FD ]
Line_21 $$ final String canonicalName = name.toString()-->Line_28 $$ if (canonicalName.equals(ignored)) [ FD ]
Line_6 $$ String description = null-->Line_119 $$ description = PyBundle.message("INSP.cannot.find.$0.in.$1", refText, type.getName())[ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_8 $$ final String text = element.getText()[ CD ]
Line_107 $$ if (metaClassType != null) -->Line_108 $$ className = metaClassType.getName()[ CD ]
Line_135 $$ hl_type = ProblemHighlightType.GENERIC_ERROR_OR_WARNING-->Line_139 $$ hl_type = ProblemHighlightType.LIKE_UNKNOWN_SYMBOL[ FD ]
Line_10 $$ String refText = text-->Line_130 $$ addCreateClassFix(refText, element, actions)[ FD ]
Line_12 $$ refText = rangeInElement.substring(text)-->Line_113 $$ description = PyBundle.message("INSP.unresolved.ref.$0.for.class.$1", refText, type.getName())[ FD ]
Line_142 $$ if ((importStatementBase != null) && GenerateBinaryStubsFix.isApplicable(importStatementBase)) -->Line_143 $$ actions.addAll(GenerateBinaryStubsFix.generateFixes(importStatementBase))[ CD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_19 $$ final List<QualifiedName> qualifiedNames = getCanonicalNames(reference, myTypeEvalContext)[ FD ]
Line_19 $$ final List<QualifiedName> qualifiedNames = getCanonicalNames(reference, myTypeEvalContext)-->Line_146 $$ final QualifiedName qualifiedName = qualifiedNames.get(0)[ FD ]
Line_158 $$ final Module module = ModuleUtilCore.findModuleForPsiElement(node)-->Line_166 $$ addInstallPackageAction(actions, suggestedPackage, module, sdk)[ FD ]
Line_102 $$ if (reference instanceof PyOperatorReference) -->Line_113 $$ description = PyBundle.message("INSP.unresolved.ref.$0.for.class.$1", refText, type.getName())[ CD ]
Line_159 $$ final Sdk sdk = PythonSdkType.findPythonSdk(module)-->Line_166 $$ addInstallPackageAction(actions, suggestedPackage, module, sdk)[ FD ]
Line_59 $$ PyCallExpression callExpression = PsiTreeUtil.getParentOfType(element, PyCallExpression.class)-->Line_60 $$ if (callExpression != null && (!(callExpression.getCallee() instanceof PyQualifiedExpression) || ((PyQualifiedExpression) callExpression.getCallee()).getQualifier() == null)) [ FD ]
Line_106 $$ final PyClassLikeType metaClassType = classType.getMetaClassType(myTypeEvalContext, true)-->Line_108 $$ className = metaClassType.getName()[ FD ]
Line_80 $$ if (reference instanceof PsiReferenceEx && description == null) -->Line_81 $$ description = ((PsiReferenceEx) reference).getUnresolvedDescription()[ CD ]
Line_125 $$ if (!markedQualified) -->Line_127 $$ if (PythonReferenceImporter.isImportable(element)) [ CD ]
Line_101 $$ if (type instanceof PyClassType) -->Line_102 $$ if (reference instanceof PyOperatorReference) [ CD ]
Line_101 $$ if (type instanceof PyClassType) -->Line_115 $$ markedQualified = true[ CD ]
Line_15 $$ final String refName = (element instanceof PyQualifiedExpression) ? ((PyQualifiedExpression) element).getReferencedName() : refText-->Line_33 $$ if (myIgnoredIdentifiers.contains(refName)) [ FD ]
Line_15 $$ final String refName = (element instanceof PyQualifiedExpression) ? ((PyQualifiedExpression) element).getReferencedName() : refText-->Line_116 $$ if (isHasCustomMember(refName, type)) [ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_136 $$ if (severity == HighlightSeverity.ERROR) [ FD ]
Line_14 $$ final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2)-->Line_130 $$ addCreateClassFix(refText, element, actions)[ FD ]
Line_161 $$ if (PyPIPackageUtil.INSTANCE.isInPyPI(packageName)) -->Line_162 $$ addInstallPackageAction(actions, packageName, module, sdk)[ CD ]
Line_111 $$ description = PyBundle.message("INSP.unresolved.operator.ref", className, refName, ((PyOperatorReference) reference).getReadableOperatorName())-->Line_126 $$ description = PyBundle.message("INSP.unresolved.ref.$0", refText)[ FD ]
Line_161 $$ if (PyPIPackageUtil.INSTANCE.isInPyPI(packageName)) -->Line_164 $$ if (PyPIPackageUtil.PACKAGES_TOPLEVEL.containsKey(packageName)) [ CD ]
Line_157 $$ final String packageName = components.get(0)-->Line_164 $$ if (PyPIPackageUtil.PACKAGES_TOPLEVEL.containsKey(packageName)) [ FD ]
Line_51 $$ if ("with".equals(refName)) -->Line_52 $$ actions.add(new UnresolvedRefAddFutureImportQuickFix())[ CD ]
Line_41 $$ if (expr.isQualified()) -->Line_63 $$ final PyFunction parentFunction = PsiTreeUtil.getParentOfType(element, PyFunction.class)[ CD ]
Line_133 $$ ProblemHighlightType hl_type-->Line_139 $$ hl_type = ProblemHighlightType.LIKE_UNKNOWN_SYMBOL[ FD ]
Line_158 $$ final Module module = ModuleUtilCore.findModuleForPsiElement(node)-->Line_159 $$ final Sdk sdk = PythonSdkType.findPythonSdk(module)[ FD ]
Line_15 $$ final String refName = (element instanceof PyQualifiedExpression) ? ((PyQualifiedExpression) element).getReferencedName() : refText-->Line_51 $$ if ("with".equals(refName)) [ FD ]
Line_14 $$ final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2)-->Line_61 $$ actions.add(new UnresolvedRefCreateFunctionQuickFix(callExpression, expr))[ FD ]
Line_97 $$ if (ignoreUnresolvedMemberForType(type, reference, refName)) -->Line_98 $$ return[ CD ]
Line_77 $$ description = PyBundle.message("INSP.module.$0.not.found", refText)-->Line_119 $$ description = PyBundle.message("INSP.cannot.find.$0.in.$1", refText, type.getName())[ FD ]
Line_83 $$ if (description == null) -->Line_84 $$ boolean markedQualified = false[ CD ]
Line_93 $$ final PyExpression qualifier = expr.getQualifier()-->Line_94 $$ if (qualifier != null) [ FD ]
Line_135 $$ hl_type = ProblemHighlightType.GENERIC_ERROR_OR_WARNING-->Line_137 $$ hl_type = ProblemHighlightType.GENERIC_ERROR[ FD ]
Line_37 $$ PyReferenceExpression expr = (PyReferenceExpression) element-->Line_90 $$ if (PyNames.COMPARISON_OPERATORS.contains(expr.getReferencedName())) [ FD ]
Line_111 $$ description = PyBundle.message("INSP.unresolved.operator.ref", className, refName, ((PyOperatorReference) reference).getReadableOperatorName())-->Line_119 $$ description = PyBundle.message("INSP.cannot.find.$0.in.$1", refText, type.getName())[ FD ]
Line_84 $$ boolean markedQualified = false-->Line_125 $$ if (!markedQualified) [ FD ]
Line_164 $$ if (PyPIPackageUtil.PACKAGES_TOPLEVEL.containsKey(packageName)) -->Line_165 $$ final String suggestedPackage = PyPIPackageUtil.PACKAGES_TOPLEVEL.get(packageName)[ CD ]
Line_164 $$ if (PyPIPackageUtil.PACKAGES_TOPLEVEL.containsKey(packageName)) -->Line_166 $$ addInstallPackageAction(actions, suggestedPackage, module, sdk)[ CD ]
Line_146 $$ final QualifiedName qualifiedName = qualifiedNames.get(0)-->Line_149 $$ actions.add(new AddIgnoredIdentifierQuickFix(qualifiedName.removeLastComponent(), true))[ FD ]
Line_36 $$ if (element instanceof PyReferenceExpression) -->Line_72 $$ if (PyModuleType.getPossibleInstanceMembers().contains(refName)) [ CD ]
Line_36 $$ if (element instanceof PyReferenceExpression) -->Line_75 $$ if ((PsiTreeUtil.getParentOfType(PsiTreeUtil.getParentOfType(node, PyImportElement.class), PyTryExceptStatement.class, PyIfStatement.class) != null)) [ CD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_102 $$ if (reference instanceof PyOperatorReference) [ FD ]
Line_102 $$ if (reference instanceof PyOperatorReference) -->Line_111 $$ description = PyBundle.message("INSP.unresolved.operator.ref", className, refName, ((PyOperatorReference) reference).getReadableOperatorName())[ CD ]
Line_21 $$ final String canonicalName = name.toString()-->Line_25 $$ if (canonicalName.startsWith(prefix)) [ FD ]
Line_55 $$ if (refText.equals("true") || refText.equals("false")) -->Line_56 $$ actions.add(new UnresolvedRefTrueFalseQuickFix(element))[ CD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_9 $$ TextRange rangeInElement = reference.getRangeInElement()[ CD ]
Line_81 $$ description = ((PsiReferenceEx) reference).getUnresolvedDescription()-->Line_119 $$ description = PyBundle.message("INSP.cannot.find.$0.in.$1", refText, type.getName())[ FD ]
Line_84 $$ boolean markedQualified = false-->Line_120 $$ markedQualified = true[ FD ]
Line_83 $$ if (description == null) -->Line_125 $$ if (!markedQualified) [ CD ]
Line_7 $$ PsiElement element = reference.getElement()-->Line_85 $$ if (element instanceof PyQualifiedExpression) [ FD ]
Line_105 $$ if (classType.isDefinition()) -->Line_106 $$ final PyClassLikeType metaClassType = classType.getMetaClassType(myTypeEvalContext, true)[ CD ]
Line_83 $$ if (description == null) -->Line_85 $$ if (element instanceof PyQualifiedExpression) [ CD ]
Line_23 $$ if (ignored.endsWith(END_WILDCARD)) -->Line_25 $$ if (canonicalName.startsWith(prefix)) [ CD ]
Line_85 $$ if (element instanceof PyQualifiedExpression) -->Line_86 $$ if ("__qualname__".equals(refText) && LanguageLevel.forElement(element).isAtLeast(LanguageLevel.PYTHON33)) [ CD ]
Line_103 $$ String className = type.getName()-->Line_111 $$ description = PyBundle.message("INSP.unresolved.operator.ref", className, refName, ((PyOperatorReference) reference).getReadableOperatorName())[ FD ]
Line_155 $$ final List<String> components = qname.getComponents()-->Line_157 $$ final String packageName = components.get(0)[ FD ]
Line_133 $$ ProblemHighlightType hl_type-->Line_137 $$ hl_type = ProblemHighlightType.GENERIC_ERROR[ FD ]
Line_7 $$ PsiElement element = reference.getElement()-->Line_59 $$ PyCallExpression callExpression = PsiTreeUtil.getParentOfType(element, PyCallExpression.class)[ FD ]
Line_146 $$ final QualifiedName qualifiedName = qualifiedNames.get(0)-->Line_148 $$ if (qualifiedName.getComponentCount() > 1) [ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_16 $$ if (refName == null || refName.length() <= 0) [ CD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_15 $$ final String refName = (element instanceof PyQualifiedExpression) ? ((PyQualifiedExpression) element).getReferencedName() : refText[ CD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_80 $$ if (reference instanceof PsiReferenceEx && description == null) [ CD ]
Line_156 $$ if (!components.isEmpty()) -->Line_158 $$ final Module module = ModuleUtilCore.findModuleForPsiElement(node)[ CD ]
Line_22 $$ for (String ignored : myIgnoredIdentifiers) -->Line_23 $$ if (ignored.endsWith(END_WILDCARD)) [ FD ]
Line_126 $$ description = PyBundle.message("INSP.unresolved.ref.$0", refText)-->Line_172 $$ registerProblem(node, description, hl_type, null, rangeInElement, actions.toArray(new LocalQuickFix[actions.size()]))[ FD ]
Line_81 $$ description = ((PsiReferenceEx) reference).getUnresolvedDescription()-->Line_113 $$ description = PyBundle.message("INSP.unresolved.ref.$0.for.class.$1", refText, type.getName())[ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_6 $$ String description = null[ CD ]
Line_14 $$ final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2)-->Line_143 $$ actions.addAll(GenerateBinaryStubsFix.generateFixes(importStatementBase))[ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_33 $$ if (myIgnoredIdentifiers.contains(refName)) [ CD ]
Line_41 $$ if (expr.isQualified()) -->Line_50 $$ if (LanguageLevel.forElement(node).isOlderThan(LanguageLevel.PYTHON26)) [ CD ]
Line_7 $$ PsiElement element = reference.getElement()-->Line_63 $$ final PyFunction parentFunction = PsiTreeUtil.getParentOfType(element, PyFunction.class)[ FD ]
Line_103 $$ String className = type.getName()-->Line_108 $$ className = metaClassType.getName()[ FD ]
Line_6 $$ String description = null-->Line_172 $$ registerProblem(node, description, hl_type, null, rangeInElement, actions.toArray(new LocalQuickFix[actions.size()]))[ FD ]
Line_12 $$ refText = rangeInElement.substring(text)-->Line_130 $$ addCreateClassFix(refText, element, actions)[ FD ]
Line_111 $$ description = PyBundle.message("INSP.unresolved.operator.ref", className, refName, ((PyOperatorReference) reference).getReadableOperatorName())-->Line_113 $$ description = PyBundle.message("INSP.unresolved.ref.$0.for.class.$1", refText, type.getName())[ FD ]
Line_111 $$ description = PyBundle.message("INSP.unresolved.operator.ref", className, refName, ((PyOperatorReference) reference).getReadableOperatorName())-->Line_172 $$ registerProblem(node, description, hl_type, null, rangeInElement, actions.toArray(new LocalQuickFix[actions.size()]))[ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_152 $$ addPluginQuickFixes(reference, actions)[ FD ]
Line_125 $$ if (!markedQualified) -->Line_126 $$ description = PyBundle.message("INSP.unresolved.ref.$0", refText)[ CD ]
Line_7 $$ PsiElement element = reference.getElement()-->Line_64 $$ final PyDecorator decorator = PsiTreeUtil.getParentOfType(element, PyDecorator.class)[ FD ]
Line_23 $$ if (ignored.endsWith(END_WILDCARD)) -->Line_24 $$ final String prefix = ignored.substring(0, ignored.length() - END_WILDCARD.length())[ CD ]
Line_10 $$ String refText = text-->Line_55 $$ if (refText.equals("true") || refText.equals("false")) [ FD ]
Line_37 $$ PyReferenceExpression expr = (PyReferenceExpression) element-->Line_93 $$ final PyExpression qualifier = expr.getQualifier()[ FD ]
Line_104 $$ final PyClassType classType = (PyClassType) type-->Line_106 $$ final PyClassLikeType metaClassType = classType.getMetaClassType(myTypeEvalContext, true)[ FD ]
Line_159 $$ final Sdk sdk = PythonSdkType.findPythonSdk(module)-->Line_162 $$ addInstallPackageAction(actions, packageName, module, sdk)[ FD ]
Line_95 $$ PyType type = myTypeEvalContext.getType(qualifier)-->Line_100 $$ addCreateMemberFromUsageFixes(type, reference, refText, actions)[ FD ]
Line_81 $$ description = ((PsiReferenceEx) reference).getUnresolvedDescription()-->Line_83 $$ if (description == null) [ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_3 $$ if (reference instanceof DocStringTypeReference) [ CD ]
Line_96 $$ if (type != null) -->Line_97 $$ if (ignoreUnresolvedMemberForType(type, reference, refName)) [ CD ]
Line_102 $$ if (reference instanceof PyOperatorReference) -->Line_103 $$ String className = type.getName()[ CD ]
Line_7 $$ PsiElement element = reference.getElement()-->Line_65 $$ final PyAnnotation annotation = PsiTreeUtil.getParentOfType(element, PyAnnotation.class)[ FD ]
Line_81 $$ description = ((PsiReferenceEx) reference).getUnresolvedDescription()-->Line_172 $$ registerProblem(node, description, hl_type, null, rangeInElement, actions.toArray(new LocalQuickFix[actions.size()]))[ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_133 $$ ProblemHighlightType hl_type[ CD ]
Line_15 $$ final String refName = (element instanceof PyQualifiedExpression) ? ((PyQualifiedExpression) element).getReferencedName() : refText-->Line_72 $$ if (PyModuleType.getPossibleInstanceMembers().contains(refName)) [ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_134 $$ if (severity == HighlightSeverity.WARNING) [ CD ]
Line_156 $$ if (!components.isEmpty()) -->Line_160 $$ if (module != null && sdk != null && PyPackageUtil.packageManagementEnabled(sdk)) [ CD ]
Line_12 $$ refText = rangeInElement.substring(text)-->Line_86 $$ if ("__qualname__".equals(refText) && LanguageLevel.forElement(element).isAtLeast(LanguageLevel.PYTHON33)) [ FD ]
Line_95 $$ PyType type = myTypeEvalContext.getType(qualifier)-->Line_103 $$ String className = type.getName()[ FD ]
Line_6 $$ String description = null-->Line_111 $$ description = PyBundle.message("INSP.unresolved.operator.ref", className, refName, ((PyOperatorReference) reference).getReadableOperatorName())[ FD ]
Line_36 $$ if (element instanceof PyReferenceExpression) -->Line_38 $$ if (PyNames.COMPARISON_OPERATORS.contains(refName)) [ CD ]
Line_67 $$ if (parentFunction != null && decorator == null && annotation == null && importStatement == null) -->Line_68 $$ actions.add(new UnresolvedReferenceAddParameterQuickFix(refName))[ CD ]
Line_105 $$ if (classType.isDefinition()) -->Line_107 $$ if (metaClassType != null) [ CD ]
Line_14 $$ final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2)-->Line_68 $$ actions.add(new UnresolvedReferenceAddParameterQuickFix(refName))[ FD ]
Line_15 $$ final String refName = (element instanceof PyQualifiedExpression) ? ((PyQualifiedExpression) element).getReferencedName() : refText-->Line_111 $$ description = PyBundle.message("INSP.unresolved.operator.ref", className, refName, ((PyOperatorReference) reference).getReadableOperatorName())[ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_7 $$ PsiElement element = reference.getElement()[ CD ]
Line_84 $$ boolean markedQualified = false-->Line_115 $$ markedQualified = true[ FD ]
Line_14 $$ final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2)-->Line_58 $$ addAddSelfFix(node, expr, actions)[ FD ]
Line_86 $$ if ("__qualname__".equals(refText) && LanguageLevel.forElement(element).isAtLeast(LanguageLevel.PYTHON33)) -->Line_87 $$ return[ CD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_134 $$ if (severity == HighlightSeverity.WARNING) [ FD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_172 $$ registerProblem(node, description, hl_type, null, rangeInElement, actions.toArray(new LocalQuickFix[actions.size()]))[ CD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_14 $$ final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2)[ CD ]
Line_102 $$ if (reference instanceof PyOperatorReference) -->Line_105 $$ if (classType.isDefinition()) [ CD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_145 $$ if (qualifiedNames.size() == 1) [ CD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_7 $$ PsiElement element = reference.getElement()[ FD ]
Line_41 $$ if (expr.isQualified()) -->Line_59 $$ PyCallExpression callExpression = PsiTreeUtil.getParentOfType(element, PyCallExpression.class)[ CD ]
Line_36 $$ if (element instanceof PyReferenceExpression) -->Line_41 $$ if (expr.isQualified()) [ CD ]
Line_10 $$ String refText = text-->Line_86 $$ if ("__qualname__".equals(refText) && LanguageLevel.forElement(element).isAtLeast(LanguageLevel.PYTHON33)) [ FD ]
Line_41 $$ if (expr.isQualified()) -->Line_66 $$ final PyImportStatement importStatement = PsiTreeUtil.getParentOfType(element, PyImportStatement.class)[ CD ]
Line_3 $$ if (reference instanceof DocStringTypeReference) -->Line_4 $$ return[ CD ]
Line_14 $$ final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2)-->Line_52 $$ actions.add(new UnresolvedRefAddFutureImportQuickFix())[ FD ]
Line_102 $$ if (reference instanceof PyOperatorReference) -->Line_104 $$ final PyClassType classType = (PyClassType) type[ CD ]
Line_113 $$ description = PyBundle.message("INSP.unresolved.ref.$0.for.class.$1", refText, type.getName())-->Line_126 $$ description = PyBundle.message("INSP.unresolved.ref.$0", refText)[ FD ]
Line_113 $$ description = PyBundle.message("INSP.unresolved.ref.$0.for.class.$1", refText, type.getName())-->Line_119 $$ description = PyBundle.message("INSP.cannot.find.$0.in.$1", refText, type.getName())[ FD ]
Line_14 $$ final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2)-->Line_152 $$ addPluginQuickFixes(reference, actions)[ FD ]
Line_41 $$ if (expr.isQualified()) -->Line_60 $$ if (callExpression != null && (!(callExpression.getCallee() instanceof PyQualifiedExpression) || ((PyQualifiedExpression) callExpression.getCallee()).getQualifier() == null)) [ CD ]
Line_6 $$ String description = null-->Line_83 $$ if (description == null) [ FD ]
Line_85 $$ if (element instanceof PyQualifiedExpression) -->Line_93 $$ final PyExpression qualifier = expr.getQualifier()[ CD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_153 $$ if (reference instanceof PyImportReference) [ CD ]
Line_153 $$ if (reference instanceof PyImportReference) -->Line_155 $$ final List<String> components = qname.getComponents()[ CD ]
Line_96 $$ if (type != null) -->Line_101 $$ if (type instanceof PyClassType) [ CD ]
Line_43 $$ if ((object_type != null) && object_type.getPossibleInstanceMembers().contains(refName)) -->Line_44 $$ return[ CD ]
Line_165 $$ final String suggestedPackage = PyPIPackageUtil.PACKAGES_TOPLEVEL.get(packageName)-->Line_166 $$ addInstallPackageAction(actions, suggestedPackage, module, sdk)[ FD ]
Line_14 $$ final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2)-->Line_128 $$ addAutoImportFix(node, reference, actions)[ FD ]
Line_7 $$ PsiElement element = reference.getElement()-->Line_8 $$ final String text = element.getText()[ FD ]
Line_38 $$ if (PyNames.COMPARISON_OPERATORS.contains(refName)) -->Line_39 $$ return[ CD ]
Line_9 $$ TextRange rangeInElement = reference.getRangeInElement()-->Line_172 $$ registerProblem(node, description, hl_type, null, rangeInElement, actions.toArray(new LocalQuickFix[actions.size()]))[ FD ]
Line_14 $$ final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2)-->Line_172 $$ registerProblem(node, description, hl_type, null, rangeInElement, actions.toArray(new LocalQuickFix[actions.size()]))[ FD ]
Line_37 $$ PyReferenceExpression expr = (PyReferenceExpression) element-->Line_58 $$ addAddSelfFix(node, expr, actions)[ FD ]
Line_7 $$ PsiElement element = reference.getElement()-->Line_66 $$ final PyImportStatement importStatement = PsiTreeUtil.getParentOfType(element, PyImportStatement.class)[ FD ]
Line_153 $$ if (reference instanceof PyImportReference) -->Line_154 $$ final QualifiedName qname = QualifiedName.fromDottedString(refName)[ CD ]
Line_125 $$ if (!markedQualified) -->Line_130 $$ addCreateClassFix(refText, element, actions)[ CD ]
Line_141 $$ PyImportStatementBase importStatementBase = PsiTreeUtil.getParentOfType(element, PyImportStatementBase.class)-->Line_143 $$ actions.addAll(GenerateBinaryStubsFix.generateFixes(importStatementBase))[ FD ]
Line_108 $$ className = metaClassType.getName()-->Line_111 $$ description = PyBundle.message("INSP.unresolved.operator.ref", className, refName, ((PyOperatorReference) reference).getReadableOperatorName())[ FD ]
Line_14 $$ final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2)-->Line_166 $$ addInstallPackageAction(actions, suggestedPackage, module, sdk)[ FD ]
Line_156 $$ if (!components.isEmpty()) -->Line_157 $$ final String packageName = components.get(0)[ CD ]
Line_14 $$ final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2)-->Line_56 $$ actions.add(new UnresolvedRefTrueFalseQuickFix(element))[ FD ]
Line_24 $$ final String prefix = ignored.substring(0, ignored.length() - END_WILDCARD.length())-->Line_25 $$ if (canonicalName.startsWith(prefix)) [ FD ]
Line_41 $$ if (expr.isQualified()) -->Line_55 $$ if (refText.equals("true") || refText.equals("false")) [ CD ]
Line_12 $$ refText = rangeInElement.substring(text)-->Line_119 $$ description = PyBundle.message("INSP.cannot.find.$0.in.$1", refText, type.getName())[ FD ]
Line_16 $$ if (refName == null || refName.length() <= 0) -->Line_17 $$ return[ CD ]
Line_14 $$ final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2)-->Line_149 $$ actions.add(new AddIgnoredIdentifierQuickFix(qualifiedName.removeLastComponent(), true))[ FD ]
Line_22 $$ for (String ignored : myIgnoredIdentifiers) -->Line_24 $$ final String prefix = ignored.substring(0, ignored.length() - END_WILDCARD.length())[ FD ]
Line_135 $$ hl_type = ProblemHighlightType.GENERIC_ERROR_OR_WARNING-->Line_172 $$ registerProblem(node, description, hl_type, null, rangeInElement, actions.toArray(new LocalQuickFix[actions.size()]))[ FD ]
Line_145 $$ if (qualifiedNames.size() == 1) -->Line_147 $$ actions.add(new AddIgnoredIdentifierQuickFix(qualifiedName, false))[ CD ]
Line_72 $$ if (PyModuleType.getPossibleInstanceMembers().contains(refName)) -->Line_73 $$ return[ CD ]
Line_10 $$ String refText = text-->Line_113 $$ description = PyBundle.message("INSP.unresolved.ref.$0.for.class.$1", refText, type.getName())[ FD ]
Line_85 $$ if (element instanceof PyQualifiedExpression) -->Line_94 $$ if (qualifier != null) [ CD ]
Line_7 $$ PsiElement element = reference.getElement()-->Line_127 $$ if (PythonReferenceImporter.isImportable(element)) [ FD ]
Line_50 $$ if (LanguageLevel.forElement(node).isOlderThan(LanguageLevel.PYTHON26)) -->Line_51 $$ if ("with".equals(refName)) [ CD ]
Line_2 $$ private void registerUnresolvedReferenceProblem(@NotNull PyElement node, @NotNull final PsiReference reference, @NotNull HighlightSeverity severity) -->Line_83 $$ if (description == null) [ CD ]
Line_77 $$ description = PyBundle.message("INSP.module.$0.not.found", refText)-->Line_83 $$ if (description == null) [ FD ]
