Line_6 $$ List<CompilerMessage> parsedMessages = new ArrayList<CompilerMessage>()-->Line_18 $$ handleCurrentMessage(parsedMessages, sb)[ FD ]
Line_17 $$ if (extraMsg.indexOf(". WARNING") > 0 || extraMsg.indexOf(". ERROR") > 0) -->Line_18 $$ handleCurrentMessage(parsedMessages, sb)[ CD ]
Line_8 $$ for (String msg : msgs) -->Line_14 $$ String[] extraMsgs = msg.split("\n")[ FD ]
Line_11 $$ if (message != null) -->Line_12 $$ parsedMessages.add(message)[ CD ]
Line_16 $$ for (String extraMsg : extraMsgs) -->Line_17 $$ if (extraMsg.indexOf(". WARNING") > 0 || extraMsg.indexOf(". ERROR") > 0) [ FD ]
Line_15 $$ StringBuilder sb = new StringBuilder()-->Line_19 $$ sb = new StringBuilder("\n").append(extraMsg).append("\n")[ FD ]
Line_19 $$ sb = new StringBuilder("\n").append(extraMsg).append("\n")-->Line_26 $$ handleCurrentMessage(parsedMessages, sb)[ FD ]
Line_2 $$ List<CompilerMessage> parseMessages(String input) throws IOException -->Line_7 $$ String[] msgs = StringUtil.convertLineSeparators(input).split(PROB_SEPARATOR)[ CD ]
Line_15 $$ StringBuilder sb = new StringBuilder()-->Line_22 $$ sb.append(extraMsg).append("\n")[ FD ]
Line_16 $$ for (String extraMsg : extraMsgs) -->Line_19 $$ sb = new StringBuilder("\n").append(extraMsg).append("\n")[ FD ]
Line_2 $$ List<CompilerMessage> parseMessages(String input) throws IOException -->Line_6 $$ List<CompilerMessage> parsedMessages = new ArrayList<CompilerMessage>()[ CD ]
Line_6 $$ List<CompilerMessage> parsedMessages = new ArrayList<CompilerMessage>()-->Line_12 $$ parsedMessages.add(message)[ FD ]
Line_16 $$ for (String extraMsg : extraMsgs) -->Line_21 $$ if (!PROB_SEPARATOR.equals(extraMsg)) [ FD ]
Line_2 $$ List<CompilerMessage> parseMessages(String input) throws IOException -->Line_3 $$ if (input.contains("The type groovy.lang.GroovyObject cannot be resolved. It is indirectly referenced from required .class files")) [ CD ]
Line_10 $$ CompilerMessage message = parseMessage(msg)-->Line_11 $$ if (message != null) [ FD ]
Line_17 $$ if (extraMsg.indexOf(". WARNING") > 0 || extraMsg.indexOf(". ERROR") > 0) -->Line_19 $$ sb = new StringBuilder("\n").append(extraMsg).append("\n")[ CD ]
Line_15 $$ StringBuilder sb = new StringBuilder()-->Line_26 $$ handleCurrentMessage(parsedMessages, sb)[ FD ]
Line_21 $$ if (!PROB_SEPARATOR.equals(extraMsg)) -->Line_22 $$ sb.append(extraMsg).append("\n")[ CD ]
Line_2 $$ List<CompilerMessage> parseMessages(String input) throws IOException -->Line_7 $$ String[] msgs = StringUtil.convertLineSeparators(input).split(PROB_SEPARATOR)[ FD ]
Line_2 $$ List<CompilerMessage> parseMessages(String input) throws IOException -->Line_30 $$ return parsedMessages[ CD ]
Line_8 $$ for (String msg : msgs) -->Line_9 $$ if (msg.length() > 1) [ FD ]
Line_11 $$ if (message != null) -->Line_26 $$ handleCurrentMessage(parsedMessages, sb)[ CD ]
Line_11 $$ if (message != null) -->Line_15 $$ StringBuilder sb = new StringBuilder()[ CD ]
Line_3 $$ if (input.contains("The type groovy.lang.GroovyObject cannot be resolved. It is indirectly referenced from required .class files")) -->Line_4 $$ return Collections.singletonList(new CompilerMessage(myBuilderName, BuildMessage.Kind.ERROR, "Cannot compile Groovy files: no Groovy library is defined for module '" + myChunk.representativeTarget().getModule().getName() + "'"))[ CD ]
Line_9 $$ if (msg.length() > 1) -->Line_11 $$ if (message != null) [ CD ]
Line_10 $$ CompilerMessage message = parseMessage(msg)-->Line_12 $$ parsedMessages.add(message)[ FD ]
Line_19 $$ sb = new StringBuilder("\n").append(extraMsg).append("\n")-->Line_22 $$ sb.append(extraMsg).append("\n")[ FD ]
Line_6 $$ List<CompilerMessage> parsedMessages = new ArrayList<CompilerMessage>()-->Line_26 $$ handleCurrentMessage(parsedMessages, sb)[ FD ]
Line_2 $$ List<CompilerMessage> parseMessages(String input) throws IOException -->Line_3 $$ if (input.contains("The type groovy.lang.GroovyObject cannot be resolved. It is indirectly referenced from required .class files")) [ FD ]
Line_15 $$ StringBuilder sb = new StringBuilder()-->Line_18 $$ handleCurrentMessage(parsedMessages, sb)[ FD ]
Line_9 $$ if (msg.length() > 1) -->Line_10 $$ CompilerMessage message = parseMessage(msg)[ CD ]
Line_16 $$ for (String extraMsg : extraMsgs) -->Line_22 $$ sb.append(extraMsg).append("\n")[ FD ]
Line_17 $$ if (extraMsg.indexOf(". WARNING") > 0 || extraMsg.indexOf(". ERROR") > 0) -->Line_21 $$ if (!PROB_SEPARATOR.equals(extraMsg)) [ CD ]
Line_8 $$ for (String msg : msgs) -->Line_10 $$ CompilerMessage message = parseMessage(msg)[ FD ]
Line_11 $$ if (message != null) -->Line_14 $$ String[] extraMsgs = msg.split("\n")[ CD ]
