Line_6 $$ if (existingClass == null) -->Line_9 $$ boolean foundConstructor = false[ CD ]
Line_14 $$ methodBody.accept(new JavaRecursiveElementWalkingVisitor() -->Line_17 $$ final PsiExpression returnValue = statement.getReturnValue()[ FD ]
Line_14 $$ methodBody.accept(new JavaRecursiveElementWalkingVisitor() -->Line_45 $$ final PsiExpression lExpression = expression.getLExpression()[ FD ]
Line_2 $$ protected boolean preprocessUsages(@NotNull final Ref<UsageInfo[]> refUsages) -->Line_75 $$ return showConflicts(conflicts, refUsages.get())[ CD ]
Line_5 $$ if (myUseExistingClass) -->Line_71 $$ if (myMoveDestination != null && !myMoveDestination.isTargetAccessible(myProject, myMethod.getContainingFile().getVirtualFile())) [ CD ]
Line_42 $$ body.accept(new JavaRecursiveElementWalkingVisitor() -->Line_45 $$ final PsiExpression lExpression = expression.getLExpression()[ CD ]
Line_64 $$ if (myUnwrapMethodName.length() == 0) -->Line_65 $$ conflicts.putValue(existingClass, "Existing class does not have getter for selected field")[ CD ]
Line_14 $$ methodBody.accept(new JavaRecursiveElementWalkingVisitor() -->Line_17 $$ final PsiExpression returnValue = statement.getReturnValue()[ CD ]
Line_9 $$ boolean foundConstructor = false-->Line_60 $$ if (!foundConstructor) [ FD ]
Line_68 $$ if (existingClass != null) -->Line_69 $$ conflicts.putValue(existingClass, RefactorJBundle.message("there.already.exists.a.class.with.the.selected.name"))[ CD ]
Line_14 $$ methodBody.accept(new JavaRecursiveElementWalkingVisitor() -->Line_44 $$ super.visitAssignmentExpression(expression)[ FD ]
Line_31 $$ if (parameters.length == 1) -->Line_39 $$ final PsiCodeBlock body = constructor.getBody()[ CD ]
Line_42 $$ body.accept(new JavaRecursiveElementWalkingVisitor() -->Line_46 $$ if (lExpression instanceof PsiReferenceExpression && ((PsiReferenceExpression) lExpression).resolve() == myDelegateField) [ CD ]
Line_31 $$ if (parameters.length == 1) -->Line_42 $$ body.accept(new JavaRecursiveElementWalkingVisitor() [ CD ]
Line_46 $$ if (lExpression instanceof PsiReferenceExpression && ((PsiReferenceExpression) lExpression).resolve() == myDelegateField) -->Line_48 $$ if (rExpression instanceof PsiReferenceExpression && ((PsiReferenceExpression) rExpression).resolve() == parameter) [ CD ]
Line_2 $$ protected boolean preprocessUsages(@NotNull final Ref<UsageInfo[]> refUsages) -->Line_4 $$ final PsiClass existingClass = JavaPsiFacade.getInstance(myProject).findClass(myQualifiedName, GlobalSearchScope.allScope(myProject))[ CD ]
Line_6 $$ if (existingClass == null) -->Line_60 $$ if (!foundConstructor) [ CD ]
Line_4 $$ final PsiClass existingClass = JavaPsiFacade.getInstance(myProject).findClass(myQualifiedName, GlobalSearchScope.allScope(myProject))-->Line_61 $$ conflicts.putValue(existingClass, "Existing class does not have appropriate constructor")[ FD ]
Line_12 $$ final PsiCodeBlock methodBody = myMethod.getBody()-->Line_13 $$ if (methodBody != null) [ FD ]
Line_5 $$ if (myUseExistingClass) -->Line_64 $$ if (myUnwrapMethodName.length() == 0) [ CD ]
Line_3 $$ MultiMap<PsiElement, String> conflicts = new MultiMap<PsiElement, String>()-->Line_72 $$ conflicts.putValue(myMethod, "Created class won't be accessible in the call place")[ FD ]
Line_3 $$ MultiMap<PsiElement, String> conflicts = new MultiMap<PsiElement, String>()-->Line_69 $$ conflicts.putValue(existingClass, RefactorJBundle.message("there.already.exists.a.class.with.the.selected.name"))[ FD ]
Line_2 $$ protected boolean preprocessUsages(@NotNull final Ref<UsageInfo[]> refUsages) -->Line_75 $$ return showConflicts(conflicts, refUsages.get())[ FD ]
Line_12 $$ final PsiCodeBlock methodBody = myMethod.getBody()-->Line_14 $$ methodBody.accept(new JavaRecursiveElementWalkingVisitor() [ FD ]
Line_17 $$ final PsiExpression returnValue = statement.getReturnValue()-->Line_18 $$ if (returnValue != null) [ FD ]
Line_42 $$ body.accept(new JavaRecursiveElementWalkingVisitor() -->Line_44 $$ super.visitAssignmentExpression(expression)[ FD ]
Line_4 $$ final PsiClass existingClass = JavaPsiFacade.getInstance(myProject).findClass(myQualifiedName, GlobalSearchScope.allScope(myProject))-->Line_28 $$ final PsiMethod[] constructors = existingClass.getConstructors()[ FD ]
Line_48 $$ if (rExpression instanceof PsiReferenceExpression && ((PsiReferenceExpression) rExpression).resolve() == parameter) -->Line_49 $$ found[0] = true[ CD ]
Line_2 $$ protected boolean preprocessUsages(@NotNull final Ref<UsageInfo[]> refUsages) -->Line_3 $$ MultiMap<PsiElement, String> conflicts = new MultiMap<PsiElement, String>()[ CD ]
Line_4 $$ final PsiClass existingClass = JavaPsiFacade.getInstance(myProject).findClass(myQualifiedName, GlobalSearchScope.allScope(myProject))-->Line_6 $$ if (existingClass == null) [ FD ]
Line_3 $$ MultiMap<PsiElement, String> conflicts = new MultiMap<PsiElement, String>()-->Line_65 $$ conflicts.putValue(existingClass, "Existing class does not have getter for selected field")[ FD ]
Line_71 $$ if (myMoveDestination != null && !myMoveDestination.isTargetAccessible(myProject, myMethod.getContainingFile().getVirtualFile())) -->Line_72 $$ conflicts.putValue(myMethod, "Created class won't be accessible in the call place")[ CD ]
Line_14 $$ methodBody.accept(new JavaRecursiveElementWalkingVisitor() -->Line_47 $$ final PsiExpression rExpression = expression.getRExpression()[ FD ]
Line_6 $$ if (existingClass == null) -->Line_11 $$ returnTypes.add(myMethod.getReturnType())[ CD ]
Line_46 $$ if (lExpression instanceof PsiReferenceExpression && ((PsiReferenceExpression) lExpression).resolve() == myDelegateField) -->Line_47 $$ final PsiExpression rExpression = expression.getRExpression()[ CD ]
Line_14 $$ methodBody.accept(new JavaRecursiveElementWalkingVisitor() -->Line_16 $$ super.visitReturnStatement(statement)[ FD ]
Line_4 $$ final PsiClass existingClass = JavaPsiFacade.getInstance(myProject).findClass(myQualifiedName, GlobalSearchScope.allScope(myProject))-->Line_69 $$ conflicts.putValue(existingClass, RefactorJBundle.message("there.already.exists.a.class.with.the.selected.name"))[ FD ]
Line_5 $$ if (myUseExistingClass) -->Line_6 $$ if (existingClass == null) [ CD ]
Line_14 $$ methodBody.accept(new JavaRecursiveElementWalkingVisitor() -->Line_18 $$ if (returnValue != null) [ CD ]
Line_6 $$ if (existingClass == null) -->Line_10 $$ final Set<PsiType> returnTypes = new HashSet<PsiType>()[ CD ]
Line_3 $$ MultiMap<PsiElement, String> conflicts = new MultiMap<PsiElement, String>()-->Line_61 $$ conflicts.putValue(existingClass, "Existing class does not have appropriate constructor")[ FD ]
Line_3 $$ MultiMap<PsiElement, String> conflicts = new MultiMap<PsiElement, String>()-->Line_75 $$ return showConflicts(conflicts, refUsages.get())[ FD ]
Line_42 $$ body.accept(new JavaRecursiveElementWalkingVisitor() -->Line_44 $$ super.visitAssignmentExpression(expression)[ CD ]
Line_10 $$ final Set<PsiType> returnTypes = new HashSet<PsiType>()-->Line_19 $$ returnTypes.add(returnValue.getType())[ FD ]
Line_6 $$ if (existingClass == null) -->Line_13 $$ if (methodBody != null) [ CD ]
Line_3 $$ MultiMap<PsiElement, String> conflicts = new MultiMap<PsiElement, String>()-->Line_7 $$ conflicts.putValue(null, RefactorJBundle.message("could.not.find.selected.wrapping.class"))[ FD ]
Line_18 $$ if (returnValue != null) -->Line_19 $$ returnTypes.add(returnValue.getType())[ CD ]
Line_17 $$ final PsiExpression returnValue = statement.getReturnValue()-->Line_19 $$ returnTypes.add(returnValue.getType())[ FD ]
Line_42 $$ body.accept(new JavaRecursiveElementWalkingVisitor() -->Line_45 $$ final PsiExpression lExpression = expression.getLExpression()[ FD ]
Line_4 $$ final PsiClass existingClass = JavaPsiFacade.getInstance(myProject).findClass(myQualifiedName, GlobalSearchScope.allScope(myProject))-->Line_35 $$ if (getInferredType(parameterType, returnType, existingClass, myMethod) == null && !TypeConversionUtil.isAssignable(parameterType, returnType)) [ FD ]
Line_10 $$ final Set<PsiType> returnTypes = new HashSet<PsiType>()-->Line_11 $$ returnTypes.add(myMethod.getReturnType())[ FD ]
Line_14 $$ methodBody.accept(new JavaRecursiveElementWalkingVisitor() -->Line_16 $$ super.visitReturnStatement(statement)[ CD ]
Line_2 $$ protected boolean preprocessUsages(@NotNull final Ref<UsageInfo[]> refUsages) -->Line_5 $$ if (myUseExistingClass) [ CD ]
Line_31 $$ if (parameters.length == 1) -->Line_33 $$ final PsiType parameterType = parameter.getType()[ CD ]
Line_6 $$ if (existingClass == null) -->Line_7 $$ conflicts.putValue(null, RefactorJBundle.message("could.not.find.selected.wrapping.class"))[ CD ]
Line_42 $$ body.accept(new JavaRecursiveElementWalkingVisitor() -->Line_47 $$ final PsiExpression rExpression = expression.getRExpression()[ FD ]
Line_60 $$ if (!foundConstructor) -->Line_61 $$ conflicts.putValue(existingClass, "Existing class does not have appropriate constructor")[ CD ]
Line_4 $$ final PsiClass existingClass = JavaPsiFacade.getInstance(myProject).findClass(myQualifiedName, GlobalSearchScope.allScope(myProject))-->Line_68 $$ if (existingClass != null) [ FD ]
Line_31 $$ if (parameters.length == 1) -->Line_40 $$ LOG.assertTrue(body != null)[ CD ]
Line_4 $$ final PsiClass existingClass = JavaPsiFacade.getInstance(myProject).findClass(myQualifiedName, GlobalSearchScope.allScope(myProject))-->Line_65 $$ conflicts.putValue(existingClass, "Existing class does not have getter for selected field")[ FD ]
Line_13 $$ if (methodBody != null) -->Line_14 $$ methodBody.accept(new JavaRecursiveElementWalkingVisitor() [ CD ]
Line_5 $$ if (myUseExistingClass) -->Line_68 $$ if (existingClass != null) [ CD ]
Line_31 $$ if (parameters.length == 1) -->Line_54 $$ if (found[0]) [ CD ]
Line_6 $$ if (existingClass == null) -->Line_12 $$ final PsiCodeBlock methodBody = myMethod.getBody()[ CD ]
Line_6 $$ if (existingClass == null) -->Line_28 $$ final PsiMethod[] constructors = existingClass.getConstructors()[ CD ]
