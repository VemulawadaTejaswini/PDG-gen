Line_12 $$ dataOffset += n-->Line_11 $$ summer.update(data, dataOffset, n)[ FD ]
Line_8 $$ while (remaining > 0) -->Line_13 $$ remaining -= n[ CD ]
Line_8 $$ while (remaining > 0) -->Line_18 $$ sums[sumsOffset++] = (byte) (calculated)[ CD ]
Line_7 $$ int remaining = dataLength-->Line_13 $$ remaining -= n[ FD ]
Line_9 $$ int n = Math.min(remaining, bytesPerChecksum)-->Line_12 $$ dataOffset += n[ FD ]
Line_3 $$ if (NativeCrc32.isAvailable()) -->Line_5 $$ return[ CD ]
Line_8 $$ while (remaining > 0) -->Line_11 $$ summer.update(data, dataOffset, n)[ CD ]
Line_2 $$ public void calculateChunkedSums(byte[] data, int dataOffset, int dataLength, byte[] sums, int sumsOffset) -->Line_17 $$ sums[sumsOffset++] = (byte) (calculated >> 8)[ FD ]
Line_2 $$ public void calculateChunkedSums(byte[] data, int dataOffset, int dataLength, byte[] sums, int sumsOffset) -->Line_16 $$ sums[sumsOffset++] = (byte) (calculated >> 16)[ FD ]
Line_7 $$ int remaining = dataLength-->Line_9 $$ int n = Math.min(remaining, bytesPerChecksum)[ FD ]
Line_2 $$ public void calculateChunkedSums(byte[] data, int dataOffset, int dataLength, byte[] sums, int sumsOffset) -->Line_18 $$ sums[sumsOffset++] = (byte) (calculated)[ FD ]
Line_8 $$ while (remaining > 0) -->Line_17 $$ sums[sumsOffset++] = (byte) (calculated >> 8)[ CD ]
Line_8 $$ while (remaining > 0) -->Line_10 $$ summer.reset()[ CD ]
Line_13 $$ remaining -= n-->Line_8 $$ while (remaining > 0) [ FD ]
Line_7 $$ int remaining = dataLength-->Line_8 $$ while (remaining > 0) [ FD ]
Line_8 $$ while (remaining > 0) -->Line_15 $$ sums[sumsOffset++] = (byte) (calculated >> 24)[ CD ]
Line_2 $$ public void calculateChunkedSums(byte[] data, int dataOffset, int dataLength, byte[] sums, int sumsOffset) -->Line_4 $$ NativeCrc32.calculateChunkedSumsByteArray(bytesPerChecksum, type.id, sums, sumsOffset, data, dataOffset, dataLength)[ FD ]
Line_2 $$ public void calculateChunkedSums(byte[] data, int dataOffset, int dataLength, byte[] sums, int sumsOffset) -->Line_15 $$ sums[sumsOffset++] = (byte) (calculated >> 24)[ FD ]
Line_2 $$ public void calculateChunkedSums(byte[] data, int dataOffset, int dataLength, byte[] sums, int sumsOffset) -->Line_11 $$ summer.update(data, dataOffset, n)[ FD ]
Line_9 $$ int n = Math.min(remaining, bytesPerChecksum)-->Line_11 $$ summer.update(data, dataOffset, n)[ FD ]
Line_13 $$ remaining -= n-->Line_9 $$ int n = Math.min(remaining, bytesPerChecksum)[ FD ]
Line_8 $$ while (remaining > 0) -->Line_12 $$ dataOffset += n[ CD ]
Line_2 $$ public void calculateChunkedSums(byte[] data, int dataOffset, int dataLength, byte[] sums, int sumsOffset) -->Line_12 $$ dataOffset += n[ FD ]
Line_2 $$ public void calculateChunkedSums(byte[] data, int dataOffset, int dataLength, byte[] sums, int sumsOffset) -->Line_3 $$ if (NativeCrc32.isAvailable()) [ CD ]
Line_8 $$ while (remaining > 0) -->Line_9 $$ int n = Math.min(remaining, bytesPerChecksum)[ CD ]
Line_8 $$ while (remaining > 0) -->Line_14 $$ long calculated = summer.getValue()[ CD ]
Line_2 $$ public void calculateChunkedSums(byte[] data, int dataOffset, int dataLength, byte[] sums, int sumsOffset) -->Line_8 $$ while (remaining > 0) [ CD ]
Line_3 $$ if (NativeCrc32.isAvailable()) -->Line_4 $$ NativeCrc32.calculateChunkedSumsByteArray(bytesPerChecksum, type.id, sums, sumsOffset, data, dataOffset, dataLength)[ CD ]
Line_9 $$ int n = Math.min(remaining, bytesPerChecksum)-->Line_13 $$ remaining -= n[ FD ]
Line_2 $$ public void calculateChunkedSums(byte[] data, int dataOffset, int dataLength, byte[] sums, int sumsOffset) -->Line_7 $$ int remaining = dataLength[ CD ]
Line_8 $$ while (remaining > 0) -->Line_16 $$ sums[sumsOffset++] = (byte) (calculated >> 16)[ CD ]
