Line_3 $$ final PsiExpression[] args = call.getArgumentList().getExpressions()-->Line_41 $$ newExpression.append(getArgument(args, index))[ FD ]
Line_2 $$ private String getMergedParam(PsiCallExpression call) -->Line_3 $$ final PsiExpression[] args = call.getArgumentList().getExpressions()[ FD ]
Line_7 $$ final String containingClassQName = myContainingClass.getQualifiedName()-->Line_8 $$ if (containingClassQName != null) [ FD ]
Line_43 $$ if (lastParamIsVararg) -->Line_45 $$ for (int i = lastArg + 1; i < args.length; i++) [ CD ]
Line_45 $$ for (int i = lastArg + 1; i < args.length; i++) -->Line_47 $$ newExpression.append(getArgument(args, i))[ FD ]
Line_18 $$ final JavaResolveResult resolvant = call.resolveMethodGenerics()-->Line_19 $$ final PsiSubstitutor substitutor = resolvant.getSubstitutor()[ FD ]
Line_17 $$ if (!typeParams.isEmpty()) -->Line_20 $$ newExpression.append('<')[ CD ]
Line_2 $$ private String getMergedParam(PsiCallExpression call) -->Line_34 $$ newExpression.append('(')[ CD ]
Line_22 $$ newExpression.append(StringUtil.join(typeParams, new Function<PsiTypeParameter, String>() -->Line_28 $$ return typeParameter.getName()[ FD ]
Line_9 $$ qualifiedName = containingClassQName + "." + className-->Line_14 $$ qualifiedName = StringUtil.getQualifiedName(packageName, className)[ FD ]
Line_45 $$ for (int i = lastArg + 1; i < args.length; i++) -->Line_47 $$ newExpression.append(getArgument(args, i))[ CD ]
Line_4 $$ StringBuffer newExpression = new StringBuffer()-->Line_51 $$ return newExpression.toString()[ FD ]
Line_4 $$ StringBuffer newExpression = new StringBuffer()-->Line_46 $$ newExpression.append(',')[ FD ]
Line_8 $$ if (containingClassQName != null) -->Line_9 $$ qualifiedName = containingClassQName + "." + className[ CD ]
Line_17 $$ if (!typeParams.isEmpty()) -->Line_21 $$ final Map<PsiTypeParameter, PsiType> substitutionMap = substitutor.getSubstitutionMap()[ CD ]
Line_2 $$ private String getMergedParam(PsiCallExpression call) -->Line_5 $$ final String qualifiedName[ CD ]
Line_5 $$ final String qualifiedName-->Line_11 $$ qualifiedName = className[ FD ]
Line_5 $$ final String qualifiedName-->Line_14 $$ qualifiedName = StringUtil.getQualifiedName(packageName, className)[ FD ]
Line_11 $$ qualifiedName = className-->Line_14 $$ qualifiedName = StringUtil.getQualifiedName(packageName, className)[ FD ]
Line_22 $$ newExpression.append(StringUtil.join(typeParams, new Function<PsiTypeParameter, String>() -->Line_25 $$ if (boundType != null) [ CD ]
Line_9 $$ qualifiedName = containingClassQName + "." + className-->Line_16 $$ newExpression.append("new ").append(qualifiedName)[ FD ]
Line_6 $$ if (myContainingClass != null) -->Line_8 $$ if (containingClassQName != null) [ CD ]
Line_11 $$ qualifiedName = className-->Line_16 $$ newExpression.append("new ").append(qualifiedName)[ FD ]
Line_4 $$ StringBuffer newExpression = new StringBuffer()-->Line_38 $$ newExpression.append(", ")[ FD ]
Line_21 $$ final Map<PsiTypeParameter, PsiType> substitutionMap = substitutor.getSubstitutionMap()-->Line_24 $$ final PsiType boundType = substitutionMap.get(typeParameter)[ FD ]
Line_24 $$ final PsiType boundType = substitutionMap.get(typeParameter)-->Line_25 $$ if (boundType != null) [ FD ]
Line_37 $$ if (!isFirst) -->Line_38 $$ newExpression.append(", ")[ CD ]
Line_8 $$ if (containingClassQName != null) -->Line_11 $$ qualifiedName = className[ CD ]
Line_45 $$ for (int i = lastArg + 1; i < args.length; i++) -->Line_46 $$ newExpression.append(',')[ CD ]
Line_2 $$ private String getMergedParam(PsiCallExpression call) -->Line_50 $$ newExpression.append(')')[ CD ]
Line_6 $$ if (myContainingClass != null) -->Line_7 $$ final String containingClassQName = myContainingClass.getQualifiedName()[ CD ]
Line_2 $$ private String getMergedParam(PsiCallExpression call) -->Line_6 $$ if (myContainingClass != null) [ CD ]
Line_4 $$ StringBuffer newExpression = new StringBuffer()-->Line_20 $$ newExpression.append('<')[ FD ]
Line_17 $$ if (!typeParams.isEmpty()) -->Line_22 $$ newExpression.append(StringUtil.join(typeParams, new Function<PsiTypeParameter, String>() [ CD ]
Line_2 $$ private String getMergedParam(PsiCallExpression call) -->Line_17 $$ if (!typeParams.isEmpty()) [ CD ]
Line_17 $$ if (!typeParams.isEmpty()) -->Line_32 $$ newExpression.append('>')[ CD ]
Line_4 $$ StringBuffer newExpression = new StringBuffer()-->Line_16 $$ newExpression.append("new ").append(qualifiedName)[ FD ]
Line_17 $$ if (!typeParams.isEmpty()) -->Line_18 $$ final JavaResolveResult resolvant = call.resolveMethodGenerics()[ CD ]
Line_22 $$ newExpression.append(StringUtil.join(typeParams, new Function<PsiTypeParameter, String>() -->Line_24 $$ final PsiType boundType = substitutionMap.get(typeParameter)[ CD ]
Line_2 $$ private String getMergedParam(PsiCallExpression call) -->Line_4 $$ StringBuffer newExpression = new StringBuffer()[ CD ]
Line_2 $$ private String getMergedParam(PsiCallExpression call) -->Line_16 $$ newExpression.append("new ").append(qualifiedName)[ CD ]
Line_17 $$ if (!typeParams.isEmpty()) -->Line_19 $$ final PsiSubstitutor substitutor = resolvant.getSubstitutor()[ CD ]
Line_4 $$ StringBuffer newExpression = new StringBuffer()-->Line_32 $$ newExpression.append('>')[ FD ]
Line_3 $$ final PsiExpression[] args = call.getArgumentList().getExpressions()-->Line_47 $$ newExpression.append(getArgument(args, i))[ FD ]
Line_2 $$ private String getMergedParam(PsiCallExpression call) -->Line_43 $$ if (lastParamIsVararg) [ CD ]
Line_2 $$ private String getMergedParam(PsiCallExpression call) -->Line_51 $$ return newExpression.toString()[ CD ]
Line_4 $$ StringBuffer newExpression = new StringBuffer()-->Line_22 $$ newExpression.append(StringUtil.join(typeParams, new Function<PsiTypeParameter, String>() [ FD ]
Line_22 $$ newExpression.append(StringUtil.join(typeParams, new Function<PsiTypeParameter, String>() -->Line_24 $$ final PsiType boundType = substitutionMap.get(typeParameter)[ FD ]
Line_4 $$ StringBuffer newExpression = new StringBuffer()-->Line_50 $$ newExpression.append(')')[ FD ]
Line_6 $$ if (myContainingClass != null) -->Line_14 $$ qualifiedName = StringUtil.getQualifiedName(packageName, className)[ CD ]
Line_14 $$ qualifiedName = StringUtil.getQualifiedName(packageName, className)-->Line_16 $$ newExpression.append("new ").append(qualifiedName)[ FD ]
Line_25 $$ if (boundType != null) -->Line_26 $$ return boundType.getCanonicalText()[ CD ]
Line_5 $$ final String qualifiedName-->Line_16 $$ newExpression.append("new ").append(qualifiedName)[ FD ]
Line_2 $$ private String getMergedParam(PsiCallExpression call) -->Line_3 $$ final PsiExpression[] args = call.getArgumentList().getExpressions()[ CD ]
Line_9 $$ qualifiedName = containingClassQName + "." + className-->Line_11 $$ qualifiedName = className[ FD ]
Line_19 $$ final PsiSubstitutor substitutor = resolvant.getSubstitutor()-->Line_21 $$ final Map<PsiTypeParameter, PsiType> substitutionMap = substitutor.getSubstitutionMap()[ FD ]
Line_25 $$ if (boundType != null) -->Line_28 $$ return typeParameter.getName()[ CD ]
Line_2 $$ private String getMergedParam(PsiCallExpression call) -->Line_18 $$ final JavaResolveResult resolvant = call.resolveMethodGenerics()[ FD ]
Line_4 $$ StringBuffer newExpression = new StringBuffer()-->Line_41 $$ newExpression.append(getArgument(args, index))[ FD ]
Line_24 $$ final PsiType boundType = substitutionMap.get(typeParameter)-->Line_26 $$ return boundType.getCanonicalText()[ FD ]
Line_4 $$ StringBuffer newExpression = new StringBuffer()-->Line_47 $$ newExpression.append(getArgument(args, i))[ FD ]
Line_4 $$ StringBuffer newExpression = new StringBuffer()-->Line_34 $$ newExpression.append('(')[ FD ]
Line_5 $$ final String qualifiedName-->Line_9 $$ qualifiedName = containingClassQName + "." + className[ FD ]
