Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_83 $$ return callbacks.toArray(new Callback[callbacks.size()])[ CD ]
Line_56 $$ callbacksMethodNames = new ArrayList<String>()-->Line_62 $$ if (!callbacksMethodNames.contains(methodName)) [ FD ]
Line_6 $$ XClass currentClazz = beanClass-->Line_11 $$ List<XMethod> methods = currentClazz.getDeclaredMethods()[ FD ]
Line_59 $$ if (xMethod.isAnnotationPresent(annotation)) -->Line_62 $$ if (!callbacksMethodNames.contains(methodName)) [ CD ]
Line_70 $$ if (!method.isAccessible()) -->Line_71 $$ method.setAccessible(true)[ CD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_22 $$ throw new RuntimeException("Callback methods annotated on the bean class must return void and take no arguments: " + annotation.getName() + " - " + xMethod)[ FD ]
Line_10 $$ Callback callback = null-->Line_63 $$ if (callback == null) [ FD ]
Line_43 $$ if (!stopDefaultListeners) -->Line_44 $$ List<Class> defaultListeners = (List<Class>) reflectionManager.getDefaults().get(EntityListeners.class)[ CD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_14 $$ Method method = reflectionManager.toMethod(xMethod)[ FD ]
Line_34 $$ if (!stopListeners) -->Line_37 $$ stopDefaultListeners = currentClazz.isAnnotationPresent(ExcludeDefaultListeners.class)[ CD ]
Line_12 $$ for (final XMethod xMethod : methods) -->Line_60 $$ final Method method = reflectionManager.toMethod(xMethod)[ FD ]
Line_52 $$ for (Class listener : orderedListeners) -->Line_54 $$ if (listener != null) [ FD ]
Line_18 $$ callback = new EntityCallback(method)-->Line_17 $$ if (callback == null) [ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_44 $$ List<Class> defaultListeners = (List<Class>) reflectionManager.getDefaults().get(EntityListeners.class)[ FD ]
Line_3 $$ List<Callback> callbacks = new ArrayList<Callback>()-->Line_74 $$ callbacks.add(0, callback)[ FD ]
Line_10 $$ Callback callback = null-->Line_26 $$ callbacks.add(0, callback)[ FD ]
Line_18 $$ callback = new EntityCallback(method)-->Line_64 $$ callback = new ListenerCallback(jpaListenerFactory.buildListener(listener), method)[ FD ]
Line_12 $$ for (final XMethod xMethod : methods) -->Line_14 $$ Method method = reflectionManager.toMethod(xMethod)[ FD ]
Line_15 $$ final String methodName = method.getName()-->Line_62 $$ if (!callbacksMethodNames.contains(methodName)) [ FD ]
Line_8 $$ boolean stopDefaultListeners = false-->Line_37 $$ stopDefaultListeners = currentClazz.isAnnotationPresent(ExcludeDefaultListeners.class)[ FD ]
Line_17 $$ if (callback == null) -->Line_27 $$ callbacksMethodNames.add(0, methodName)[ CD ]
Line_5 $$ List<Class> orderedListeners = new ArrayList<Class>()-->Line_48 $$ orderedListeners.add(defaultListeners.get(i))[ FD ]
Line_45 $$ if (defaultListeners != null) -->Line_46 $$ int defaultListenerSize = defaultListeners.size()[ CD ]
Line_8 $$ boolean stopDefaultListeners = false-->Line_43 $$ if (!stopDefaultListeners) [ FD ]
Line_47 $$ for (int i = defaultListenerSize - 1; i >= 0; i--) -->Line_48 $$ orderedListeners.add(defaultListeners.get(i))[ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_73 $$ log.debugf("Adding %s as %s callback for entity %s", methodName, annotation.getSimpleName(), beanClass.getName())[ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_55 $$ XClass xListener = reflectionManager.toXClass(listener)[ FD ]
Line_54 $$ if (listener != null) -->Line_56 $$ callbacksMethodNames = new ArrayList<String>()[ CD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_4 $$ List<String> callbacksMethodNames = new ArrayList<String>()[ CD ]
Line_60 $$ final Method method = reflectionManager.toMethod(xMethod)-->Line_65 $$ Class returnType = method.getReturnType()[ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_5 $$ List<Class> orderedListeners = new ArrayList<Class>()[ CD ]
Line_13 $$ if (xMethod.isAnnotationPresent(annotation)) -->Line_14 $$ Method method = reflectionManager.toMethod(xMethod)[ CD ]
Line_6 $$ XClass currentClazz = beanClass-->Line_39 $$ do [ FD ]
Line_39 $$ do -->Line_40 $$ currentClazz = currentClazz.getSuperclass()[ CD ]
Line_63 $$ if (callback == null) -->Line_70 $$ if (!method.isAccessible()) [ CD ]
Line_58 $$ for (final XMethod xMethod : methods) -->Line_60 $$ final Method method = reflectionManager.toMethod(xMethod)[ FD ]
Line_4 $$ List<String> callbacksMethodNames = new ArrayList<String>()-->Line_16 $$ if (!callbacksMethodNames.contains(methodName)) [ FD ]
Line_17 $$ if (callback == null) -->Line_21 $$ if (returnType != Void.TYPE || args.length != 0) [ CD ]
Line_34 $$ if (!stopListeners) -->Line_35 $$ getListeners(currentClazz, orderedListeners)[ CD ]
Line_63 $$ if (callback == null) -->Line_64 $$ callback = new ListenerCallback(jpaListenerFactory.buildListener(listener), method)[ CD ]
Line_34 $$ if (!stopListeners) -->Line_36 $$ stopListeners = currentClazz.isAnnotationPresent(ExcludeSuperclassListeners.class)[ CD ]
Line_14 $$ Method method = reflectionManager.toMethod(xMethod)-->Line_19 $$ Class returnType = method.getReturnType()[ FD ]
Line_12 $$ for (final XMethod xMethod : methods) -->Line_13 $$ if (xMethod.isAnnotationPresent(annotation)) [ FD ]
Line_54 $$ if (listener != null) -->Line_57 $$ List<XMethod> methods = xListener.getDeclaredMethods()[ CD ]
Line_60 $$ final Method method = reflectionManager.toMethod(xMethod)-->Line_71 $$ method.setAccessible(true)[ FD ]
Line_9 $$ do -->Line_39 $$ do [ CD ]
Line_17 $$ if (callback == null) -->Line_25 $$ log.debugf("Adding %s as %s callback for entity %s", methodName, annotation.getSimpleName(), beanClass.getName())[ CD ]
Line_10 $$ Callback callback = null-->Line_74 $$ callbacks.add(0, callback)[ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_60 $$ final Method method = reflectionManager.toMethod(xMethod)[ FD ]
Line_63 $$ if (callback == null) -->Line_73 $$ log.debugf("Adding %s as %s callback for entity %s", methodName, annotation.getSimpleName(), beanClass.getName())[ CD ]
Line_7 $$ boolean stopListeners = false-->Line_34 $$ if (!stopListeners) [ FD ]
Line_6 $$ XClass currentClazz = beanClass-->Line_9 $$ do [ FD ]
Line_4 $$ List<String> callbacksMethodNames = new ArrayList<String>()-->Line_27 $$ callbacksMethodNames.add(0, methodName)[ FD ]
Line_62 $$ if (!callbacksMethodNames.contains(methodName)) -->Line_63 $$ if (callback == null) [ CD ]
Line_14 $$ Method method = reflectionManager.toMethod(xMethod)-->Line_66 $$ Class[] args = method.getParameterTypes()[ FD ]
Line_3 $$ List<Callback> callbacks = new ArrayList<Callback>()-->Line_83 $$ return callbacks.toArray(new Callback[callbacks.size()])[ FD ]
Line_45 $$ if (defaultListeners != null) -->Line_47 $$ for (int i = defaultListenerSize - 1; i >= 0; i--) [ CD ]
Line_60 $$ final Method method = reflectionManager.toMethod(xMethod)-->Line_66 $$ Class[] args = method.getParameterTypes()[ FD ]
Line_53 $$ Callback callback = null-->Line_64 $$ callback = new ListenerCallback(jpaListenerFactory.buildListener(listener), method)[ FD ]
Line_64 $$ callback = new ListenerCallback(jpaListenerFactory.buildListener(listener), method)-->Line_74 $$ callbacks.add(0, callback)[ FD ]
Line_15 $$ final String methodName = method.getName()-->Line_27 $$ callbacksMethodNames.add(0, methodName)[ FD ]
Line_7 $$ boolean stopListeners = false-->Line_36 $$ stopListeners = currentClazz.isAnnotationPresent(ExcludeSuperclassListeners.class)[ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_8 $$ boolean stopDefaultListeners = false[ CD ]
Line_15 $$ final String methodName = method.getName()-->Line_73 $$ log.debugf("Adding %s as %s callback for entity %s", methodName, annotation.getSimpleName(), beanClass.getName())[ FD ]
Line_14 $$ Method method = reflectionManager.toMethod(xMethod)-->Line_71 $$ method.setAccessible(true)[ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_59 $$ if (xMethod.isAnnotationPresent(annotation)) [ FD ]
Line_40 $$ currentClazz = currentClazz.getSuperclass()-->Line_39 $$ do [ FD ]
Line_14 $$ Method method = reflectionManager.toMethod(xMethod)-->Line_65 $$ Class returnType = method.getReturnType()[ FD ]
Line_52 $$ for (Class listener : orderedListeners) -->Line_64 $$ callback = new ListenerCallback(jpaListenerFactory.buildListener(listener), method)[ FD ]
Line_63 $$ if (callback == null) -->Line_65 $$ Class returnType = method.getReturnType()[ CD ]
Line_44 $$ List<Class> defaultListeners = (List<Class>) reflectionManager.getDefaults().get(EntityListeners.class)-->Line_48 $$ orderedListeners.add(defaultListeners.get(i))[ FD ]
Line_17 $$ if (callback == null) -->Line_26 $$ callbacks.add(0, callback)[ CD ]
Line_37 $$ stopDefaultListeners = currentClazz.isAnnotationPresent(ExcludeDefaultListeners.class)-->Line_43 $$ if (!stopDefaultListeners) [ FD ]
Line_14 $$ Method method = reflectionManager.toMethod(xMethod)-->Line_20 $$ Class[] args = method.getParameterTypes()[ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_43 $$ if (!stopDefaultListeners) [ CD ]
Line_10 $$ Callback callback = null-->Line_17 $$ if (callback == null) [ FD ]
Line_18 $$ callback = new EntityCallback(method)-->Line_26 $$ callbacks.add(0, callback)[ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_13 $$ if (xMethod.isAnnotationPresent(annotation)) [ FD ]
Line_6 $$ XClass currentClazz = beanClass-->Line_36 $$ stopListeners = currentClazz.isAnnotationPresent(ExcludeSuperclassListeners.class)[ FD ]
Line_17 $$ if (callback == null) -->Line_20 $$ Class[] args = method.getParameterTypes()[ CD ]
Line_4 $$ List<String> callbacksMethodNames = new ArrayList<String>()-->Line_62 $$ if (!callbacksMethodNames.contains(methodName)) [ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_76 $$ throw new PersistenceException("You can only annotate one callback method with " + annotation.getName() + " in bean class: " + beanClass.getName() + " and callback listener: " + listener.getName())[ FD ]
Line_17 $$ if (callback == null) -->Line_24 $$ method.setAccessible(true)[ CD ]
Line_44 $$ List<Class> defaultListeners = (List<Class>) reflectionManager.getDefaults().get(EntityListeners.class)-->Line_45 $$ if (defaultListeners != null) [ FD ]
Line_43 $$ if (!stopDefaultListeners) -->Line_45 $$ if (defaultListeners != null) [ CD ]
Line_15 $$ final String methodName = method.getName()-->Line_16 $$ if (!callbacksMethodNames.contains(methodName)) [ FD ]
Line_9 $$ do -->Line_10 $$ Callback callback = null[ CD ]
Line_59 $$ if (xMethod.isAnnotationPresent(annotation)) -->Line_60 $$ final Method method = reflectionManager.toMethod(xMethod)[ CD ]
Line_60 $$ final Method method = reflectionManager.toMethod(xMethod)-->Line_61 $$ final String methodName = method.getName()[ FD ]
Line_63 $$ if (callback == null) -->Line_74 $$ callbacks.add(0, callback)[ CD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_25 $$ log.debugf("Adding %s as %s callback for entity %s", methodName, annotation.getSimpleName(), beanClass.getName())[ FD ]
Line_63 $$ if (callback == null) -->Line_66 $$ Class[] args = method.getParameterTypes()[ CD ]
Line_17 $$ if (callback == null) -->Line_18 $$ callback = new EntityCallback(method)[ CD ]
Line_13 $$ if (xMethod.isAnnotationPresent(annotation)) -->Line_16 $$ if (!callbacksMethodNames.contains(methodName)) [ CD ]
Line_14 $$ Method method = reflectionManager.toMethod(xMethod)-->Line_15 $$ final String methodName = method.getName()[ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_7 $$ boolean stopListeners = false[ CD ]
Line_5 $$ List<Class> orderedListeners = new ArrayList<Class>()-->Line_35 $$ getListeners(currentClazz, orderedListeners)[ FD ]
Line_55 $$ XClass xListener = reflectionManager.toXClass(listener)-->Line_57 $$ List<XMethod> methods = xListener.getDeclaredMethods()[ FD ]
Line_6 $$ XClass currentClazz = beanClass-->Line_37 $$ stopDefaultListeners = currentClazz.isAnnotationPresent(ExcludeDefaultListeners.class)[ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_68 $$ throw new PersistenceException("Callback methods annotated in a listener bean class must return void and take one argument: " + annotation.getName() + " - " + method)[ FD ]
Line_63 $$ if (callback == null) -->Line_67 $$ if (returnType != Void.TYPE || args.length != 1) [ CD ]
Line_6 $$ XClass currentClazz = beanClass-->Line_35 $$ getListeners(currentClazz, orderedListeners)[ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_9 $$ do [ CD ]
Line_52 $$ for (Class listener : orderedListeners) -->Line_55 $$ XClass xListener = reflectionManager.toXClass(listener)[ FD ]
Line_53 $$ Callback callback = null-->Line_74 $$ callbacks.add(0, callback)[ FD ]
Line_15 $$ final String methodName = method.getName()-->Line_25 $$ log.debugf("Adding %s as %s callback for entity %s", methodName, annotation.getSimpleName(), beanClass.getName())[ FD ]
Line_58 $$ for (final XMethod xMethod : methods) -->Line_59 $$ if (xMethod.isAnnotationPresent(annotation)) [ FD ]
Line_14 $$ Method method = reflectionManager.toMethod(xMethod)-->Line_61 $$ final String methodName = method.getName()[ FD ]
Line_12 $$ for (final XMethod xMethod : methods) -->Line_59 $$ if (xMethod.isAnnotationPresent(annotation)) [ FD ]
Line_13 $$ if (xMethod.isAnnotationPresent(annotation)) -->Line_15 $$ final String methodName = method.getName()[ CD ]
Line_16 $$ if (!callbacksMethodNames.contains(methodName)) -->Line_17 $$ if (callback == null) [ CD ]
Line_60 $$ final Method method = reflectionManager.toMethod(xMethod)-->Line_70 $$ if (!method.isAccessible()) [ FD ]
Line_61 $$ final String methodName = method.getName()-->Line_73 $$ log.debugf("Adding %s as %s callback for entity %s", methodName, annotation.getSimpleName(), beanClass.getName())[ FD ]
Line_18 $$ callback = new EntityCallback(method)-->Line_63 $$ if (callback == null) [ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_3 $$ List<Callback> callbacks = new ArrayList<Callback>()[ CD ]
Line_3 $$ List<Callback> callbacks = new ArrayList<Callback>()-->Line_26 $$ callbacks.add(0, callback)[ FD ]
Line_6 $$ XClass currentClazz = beanClass-->Line_40 $$ currentClazz = currentClazz.getSuperclass()[ FD ]
Line_44 $$ List<Class> defaultListeners = (List<Class>) reflectionManager.getDefaults().get(EntityListeners.class)-->Line_46 $$ int defaultListenerSize = defaultListeners.size()[ FD ]
Line_47 $$ for (int i = defaultListenerSize - 1; i >= 0; i--) -->Line_48 $$ orderedListeners.add(defaultListeners.get(i))[ CD ]
Line_53 $$ Callback callback = null-->Line_63 $$ if (callback == null) [ FD ]
Line_9 $$ do -->Line_34 $$ if (!stopListeners) [ CD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_29 $$ throw new PersistenceException("You can only annotate one callback method with " + annotation.getName() + " in bean class: " + beanClass.getName())[ FD ]
Line_17 $$ if (callback == null) -->Line_19 $$ Class returnType = method.getReturnType()[ CD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_6 $$ XClass currentClazz = beanClass[ CD ]
Line_59 $$ if (xMethod.isAnnotationPresent(annotation)) -->Line_61 $$ final String methodName = method.getName()[ CD ]
Line_14 $$ Method method = reflectionManager.toMethod(xMethod)-->Line_70 $$ if (!method.isAccessible()) [ FD ]
Line_10 $$ Callback callback = null-->Line_18 $$ callback = new EntityCallback(method)[ FD ]
Line_4 $$ List<String> callbacksMethodNames = new ArrayList<String>()-->Line_56 $$ callbacksMethodNames = new ArrayList<String>()[ FD ]
Line_14 $$ Method method = reflectionManager.toMethod(xMethod)-->Line_24 $$ method.setAccessible(true)[ FD ]
Line_61 $$ final String methodName = method.getName()-->Line_62 $$ if (!callbacksMethodNames.contains(methodName)) [ FD ]
Line_54 $$ if (listener != null) -->Line_55 $$ XClass xListener = reflectionManager.toXClass(listener)[ CD ]
Line_18 $$ callback = new EntityCallback(method)-->Line_74 $$ callbacks.add(0, callback)[ FD ]
Line_52 $$ for (Class listener : orderedListeners) -->Line_76 $$ throw new PersistenceException("You can only annotate one callback method with " + annotation.getName() + " in bean class: " + beanClass.getName() + " and callback listener: " + listener.getName())[ FD ]
Line_36 $$ stopListeners = currentClazz.isAnnotationPresent(ExcludeSuperclassListeners.class)-->Line_34 $$ if (!stopListeners) [ FD ]
Line_9 $$ do -->Line_11 $$ List<XMethod> methods = currentClazz.getDeclaredMethods()[ CD ]
Line_10 $$ Callback callback = null-->Line_64 $$ callback = new ListenerCallback(jpaListenerFactory.buildListener(listener), method)[ FD ]
