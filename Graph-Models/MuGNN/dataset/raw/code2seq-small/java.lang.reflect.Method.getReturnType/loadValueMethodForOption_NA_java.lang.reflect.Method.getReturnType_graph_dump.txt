Line_6 $$ OptionValues optionValues = method.getAnnotation(OptionValues.class)-->Line_7 $$ if (optionValues != null) [ FD ]
Line_2 $$ private static List<JavaMethod<Object, Collection>> loadValueMethodForOption(Class<?> declaredClass) -->Line_4 $$ for (Class<?> type = declaredClass; type != Object.class && type != null; type = type.getSuperclass()) [ CD ]
Line_5 $$ for (Method method : type.getDeclaredMethods()) -->Line_11 $$ throw new OptionValidationException(String.format("@OptionValues annotation not supported on method '%s' in class '%s'. Supported method must be non-static, return a Collection<String> and take no parameters.", method.getName(), type.getName()))[ FD ]
Line_2 $$ private static List<JavaMethod<Object, Collection>> loadValueMethodForOption(Class<?> declaredClass) -->Line_3 $$ List<JavaMethod<Object, Collection>> methods = new ArrayList<JavaMethod<Object, Collection>>()[ CD ]
Line_3 $$ List<JavaMethod<Object, Collection>> methods = new ArrayList<JavaMethod<Object, Collection>>()-->Line_9 $$ methods.add(JavaReflectionUtil.method(Object.class, Collection.class, method))[ FD ]
Line_7 $$ if (optionValues != null) -->Line_8 $$ if (Collection.class.isAssignableFrom(method.getReturnType()) && method.getParameterTypes().length == 0 && !Modifier.isStatic(method.getModifiers())) [ CD ]
Line_5 $$ for (Method method : type.getDeclaredMethods()) -->Line_6 $$ OptionValues optionValues = method.getAnnotation(OptionValues.class)[ FD ]
Line_4 $$ for (Class<?> type = declaredClass; type != Object.class && type != null; type = type.getSuperclass()) -->Line_5 $$ for (Method method : type.getDeclaredMethods()) [ FD ]
Line_5 $$ for (Method method : type.getDeclaredMethods()) -->Line_8 $$ if (Collection.class.isAssignableFrom(method.getReturnType()) && method.getParameterTypes().length == 0 && !Modifier.isStatic(method.getModifiers())) [ FD ]
Line_8 $$ if (Collection.class.isAssignableFrom(method.getReturnType()) && method.getParameterTypes().length == 0 && !Modifier.isStatic(method.getModifiers())) -->Line_9 $$ methods.add(JavaReflectionUtil.method(Object.class, Collection.class, method))[ CD ]
Line_5 $$ for (Method method : type.getDeclaredMethods()) -->Line_9 $$ methods.add(JavaReflectionUtil.method(Object.class, Collection.class, method))[ FD ]
Line_2 $$ private static List<JavaMethod<Object, Collection>> loadValueMethodForOption(Class<?> declaredClass) -->Line_16 $$ return methods[ CD ]
Line_4 $$ for (Class<?> type = declaredClass; type != Object.class && type != null; type = type.getSuperclass()) -->Line_11 $$ throw new OptionValidationException(String.format("@OptionValues annotation not supported on method '%s' in class '%s'. Supported method must be non-static, return a Collection<String> and take no parameters.", method.getName(), type.getName()))[ FD ]
