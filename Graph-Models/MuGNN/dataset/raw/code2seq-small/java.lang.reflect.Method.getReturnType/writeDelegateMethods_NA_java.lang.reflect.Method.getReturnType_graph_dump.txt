Line_14 $$ methodsByReturnType = Maps.newHashMap()-->Line_15 $$ methodsToDelegate.put(methodKey, methodsByReturnType)[ FD ]
Line_14 $$ methodsByReturnType = Maps.newHashMap()-->Line_31 $$ for (Method methodToDelegate : methodsByReturnType.values()) [ FD ]
Line_13 $$ if (methodsByReturnType == null) -->Line_14 $$ methodsByReturnType = Maps.newHashMap()[ CD ]
Line_3 $$ Class<?> delegateClass = delegateSchema.getType().getConcreteClass()-->Line_4 $$ Type delegateType = Type.getType(delegateClass)[ FD ]
Line_7 $$ for (Method methodToDelegate : typeToDelegate.getMethods()) -->Line_17 $$ methodsByReturnType.put(methodToDelegate.getReturnType(), methodToDelegate)[ FD ]
Line_11 $$ Equivalence.Wrapper<Method> methodKey = METHOD_EQUIVALENCE.wrap(methodToDelegate)-->Line_15 $$ methodsToDelegate.put(methodKey, methodsByReturnType)[ FD ]
Line_11 $$ Equivalence.Wrapper<Method> methodKey = METHOD_EQUIVALENCE.wrap(methodToDelegate)-->Line_27 $$ if (!delegateMethodKeys.contains(methodKey)) [ FD ]
Line_2 $$ private void writeDelegateMethods(final ClassVisitor visitor, final Type generatedType, StructSchema<?> delegateSchema, Set<Class<?>> typesToDelegate) -->Line_4 $$ Type delegateType = Type.getType(delegateClass)[ CD ]
Line_13 $$ if (methodsByReturnType == null) -->Line_15 $$ methodsToDelegate.put(methodKey, methodsByReturnType)[ CD ]
Line_20 $$ Set<Equivalence.Wrapper<Method>> delegateMethodKeys = ImmutableSet.copyOf(Iterables.transform(Arrays.asList(delegateClass.getMethods()), new Function<Method, Equivalence.Wrapper<Method>>() -->Line_27 $$ if (!delegateMethodKeys.contains(methodKey)) [ FD ]
Line_5 $$ Map<Equivalence.Wrapper<Method>, Map<Class<?>, Method>> methodsToDelegate = Maps.newHashMap()-->Line_15 $$ methodsToDelegate.put(methodKey, methodsByReturnType)[ FD ]
Line_7 $$ for (Method methodToDelegate : typeToDelegate.getMethods()) -->Line_32 $$ writeDelegatedMethod(visitor, generatedType, delegateType, methodToDelegate)[ FD ]
Line_7 $$ for (Method methodToDelegate : typeToDelegate.getMethods()) -->Line_8 $$ if (ModelSchemaUtils.isIgnoredMethod(methodToDelegate)) [ FD ]
Line_5 $$ Map<Equivalence.Wrapper<Method>, Map<Class<?>, Method>> methodsToDelegate = Maps.newHashMap()-->Line_12 $$ Map<Class<?>, Method> methodsByReturnType = methodsToDelegate.get(methodKey)[ FD ]
Line_12 $$ Map<Class<?>, Method> methodsByReturnType = methodsToDelegate.get(methodKey)-->Line_15 $$ methodsToDelegate.put(methodKey, methodsByReturnType)[ FD ]
Line_7 $$ for (Method methodToDelegate : typeToDelegate.getMethods()) -->Line_11 $$ Equivalence.Wrapper<Method> methodKey = METHOD_EQUIVALENCE.wrap(methodToDelegate)[ FD ]
Line_2 $$ private void writeDelegateMethods(final ClassVisitor visitor, final Type generatedType, StructSchema<?> delegateSchema, Set<Class<?>> typesToDelegate) -->Line_3 $$ Class<?> delegateClass = delegateSchema.getType().getConcreteClass()[ CD ]
Line_12 $$ Map<Class<?>, Method> methodsByReturnType = methodsToDelegate.get(methodKey)-->Line_31 $$ for (Method methodToDelegate : methodsByReturnType.values()) [ FD ]
Line_2 $$ private void writeDelegateMethods(final ClassVisitor visitor, final Type generatedType, StructSchema<?> delegateSchema, Set<Class<?>> typesToDelegate) -->Line_32 $$ writeDelegatedMethod(visitor, generatedType, delegateType, methodToDelegate)[ FD ]
Line_2 $$ private void writeDelegateMethods(final ClassVisitor visitor, final Type generatedType, StructSchema<?> delegateSchema, Set<Class<?>> typesToDelegate) -->Line_3 $$ Class<?> delegateClass = delegateSchema.getType().getConcreteClass()[ FD ]
Line_20 $$ Set<Equivalence.Wrapper<Method>> delegateMethodKeys = ImmutableSet.copyOf(Iterables.transform(Arrays.asList(delegateClass.getMethods()), new Function<Method, Equivalence.Wrapper<Method>>() -->Line_22 $$ return METHOD_EQUIVALENCE.wrap(method)[ CD ]
Line_11 $$ Equivalence.Wrapper<Method> methodKey = METHOD_EQUIVALENCE.wrap(methodToDelegate)-->Line_12 $$ Map<Class<?>, Method> methodsByReturnType = methodsToDelegate.get(methodKey)[ FD ]
Line_6 $$ for (Class<?> typeToDelegate : typesToDelegate) -->Line_7 $$ for (Method methodToDelegate : typeToDelegate.getMethods()) [ FD ]
Line_4 $$ Type delegateType = Type.getType(delegateClass)-->Line_32 $$ writeDelegatedMethod(visitor, generatedType, delegateType, methodToDelegate)[ FD ]
Line_20 $$ Set<Equivalence.Wrapper<Method>> delegateMethodKeys = ImmutableSet.copyOf(Iterables.transform(Arrays.asList(delegateClass.getMethods()), new Function<Method, Equivalence.Wrapper<Method>>() -->Line_22 $$ return METHOD_EQUIVALENCE.wrap(method)[ FD ]
Line_14 $$ methodsByReturnType = Maps.newHashMap()-->Line_17 $$ methodsByReturnType.put(methodToDelegate.getReturnType(), methodToDelegate)[ FD ]
Line_2 $$ private void writeDelegateMethods(final ClassVisitor visitor, final Type generatedType, StructSchema<?> delegateSchema, Set<Class<?>> typesToDelegate) -->Line_20 $$ Set<Equivalence.Wrapper<Method>> delegateMethodKeys = ImmutableSet.copyOf(Iterables.transform(Arrays.asList(delegateClass.getMethods()), new Function<Method, Equivalence.Wrapper<Method>>() [ CD ]
Line_2 $$ private void writeDelegateMethods(final ClassVisitor visitor, final Type generatedType, StructSchema<?> delegateSchema, Set<Class<?>> typesToDelegate) -->Line_5 $$ Map<Equivalence.Wrapper<Method>, Map<Class<?>, Method>> methodsToDelegate = Maps.newHashMap()[ CD ]
Line_12 $$ Map<Class<?>, Method> methodsByReturnType = methodsToDelegate.get(methodKey)-->Line_17 $$ methodsByReturnType.put(methodToDelegate.getReturnType(), methodToDelegate)[ FD ]
Line_12 $$ Map<Class<?>, Method> methodsByReturnType = methodsToDelegate.get(methodKey)-->Line_13 $$ if (methodsByReturnType == null) [ FD ]
Line_5 $$ Map<Equivalence.Wrapper<Method>, Map<Class<?>, Method>> methodsToDelegate = Maps.newHashMap()-->Line_25 $$ for (Map.Entry<Equivalence.Wrapper<Method>, Map<Class<?>, Method>> entry : methodsToDelegate.entrySet()) [ FD ]
Line_12 $$ Map<Class<?>, Method> methodsByReturnType = methodsToDelegate.get(methodKey)-->Line_14 $$ methodsByReturnType = Maps.newHashMap()[ FD ]
Line_3 $$ Class<?> delegateClass = delegateSchema.getType().getConcreteClass()-->Line_20 $$ Set<Equivalence.Wrapper<Method>> delegateMethodKeys = ImmutableSet.copyOf(Iterables.transform(Arrays.asList(delegateClass.getMethods()), new Function<Method, Equivalence.Wrapper<Method>>() [ FD ]
