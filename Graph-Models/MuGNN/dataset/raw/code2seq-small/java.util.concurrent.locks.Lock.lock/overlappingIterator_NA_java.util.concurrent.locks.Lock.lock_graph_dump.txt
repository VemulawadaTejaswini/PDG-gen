Line_36 $$ T t = currentNode.intervals.get(indexInCurrentList++).get()-->Line_37 $$ if (t != null) [ FD ]
Line_51 $$ while (indexInCurrentList != currentNode.intervals.size()) -->Line_53 $$ if (t != null) [ CD ]
Line_114 $$ if (parent == null)-->Line_115 $$ return null[ CD ]
Line_29 $$ if (current != null)-->Line_30 $$ return true[ CD ]
Line_35 $$ while (indexInCurrentList != currentNode.intervals.size()) -->Line_36 $$ T t = currentNode.intervals.get(indexInCurrentList++).get()[ CD ]
Line_17 $$ return new PeekableIterator<T>() -->Line_42 $$ indexInCurrentList = 0[ CD ]
Line_17 $$ return new PeekableIterator<T>() -->Line_67 $$ T t = current[ CD ]
Line_17 $$ return new PeekableIterator<T>() -->Line_74 $$ if (!hasNext())[ CD ]
Line_101 $$ if (startOffset <= rightMaxEnd) -->Line_102 $$ int rightDelta = delta + right.delta[ CD ]
Line_36 $$ T t = currentNode.intervals.get(indexInCurrentList++).get()-->Line_53 $$ if (t != null) [ FD ]
Line_17 $$ return new PeekableIterator<T>() -->Line_35 $$ while (indexInCurrentList != currentNode.intervals.size()) [ CD ]
Line_50 $$ indexInCurrentList = 0-->Line_51 $$ while (indexInCurrentList != currentNode.intervals.size()) [ FD ]
Line_42 $$ indexInCurrentList = 0-->Line_51 $$ while (indexInCurrentList != currentNode.intervals.size()) [ FD ]
Line_102 $$ int rightDelta = delta + right.delta-->Line_103 $$ while (right.getLeft() != null && startOffset <= maxEndOf(right.getLeft(), rightDelta)) [ FD ]
Line_107 $$ deltaUpToRootExclusive = rightDelta - right.delta-->Line_119 $$ deltaUpToRootExclusive -= parent.delta[ FD ]
Line_17 $$ return new PeekableIterator<T>() -->Line_99 $$ if (right != null) [ CD ]
Line_31 $$ if (currentNode == null)-->Line_32 $$ return false[ CD ]
Line_17 $$ return new PeekableIterator<T>() -->Line_91 $$ assert root.isValid() : root[ FD ]
Line_6 $$ final int startOffset = rangeInterval.getStartOffset()-->Line_101 $$ if (startOffset <= rightMaxEnd) [ FD ]
Line_103 $$ while (right.getLeft() != null && startOffset <= maxEndOf(right.getLeft(), rightDelta)) -->Line_105 $$ rightDelta += right.delta[ CD ]
Line_48 $$ if (overlaps(currentNode, rangeInterval, deltaUpToRootExclusive)) -->Line_58 $$ indexInCurrentList = 0[ CD ]
Line_113 $$ IntervalNode<T> parent = root.getParent()-->Line_120 $$ if (parent.getLeft() == root) [ FD ]
Line_17 $$ return new PeekableIterator<T>() -->Line_113 $$ IntervalNode<T> parent = root.getParent()[ FD ]
Line_53 $$ if (t != null) -->Line_55 $$ return true[ CD ]
Line_17 $$ return new PeekableIterator<T>() -->Line_29 $$ if (current != null)[ CD ]
Line_42 $$ indexInCurrentList = 0-->Line_58 $$ indexInCurrentList = 0[ FD ]
Line_17 $$ return new PeekableIterator<T>() -->Line_69 $$ return t[ CD ]
Line_99 $$ if (right != null) -->Line_100 $$ int rightMaxEnd = maxEndOf(right, delta)[ CD ]
Line_103 $$ while (right.getLeft() != null && startOffset <= maxEndOf(right.getLeft(), rightDelta)) -->Line_104 $$ right = right.getLeft()[ CD ]
Line_8 $$ final IntervalNode<T> firstOverlap = findMinOverlappingWith(getRoot(), rangeInterval, modCount, 0)-->Line_15 $$ final int firstOverlapStart = firstOverlap.intervalStart() + firstOverlapDelta[ FD ]
Line_17 $$ return new PeekableIterator<T>() -->Line_86 $$ l.readLock().unlock()[ CD ]
Line_92 $$ int delta = deltaUpToRootExclusive + root.delta-->Line_100 $$ int rightMaxEnd = maxEndOf(right, delta)[ FD ]
Line_37 $$ if (t != null) -->Line_39 $$ return true[ CD ]
Line_43 $$ while (true) -->Line_44 $$ currentNode = nextNode(currentNode)[ CD ]
Line_17 $$ return new PeekableIterator<T>() -->Line_33 $$ if (modCount != modCountBefore)[ CD ]
Line_43 $$ while (true) -->Line_48 $$ if (overlaps(currentNode, rangeInterval, deltaUpToRootExclusive)) [ CD ]
Line_105 $$ rightDelta += right.delta-->Line_103 $$ while (right.getLeft() != null && startOffset <= maxEndOf(right.getLeft(), rightDelta)) [ FD ]
Line_101 $$ if (startOffset <= rightMaxEnd) -->Line_107 $$ deltaUpToRootExclusive = rightDelta - right.delta[ CD ]
Line_102 $$ int rightDelta = delta + right.delta-->Line_107 $$ deltaUpToRootExclusive = rightDelta - right.delta[ FD ]
Line_48 $$ if (overlaps(currentNode, rangeInterval, deltaUpToRootExclusive)) -->Line_50 $$ indexInCurrentList = 0[ CD ]
Line_102 $$ int rightDelta = delta + right.delta-->Line_105 $$ rightDelta += right.delta[ FD ]
Line_42 $$ indexInCurrentList = 0-->Line_50 $$ indexInCurrentList = 0[ FD ]
Line_104 $$ right = right.getLeft()-->Line_103 $$ while (right.getLeft() != null && startOffset <= maxEndOf(right.getLeft(), rightDelta)) [ FD ]
Line_8 $$ final IntervalNode<T> firstOverlap = findMinOverlappingWith(getRoot(), rangeInterval, modCount, 0)-->Line_14 $$ final int firstOverlapDelta = firstOverlap.computeDeltaUpToRoot()[ FD ]
Line_99 $$ if (right != null) -->Line_101 $$ if (startOffset <= rightMaxEnd) [ CD ]
Line_42 $$ indexInCurrentList = 0-->Line_52 $$ T t = currentNode.intervals.get(indexInCurrentList++).get()[ FD ]
Line_105 $$ rightDelta += right.delta-->Line_107 $$ deltaUpToRootExclusive = rightDelta - right.delta[ FD ]
Line_100 $$ int rightMaxEnd = maxEndOf(right, delta)-->Line_101 $$ if (startOffset <= rightMaxEnd) [ FD ]
Line_101 $$ if (startOffset <= rightMaxEnd) -->Line_103 $$ while (right.getLeft() != null && startOffset <= maxEndOf(right.getLeft(), rightDelta)) [ CD ]
Line_9 $$ if (firstOverlap == null) -->Line_10 $$ l.readLock().unlock()[ CD ]
Line_16 $$ final int modCountBefore = modCount-->Line_33 $$ if (modCount != modCountBefore)[ FD ]
Line_17 $$ return new PeekableIterator<T>() -->Line_43 $$ while (true) [ CD ]
Line_45 $$ if (currentNode == null) -->Line_46 $$ return false[ CD ]
Line_17 $$ return new PeekableIterator<T>() -->Line_93 $$ int myMaxEnd = maxEndOf(root, deltaUpToRootExclusive)[ CD ]
Line_101 $$ if (startOffset <= rightMaxEnd) -->Line_108 $$ return right[ CD ]
Line_17 $$ return new PeekableIterator<T>() -->Line_93 $$ int myMaxEnd = maxEndOf(root, deltaUpToRootExclusive)[ FD ]
Line_120 $$ if (parent.getLeft() == root) -->Line_121 $$ return parent[ CD ]
Line_8 $$ final IntervalNode<T> firstOverlap = findMinOverlappingWith(getRoot(), rangeInterval, modCount, 0)-->Line_9 $$ if (firstOverlap == null) [ FD ]
Line_50 $$ indexInCurrentList = 0-->Line_52 $$ T t = currentNode.intervals.get(indexInCurrentList++).get()[ FD ]
Line_43 $$ while (true) -->Line_45 $$ if (currentNode == null) [ CD ]
Line_51 $$ while (indexInCurrentList != currentNode.intervals.size()) -->Line_52 $$ T t = currentNode.intervals.get(indexInCurrentList++).get()[ CD ]
Line_35 $$ while (indexInCurrentList != currentNode.intervals.size()) -->Line_37 $$ if (t != null) [ CD ]
Line_48 $$ if (overlaps(currentNode, rangeInterval, deltaUpToRootExclusive)) -->Line_51 $$ while (indexInCurrentList != currentNode.intervals.size()) [ CD ]
Line_52 $$ T t = currentNode.intervals.get(indexInCurrentList++).get()-->Line_53 $$ if (t != null) [ FD ]
Line_17 $$ return new PeekableIterator<T>() -->Line_65 $$ if (!hasNext())[ CD ]
Line_17 $$ return new PeekableIterator<T>() -->Line_92 $$ int delta = deltaUpToRootExclusive + root.delta[ CD ]
Line_17 $$ return new PeekableIterator<T>() -->Line_120 $$ if (parent.getLeft() == root) [ FD ]
Line_17 $$ return new PeekableIterator<T>() -->Line_31 $$ if (currentNode == null)[ CD ]
Line_113 $$ IntervalNode<T> parent = root.getParent()-->Line_114 $$ if (parent == null)[ FD ]
Line_50 $$ indexInCurrentList = 0-->Line_58 $$ indexInCurrentList = 0[ FD ]
Line_17 $$ return new PeekableIterator<T>() -->Line_76 $$ return current[ CD ]
