Line_56 $$ Collection<Token> tokens = bootstrapAddresses.get(endpoint)-->Line_57 $$ allLeftMetadata.updateNormalTokens(tokens, endpoint)[ FD ]
Line_28 $$ Multimap<Range<Token>, InetAddress> newPendingRanges = HashMultimap.create()-->Line_58 $$ newPendingRanges.put(range, endpoint)[ FD ]
Line_40 $$ for (InetAddress endpoint : leavingEndpoints) affectedRanges.addAll(addressRanges.get(endpoint))-->Line_71 $$ newPendingRanges.put(range, endpoint)[ FD ]
Line_28 $$ Multimap<Range<Token>, InetAddress> newPendingRanges = HashMultimap.create()-->Line_32 $$ pendingRanges.put(keyspaceName, newPendingRanges)[ FD ]
Line_29 $$ if (bootstrapTokens.isEmpty() && leavingEndpoints.isEmpty() && movingEndpoints.isEmpty()) -->Line_32 $$ pendingRanges.put(keyspaceName, newPendingRanges)[ CD ]
Line_28 $$ Multimap<Range<Token>, InetAddress> newPendingRanges = HashMultimap.create()-->Line_71 $$ newPendingRanges.put(range, endpoint)[ FD ]
Line_28 $$ Multimap<Range<Token>, InetAddress> newPendingRanges = HashMultimap.create()-->Line_48 $$ newPendingRanges.putAll(range, Sets.difference(newEndpoints, currentEndpoints))[ FD ]
Line_40 $$ for (InetAddress endpoint : leavingEndpoints) affectedRanges.addAll(addressRanges.get(endpoint))-->Line_73 $$ allLeftMetadata.removeEndpoint(endpoint)[ FD ]
Line_45 $$ for (Range<Token> range : affectedRanges) -->Line_48 $$ newPendingRanges.putAll(range, Sets.difference(newEndpoints, currentEndpoints))[ FD ]
Line_47 $$ Set<InetAddress> newEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right, allLeftMetadata))-->Line_48 $$ newPendingRanges.putAll(range, Sets.difference(newEndpoints, currentEndpoints))[ FD ]
Line_35 $$ Multimap<InetAddress, Range<Token>> addressRanges = strategy.getAddressRanges()-->Line_40 $$ affectedRanges.addAll(addressRanges.get(endpoint))[ FD ]
Line_40 $$ for (InetAddress endpoint : leavingEndpoints) affectedRanges.addAll(addressRanges.get(endpoint))-->Line_57 $$ allLeftMetadata.updateNormalTokens(tokens, endpoint)[ FD ]
Line_28 $$ Multimap<Range<Token>, InetAddress> newPendingRanges = HashMultimap.create()-->Line_75 $$ pendingRanges.put(keyspaceName, newPendingRanges)[ FD ]
Line_29 $$ if (bootstrapTokens.isEmpty() && leavingEndpoints.isEmpty() && movingEndpoints.isEmpty()) -->Line_33 $$ return[ CD ]
Line_40 $$ for (InetAddress endpoint : leavingEndpoints) affectedRanges.addAll(addressRanges.get(endpoint))-->Line_70 $$ for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint)) [ FD ]
Line_29 $$ if (bootstrapTokens.isEmpty() && leavingEndpoints.isEmpty() && movingEndpoints.isEmpty()) -->Line_30 $$ if (logger.isTraceEnabled())[ CD ]
Line_40 $$ for (InetAddress endpoint : leavingEndpoints) affectedRanges.addAll(addressRanges.get(endpoint))-->Line_58 $$ for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint)) newPendingRanges.put(range, endpoint)[ FD ]
Line_40 $$ for (InetAddress endpoint : leavingEndpoints) affectedRanges.addAll(addressRanges.get(endpoint))-->Line_58 $$ newPendingRanges.put(range, endpoint)[ FD ]
Line_45 $$ for (Range<Token> range : affectedRanges) -->Line_58 $$ newPendingRanges.put(range, endpoint)[ FD ]
Line_45 $$ for (Range<Token> range : affectedRanges) -->Line_71 $$ newPendingRanges.put(range, endpoint)[ FD ]
Line_30 $$ if (logger.isTraceEnabled())-->Line_31 $$ logger.trace("No bootstrapping, leaving or moving nodes -> empty pending ranges for [ CD ]
Line_46 $$ Set<InetAddress> currentEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right, metadata))-->Line_48 $$ newPendingRanges.putAll(range, Sets.difference(newEndpoints, currentEndpoints))[ FD ]
Line_40 $$ for (InetAddress endpoint : leavingEndpoints) affectedRanges.addAll(addressRanges.get(endpoint))-->Line_59 $$ allLeftMetadata.removeEndpoint(endpoint)[ FD ]
Line_76 $$ if (logger.isTraceEnabled())-->Line_77 $$ logger.trace("Pending ranges:\n[ CD ]
Line_40 $$ for (InetAddress endpoint : leavingEndpoints) affectedRanges.addAll(addressRanges.get(endpoint))-->Line_56 $$ Collection<Token> tokens = bootstrapAddresses.get(endpoint)[ FD ]
