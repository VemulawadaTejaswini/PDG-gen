Line_10 $$ for (int i = 0; i < NUMBER_OF_SEGMENTS; i++) -->Line_12 $$ haveSegmentLock[i] = true[ CD ]
Line_33 $$ while (h != null) -->Line_35 $$ h = h.after[ CD ]
Line_33 $$ while (h != null) -->Line_34 $$ removalListener.onRemoval(new RemovalNotification(h.key, h.value, RemovalNotification.RemovalReason.INVALIDATED))[ CD ]
Line_35 $$ h = h.after-->Line_33 $$ while (h != null) [ FD ]
Line_7 $$ Entry<K, V> h-->Line_15 $$ h = head[ FD ]
Line_27 $$ for (int i = NUMBER_OF_SEGMENTS - 1; i >= 0; i--) -->Line_28 $$ if (haveSegmentLock[i]) [ CD ]
Line_18 $$ while (current != null) -->Line_20 $$ current = current.after[ CD ]
Line_7 $$ Entry<K, V> h-->Line_33 $$ while (h != null) [ FD ]
Line_15 $$ h = head-->Line_33 $$ while (h != null) [ FD ]
Line_10 $$ for (int i = 0; i < NUMBER_OF_SEGMENTS; i++) -->Line_11 $$ segments[i].segmentLock.writeLock().lock()[ CD ]
Line_7 $$ Entry<K, V> h-->Line_35 $$ h = h.after[ FD ]
Line_17 $$ Entry<K, V> current = head-->Line_20 $$ current = current.after[ FD ]
Line_27 $$ for (int i = NUMBER_OF_SEGMENTS - 1; i >= 0; i--) -->Line_28 $$ if (haveSegmentLock[i]) [ FD ]
Line_8 $$ boolean[] haveSegmentLock = new boolean[NUMBER_OF_SEGMENTS]-->Line_28 $$ if (haveSegmentLock[i]) [ FD ]
Line_10 $$ for (int i = 0; i < NUMBER_OF_SEGMENTS; i++) -->Line_28 $$ if (haveSegmentLock[i]) [ FD ]
Line_17 $$ Entry<K, V> current = head-->Line_18 $$ while (current != null) [ FD ]
Line_10 $$ for (int i = 0; i < NUMBER_OF_SEGMENTS; i++) -->Line_27 $$ for (int i = NUMBER_OF_SEGMENTS - 1; i >= 0; i--) [ FD ]
Line_20 $$ current = current.after-->Line_18 $$ while (current != null) [ FD ]
Line_15 $$ h = head-->Line_35 $$ h = h.after[ FD ]
Line_18 $$ while (current != null) -->Line_19 $$ current.state = State.DELETED[ CD ]
Line_28 $$ if (haveSegmentLock[i]) -->Line_29 $$ segments[i].segmentLock.writeLock().unlock()[ CD ]
