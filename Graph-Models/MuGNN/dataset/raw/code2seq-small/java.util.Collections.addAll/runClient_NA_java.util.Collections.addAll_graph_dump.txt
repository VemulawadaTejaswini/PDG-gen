Line_12 $$ if (myTraceClient) -->Line_13 $$ LOG.info("*** running:\n" + arguments)[ CD ]
Line_12 $$ if (myTraceClient) -->Line_14 $$ if (StringUtil.isNotEmpty(stdin)) [ CD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_5 $$ if (client.exists()) [ CD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_11 $$ Collections.addAll(arguments, commandLine)[ CD ]
Line_35 $$ final CapturingProcessHandler handler = new CapturingProcessHandler(clientProcess, CharsetToolkit.getDefaultSystemCharset(), StringUtil.join(arguments, " "))-->Line_36 $$ final ProcessOutput result = handler.runProcess(100 * 1000, false)[ FD ]
Line_36 $$ final ProcessOutput result = handler.runProcess(100 * 1000, false)-->Line_37 $$ if (myTraceClient || result.isTimeout()) [ FD ]
Line_18 $$ final ProcessBuilder builder = new ProcessBuilder().command(arguments)-->Line_23 $$ builder.environment().putAll(myClientEnvironment)[ FD ]
Line_43 $$ final String err = result.getStderr().trim()-->Line_44 $$ if (err.length() > 0) [ FD ]
Line_18 $$ final ProcessBuilder builder = new ProcessBuilder().command(arguments)-->Line_25 $$ final Process clientProcess = builder.start()[ FD ]
Line_37 $$ if (myTraceClient || result.isTimeout()) -->Line_44 $$ if (err.length() > 0) [ CD ]
Line_44 $$ if (err.length() > 0) -->Line_45 $$ LOG.debug("*** error:\n" + err)[ CD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_26 $$ if (stdin != null) [ FD ]
Line_3 $$ final List<String> arguments = new ArrayList<String>()-->Line_11 $$ Collections.addAll(arguments, commandLine)[ FD ]
Line_3 $$ final List<String> arguments = new ArrayList<String>()-->Line_6 $$ arguments.add(client.toString())[ FD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_4 $$ final File client = new File(myClientBinaryPath, SystemInfo.isWindows ? exeName + ".exe" : exeName)[ CD ]
Line_48 $$ if (result.isTimeout()) -->Line_50 $$ handler.destroyProcess()[ CD ]
Line_35 $$ final CapturingProcessHandler handler = new CapturingProcessHandler(clientProcess, CharsetToolkit.getDefaultSystemCharset(), StringUtil.join(arguments, " "))-->Line_50 $$ handler.destroyProcess()[ FD ]
Line_37 $$ if (myTraceClient || result.isTimeout()) -->Line_40 $$ if (out.length() > 0) [ CD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_12 $$ if (myTraceClient) [ CD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_18 $$ final ProcessBuilder builder = new ProcessBuilder().command(arguments)[ CD ]
Line_27 $$ final OutputStream outputStream = clientProcess.getOutputStream()-->Line_30 $$ outputStream.write(bytes)[ FD ]
Line_26 $$ if (stdin != null) -->Line_27 $$ final OutputStream outputStream = clientProcess.getOutputStream()[ CD ]
Line_40 $$ if (out.length() > 0) -->Line_41 $$ LOG.debug("*** output:\n" + out)[ CD ]
Line_48 $$ if (result.isTimeout()) -->Line_49 $$ String processList = LogUtil.getProcessList()[ CD ]
Line_29 $$ final byte[] bytes = stdin.getBytes()-->Line_30 $$ outputStream.write(bytes)[ FD ]
Line_3 $$ final List<String> arguments = new ArrayList<String>()-->Line_18 $$ final ProcessBuilder builder = new ProcessBuilder().command(arguments)[ FD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_48 $$ if (result.isTimeout()) [ CD ]
Line_3 $$ final List<String> arguments = new ArrayList<String>()-->Line_35 $$ final CapturingProcessHandler handler = new CapturingProcessHandler(clientProcess, CharsetToolkit.getDefaultSystemCharset(), StringUtil.join(arguments, " "))[ FD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_20 $$ builder.directory(workingDir)[ FD ]
Line_22 $$ if (myClientEnvironment != null) -->Line_23 $$ builder.environment().putAll(myClientEnvironment)[ CD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_14 $$ if (StringUtil.isNotEmpty(stdin)) [ FD ]
Line_36 $$ final ProcessOutput result = handler.runProcess(100 * 1000, false)-->Line_38 $$ LOG.debug("*** result: " + result.getExitCode())[ FD ]
Line_39 $$ final String out = result.getStdout().trim()-->Line_40 $$ if (out.length() > 0) [ FD ]
Line_18 $$ final ProcessBuilder builder = new ProcessBuilder().command(arguments)-->Line_20 $$ builder.directory(workingDir)[ FD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_29 $$ final byte[] bytes = stdin.getBytes()[ FD ]
Line_37 $$ if (myTraceClient || result.isTimeout()) -->Line_38 $$ LOG.debug("*** result: " + result.getExitCode())[ CD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_35 $$ final CapturingProcessHandler handler = new CapturingProcessHandler(clientProcess, CharsetToolkit.getDefaultSystemCharset(), StringUtil.join(arguments, " "))[ CD ]
Line_37 $$ if (myTraceClient || result.isTimeout()) -->Line_39 $$ final String out = result.getStdout().trim()[ CD ]
Line_36 $$ final ProcessOutput result = handler.runProcess(100 * 1000, false)-->Line_39 $$ final String out = result.getStdout().trim()[ FD ]
Line_5 $$ if (client.exists()) -->Line_6 $$ arguments.add(client.toString())[ CD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_37 $$ if (myTraceClient || result.isTimeout()) [ CD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_22 $$ if (myClientEnvironment != null) [ CD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_36 $$ final ProcessOutput result = handler.runProcess(100 * 1000, false)[ CD ]
Line_25 $$ final Process clientProcess = builder.start()-->Line_27 $$ final OutputStream outputStream = clientProcess.getOutputStream()[ FD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_19 $$ if (workingDir != null) [ FD ]
Line_4 $$ final File client = new File(myClientBinaryPath, SystemInfo.isWindows ? exeName + ".exe" : exeName)-->Line_6 $$ arguments.add(client.toString())[ FD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_3 $$ final List<String> arguments = new ArrayList<String>()[ CD ]
Line_19 $$ if (workingDir != null) -->Line_20 $$ builder.directory(workingDir)[ CD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_26 $$ if (stdin != null) [ CD ]
Line_14 $$ if (StringUtil.isNotEmpty(stdin)) -->Line_15 $$ LOG.info("*** stdin:\n" + stdin)[ CD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_11 $$ Collections.addAll(arguments, commandLine)[ FD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_25 $$ final Process clientProcess = builder.start()[ CD ]
Line_37 $$ if (myTraceClient || result.isTimeout()) -->Line_43 $$ final String err = result.getStderr().trim()[ CD ]
Line_36 $$ final ProcessOutput result = handler.runProcess(100 * 1000, false)-->Line_48 $$ if (result.isTimeout()) [ FD ]
Line_4 $$ final File client = new File(myClientBinaryPath, SystemInfo.isWindows ? exeName + ".exe" : exeName)-->Line_5 $$ if (client.exists()) [ FD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_19 $$ if (workingDir != null) [ CD ]
Line_2 $$ public ProcessOutput runClient(@NotNull String exeName, @Nullable String stdin, @Nullable final File workingDir, String... commandLine) throws IOException -->Line_53 $$ return result[ CD ]
Line_36 $$ final ProcessOutput result = handler.runProcess(100 * 1000, false)-->Line_43 $$ final String err = result.getStderr().trim()[ FD ]
Line_27 $$ final OutputStream outputStream = clientProcess.getOutputStream()-->Line_32 $$ outputStream.close()[ FD ]
