Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_5 $$ if (!config.isInstrumentClasses()) [ CD ]
Line_38 $$ for (File form : forms) -->Line_39 $$ formPaths.add(form.getPath())[ FD ]
Line_25 $$ final List<File> classpath = new ArrayList<File>()-->Line_29 $$ classpath.addAll(chunkSourcePath.keySet())[ FD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_9 $$ FORMS_TO_COMPILE.set(context, null)[ FD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_32 $$ final Map<File, Collection<File>> processed = instrumentForms(context, chunk, chunkSourcePath, finder, formsToCompile, outputConsumer)[ FD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_33 $$ final OneToManyPathsMapping sourceToFormMap = context.getProjectDescriptor().dataManager.getSourceToFormMap()[ FD ]
Line_8 $$ final Map<File, Collection<File>> srcToForms = FORMS_TO_COMPILE.get(context)-->Line_42 $$ srcToForms.remove(src)[ FD ]
Line_8 $$ final Map<File, Collection<File>> srcToForms = FORMS_TO_COMPILE.get(context)-->Line_10 $$ if (srcToForms == null || srcToForms.isEmpty()) [ FD ]
Line_25 $$ final List<File> classpath = new ArrayList<File>()-->Line_26 $$ classpath.addAll(ProjectPaths.getCompilationClasspath(chunk, false))[ FD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_30 $$ final InstrumentationClassFinder finder = ClassProcessingBuilder.createInstrumentationClassFinder(platformCp, classpath, outputConsumer)[ FD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_17 $$ if (JavaBuilderUtil.isCompileJavaIncrementally(context)) [ FD ]
Line_28 $$ final Map<File, String> chunkSourcePath = ProjectPaths.getSourceRootsWithDependents(chunk)-->Line_32 $$ final Map<File, Collection<File>> processed = instrumentForms(context, chunk, chunkSourcePath, finder, formsToCompile, outputConsumer)[ FD ]
Line_13 $$ final Set<File> formsToCompile = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_32 $$ final Map<File, Collection<File>> processed = instrumentForms(context, chunk, chunkSourcePath, finder, formsToCompile, outputConsumer)[ FD ]
Line_10 $$ if (srcToForms == null || srcToForms.isEmpty()) -->Line_11 $$ return ExitCode.NOTHING_DONE[ CD ]
Line_18 $$ final ProjectBuilderLogger logger = context.getLoggingManager().getProjectBuilderLogger()-->Line_20 $$ logger.logCompiledFiles(formsToCompile, getPresentableName(), "Compiling forms:")[ FD ]
Line_5 $$ if (!config.isInstrumentClasses()) -->Line_6 $$ return ExitCode.NOTHING_DONE[ CD ]
Line_8 $$ final Map<File, Collection<File>> srcToForms = FORMS_TO_COMPILE.get(context)-->Line_14 $$ for (Collection<File> files : srcToForms.values()) [ FD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_28 $$ final Map<File, String> chunkSourcePath = ProjectPaths.getSourceRootsWithDependents(chunk)[ FD ]
Line_44 $$ for (File srcFile : srcToForms.keySet()) -->Line_45 $$ sourceToFormMap.remove(srcFile.getPath())[ FD ]
Line_30 $$ final InstrumentationClassFinder finder = ClassProcessingBuilder.createInstrumentationClassFinder(platformCp, classpath, outputConsumer)-->Line_32 $$ final Map<File, Collection<File>> processed = instrumentForms(context, chunk, chunkSourcePath, finder, formsToCompile, outputConsumer)[ FD ]
Line_34 $$ for (Map.Entry<File, Collection<File>> entry : processed.entrySet()) -->Line_36 $$ final Collection<File> forms = entry.getValue()[ FD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_13 $$ final Set<File> formsToCompile = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)[ CD ]
Line_37 $$ final Collection<String> formPaths = new ArrayList<String>(forms.size())-->Line_39 $$ formPaths.add(form.getPath())[ FD ]
Line_33 $$ final OneToManyPathsMapping sourceToFormMap = context.getProjectDescriptor().dataManager.getSourceToFormMap()-->Line_41 $$ sourceToFormMap.update(src.getPath(), formPaths)[ FD ]
Line_13 $$ final Set<File> formsToCompile = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_15 $$ formsToCompile.addAll(files)[ FD ]
Line_25 $$ final List<File> classpath = new ArrayList<File>()-->Line_27 $$ classpath.add(getResourcePath(GridConstraints.class))[ FD ]
Line_4 $$ final JpsUiDesignerConfiguration config = JpsUiDesignerExtensionService.getInstance().getOrCreateUiDesignerConfiguration(project)-->Line_5 $$ if (!config.isInstrumentClasses()) [ FD ]
Line_35 $$ final File src = entry.getKey()-->Line_41 $$ sourceToFormMap.update(src.getPath(), formPaths)[ FD ]
Line_18 $$ final ProjectBuilderLogger logger = context.getLoggingManager().getProjectBuilderLogger()-->Line_19 $$ if (logger.isEnabled()) [ FD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_53 $$ return ExitCode.OK[ CD ]
Line_34 $$ for (Map.Entry<File, Collection<File>> entry : processed.entrySet()) -->Line_35 $$ final File src = entry.getKey()[ FD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_4 $$ final JpsUiDesignerConfiguration config = JpsUiDesignerExtensionService.getInstance().getOrCreateUiDesignerConfiguration(project)[ CD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_3 $$ final JpsProject project = context.getProjectDescriptor().getProject()[ CD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_10 $$ if (srcToForms == null || srcToForms.isEmpty()) [ CD ]
Line_8 $$ final Map<File, Collection<File>> srcToForms = FORMS_TO_COMPILE.get(context)-->Line_44 $$ for (File srcFile : srcToForms.keySet()) [ FD ]
Line_17 $$ if (JavaBuilderUtil.isCompileJavaIncrementally(context)) -->Line_19 $$ if (logger.isEnabled()) [ CD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_26 $$ classpath.addAll(ProjectPaths.getCompilationClasspath(chunk, false))[ FD ]
Line_3 $$ final JpsProject project = context.getProjectDescriptor().getProject()-->Line_4 $$ final JpsUiDesignerConfiguration config = JpsUiDesignerExtensionService.getInstance().getOrCreateUiDesignerConfiguration(project)[ FD ]
Line_28 $$ final Map<File, String> chunkSourcePath = ProjectPaths.getSourceRootsWithDependents(chunk)-->Line_29 $$ classpath.addAll(chunkSourcePath.keySet())[ FD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_18 $$ final ProjectBuilderLogger logger = context.getLoggingManager().getProjectBuilderLogger()[ FD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_8 $$ final Map<File, Collection<File>> srcToForms = FORMS_TO_COMPILE.get(context)[ FD ]
Line_17 $$ if (JavaBuilderUtil.isCompileJavaIncrementally(context)) -->Line_18 $$ final ProjectBuilderLogger logger = context.getLoggingManager().getProjectBuilderLogger()[ CD ]
Line_32 $$ final Map<File, Collection<File>> processed = instrumentForms(context, chunk, chunkSourcePath, finder, formsToCompile, outputConsumer)-->Line_34 $$ for (Map.Entry<File, Collection<File>> entry : processed.entrySet()) [ FD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_51 $$ context.processMessage(new ProgressMessage("Finished instrumenting forms [" + chunk.getPresentableShortName() + "]"))[ FD ]
Line_25 $$ final List<File> classpath = new ArrayList<File>()-->Line_30 $$ final InstrumentationClassFinder finder = ClassProcessingBuilder.createInstrumentationClassFinder(platformCp, classpath, outputConsumer)[ FD ]
Line_36 $$ final Collection<File> forms = entry.getValue()-->Line_37 $$ final Collection<String> formPaths = new ArrayList<String>(forms.size())[ FD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_9 $$ FORMS_TO_COMPILE.set(context, null)[ CD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_17 $$ if (JavaBuilderUtil.isCompileJavaIncrementally(context)) [ CD ]
Line_19 $$ if (logger.isEnabled()) -->Line_20 $$ logger.logCompiledFiles(formsToCompile, getPresentableName(), "Compiling forms:")[ CD ]
Line_24 $$ final Collection<File> platformCp = ProjectPaths.getPlatformCompilationClasspath(chunk, false)-->Line_30 $$ final InstrumentationClassFinder finder = ClassProcessingBuilder.createInstrumentationClassFinder(platformCp, classpath, outputConsumer)[ FD ]
Line_35 $$ final File src = entry.getKey()-->Line_42 $$ srcToForms.remove(src)[ FD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_3 $$ final JpsProject project = context.getProjectDescriptor().getProject()[ FD ]
Line_14 $$ for (Collection<File> files : srcToForms.values()) -->Line_15 $$ formsToCompile.addAll(files)[ FD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_24 $$ final Collection<File> platformCp = ProjectPaths.getPlatformCompilationClasspath(chunk, false)[ FD ]
Line_2 $$ public ExitCode build(CompileContext context, ModuleChunk chunk, DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder, OutputConsumer outputConsumer) throws ProjectBuildException, IOException -->Line_8 $$ final Map<File, Collection<File>> srcToForms = FORMS_TO_COMPILE.get(context)[ CD ]
Line_30 $$ final InstrumentationClassFinder finder = ClassProcessingBuilder.createInstrumentationClassFinder(platformCp, classpath, outputConsumer)-->Line_48 $$ finder.releaseResources()[ FD ]
Line_37 $$ final Collection<String> formPaths = new ArrayList<String>(forms.size())-->Line_41 $$ sourceToFormMap.update(src.getPath(), formPaths)[ FD ]
Line_33 $$ final OneToManyPathsMapping sourceToFormMap = context.getProjectDescriptor().dataManager.getSourceToFormMap()-->Line_45 $$ sourceToFormMap.remove(srcFile.getPath())[ FD ]
Line_13 $$ final Set<File> formsToCompile = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_20 $$ logger.logCompiledFiles(formsToCompile, getPresentableName(), "Compiling forms:")[ FD ]
