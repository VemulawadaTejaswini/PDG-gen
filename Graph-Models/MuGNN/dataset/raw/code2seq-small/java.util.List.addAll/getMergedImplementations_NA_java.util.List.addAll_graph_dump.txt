Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() -->Line_38 $$ map.addAll((Collection<Object>) o)[ FD ]
Line_39 $$ if (o != null) -->Line_40 $$ map.add(o)[ CD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_4 $$ if (returnType.isInterface()) [ CD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_4 $$ if (returnType.isInterface()) [ FD ]
Line_17 $$ for (int i = 0; i < implementations.size(); i++) -->Line_18 $$ Object t = implementations.get(i)[ FD ]
Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() -->Line_25 $$ addToMaps(o, counts, map, i, results, true, intersect)[ FD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_30 $$ results.add(mergeImplementations(returnType, new ArrayList<Object>(objects)))[ FD ]
Line_21 $$ for (final Object o1 : (Collection) o) -->Line_22 $$ addToMaps(o1, counts, map, i, results, false, intersect)[ FD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_36 $$ final Object o = method.invoke(t, args)[ FD ]
Line_19 $$ final Object o = method.invoke(t, args)-->Line_40 $$ map.add(o)[ FD ]
Line_3 $$ final List<Object> results = new ArrayList<Object>()-->Line_44 $$ results.addAll(map)[ FD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_18 $$ Object t = implementations.get(i)[ FD ]
Line_24 $$ if (o != null) -->Line_25 $$ addToMaps(o, counts, map, i, results, true, intersect)[ CD ]
Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() -->Line_22 $$ addToMaps(o1, counts, map, i, results, false, intersect)[ FD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_46 $$ return results[ CD ]
Line_3 $$ final List<Object> results = new ArrayList<Object>()-->Line_22 $$ addToMaps(o1, counts, map, i, results, false, intersect)[ FD ]
Line_19 $$ final Object o = method.invoke(t, args)-->Line_37 $$ if (o instanceof Collection) [ FD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_14 $$ return new int[implementations.size()][ FD ]
Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() -->Line_29 $$ for (final Set<Object> objects : map.get(primaryKey)) [ FD ]
Line_3 $$ final List<Object> results = new ArrayList<Object>()-->Line_30 $$ results.add(mergeImplementations(returnType, new ArrayList<Object>(objects)))[ FD ]
Line_18 $$ Object t = implementations.get(i)-->Line_36 $$ final Object o = method.invoke(t, args)[ FD ]
Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() -->Line_40 $$ map.add(o)[ FD ]
Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() -->Line_8 $$ orderedPrimaryKeys.add(key)[ CD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_17 $$ for (int i = 0; i < implementations.size(); i++) [ FD ]
Line_17 $$ for (int i = 0; i < implementations.size(); i++) -->Line_19 $$ final Object o = method.invoke(t, args)[ CD ]
Line_4 $$ if (returnType.isInterface()) -->Line_5 $$ final List<Object> orderedPrimaryKeys = new SmartList<Object>()[ CD ]
Line_19 $$ final Object o = method.invoke(t, args)-->Line_20 $$ if (o instanceof Collection) [ FD ]
Line_12 $$ final FactoryMap<Object, int[]> counts = new FactoryMap<Object, int[]>() -->Line_14 $$ return new int[implementations.size()][ CD ]
Line_17 $$ for (int i = 0; i < implementations.size(); i++) -->Line_20 $$ if (o instanceof Collection) [ CD ]
Line_5 $$ final List<Object> orderedPrimaryKeys = new SmartList<Object>()-->Line_8 $$ orderedPrimaryKeys.add(key)[ FD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_25 $$ addToMaps(o, counts, map, i, results, true, intersect)[ FD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_3 $$ final List<Object> results = new ArrayList<Object>()[ CD ]
Line_3 $$ final List<Object> results = new ArrayList<Object>()-->Line_25 $$ addToMaps(o, counts, map, i, results, true, intersect)[ FD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_22 $$ addToMaps(o1, counts, map, i, results, false, intersect)[ FD ]
Line_18 $$ Object t = implementations.get(i)-->Line_19 $$ final Object o = method.invoke(t, args)[ FD ]
Line_17 $$ for (int i = 0; i < implementations.size(); i++) -->Line_18 $$ Object t = implementations.get(i)[ CD ]
Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() -->Line_9 $$ return new SmartList<Set<Object>>()[ CD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_19 $$ final Object o = method.invoke(t, args)[ FD ]
Line_17 $$ for (int i = 0; i < implementations.size(); i++) -->Line_22 $$ addToMaps(o1, counts, map, i, results, false, intersect)[ FD ]
Line_17 $$ for (int i = 0; i < implementations.size(); i++) -->Line_25 $$ addToMaps(o, counts, map, i, results, true, intersect)[ FD ]
Line_19 $$ final Object o = method.invoke(t, args)-->Line_39 $$ if (o != null) [ FD ]
Line_4 $$ if (returnType.isInterface()) -->Line_44 $$ results.addAll(map)[ CD ]
Line_20 $$ if (o instanceof Collection) -->Line_24 $$ if (o != null) [ CD ]
Line_37 $$ if (o instanceof Collection) -->Line_38 $$ map.addAll((Collection<Object>) o)[ CD ]
Line_4 $$ if (returnType.isInterface()) -->Line_17 $$ for (int i = 0; i < implementations.size(); i++) [ CD ]
Line_19 $$ final Object o = method.invoke(t, args)-->Line_25 $$ addToMaps(o, counts, map, i, results, true, intersect)[ FD ]
Line_19 $$ final Object o = method.invoke(t, args)-->Line_24 $$ if (o != null) [ FD ]
Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() -->Line_44 $$ results.addAll(map)[ FD ]
Line_37 $$ if (o instanceof Collection) -->Line_39 $$ if (o != null) [ CD ]
Line_4 $$ if (returnType.isInterface()) -->Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() [ CD ]
Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() -->Line_8 $$ orderedPrimaryKeys.add(key)[ FD ]
