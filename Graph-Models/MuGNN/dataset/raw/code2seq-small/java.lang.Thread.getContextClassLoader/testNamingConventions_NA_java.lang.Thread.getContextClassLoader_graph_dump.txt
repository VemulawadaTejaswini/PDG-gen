Line_11 $$ final String path = "/" + packageName.replace('.', '/')-->Line_12 $$ final Path startPath = getDataPath(path)[ FD ]
Line_23 $$ Class<?> clazz = loadClass(filename)-->Line_33 $$ innerClasses.add(clazz)[ FD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_8 $$ final Set<Class> innerClasses = new HashSet()[ CD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_83 $$ assertNoViolations("Pure Unit-Test found must subclass one of [" + classesToSubclass + "]:\n", pureUnitTest)[ CD ]
Line_23 $$ Class<?> clazz = loadClass(filename)-->Line_43 $$ pureUnitTest.add(clazz)[ FD ]
Line_3 $$ final Set<Class> notImplementing = new HashSet()-->Line_31 $$ notImplementing.add(clazz)[ FD ]
Line_21 $$ String filename = file.getFileName().toString()-->Line_60 $$ pkg.append(filename.substring(0, filename.length() - 6))[ FD ]
Line_7 $$ final Set<Class> notRunnable = new HashSet()-->Line_29 $$ notRunnable.add(clazz)[ FD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_79 $$ String classesToSubclass = String.join(",", ESTestCase.class.getSimpleName(), ESTestCase.class.getSimpleName(), ESTokenStreamTestCase.class.getSimpleName(), LuceneTestCase.class.getSimpleName())[ CD ]
Line_32 $$ if (Modifier.isStatic(clazz.getModifiers())) -->Line_33 $$ innerClasses.add(clazz)[ CD ]
Line_23 $$ Class<?> clazz = loadClass(filename)-->Line_37 $$ notImplementing.add(clazz)[ FD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_74 $$ assertTrue(notRunnable.remove(DummyAbstractTests.class))[ CD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_9 $$ String[] packages = [ CD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_6 $$ final Set<Class> integTestsInDisguise = new HashSet()[ CD ]
Line_23 $$ Class<?> clazz = loadClass(filename)-->Line_40 $$ if (isTestCase(clazz)) [ FD ]
Line_40 $$ if (isTestCase(clazz)) -->Line_41 $$ missingSuffix.add(clazz)[ CD ]
Line_5 $$ final Set<Class> missingSuffix = new HashSet()-->Line_73 $$ assertTrue(missingSuffix.remove(WrongNameTheSecond.class))[ FD ]
Line_23 $$ Class<?> clazz = loadClass(filename)-->Line_53 $$ return LuceneTestCase.class.isAssignableFrom(clazz)[ FD ]
Line_13 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_60 $$ pkg.append(filename.substring(0, filename.length() - 6))[ CD ]
Line_10 $$ for (final String packageName : packages) -->Line_11 $$ final String path = "/" + packageName.replace('.', '/')[ FD ]
Line_23 $$ Class<?> clazz = loadClass(filename)-->Line_25 $$ if (ESIntegTestCase.class.isAssignableFrom(clazz)) [ FD ]
Line_28 $$ if (Modifier.isAbstract(clazz.getModifiers()) || Modifier.isInterface(clazz.getModifiers())) -->Line_30 $$ if (isTestCase(clazz) == false) [ CD ]
Line_30 $$ if (isTestCase(clazz) == false) -->Line_31 $$ notImplementing.add(clazz)[ CD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_4 $$ final Set<Class> pureUnitTest = new HashSet()[ CD ]
Line_8 $$ final Set<Class> innerClasses = new HashSet()-->Line_76 $$ assertTrue(innerClasses.remove(InnerTests.class))[ FD ]
Line_3 $$ final Set<Class> notImplementing = new HashSet()-->Line_84 $$ assertNoViolations("Classes ending with [Tests] must subclass [" + classesToSubclass + "]:\n", notImplementing)[ FD ]
Line_4 $$ final Set<Class> pureUnitTest = new HashSet()-->Line_83 $$ assertNoViolations("Pure Unit-Test found must subclass one of [" + classesToSubclass + "]:\n", pureUnitTest)[ FD ]
Line_6 $$ final Set<Class> integTestsInDisguise = new HashSet()-->Line_85 $$ assertNoViolations("Subclasses of ESIntegTestCase should end with IT as they are integration tests:\n", integTestsInDisguise)[ FD ]
Line_22 $$ if (filename.endsWith(".class")) -->Line_24 $$ if (clazz.getName().endsWith("Tests")) [ CD ]
Line_8 $$ final Set<Class> innerClasses = new HashSet()-->Line_33 $$ innerClasses.add(clazz)[ FD ]
Line_13 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_53 $$ return LuceneTestCase.class.isAssignableFrom(clazz)[ CD ]
Line_3 $$ final Set<Class> notImplementing = new HashSet()-->Line_37 $$ notImplementing.add(clazz)[ FD ]
Line_56 $$ StringBuilder pkg = new StringBuilder()-->Line_58 $$ pkg.append(p.getFileName().toString()).append(".")[ FD ]
Line_13 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_67 $$ pkgPrefix = pkgPrefix.getParent()[ CD ]
Line_23 $$ Class<?> clazz = loadClass(filename)-->Line_41 $$ missingSuffix.add(clazz)[ FD ]
Line_5 $$ final Set<Class> missingSuffix = new HashSet()-->Line_72 $$ assertTrue(missingSuffix.remove(WrongName.class))[ FD ]
Line_13 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_16 $$ pkgPrefix = pkgPrefix.resolve(dir.getFileName())[ CD ]
Line_13 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_17 $$ return FileVisitResult.CONTINUE[ CD ]
Line_57 $$ for (Path p : pkgPrefix) -->Line_58 $$ pkg.append(p.getFileName().toString()).append(".")[ FD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_75 $$ assertTrue(notRunnable.remove(DummyInterfaceTests.class))[ CD ]
Line_6 $$ final Set<Class> integTestsInDisguise = new HashSet()-->Line_26 $$ integTestsInDisguise.add(clazz)[ FD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_77 $$ assertTrue(notImplementing.remove(NotImplementingTests.class))[ CD ]
Line_23 $$ Class<?> clazz = loadClass(filename)-->Line_32 $$ if (Modifier.isStatic(clazz.getModifiers())) [ FD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_76 $$ assertTrue(innerClasses.remove(InnerTests.class))[ CD ]
Line_7 $$ final Set<Class> notRunnable = new HashSet()-->Line_81 $$ assertNoViolations("Classes ending with [Tests] are abstract or interfaces:\n", notRunnable)[ FD ]
Line_4 $$ final Set<Class> pureUnitTest = new HashSet()-->Line_43 $$ pureUnitTest.add(clazz)[ FD ]
Line_4 $$ final Set<Class> pureUnitTest = new HashSet()-->Line_78 $$ assertTrue(pureUnitTest.remove(PlainUnit.class))[ FD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_82 $$ assertNoViolations("Found inner classes that are tests, which are excluded from the test runner:\n", innerClasses)[ CD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_3 $$ final Set<Class> notImplementing = new HashSet()[ CD ]
Line_7 $$ final Set<Class> notRunnable = new HashSet()-->Line_75 $$ assertTrue(notRunnable.remove(DummyInterfaceTests.class))[ FD ]
Line_35 $$ if (clazz.getName().endsWith("IT")) -->Line_36 $$ if (isTestCase(clazz) == false) [ CD ]
Line_36 $$ if (isTestCase(clazz) == false) -->Line_37 $$ notImplementing.add(clazz)[ CD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_7 $$ final Set<Class> notRunnable = new HashSet()[ CD ]
Line_23 $$ Class<?> clazz = loadClass(filename)-->Line_30 $$ if (isTestCase(clazz) == false) [ FD ]
Line_13 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_60 $$ pkg.append(filename.substring(0, filename.length() - 6))[ FD ]
Line_23 $$ Class<?> clazz = loadClass(filename)-->Line_28 $$ if (Modifier.isAbstract(clazz.getModifiers()) || Modifier.isInterface(clazz.getModifiers())) [ FD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_72 $$ assertTrue(missingSuffix.remove(WrongName.class))[ CD ]
Line_21 $$ String filename = file.getFileName().toString()-->Line_22 $$ if (filename.endsWith(".class")) [ FD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_84 $$ assertNoViolations("Classes ending with [Tests] must subclass [" + classesToSubclass + "]:\n", notImplementing)[ CD ]
Line_5 $$ final Set<Class> missingSuffix = new HashSet()-->Line_41 $$ missingSuffix.add(clazz)[ FD ]
Line_56 $$ StringBuilder pkg = new StringBuilder()-->Line_60 $$ pkg.append(filename.substring(0, filename.length() - 6))[ FD ]
Line_11 $$ final String path = "/" + packageName.replace('.', '/')-->Line_13 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() [ FD ]
Line_23 $$ Class<?> clazz = loadClass(filename)-->Line_42 $$ if (junit.framework.Test.class.isAssignableFrom(clazz)) [ FD ]
Line_13 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_68 $$ return FileVisitResult.CONTINUE[ CD ]
Line_21 $$ String filename = file.getFileName().toString()-->Line_23 $$ Class<?> clazz = loadClass(filename)[ FD ]
Line_13 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_50 $$ return FileVisitResult.CONTINUE[ CD ]
Line_28 $$ if (Modifier.isAbstract(clazz.getModifiers()) || Modifier.isInterface(clazz.getModifiers())) -->Line_29 $$ notRunnable.add(clazz)[ CD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_81 $$ assertNoViolations("Classes ending with [Tests] are abstract or interfaces:\n", notRunnable)[ CD ]
Line_23 $$ Class<?> clazz = loadClass(filename)-->Line_39 $$ if (Modifier.isAbstract(clazz.getModifiers()) == false && Modifier.isInterface(clazz.getModifiers()) == false) [ FD ]
Line_25 $$ if (ESIntegTestCase.class.isAssignableFrom(clazz)) -->Line_26 $$ integTestsInDisguise.add(clazz)[ CD ]
Line_23 $$ Class<?> clazz = loadClass(filename)-->Line_35 $$ if (clazz.getName().endsWith("IT")) [ FD ]
Line_13 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_53 $$ return LuceneTestCase.class.isAssignableFrom(clazz)[ FD ]
Line_23 $$ Class<?> clazz = loadClass(filename)-->Line_29 $$ notRunnable.add(clazz)[ FD ]
Line_8 $$ final Set<Class> innerClasses = new HashSet()-->Line_82 $$ assertNoViolations("Found inner classes that are tests, which are excluded from the test runner:\n", innerClasses)[ FD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_85 $$ assertNoViolations("Subclasses of ESIntegTestCase should end with IT as they are integration tests:\n", integTestsInDisguise)[ CD ]
Line_23 $$ Class<?> clazz = loadClass(filename)-->Line_24 $$ if (clazz.getName().endsWith("Tests")) [ FD ]
Line_3 $$ final Set<Class> notImplementing = new HashSet()-->Line_77 $$ assertTrue(notImplementing.remove(NotImplementingTests.class))[ FD ]
Line_40 $$ if (isTestCase(clazz)) -->Line_42 $$ if (junit.framework.Test.class.isAssignableFrom(clazz)) [ CD ]
Line_22 $$ if (filename.endsWith(".class")) -->Line_23 $$ Class<?> clazz = loadClass(filename)[ CD ]
Line_23 $$ Class<?> clazz = loadClass(filename)-->Line_31 $$ notImplementing.add(clazz)[ FD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_5 $$ final Set<Class> missingSuffix = new HashSet()[ CD ]
Line_23 $$ Class<?> clazz = loadClass(filename)-->Line_26 $$ integTestsInDisguise.add(clazz)[ FD ]
Line_12 $$ final Path startPath = getDataPath(path)-->Line_13 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() [ FD ]
Line_35 $$ if (clazz.getName().endsWith("IT")) -->Line_39 $$ if (Modifier.isAbstract(clazz.getModifiers()) == false && Modifier.isInterface(clazz.getModifiers()) == false) [ CD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_78 $$ assertTrue(pureUnitTest.remove(PlainUnit.class))[ CD ]
Line_13 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_21 $$ String filename = file.getFileName().toString()[ FD ]
Line_24 $$ if (clazz.getName().endsWith("Tests")) -->Line_28 $$ if (Modifier.isAbstract(clazz.getModifiers()) || Modifier.isInterface(clazz.getModifiers())) [ CD ]
Line_30 $$ if (isTestCase(clazz) == false) -->Line_32 $$ if (Modifier.isStatic(clazz.getModifiers())) [ CD ]
Line_13 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_56 $$ StringBuilder pkg = new StringBuilder()[ CD ]
Line_5 $$ final Set<Class> missingSuffix = new HashSet()-->Line_80 $$ assertNoViolations("Not all subclasses of " + ESTestCase.class.getSimpleName() + " match the naming convention. Concrete classes must end with [Tests]:\n", missingSuffix)[ FD ]
Line_24 $$ if (clazz.getName().endsWith("Tests")) -->Line_35 $$ if (clazz.getName().endsWith("IT")) [ CD ]
Line_56 $$ StringBuilder pkg = new StringBuilder()-->Line_61 $$ return Thread.currentThread().getContextClassLoader().loadClass(pkg.toString())[ FD ]
Line_42 $$ if (junit.framework.Test.class.isAssignableFrom(clazz)) -->Line_43 $$ pureUnitTest.add(clazz)[ CD ]
Line_24 $$ if (clazz.getName().endsWith("Tests")) -->Line_25 $$ if (ESIntegTestCase.class.isAssignableFrom(clazz)) [ CD ]
Line_7 $$ final Set<Class> notRunnable = new HashSet()-->Line_74 $$ assertTrue(notRunnable.remove(DummyAbstractTests.class))[ FD ]
Line_13 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_61 $$ return Thread.currentThread().getContextClassLoader().loadClass(pkg.toString())[ CD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_80 $$ assertNoViolations("Not all subclasses of " + ESTestCase.class.getSimpleName() + " match the naming convention. Concrete classes must end with [Tests]:\n", missingSuffix)[ CD ]
Line_13 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_16 $$ pkgPrefix = pkgPrefix.resolve(dir.getFileName())[ FD ]
Line_2 $$ public void testNamingConventions() throws ClassNotFoundException, IOException, URISyntaxException -->Line_73 $$ assertTrue(missingSuffix.remove(WrongNameTheSecond.class))[ CD ]
Line_23 $$ Class<?> clazz = loadClass(filename)-->Line_36 $$ if (isTestCase(clazz) == false) [ FD ]
Line_39 $$ if (Modifier.isAbstract(clazz.getModifiers()) == false && Modifier.isInterface(clazz.getModifiers()) == false) -->Line_40 $$ if (isTestCase(clazz)) [ CD ]
