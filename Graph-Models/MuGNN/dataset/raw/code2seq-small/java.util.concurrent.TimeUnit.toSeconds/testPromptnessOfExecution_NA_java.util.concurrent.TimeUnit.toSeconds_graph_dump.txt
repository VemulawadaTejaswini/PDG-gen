Line_41 $$ while (!pending.isEmpty() && timeout > System.nanoTime()) -->Line_49 $$ if (!complete && System.nanoTime() > first.timeout) [ CD ]
Line_77 $$ if (baseTime == 0)-->Line_78 $$ time = (long) (workTime.sample() * multiplier)[ CD ]
Line_24 $$ for (float multiplier = 0f; multiplier < 2.01f; ) -->Line_94 $$ pending.add(new Batch(results, end, executorIndex))[ CD ]
Line_24 $$ for (float multiplier = 0f; multiplier < 2.01f; ) -->Line_71 $$ if (Math.random() > 0.5)[ CD ]
Line_24 $$ for (float multiplier = 0f; multiplier < 2.01f; ) -->Line_75 $$ for (int j = 0; j < count; j++) [ CD ]
Line_49 $$ if (!complete && System.nanoTime() > first.timeout) -->Line_52 $$ complete = true[ CD ]
Line_20 $$ long events = 0-->Line_27 $$ events = 0[ FD ]
Line_37 $$ if (pending.size() == executorCount)-->Line_38 $$ timeout = pending.first().timeout[ CD ]
Line_81 $$ if (time < minWorkTime)-->Line_82 $$ time = minWorkTime[ CD ]
Line_34 $$ timeout = 0-->Line_36 $$ timeout = Long.MAX_VALUE[ FD ]
Line_75 $$ for (int j = 0; j < count; j++) -->Line_76 $$ long time[ CD ]
Line_80 $$ time = (long) (baseTime * Math.random())-->Line_81 $$ if (time < minWorkTime)[ FD ]
Line_32 $$ long timeout-->Line_34 $$ timeout = 0[ FD ]
Line_25 $$ if (System.nanoTime() > until) -->Line_26 $$ System.out.println(String.format("Completed %.0fK batches with %.1fM events", runs * 0.001f, events * 0.000001f))[ CD ]
Line_84 $$ time = maxWorkTime-->Line_83 $$ if (time > maxWorkTime)[ FD ]
Line_2 $$ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement) throws InterruptedException, ExecutionException -->Line_29 $$ multiplier += loadIncrement[ FD ]
Line_75 $$ for (int j = 0; j < count; j++) -->Line_86 $$ Future<?> future = executor.submit(new WaitTask(time))[ CD ]
Line_76 $$ long time-->Line_80 $$ time = (long) (baseTime * Math.random())[ FD ]
Line_2 $$ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement) throws InterruptedException, ExecutionException -->Line_10 $$ final WeibullDistribution[] workCount = new WeibullDistribution[executorCount][ CD ]
Line_22 $$ final BitSet executorsWithWork = new BitSet(executorCount)-->Line_61 $$ int executorIndex = executorsWithWork.nextClearBit(0)[ FD ]
Line_2 $$ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement) throws InterruptedException, ExecutionException -->Line_12 $$ for (int i = 0; i < executors.length; i++) [ CD ]
Line_34 $$ timeout = 0-->Line_38 $$ timeout = pending.first().timeout[ FD ]
Line_4 $$ int threadCount = 8-->Line_14 $$ threadCounts[i] = threadCount[ FD ]
Line_2 $$ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement) throws InterruptedException, ExecutionException -->Line_20 $$ long events = 0[ CD ]
Line_76 $$ long time-->Line_83 $$ if (time > maxWorkTime)[ FD ]
Line_75 $$ for (int j = 0; j < count; j++) -->Line_81 $$ if (time < minWorkTime)[ CD ]
Line_54 $$ if (complete) -->Line_55 $$ pending.pollFirst()[ CD ]
Line_80 $$ time = (long) (baseTime * Math.random())-->Line_82 $$ time = minWorkTime[ FD ]
Line_24 $$ for (float multiplier = 0f; multiplier < 2.01f; ) -->Line_93 $$ events += results.size()[ CD ]
Line_21 $$ final TreeSet<Batch> pending = new TreeSet()-->Line_94 $$ pending.add(new Batch(results, end, executorIndex))[ FD ]
Line_2 $$ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement) throws InterruptedException, ExecutionException -->Line_30 $$ System.out.println(String.format("Running for %ds with load multiplier %.1f", TimeUnit.NANOSECONDS.toSeconds(intervalNanos), multiplier))[ FD ]
Line_25 $$ if (System.nanoTime() > until) -->Line_29 $$ multiplier += loadIncrement[ CD ]
Line_46 $$ complete = true-->Line_52 $$ complete = true[ FD ]
Line_7 $$ final long minWorkTime = TimeUnit.MICROSECONDS.toNanos(1)-->Line_81 $$ if (time < minWorkTime)[ FD ]
Line_27 $$ events = 0-->Line_93 $$ events += results.size()[ FD ]
Line_8 $$ final long maxWorkTime = TimeUnit.MILLISECONDS.toNanos(1)-->Line_84 $$ time = maxWorkTime[ FD ]
Line_5 $$ int maxQueued = 1024-->Line_17 $$ maxQueued *= 2[ FD ]
Line_84 $$ time = maxWorkTime-->Line_81 $$ if (time < minWorkTime)[ FD ]
Line_83 $$ if (time > maxWorkTime)-->Line_84 $$ time = maxWorkTime[ CD ]
Line_4 $$ int threadCount = 8-->Line_16 $$ threadCount *= 2[ FD ]
Line_32 $$ long timeout-->Line_40 $$ timeout = (long) (Math.random() * pending.last().timeout)[ FD ]
Line_77 $$ if (baseTime == 0)-->Line_80 $$ time = (long) (baseTime * Math.random())[ CD ]
Line_21 $$ final TreeSet<Batch> pending = new TreeSet()-->Line_33 $$ if (pending.isEmpty())[ FD ]
Line_2 $$ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement) throws InterruptedException, ExecutionException -->Line_9 $$ final int[] threadCounts = new int[executorCount][ CD ]
Line_32 $$ long timeout-->Line_59 $$ if (timeout == Long.MAX_VALUE)[ FD ]
Line_19 $$ long runs = 0-->Line_91 $$ if (runs++ > executorCount && now > end)[ FD ]
Line_78 $$ time = (long) (workTime.sample() * multiplier)-->Line_81 $$ if (time < minWorkTime)[ FD ]
Line_76 $$ long time-->Line_81 $$ if (time < minWorkTime)[ FD ]
Line_34 $$ timeout = 0-->Line_40 $$ timeout = (long) (Math.random() * pending.last().timeout)[ FD ]
Line_22 $$ final BitSet executorsWithWork = new BitSet(executorCount)-->Line_56 $$ executorsWithWork.clear(first.executorIndex)[ FD ]
Line_20 $$ long events = 0-->Line_93 $$ events += results.size()[ FD ]
Line_17 $$ maxQueued *= 2-->Line_13 $$ executors[i] = SharedExecutorPool.SHARED.newExecutor(threadCount, maxQueued, "test" + i, "test" + i)[ FD ]
Line_16 $$ threadCount *= 2-->Line_13 $$ executors[i] = SharedExecutorPool.SHARED.newExecutor(threadCount, maxQueued, "test" + i, "test" + i)[ FD ]
Line_43 $$ boolean complete = false-->Line_46 $$ complete = true[ FD ]
Line_25 $$ if (System.nanoTime() > until) -->Line_27 $$ events = 0[ CD ]
Line_76 $$ long time-->Line_78 $$ time = (long) (workTime.sample() * multiplier)[ FD ]
Line_12 $$ for (int i = 0; i < executors.length; i++) -->Line_17 $$ maxQueued *= 2[ CD ]
Line_2 $$ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement) throws InterruptedException, ExecutionException -->Line_22 $$ final BitSet executorsWithWork = new BitSet(executorCount)[ CD ]
Line_16 $$ threadCount *= 2-->Line_14 $$ threadCounts[i] = threadCount[ FD ]
Line_2 $$ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement) throws InterruptedException, ExecutionException -->Line_6 $$ final WeibullDistribution workTime = new WeibullDistribution(3, 200000)[ CD ]
Line_34 $$ timeout = 0-->Line_59 $$ if (timeout == Long.MAX_VALUE)[ FD ]
Line_78 $$ time = (long) (workTime.sample() * multiplier)-->Line_83 $$ if (time > maxWorkTime)[ FD ]
Line_37 $$ if (pending.size() == executorCount)-->Line_40 $$ timeout = (long) (Math.random() * pending.last().timeout)[ CD ]
Line_36 $$ timeout = Long.MAX_VALUE-->Line_59 $$ if (timeout == Long.MAX_VALUE)[ FD ]
Line_35 $$ if (Math.random() > 0.98)-->Line_36 $$ timeout = Long.MAX_VALUE[ CD ]
Line_12 $$ for (int i = 0; i < executors.length; i++) -->Line_15 $$ workCount[i] = new WeibullDistribution(2, maxQueued)[ CD ]
Line_3 $$ final int executorCount = 4-->Line_37 $$ if (pending.size() == executorCount)[ FD ]
Line_24 $$ for (float multiplier = 0f; multiplier < 2.01f; ) -->Line_59 $$ if (timeout == Long.MAX_VALUE)[ CD ]
Line_23 $$ long until = 0-->Line_28 $$ until = System.nanoTime() + intervalNanos[ FD ]
Line_75 $$ for (int j = 0; j < count; j++) -->Line_77 $$ if (baseTime == 0)[ CD ]
Line_38 $$ timeout = pending.first().timeout-->Line_40 $$ timeout = (long) (Math.random() * pending.last().timeout)[ FD ]
Line_75 $$ for (int j = 0; j < count; j++) -->Line_87 $$ results.add(new Result(future, System.nanoTime() + time))[ CD ]
Line_21 $$ final TreeSet<Batch> pending = new TreeSet()-->Line_42 $$ Batch first = pending.first()[ FD ]
Line_3 $$ final int executorCount = 4-->Line_62 $$ if (executorIndex >= executorCount)[ FD ]
Line_2 $$ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement) throws InterruptedException, ExecutionException -->Line_19 $$ long runs = 0[ CD ]
Line_78 $$ time = (long) (workTime.sample() * multiplier)-->Line_80 $$ time = (long) (baseTime * Math.random())[ FD ]
Line_21 $$ final TreeSet<Batch> pending = new TreeSet()-->Line_55 $$ pending.pollFirst()[ FD ]
Line_25 $$ if (System.nanoTime() > until) -->Line_28 $$ until = System.nanoTime() + intervalNanos[ CD ]
Line_2 $$ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement) throws InterruptedException, ExecutionException -->Line_21 $$ final TreeSet<Batch> pending = new TreeSet()[ CD ]
Line_36 $$ timeout = Long.MAX_VALUE-->Line_38 $$ timeout = pending.first().timeout[ FD ]
Line_24 $$ for (float multiplier = 0f; multiplier < 2.01f; ) -->Line_29 $$ multiplier += loadIncrement[ FD ]
Line_75 $$ for (int j = 0; j < count; j++) -->Line_83 $$ if (time > maxWorkTime)[ CD ]
Line_24 $$ for (float multiplier = 0f; multiplier < 2.01f; ) -->Line_61 $$ int executorIndex = executorsWithWork.nextClearBit(0)[ CD ]
Line_12 $$ for (int i = 0; i < executors.length; i++) -->Line_16 $$ threadCount *= 2[ CD ]
Line_24 $$ for (float multiplier = 0f; multiplier < 2.01f; ) -->Line_30 $$ System.out.println(String.format("Running for %ds with load multiplier %.1f", TimeUnit.NANOSECONDS.toSeconds(intervalNanos), multiplier))[ FD ]
Line_32 $$ long timeout-->Line_38 $$ timeout = pending.first().timeout[ FD ]
Line_2 $$ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement) throws InterruptedException, ExecutionException -->Line_7 $$ final long minWorkTime = TimeUnit.MICROSECONDS.toNanos(1)[ CD ]
Line_25 $$ if (System.nanoTime() > until) -->Line_30 $$ System.out.println(String.format("Running for %ds with load multiplier %.1f", TimeUnit.NANOSECONDS.toSeconds(intervalNanos), multiplier))[ CD ]
Line_4 $$ int threadCount = 8-->Line_13 $$ executors[i] = SharedExecutorPool.SHARED.newExecutor(threadCount, maxQueued, "test" + i, "test" + i)[ FD ]
Line_22 $$ final BitSet executorsWithWork = new BitSet(executorCount)-->Line_64 $$ executorsWithWork.set(executorIndex)[ FD ]
Line_24 $$ for (float multiplier = 0f; multiplier < 2.01f; ) -->Line_25 $$ if (System.nanoTime() > until) [ CD ]
Line_2 $$ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement) throws InterruptedException, ExecutionException -->Line_28 $$ until = System.nanoTime() + intervalNanos[ FD ]
Line_35 $$ if (Math.random() > 0.98)-->Line_37 $$ if (pending.size() == executorCount)[ CD ]
Line_21 $$ final TreeSet<Batch> pending = new TreeSet()-->Line_41 $$ while (!pending.isEmpty() && timeout > System.nanoTime()) [ FD ]
Line_82 $$ time = minWorkTime-->Line_81 $$ if (time < minWorkTime)[ FD ]
Line_78 $$ time = (long) (workTime.sample() * multiplier)-->Line_82 $$ time = minWorkTime[ FD ]
Line_21 $$ final TreeSet<Batch> pending = new TreeSet()-->Line_37 $$ if (pending.size() == executorCount)[ FD ]
Line_36 $$ timeout = Long.MAX_VALUE-->Line_40 $$ timeout = (long) (Math.random() * pending.last().timeout)[ FD ]
Line_29 $$ multiplier += loadIncrement-->Line_24 $$ for (float multiplier = 0f; multiplier < 2.01f; ) [ FD ]
Line_12 $$ for (int i = 0; i < executors.length; i++) -->Line_14 $$ threadCounts[i] = threadCount[ CD ]
Line_33 $$ if (pending.isEmpty())-->Line_34 $$ timeout = 0[ CD ]
Line_76 $$ long time-->Line_84 $$ time = maxWorkTime[ FD ]
Line_41 $$ while (!pending.isEmpty() && timeout > System.nanoTime()) -->Line_42 $$ Batch first = pending.first()[ CD ]
Line_29 $$ multiplier += loadIncrement-->Line_30 $$ System.out.println(String.format("Running for %ds with load multiplier %.1f", TimeUnit.NANOSECONDS.toSeconds(intervalNanos), multiplier))[ FD ]
Line_7 $$ final long minWorkTime = TimeUnit.MICROSECONDS.toNanos(1)-->Line_82 $$ time = minWorkTime[ FD ]
Line_8 $$ final long maxWorkTime = TimeUnit.MILLISECONDS.toNanos(1)-->Line_83 $$ if (time > maxWorkTime)[ FD ]
Line_24 $$ for (float multiplier = 0f; multiplier < 2.01f; ) -->Line_64 $$ executorsWithWork.set(executorIndex)[ CD ]
Line_43 $$ boolean complete = false-->Line_52 $$ complete = true[ FD ]
Line_24 $$ for (float multiplier = 0f; multiplier < 2.01f; ) -->Line_69 $$ long start = System.nanoTime()[ CD ]
Line_40 $$ timeout = (long) (Math.random() * pending.last().timeout)-->Line_59 $$ if (timeout == Long.MAX_VALUE)[ FD ]
Line_24 $$ for (float multiplier = 0f; multiplier < 2.01f; ) -->Line_33 $$ if (pending.isEmpty())[ CD ]
Line_24 $$ for (float multiplier = 0f; multiplier < 2.01f; ) -->Line_90 $$ long now = System.nanoTime()[ CD ]
Line_24 $$ for (float multiplier = 0f; multiplier < 2.01f; ) -->Line_62 $$ if (executorIndex >= executorCount)[ CD ]
Line_76 $$ long time-->Line_82 $$ time = minWorkTime[ FD ]
Line_24 $$ for (float multiplier = 0f; multiplier < 2.01f; ) -->Line_41 $$ while (!pending.isEmpty() && timeout > System.nanoTime()) [ CD ]
Line_28 $$ until = System.nanoTime() + intervalNanos-->Line_25 $$ if (System.nanoTime() > until) [ FD ]
Line_43 $$ boolean complete = false-->Line_49 $$ if (!complete && System.nanoTime() > first.timeout) [ FD ]
Line_41 $$ while (!pending.isEmpty() && timeout > System.nanoTime()) -->Line_43 $$ boolean complete = false[ CD ]
Line_46 $$ complete = true-->Line_49 $$ if (!complete && System.nanoTime() > first.timeout) [ FD ]
Line_52 $$ complete = true-->Line_49 $$ if (!complete && System.nanoTime() > first.timeout) [ FD ]
Line_78 $$ time = (long) (workTime.sample() * multiplier)-->Line_84 $$ time = maxWorkTime[ FD ]
Line_23 $$ long until = 0-->Line_25 $$ if (System.nanoTime() > until) [ FD ]
Line_41 $$ while (!pending.isEmpty() && timeout > System.nanoTime()) -->Line_54 $$ if (complete) [ CD ]
Line_54 $$ if (complete) -->Line_56 $$ executorsWithWork.clear(first.executorIndex)[ CD ]
Line_12 $$ for (int i = 0; i < executors.length; i++) -->Line_13 $$ executors[i] = SharedExecutorPool.SHARED.newExecutor(threadCount, maxQueued, "test" + i, "test" + i)[ CD ]
Line_82 $$ time = minWorkTime-->Line_84 $$ time = maxWorkTime[ FD ]
Line_21 $$ final TreeSet<Batch> pending = new TreeSet()-->Line_40 $$ timeout = (long) (Math.random() * pending.last().timeout)[ FD ]
Line_2 $$ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement) throws InterruptedException, ExecutionException -->Line_11 $$ final ExecutorService[] executors = new ExecutorService[executorCount][ CD ]
Line_24 $$ for (float multiplier = 0f; multiplier < 2.01f; ) -->Line_91 $$ if (runs++ > executorCount && now > end)[ CD ]
Line_2 $$ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement) throws InterruptedException, ExecutionException -->Line_4 $$ int threadCount = 8[ CD ]
Line_2 $$ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement) throws InterruptedException, ExecutionException -->Line_3 $$ final int executorCount = 4[ CD ]
Line_80 $$ time = (long) (baseTime * Math.random())-->Line_84 $$ time = maxWorkTime[ FD ]
Line_33 $$ if (pending.isEmpty())-->Line_35 $$ if (Math.random() > 0.98)[ CD ]
Line_32 $$ long timeout-->Line_36 $$ timeout = Long.MAX_VALUE[ FD ]
Line_5 $$ int maxQueued = 1024-->Line_13 $$ executors[i] = SharedExecutorPool.SHARED.newExecutor(threadCount, maxQueued, "test" + i, "test" + i)[ FD ]
Line_2 $$ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement) throws InterruptedException, ExecutionException -->Line_24 $$ for (float multiplier = 0f; multiplier < 2.01f; ) [ CD ]
Line_21 $$ final TreeSet<Batch> pending = new TreeSet()-->Line_38 $$ timeout = pending.first().timeout[ FD ]
Line_6 $$ final WeibullDistribution workTime = new WeibullDistribution(3, 200000)-->Line_78 $$ time = (long) (workTime.sample() * multiplier)[ FD ]
Line_24 $$ for (float multiplier = 0f; multiplier < 2.01f; ) -->Line_32 $$ long timeout[ CD ]
Line_80 $$ time = (long) (baseTime * Math.random())-->Line_83 $$ if (time > maxWorkTime)[ FD ]
Line_6 $$ final WeibullDistribution workTime = new WeibullDistribution(3, 200000)-->Line_72 $$ baseTime = 2 * (long) (workTime.sample() * multiplier)[ FD ]
Line_2 $$ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement) throws InterruptedException, ExecutionException -->Line_23 $$ long until = 0[ CD ]
Line_38 $$ timeout = pending.first().timeout-->Line_59 $$ if (timeout == Long.MAX_VALUE)[ FD ]
Line_2 $$ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement) throws InterruptedException, ExecutionException -->Line_8 $$ final long maxWorkTime = TimeUnit.MILLISECONDS.toNanos(1)[ CD ]
Line_2 $$ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement) throws InterruptedException, ExecutionException -->Line_5 $$ int maxQueued = 1024[ CD ]
Line_82 $$ time = minWorkTime-->Line_83 $$ if (time > maxWorkTime)[ FD ]
Line_59 $$ if (timeout == Long.MAX_VALUE)-->Line_60 $$ Uninterruptibles.sleepUninterruptibly(10, TimeUnit.MILLISECONDS)[ CD ]
