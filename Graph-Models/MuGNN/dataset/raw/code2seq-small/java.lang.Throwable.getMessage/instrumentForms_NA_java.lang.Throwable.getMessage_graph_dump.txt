Line_6 $$ for (File formFile : forms) -->Line_9 $$ rootContainer = Utils.getRootContainer(formFile.toURI().toURL(), new CompiledClassPropertiesProvider(finder.getLoader()))[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_13 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, e.getMessage(), formFile.getPath()))[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_40 $$ context.processMessage(new ProgressMessage("Instrumenting forms... [" + chunk.getPresentableShortName() + "]"))[ FD ]
Line_56 $$ StringBuilder message = new StringBuilder()-->Line_58 $$ if (message.length() > 0) [ FD ]
Line_7 $$ final LwRootContainer rootContainer-->Line_9 $$ rootContainer = Utils.getRootContainer(formFile.toURI().toURL(), new CompiledClassPropertiesProvider(finder.getLoader()))[ FD ]
Line_28 $$ if (compiled == null) -->Line_29 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, "Class to bind does not exist: " + classToBind, formFile.getAbsolutePath()))[ CD ]
Line_6 $$ for (File formFile : forms) -->Line_29 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, "Class to bind does not exist: " + classToBind, formFile.getAbsolutePath()))[ FD ]
Line_23 $$ final String classToBind = rootContainer.getClassToBind()-->Line_37 $$ class2form.put(classToBind, formFile)[ FD ]
Line_4 $$ final Map<String, File> class2form = new HashMap<String, File>()-->Line_32 $$ final File alreadyProcessedForm = class2form.get(classToBind)[ FD ]
Line_27 $$ final CompiledClass compiled = findClassFile(outConsumer, classToBind)-->Line_48 $$ compiled.setContent(new BinaryContent(patchedBytes))[ FD ]
Line_41 $$ final BinaryContent originalContent = compiled.getContent()-->Line_42 $$ final ClassReader classReader = new FailSafeClassReader(originalContent.getBuffer(), originalContent.getOffset(), originalContent.getLength())[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_27 $$ final CompiledClass compiled = findClassFile(outConsumer, classToBind)[ FD ]
Line_6 $$ for (File formFile : forms) -->Line_66 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, "Forms instrumentation failed" + e.getMessage(), formFile.getAbsolutePath()))[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_3 $$ final Map<File, Collection<File>> instrumented = new THashMap<File, Collection<File>>(FileUtil.FILE_HASHING_STRATEGY)[ CD ]
Line_4 $$ final Map<String, File> class2form = new HashMap<String, File>()-->Line_37 $$ class2form.put(classToBind, formFile)[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_29 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, "Class to bind does not exist: " + classToBind, formFile.getAbsolutePath()))[ FD ]
Line_27 $$ final CompiledClass compiled = findClassFile(outConsumer, classToBind)-->Line_28 $$ if (compiled == null) [ FD ]
Line_6 $$ for (File formFile : forms) -->Line_52 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, warning.getErrorMessage(), formFile.getAbsolutePath()))[ FD ]
Line_23 $$ final String classToBind = rootContainer.getClassToBind()-->Line_24 $$ if (classToBind == null) [ FD ]
Line_6 $$ for (File formFile : forms) -->Line_37 $$ class2form.put(classToBind, formFile)[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_17 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, e.getMessage(), formFile.getPath()))[ FD ]
Line_43 $$ final int version = ClassProcessingBuilder.getClassFileVersion(classReader)-->Line_44 $$ final InstrumenterClassWriter classWriter = new InstrumenterClassWriter(classReader, ClassProcessingBuilder.getAsmClassWriterFlags(version), finder)[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_34 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, formFile.getAbsolutePath() + ": The form is bound to the class " + classToBind + ".\nAnother form " + alreadyProcessedForm.getAbsolutePath() + " is also bound to this class", formFile.getAbsolutePath()))[ FD ]
Line_27 $$ final CompiledClass compiled = findClassFile(outConsumer, classToBind)-->Line_41 $$ final BinaryContent originalContent = compiled.getContent()[ FD ]
Line_58 $$ if (message.length() > 0) -->Line_59 $$ message.append("\n")[ CD ]
Line_57 $$ for (final FormErrorInfo error : errors) -->Line_61 $$ message.append(formFile.getAbsolutePath()).append(": ").append(error.getErrorMessage())[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_63 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, message.toString()))[ FD ]
Line_9 $$ rootContainer = Utils.getRootContainer(formFile.toURI().toURL(), new CompiledClassPropertiesProvider(finder.getLoader()))-->Line_23 $$ final String classToBind = rootContainer.getClassToBind()[ FD ]
Line_33 $$ if (alreadyProcessedForm != null) -->Line_34 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, formFile.getAbsolutePath() + ": The form is bound to the class " + classToBind + ".\nAnother form " + alreadyProcessedForm.getAbsolutePath() + " is also bound to this class", formFile.getAbsolutePath()))[ CD ]
Line_51 $$ for (final FormErrorInfo warning : warnings) -->Line_52 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, warning.getErrorMessage(), formFile.getAbsolutePath()))[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_66 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, "Forms instrumentation failed" + e.getMessage(), formFile.getAbsolutePath()))[ FD ]
Line_42 $$ final ClassReader classReader = new FailSafeClassReader(originalContent.getBuffer(), originalContent.getOffset(), originalContent.getLength())-->Line_43 $$ final int version = ClassProcessingBuilder.getClassFileVersion(classReader)[ FD ]
Line_47 $$ if (patchedBytes != null) -->Line_48 $$ compiled.setContent(new BinaryContent(patchedBytes))[ CD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_4 $$ final Map<String, File> class2form = new HashMap<String, File>()[ CD ]
Line_23 $$ final String classToBind = rootContainer.getClassToBind()-->Line_27 $$ final CompiledClass compiled = findClassFile(outConsumer, classToBind)[ FD ]
Line_56 $$ StringBuilder message = new StringBuilder()-->Line_61 $$ message.append(formFile.getAbsolutePath()).append(": ").append(error.getErrorMessage())[ FD ]
Line_56 $$ StringBuilder message = new StringBuilder()-->Line_59 $$ message.append("\n")[ FD ]
Line_32 $$ final File alreadyProcessedForm = class2form.get(classToBind)-->Line_33 $$ if (alreadyProcessedForm != null) [ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_52 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, warning.getErrorMessage(), formFile.getAbsolutePath()))[ FD ]
Line_6 $$ for (File formFile : forms) -->Line_21 $$ throw new ProjectBuildException("Cannot process form file " + formFile.getAbsolutePath(), e)[ FD ]
Line_45 $$ final AsmCodeGenerator codeGenerator = new AsmCodeGenerator(rootContainer, finder, nestedFormsLoader, false, classWriter)-->Line_54 $$ final FormErrorInfo[] errors = codeGenerator.getErrors()[ FD ]
Line_32 $$ final File alreadyProcessedForm = class2form.get(classToBind)-->Line_34 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, formFile.getAbsolutePath() + ": The form is bound to the class " + classToBind + ".\nAnother form " + alreadyProcessedForm.getAbsolutePath() + " is also bound to this class", formFile.getAbsolutePath()))[ FD ]
Line_45 $$ final AsmCodeGenerator codeGenerator = new AsmCodeGenerator(rootContainer, finder, nestedFormsLoader, false, classWriter)-->Line_46 $$ final byte[] patchedBytes = codeGenerator.patchClass(classReader)[ FD ]
Line_6 $$ for (File formFile : forms) -->Line_13 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, e.getMessage(), formFile.getPath()))[ FD ]
Line_45 $$ final AsmCodeGenerator codeGenerator = new AsmCodeGenerator(rootContainer, finder, nestedFormsLoader, false, classWriter)-->Line_50 $$ final FormErrorInfo[] warnings = codeGenerator.getWarnings()[ FD ]
Line_6 $$ for (File formFile : forms) -->Line_61 $$ message.append(formFile.getAbsolutePath()).append(": ").append(error.getErrorMessage())[ FD ]
Line_27 $$ final CompiledClass compiled = findClassFile(outConsumer, classToBind)-->Line_38 $$ addBinding(compiled.getSourceFile(), formFile, instrumented)[ FD ]
Line_46 $$ final byte[] patchedBytes = codeGenerator.patchClass(classReader)-->Line_47 $$ if (patchedBytes != null) [ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_5 $$ final MyNestedFormLoader nestedFormsLoader = new MyNestedFormLoader(chunkSourcePath, ProjectPaths.getOutputPathsWithDependents(chunk))[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_5 $$ final MyNestedFormLoader nestedFormsLoader = new MyNestedFormLoader(chunkSourcePath, ProjectPaths.getOutputPathsWithDependents(chunk))[ CD ]
Line_23 $$ final String classToBind = rootContainer.getClassToBind()-->Line_32 $$ final File alreadyProcessedForm = class2form.get(classToBind)[ FD ]
Line_3 $$ final Map<File, Collection<File>> instrumented = new THashMap<File, Collection<File>>(FileUtil.FILE_HASHING_STRATEGY)-->Line_38 $$ addBinding(compiled.getSourceFile(), formFile, instrumented)[ FD ]
Line_55 $$ if (errors.length > 0) -->Line_56 $$ StringBuilder message = new StringBuilder()[ CD ]
Line_56 $$ StringBuilder message = new StringBuilder()-->Line_63 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, message.toString()))[ FD ]
Line_7 $$ final LwRootContainer rootContainer-->Line_23 $$ final String classToBind = rootContainer.getClassToBind()[ FD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_69 $$ return instrumented[ CD ]
Line_6 $$ for (File formFile : forms) -->Line_17 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, e.getMessage(), formFile.getPath()))[ FD ]
Line_6 $$ for (File formFile : forms) -->Line_38 $$ addBinding(compiled.getSourceFile(), formFile, instrumented)[ FD ]
Line_55 $$ if (errors.length > 0) -->Line_63 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, message.toString()))[ CD ]
Line_2 $$ private Map<File, Collection<File>> instrumentForms(CompileContext context, ModuleChunk chunk, final Map<File, String> chunkSourcePath, final InstrumentationClassFinder finder, Collection<File> forms, OutputConsumer outConsumer) throws ProjectBuildException -->Line_9 $$ rootContainer = Utils.getRootContainer(formFile.toURI().toURL(), new CompiledClassPropertiesProvider(finder.getLoader()))[ FD ]
Line_6 $$ for (File formFile : forms) -->Line_34 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.WARNING, formFile.getAbsolutePath() + ": The form is bound to the class " + classToBind + ".\nAnother form " + alreadyProcessedForm.getAbsolutePath() + " is also bound to this class", formFile.getAbsolutePath()))[ FD ]
Line_42 $$ final ClassReader classReader = new FailSafeClassReader(originalContent.getBuffer(), originalContent.getOffset(), originalContent.getLength())-->Line_46 $$ final byte[] patchedBytes = codeGenerator.patchClass(classReader)[ FD ]
