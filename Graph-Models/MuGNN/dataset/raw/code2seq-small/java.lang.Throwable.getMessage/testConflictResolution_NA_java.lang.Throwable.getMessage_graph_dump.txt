Line_11 $$ for (int i = 0; i < writers; i++) -->Line_13 $$ Thread t = new Thread(new WrappedRunnable() [ CD ]
Line_11 $$ for (int i = 0; i < writers; i++) -->Line_33 $$ for (int i = 0; i < writers; i++) threads[i].join()[ FD ]
Line_3 $$ final int writers = 96-->Line_33 $$ for (int i = 0; i < writers; i++) threads[i].join()[ FD ]
Line_2 $$ public void testConflictResolution() throws Throwable -->Line_6 $$ createTable("CREATE TABLE %s (" + "a int," + "b int," + "c int," + "PRIMARY KEY (a, b))")[ CD ]
Line_13 $$ Thread t = new Thread(new WrappedRunnable() -->Line_30 $$ t.start()[ FD ]
Line_11 $$ for (int i = 0; i < writers; i++) -->Line_30 $$ t.start()[ CD ]
Line_55 $$ if (failedWrites.containsKey(c)) -->Line_56 $$ if (overlappingFailedWrites.length() != 0)[ CD ]
Line_11 $$ for (int i = 0; i < writers; i++) -->Line_12 $$ final int writer = i[ CD ]
Line_4 $$ final int insertsPerWriter = 50-->Line_18 $$ for (int i = 0; i < insertsPerWriter; i++) [ FD ]
Line_64 $$ if (rows.isEmpty()) -->Line_66 $$ if (rows.size() == 1 && !containsC) [ CD ]
Line_2 $$ public void testConflictResolution() throws Throwable -->Line_7 $$ executeNet(protocolVersion, "USE " + keyspace())[ CD ]
Line_2 $$ public void testConflictResolution() throws Throwable -->Line_42 $$ int value = executeNet(protocolVersion, "SELECT c FROM %s WHERE a = 1 AND b = 1").one().getInt("c")[ CD ]
Line_56 $$ if (overlappingFailedWrites.length() != 0)-->Line_57 $$ overlappingFailedWrites.append(' ')[ CD ]
Line_18 $$ for (int i = 0; i < insertsPerWriter; i++) -->Line_34 $$ for (int i = 0; i < writers * insertsPerWriter; i++) [ FD ]
Line_49 $$ if (c == value)-->Line_52 $$ if (others.length() != 0)[ CD ]
Line_34 $$ for (int i = 0; i < writers * insertsPerWriter; i++) -->Line_35 $$ if (executeNet(protocolVersion, "SELECT COUNT(*) FROM system.batchlog").one().getLong(0) == 0)[ CD ]
Line_2 $$ public void testConflictResolution() throws Throwable -->Line_8 $$ createView("mv", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE c IS NOT NULL AND a IS NOT NULL AND b IS NOT NULL PRIMARY KEY (c, a, b)")[ CD ]
Line_2 $$ public void testConflictResolution() throws Throwable -->Line_4 $$ final int insertsPerWriter = 50[ CD ]
Line_2 $$ public void testConflictResolution() throws Throwable -->Line_11 $$ for (int i = 0; i < writers; i++) [ CD ]
Line_5 $$ final Map<Integer, Exception> failedWrites = new ConcurrentHashMap()-->Line_55 $$ if (failedWrites.containsKey(c)) [ FD ]
Line_9 $$ CyclicBarrier semaphore = new CyclicBarrier(writers)-->Line_17 $$ semaphore.await()[ FD ]
Line_2 $$ public void testConflictResolution() throws Throwable -->Line_62 $$ if (rows.size() > 1) [ CD ]
Line_62 $$ if (rows.size() > 1) -->Line_64 $$ if (rows.isEmpty()) [ CD ]
Line_2 $$ public void testConflictResolution() throws Throwable -->Line_33 $$ for (int i = 0; i < writers; i++) threads[i].join()[ CD ]
Line_5 $$ final Map<Integer, Exception> failedWrites = new ConcurrentHashMap()-->Line_58 $$ overlappingFailedWrites.append(c).append(':').append(failedWrites.get(c).getMessage())[ FD ]
Line_49 $$ if (c == value)-->Line_55 $$ if (failedWrites.containsKey(c)) [ CD ]
Line_11 $$ for (int i = 0; i < writers; i++) -->Line_34 $$ for (int i = 0; i < writers * insertsPerWriter; i++) [ FD ]
Line_2 $$ public void testConflictResolution() throws Throwable -->Line_5 $$ final Map<Integer, Exception> failedWrites = new ConcurrentHashMap()[ CD ]
Line_2 $$ public void testConflictResolution() throws Throwable -->Line_3 $$ final int writers = 96[ CD ]
Line_2 $$ public void testConflictResolution() throws Throwable -->Line_9 $$ CyclicBarrier semaphore = new CyclicBarrier(writers)[ CD ]
Line_33 $$ for (int i = 0; i < writers; i++) threads[i].join()-->Line_34 $$ for (int i = 0; i < writers * insertsPerWriter; i++) [ FD ]
Line_2 $$ public void testConflictResolution() throws Throwable -->Line_34 $$ for (int i = 0; i < writers * insertsPerWriter; i++) [ CD ]
Line_49 $$ if (c == value)-->Line_54 $$ others.append(c)[ CD ]
Line_3 $$ final int writers = 96-->Line_11 $$ for (int i = 0; i < writers; i++) [ FD ]
Line_2 $$ public void testConflictResolution() throws Throwable -->Line_43 $$ List<Row> rows = executeNet(protocolVersion, "SELECT c FROM " + keyspace() + ".mv").all()[ CD ]
Line_55 $$ if (failedWrites.containsKey(c)) -->Line_58 $$ overlappingFailedWrites.append(c).append(':').append(failedWrites.get(c).getMessage())[ CD ]
Line_2 $$ public void testConflictResolution() throws Throwable -->Line_10 $$ Thread[] threads = new Thread[writers][ CD ]
Line_5 $$ final Map<Integer, Exception> failedWrites = new ConcurrentHashMap()-->Line_22 $$ failedWrites.put(i + writerOffset, e)[ FD ]
Line_52 $$ if (others.length() != 0)-->Line_53 $$ others.append(' ')[ CD ]
Line_11 $$ for (int i = 0; i < writers; i++) -->Line_18 $$ for (int i = 0; i < insertsPerWriter; i++) [ FD ]
Line_18 $$ for (int i = 0; i < insertsPerWriter; i++) -->Line_33 $$ for (int i = 0; i < writers; i++) threads[i].join()[ FD ]
