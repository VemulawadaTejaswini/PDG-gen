Line_10 $$ String message = String.format("Starting repair command #%d, repairing keyspace %s with %s", cmd, keyspace, options)-->Line_11 $$ logger.info(message)[ FD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_65 $$ final ListeningExecutorService executor = MoreExecutors.listeningDecorator(new JMXConfigurableThreadPoolExecutor(options.getJobThreads(), Integer.MAX_VALUE, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new NamedThreadFactory("Repair#" + cmd), "internal"))[ CD ]
Line_100 $$ Futures.addCallback(anticompactionResult, new FutureCallback<Object>() -->Line_116 $$ String duration = DurationFormatUtils.formatDurationWords(System.currentTimeMillis() - startTime, true, true)[ CD ]
Line_68 $$ final RepairSession session = ActiveRepairService.instance.submitRepairSession(parentSession, p.right, keyspace, options.getParallelism(), p.left, repairedAt, executor, cfnames)-->Line_69 $$ if (session == null)[ FD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_50 $$ for (int i = 0; i < columnFamilyStores.size(); i++) [ CD ]
Line_73 $$ String message = String.format("Repair session %s for range %s finished", session.getId(), session.getRanges().toString())-->Line_79 $$ logger.error(message, t)[ FD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_53 $$ final UUID parentSession = UUIDGen.getTimeUUID()[ CD ]
Line_5 $$ final AtomicInteger progress = new AtomicInteger()-->Line_62 $$ fireErrorAndComplete(tag, progress.get(), totalProgress, t.getMessage())[ FD ]
Line_65 $$ final ListeningExecutorService executor = MoreExecutors.listeningDecorator(new JMXConfigurableThreadPoolExecutor(options.getJobThreads(), Integer.MAX_VALUE, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new NamedThreadFactory("Repair#" + cmd), "internal"))-->Line_68 $$ final RepairSession session = ActiveRepairService.instance.submitRepairSession(parentSession, p.right, keyspace, options.getParallelism(), p.left, repairedAt, executor, cfnames)[ FD ]
Line_103 $$ if (hasFailure.get()) -->Line_104 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.ERROR, progress.get(), totalProgress, "Some repair failed"))[ CD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_5 $$ final AtomicInteger progress = new AtomicInteger()[ CD ]
Line_71 $$ Futures.addCallback(session, new FutureCallback<RepairSessionResult>() -->Line_79 $$ logger.error(message, t)[ CD ]
Line_13 $$ if (options.isTraced()) -->Line_25 $$ traceState = null[ CD ]
Line_100 $$ Futures.addCallback(anticompactionResult, new FutureCallback<Object>() -->Line_103 $$ if (hasFailure.get()) [ CD ]
Line_17 $$ traceState = Tracing.instance.begin("repair", ImmutableMap.of("keyspace", keyspace, "columnFamilies", cfsb.substring(2)))-->Line_20 $$ traceState.addProgressListener(listener)[ FD ]
Line_13 $$ if (options.isTraced()) -->Line_23 $$ queryThread.start()[ CD ]
Line_30 $$ for (Range<Token> range : options.getRanges()) -->Line_32 $$ addRangeToNeighbors(commonRanges, range, neighbors)[ FD ]
Line_73 $$ String message = String.format("Repair session %s for range %s finished", session.getId(), session.getRanges().toString())-->Line_119 $$ logger.info(message)[ FD ]
Line_4 $$ final String tag = "repair:" + cmd-->Line_104 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.ERROR, progress.get(), totalProgress, "Some repair failed"))[ FD ]
Line_5 $$ final AtomicInteger progress = new AtomicInteger()-->Line_75 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.PROGRESS, progress.incrementAndGet(), totalProgress, message))[ FD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_41 $$ List<ColumnFamilyStore> columnFamilyStores = new ArrayList()[ CD ]
Line_58 $$ repairedAt = ActiveRepairService.instance.getParentRepairSession(parentSession).getRepairedAt()-->Line_68 $$ final RepairSession session = ActiveRepairService.instance.submitRepairSession(parentSession, p.right, keyspace, options.getParallelism(), p.left, repairedAt, executor, cfnames)[ FD ]
Line_120 $$ if (options.isTraced() && traceState != null) -->Line_124 $$ Tracing.instance.stopSession()[ CD ]
Line_100 $$ Futures.addCallback(anticompactionResult, new FutureCallback<Object>() -->Line_112 $$ SystemDistributedKeyspace.failParentRepair(parentSession, t)[ CD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_12 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.START, 0, 100, message))[ CD ]
Line_41 $$ List<ColumnFamilyStore> columnFamilyStores = new ArrayList()-->Line_51 $$ cfnames[i] = columnFamilyStores.get(i).name[ FD ]
Line_28 $$ List<Pair<Set<InetAddress>, ? extends Collection<Range<Token>>>> commonRanges = new ArrayList()-->Line_32 $$ addRangeToNeighbors(commonRanges, range, neighbors)[ FD ]
Line_49 $$ String[] cfnames = new String[columnFamilyStores.size()]-->Line_54 $$ SystemDistributedKeyspace.startParentRepair(parentSession, keyspace, cfnames, options.getRanges())[ FD ]
Line_68 $$ final RepairSession session = ActiveRepairService.instance.submitRepairSession(parentSession, p.right, keyspace, options.getParallelism(), p.left, repairedAt, executor, cfnames)-->Line_83 $$ futures.add(session)[ FD ]
Line_103 $$ if (hasFailure.get()) -->Line_106 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.SUCCESS, progress.get(), totalProgress, "Repair completed successfully"))[ CD ]
Line_78 $$ String message = String.format("Repair session %s for range %s failed with error %s", session.getId(), session.getRanges().toString(), t.getMessage())-->Line_123 $$ Tracing.traceRepair(message)[ FD ]
Line_68 $$ final RepairSession session = ActiveRepairService.instance.submitRepairSession(parentSession, p.right, keyspace, options.getParallelism(), p.left, repairedAt, executor, cfnames)-->Line_71 $$ Futures.addCallback(session, new FutureCallback<RepairSessionResult>() [ FD ]
Line_25 $$ traceState = null-->Line_121 $$ traceState.removeProgressListener(listener)[ FD ]
Line_66 $$ List<ListenableFuture<RepairSessionResult>> futures = new ArrayList(options.getRanges().size())-->Line_87 $$ final ListenableFuture<List<RepairSessionResult>> allSessions = Futures.successfulAsList(futures)[ FD ]
Line_25 $$ traceState = null-->Line_122 $$ Tracing.instance.set(traceState)[ FD ]
Line_4 $$ final String tag = "repair:" + cmd-->Line_62 $$ fireErrorAndComplete(tag, progress.get(), totalProgress, t.getMessage())[ FD ]
Line_49 $$ String[] cfnames = new String[columnFamilyStores.size()]-->Line_68 $$ final RepairSession session = ActiveRepairService.instance.submitRepairSession(parentSession, p.right, keyspace, options.getParallelism(), p.left, repairedAt, executor, cfnames)[ FD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_100 $$ Futures.addCallback(anticompactionResult, new FutureCallback<Object>() [ CD ]
Line_5 $$ final AtomicInteger progress = new AtomicInteger()-->Line_35 $$ progress.incrementAndGet()[ FD ]
Line_3 $$ final TraceState traceState-->Line_25 $$ traceState = null[ FD ]
Line_117 $$ String message = String.format("Repair command #%d finished in %s", cmd, duration)-->Line_123 $$ Tracing.traceRepair(message)[ FD ]
Line_71 $$ Futures.addCallback(session, new FutureCallback<RepairSessionResult>() -->Line_78 $$ String message = String.format("Repair session %s for range %s failed with error %s", session.getId(), session.getRanges().toString(), t.getMessage())[ CD ]
Line_4 $$ final String tag = "repair:" + cmd-->Line_111 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.ERROR, progress.get(), totalProgress, t.getMessage()))[ FD ]
Line_21 $$ Thread queryThread = createQueryThread(cmd, sessionId)-->Line_22 $$ queryThread.setName("RepairTracePolling")[ FD ]
Line_5 $$ final AtomicInteger progress = new AtomicInteger()-->Line_104 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.ERROR, progress.get(), totalProgress, "Some repair failed"))[ FD ]
Line_100 $$ Futures.addCallback(anticompactionResult, new FutureCallback<Object>() -->Line_111 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.ERROR, progress.get(), totalProgress, t.getMessage()))[ FD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_4 $$ final String tag = "repair:" + cmd[ CD ]
Line_13 $$ if (options.isTraced()) -->Line_21 $$ Thread queryThread = createQueryThread(cmd, sessionId)[ CD ]
Line_13 $$ if (options.isTraced()) -->Line_19 $$ traceState.enableActivityNotification(tag)[ CD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_87 $$ final ListenableFuture<List<RepairSessionResult>> allSessions = Futures.successfulAsList(futures)[ CD ]
Line_120 $$ if (options.isTraced() && traceState != null) -->Line_122 $$ Tracing.instance.set(traceState)[ CD ]
Line_55 $$ long repairedAt-->Line_58 $$ repairedAt = ActiveRepairService.instance.getParentRepairSession(parentSession).getRepairedAt()[ FD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_7 $$ String[] columnFamilies = options.getColumnFamilies().toArray(new String[options.getColumnFamilies().size()])[ CD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_9 $$ final long startTime = System.currentTimeMillis()[ CD ]
Line_17 $$ traceState = Tracing.instance.begin("repair", ImmutableMap.of("keyspace", keyspace, "columnFamilies", cfsb.substring(2)))-->Line_122 $$ Tracing.instance.set(traceState)[ FD ]
Line_30 $$ for (Range<Token> range : options.getRanges()) -->Line_31 $$ Set<InetAddress> neighbors = ActiveRepairService.getNeighbors(keyspace, range, options.getDataCenters(), options.getHosts())[ FD ]
Line_100 $$ Futures.addCallback(anticompactionResult, new FutureCallback<Object>() -->Line_108 $$ repairComplete()[ CD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_8 $$ Iterable<ColumnFamilyStore> validColumnFamilies = storageService.getValidColumnFamilies(false, false, keyspace, columnFamilies)[ CD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_13 $$ if (options.isTraced()) [ CD ]
Line_100 $$ Futures.addCallback(anticompactionResult, new FutureCallback<Object>() -->Line_119 $$ logger.info(message)[ CD ]
Line_41 $$ List<ColumnFamilyStore> columnFamilyStores = new ArrayList()-->Line_50 $$ for (int i = 0; i < columnFamilyStores.size(); i++) [ FD ]
Line_50 $$ for (int i = 0; i < columnFamilyStores.size(); i++) -->Line_51 $$ cfnames[i] = columnFamilyStores.get(i).name[ FD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_55 $$ long repairedAt[ CD ]
Line_31 $$ Set<InetAddress> neighbors = ActiveRepairService.getNeighbors(keyspace, range, options.getDataCenters(), options.getHosts())-->Line_33 $$ allNeighbors.addAll(neighbors)[ FD ]
Line_17 $$ traceState = Tracing.instance.begin("repair", ImmutableMap.of("keyspace", keyspace, "columnFamilies", cfsb.substring(2)))-->Line_121 $$ traceState.removeProgressListener(listener)[ FD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_3 $$ final TraceState traceState[ CD ]
Line_7 $$ String[] columnFamilies = options.getColumnFamilies().toArray(new String[options.getColumnFamilies().size()])-->Line_8 $$ Iterable<ColumnFamilyStore> validColumnFamilies = storageService.getValidColumnFamilies(false, false, keyspace, columnFamilies)[ FD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_66 $$ List<ListenableFuture<RepairSessionResult>> futures = new ArrayList(options.getRanges().size())[ CD ]
Line_78 $$ String message = String.format("Repair session %s for range %s failed with error %s", session.getId(), session.getRanges().toString(), t.getMessage())-->Line_119 $$ logger.info(message)[ FD ]
Line_41 $$ List<ColumnFamilyStore> columnFamilyStores = new ArrayList()-->Line_57 $$ ActiveRepairService.instance.prepareForRepair(parentSession, allNeighbors, options, columnFamilyStores)[ FD ]
Line_5 $$ final AtomicInteger progress = new AtomicInteger()-->Line_59 $$ progress.incrementAndGet()[ FD ]
Line_3 $$ final TraceState traceState-->Line_19 $$ traceState.enableActivityNotification(tag)[ FD ]
Line_53 $$ final UUID parentSession = UUIDGen.getTimeUUID()-->Line_68 $$ final RepairSession session = ActiveRepairService.instance.submitRepairSession(parentSession, p.right, keyspace, options.getParallelism(), p.left, repairedAt, executor, cfnames)[ FD ]
Line_53 $$ final UUID parentSession = UUIDGen.getTimeUUID()-->Line_97 $$ return ActiveRepairService.instance.finishParentSession(parentSession, allNeighbors, successfulRanges)[ FD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_88 $$ ListenableFuture anticompactionResult = Futures.transform(allSessions, new AsyncFunction<List<RepairSessionResult>, Object>() [ CD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_6 $$ final int totalProgress = 3 + options.getRanges().size()[ CD ]
Line_6 $$ final int totalProgress = 3 + options.getRanges().size()-->Line_38 $$ fireErrorAndComplete(tag, progress.get(), totalProgress, e.getMessage())[ FD ]
Line_100 $$ Futures.addCallback(anticompactionResult, new FutureCallback<Object>() -->Line_113 $$ repairComplete()[ CD ]
Line_53 $$ final UUID parentSession = UUIDGen.getTimeUUID()-->Line_58 $$ repairedAt = ActiveRepairService.instance.getParentRepairSession(parentSession).getRepairedAt()[ FD ]
Line_117 $$ String message = String.format("Repair command #%d finished in %s", cmd, duration)-->Line_119 $$ logger.info(message)[ FD ]
Line_4 $$ final String tag = "repair:" + cmd-->Line_46 $$ fireErrorAndComplete(tag, progress.get(), totalProgress, e.getMessage())[ FD ]
Line_68 $$ final RepairSession session = ActiveRepairService.instance.submitRepairSession(parentSession, p.right, keyspace, options.getParallelism(), p.left, repairedAt, executor, cfnames)-->Line_78 $$ String message = String.format("Repair session %s for range %s failed with error %s", session.getId(), session.getRanges().toString(), t.getMessage())[ FD ]
Line_41 $$ List<ColumnFamilyStore> columnFamilyStores = new ArrayList()-->Line_43 $$ Iterables.addAll(columnFamilyStores, validColumnFamilies)[ FD ]
Line_17 $$ traceState = Tracing.instance.begin("repair", ImmutableMap.of("keyspace", keyspace, "columnFamilies", cfsb.substring(2)))-->Line_25 $$ traceState = null[ FD ]
Line_10 $$ String message = String.format("Starting repair command #%d, repairing keyspace %s with %s", cmd, keyspace, options)-->Line_74 $$ logger.info(message)[ FD ]
Line_73 $$ String message = String.format("Repair session %s for range %s finished", session.getId(), session.getRanges().toString())-->Line_123 $$ Tracing.traceRepair(message)[ FD ]
Line_100 $$ Futures.addCallback(anticompactionResult, new FutureCallback<Object>() -->Line_120 $$ if (options.isTraced() && traceState != null) [ CD ]
Line_71 $$ Futures.addCallback(session, new FutureCallback<RepairSessionResult>() -->Line_111 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.ERROR, progress.get(), totalProgress, t.getMessage()))[ FD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_27 $$ final Set<InetAddress> allNeighbors = new HashSet()[ CD ]
Line_53 $$ final UUID parentSession = UUIDGen.getTimeUUID()-->Line_112 $$ SystemDistributedKeyspace.failParentRepair(parentSession, t)[ FD ]
Line_4 $$ final String tag = "repair:" + cmd-->Line_19 $$ traceState.enableActivityNotification(tag)[ FD ]
Line_13 $$ if (options.isTraced()) -->Line_16 $$ UUID sessionId = Tracing.instance.newSession(Tracing.TraceType.REPAIR)[ CD ]
Line_100 $$ Futures.addCallback(anticompactionResult, new FutureCallback<Object>() -->Line_126 $$ executor.shutdownNow()[ CD ]
Line_17 $$ traceState = Tracing.instance.begin("repair", ImmutableMap.of("keyspace", keyspace, "columnFamilies", cfsb.substring(2)))-->Line_19 $$ traceState.enableActivityNotification(tag)[ FD ]
Line_4 $$ final String tag = "repair:" + cmd-->Line_75 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.PROGRESS, progress.incrementAndGet(), totalProgress, message))[ FD ]
Line_10 $$ String message = String.format("Starting repair command #%d, repairing keyspace %s with %s", cmd, keyspace, options)-->Line_18 $$ Tracing.traceRepair(message)[ FD ]
Line_14 $$ StringBuilder cfsb = new StringBuilder()-->Line_15 $$ cfsb.append(", ").append(cfs.keyspace.getName()).append(".").append(cfs.name)[ FD ]
Line_8 $$ Iterable<ColumnFamilyStore> validColumnFamilies = storageService.getValidColumnFamilies(false, false, keyspace, columnFamilies)-->Line_43 $$ Iterables.addAll(columnFamilyStores, validColumnFamilies)[ FD ]
Line_100 $$ Futures.addCallback(anticompactionResult, new FutureCallback<Object>() -->Line_111 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.ERROR, progress.get(), totalProgress, t.getMessage()))[ CD ]
Line_116 $$ String duration = DurationFormatUtils.formatDurationWords(System.currentTimeMillis() - startTime, true, true)-->Line_117 $$ String message = String.format("Repair command #%d finished in %s", cmd, duration)[ FD ]
Line_90 $$ for (RepairSessionResult sessionResult : results) -->Line_91 $$ if (sessionResult != null) [ FD ]
Line_3 $$ final TraceState traceState-->Line_20 $$ traceState.addProgressListener(listener)[ FD ]
Line_100 $$ Futures.addCallback(anticompactionResult, new FutureCallback<Object>() -->Line_102 $$ SystemDistributedKeyspace.successfulParentRepair(parentSession, successfulRanges)[ CD ]
Line_73 $$ String message = String.format("Repair session %s for range %s finished", session.getId(), session.getRanges().toString())-->Line_74 $$ logger.info(message)[ FD ]
Line_53 $$ final UUID parentSession = UUIDGen.getTimeUUID()-->Line_54 $$ SystemDistributedKeyspace.startParentRepair(parentSession, keyspace, cfnames, options.getRanges())[ FD ]
Line_3 $$ final TraceState traceState-->Line_122 $$ Tracing.instance.set(traceState)[ FD ]
Line_88 $$ ListenableFuture anticompactionResult = Futures.transform(allSessions, new AsyncFunction<List<RepairSessionResult>, Object>() -->Line_97 $$ return ActiveRepairService.instance.finishParentSession(parentSession, allNeighbors, successfulRanges)[ CD ]
Line_6 $$ final int totalProgress = 3 + options.getRanges().size()-->Line_46 $$ fireErrorAndComplete(tag, progress.get(), totalProgress, e.getMessage())[ FD ]
Line_5 $$ final AtomicInteger progress = new AtomicInteger()-->Line_44 $$ progress.incrementAndGet()[ FD ]
Line_100 $$ Futures.addCallback(anticompactionResult, new FutureCallback<Object>() -->Line_112 $$ SystemDistributedKeyspace.failParentRepair(parentSession, t)[ FD ]
Line_100 $$ Futures.addCallback(anticompactionResult, new FutureCallback<Object>() -->Line_117 $$ String message = String.format("Repair command #%d finished in %s", cmd, duration)[ CD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_11 $$ logger.info(message)[ CD ]
Line_10 $$ String message = String.format("Starting repair command #%d, repairing keyspace %s with %s", cmd, keyspace, options)-->Line_79 $$ logger.error(message, t)[ FD ]
Line_6 $$ final int totalProgress = 3 + options.getRanges().size()-->Line_62 $$ fireErrorAndComplete(tag, progress.get(), totalProgress, t.getMessage())[ FD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_54 $$ SystemDistributedKeyspace.startParentRepair(parentSession, keyspace, cfnames, options.getRanges())[ CD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_49 $$ String[] cfnames = new String[columnFamilyStores.size()][ CD ]
Line_5 $$ final AtomicInteger progress = new AtomicInteger()-->Line_46 $$ fireErrorAndComplete(tag, progress.get(), totalProgress, e.getMessage())[ FD ]
Line_27 $$ final Set<InetAddress> allNeighbors = new HashSet()-->Line_33 $$ allNeighbors.addAll(neighbors)[ FD ]
Line_71 $$ Futures.addCallback(session, new FutureCallback<RepairSessionResult>() -->Line_80 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.PROGRESS, progress.incrementAndGet(), totalProgress, message))[ CD ]
Line_27 $$ final Set<InetAddress> allNeighbors = new HashSet()-->Line_97 $$ return ActiveRepairService.instance.finishParentSession(parentSession, allNeighbors, successfulRanges)[ FD ]
Line_27 $$ final Set<InetAddress> allNeighbors = new HashSet()-->Line_57 $$ ActiveRepairService.instance.prepareForRepair(parentSession, allNeighbors, options, columnFamilyStores)[ FD ]
Line_68 $$ final RepairSession session = ActiveRepairService.instance.submitRepairSession(parentSession, p.right, keyspace, options.getParallelism(), p.left, repairedAt, executor, cfnames)-->Line_73 $$ String message = String.format("Repair session %s for range %s finished", session.getId(), session.getRanges().toString())[ FD ]
Line_3 $$ final TraceState traceState-->Line_121 $$ traceState.removeProgressListener(listener)[ FD ]
Line_53 $$ final UUID parentSession = UUIDGen.getTimeUUID()-->Line_102 $$ SystemDistributedKeyspace.successfulParentRepair(parentSession, successfulRanges)[ FD ]
Line_4 $$ final String tag = "repair:" + cmd-->Line_80 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.PROGRESS, progress.incrementAndGet(), totalProgress, message))[ FD ]
Line_5 $$ final AtomicInteger progress = new AtomicInteger()-->Line_80 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.PROGRESS, progress.incrementAndGet(), totalProgress, message))[ FD ]
Line_10 $$ String message = String.format("Starting repair command #%d, repairing keyspace %s with %s", cmd, keyspace, options)-->Line_119 $$ logger.info(message)[ FD ]
Line_71 $$ Futures.addCallback(session, new FutureCallback<RepairSessionResult>() -->Line_79 $$ logger.error(message, t)[ FD ]
Line_53 $$ final UUID parentSession = UUIDGen.getTimeUUID()-->Line_61 $$ SystemDistributedKeyspace.failParentRepair(parentSession, t)[ FD ]
Line_5 $$ final AtomicInteger progress = new AtomicInteger()-->Line_106 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.SUCCESS, progress.get(), totalProgress, "Repair completed successfully"))[ FD ]
Line_65 $$ final ListeningExecutorService executor = MoreExecutors.listeningDecorator(new JMXConfigurableThreadPoolExecutor(options.getJobThreads(), Integer.MAX_VALUE, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new NamedThreadFactory("Repair#" + cmd), "internal"))-->Line_126 $$ executor.shutdownNow()[ FD ]
Line_71 $$ Futures.addCallback(session, new FutureCallback<RepairSessionResult>() -->Line_75 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.PROGRESS, progress.incrementAndGet(), totalProgress, message))[ CD ]
Line_4 $$ final String tag = "repair:" + cmd-->Line_106 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.SUCCESS, progress.get(), totalProgress, "Repair completed successfully"))[ FD ]
Line_4 $$ final String tag = "repair:" + cmd-->Line_12 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.START, 0, 100, message))[ FD ]
Line_10 $$ String message = String.format("Starting repair command #%d, repairing keyspace %s with %s", cmd, keyspace, options)-->Line_123 $$ Tracing.traceRepair(message)[ FD ]
Line_78 $$ String message = String.format("Repair session %s for range %s failed with error %s", session.getId(), session.getRanges().toString(), t.getMessage())-->Line_79 $$ logger.error(message, t)[ FD ]
Line_4 $$ final String tag = "repair:" + cmd-->Line_38 $$ fireErrorAndComplete(tag, progress.get(), totalProgress, e.getMessage())[ FD ]
Line_14 $$ StringBuilder cfsb = new StringBuilder()-->Line_17 $$ traceState = Tracing.instance.begin("repair", ImmutableMap.of("keyspace", keyspace, "columnFamilies", cfsb.substring(2)))[ FD ]
Line_5 $$ final AtomicInteger progress = new AtomicInteger()-->Line_118 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.COMPLETE, progress.get(), totalProgress, message))[ FD ]
Line_31 $$ Set<InetAddress> neighbors = ActiveRepairService.getNeighbors(keyspace, range, options.getDataCenters(), options.getHosts())-->Line_32 $$ addRangeToNeighbors(commonRanges, range, neighbors)[ FD ]
Line_91 $$ if (sessionResult != null) -->Line_94 $$ hasFailure.compareAndSet(false, true)[ CD ]
Line_55 $$ long repairedAt-->Line_68 $$ final RepairSession session = ActiveRepairService.instance.submitRepairSession(parentSession, p.right, keyspace, options.getParallelism(), p.left, repairedAt, executor, cfnames)[ FD ]
Line_91 $$ if (sessionResult != null) -->Line_92 $$ successfulRanges.addAll(sessionResult.ranges)[ CD ]
Line_13 $$ if (options.isTraced()) -->Line_17 $$ traceState = Tracing.instance.begin("repair", ImmutableMap.of("keyspace", keyspace, "columnFamilies", cfsb.substring(2)))[ CD ]
Line_41 $$ List<ColumnFamilyStore> columnFamilyStores = new ArrayList()-->Line_49 $$ String[] cfnames = new String[columnFamilyStores.size()][ FD ]
Line_5 $$ final AtomicInteger progress = new AtomicInteger()-->Line_111 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.ERROR, progress.get(), totalProgress, t.getMessage()))[ FD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_28 $$ List<Pair<Set<InetAddress>, ? extends Collection<Range<Token>>>> commonRanges = new ArrayList()[ CD ]
Line_71 $$ Futures.addCallback(session, new FutureCallback<RepairSessionResult>() -->Line_74 $$ logger.info(message)[ CD ]
Line_21 $$ Thread queryThread = createQueryThread(cmd, sessionId)-->Line_23 $$ queryThread.start()[ FD ]
Line_120 $$ if (options.isTraced() && traceState != null) -->Line_123 $$ Tracing.traceRepair(message)[ CD ]
Line_66 $$ List<ListenableFuture<RepairSessionResult>> futures = new ArrayList(options.getRanges().size())-->Line_83 $$ futures.add(session)[ FD ]
Line_71 $$ Futures.addCallback(session, new FutureCallback<RepairSessionResult>() -->Line_112 $$ SystemDistributedKeyspace.failParentRepair(parentSession, t)[ FD ]
Line_3 $$ final TraceState traceState-->Line_17 $$ traceState = Tracing.instance.begin("repair", ImmutableMap.of("keyspace", keyspace, "columnFamilies", cfsb.substring(2)))[ FD ]
Line_13 $$ if (options.isTraced()) -->Line_22 $$ queryThread.setName("RepairTracePolling")[ CD ]
Line_2 $$ protected void runMayThrow() throws Exception -->Line_10 $$ String message = String.format("Starting repair command #%d, repairing keyspace %s with %s", cmd, keyspace, options)[ CD ]
Line_16 $$ UUID sessionId = Tracing.instance.newSession(Tracing.TraceType.REPAIR)-->Line_21 $$ Thread queryThread = createQueryThread(cmd, sessionId)[ FD ]
Line_53 $$ final UUID parentSession = UUIDGen.getTimeUUID()-->Line_57 $$ ActiveRepairService.instance.prepareForRepair(parentSession, allNeighbors, options, columnFamilyStores)[ FD ]
Line_71 $$ Futures.addCallback(session, new FutureCallback<RepairSessionResult>() -->Line_78 $$ String message = String.format("Repair session %s for range %s failed with error %s", session.getId(), session.getRanges().toString(), t.getMessage())[ FD ]
Line_100 $$ Futures.addCallback(anticompactionResult, new FutureCallback<Object>() -->Line_118 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.COMPLETE, progress.get(), totalProgress, message))[ CD ]
Line_20 $$ for (ProgressListener listener : listeners) traceState.addProgressListener(listener)-->Line_121 $$ traceState.removeProgressListener(listener)[ FD ]
Line_13 $$ if (options.isTraced()) -->Line_18 $$ Tracing.traceRepair(message)[ CD ]
Line_50 $$ for (int i = 0; i < columnFamilyStores.size(); i++) -->Line_51 $$ cfnames[i] = columnFamilyStores.get(i).name[ CD ]
Line_13 $$ if (options.isTraced()) -->Line_14 $$ StringBuilder cfsb = new StringBuilder()[ CD ]
Line_4 $$ final String tag = "repair:" + cmd-->Line_118 $$ fireProgressEvent(tag, new ProgressEvent(ProgressEventType.COMPLETE, progress.get(), totalProgress, message))[ FD ]
Line_71 $$ Futures.addCallback(session, new FutureCallback<RepairSessionResult>() -->Line_73 $$ String message = String.format("Repair session %s for range %s finished", session.getId(), session.getRanges().toString())[ CD ]
Line_5 $$ final AtomicInteger progress = new AtomicInteger()-->Line_38 $$ fireErrorAndComplete(tag, progress.get(), totalProgress, e.getMessage())[ FD ]
