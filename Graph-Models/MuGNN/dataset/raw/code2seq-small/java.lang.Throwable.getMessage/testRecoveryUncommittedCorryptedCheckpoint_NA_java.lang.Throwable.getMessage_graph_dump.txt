Line_10 $$ if (op == prepareOp) -->Line_11 $$ translogGeneration = translog.getGeneration()[ CD ]
Line_10 $$ if (op == prepareOp) -->Line_12 $$ translog.prepareCommit()[ CD ]
Line_18 $$ TranslogConfig config = translog.getConfig()-->Line_29 $$ Checkpoint.write(config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)), read, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING)[ FD ]
Line_10 $$ if (op == prepareOp) -->Line_14 $$ assertNotNull(translogGeneration.translogUUID)[ CD ]
Line_36 $$ for (int i = 0; i < upTo; i++) -->Line_37 $$ Translog.Operation next = snapshot.next()[ CD ]
Line_2 $$ public void testRecoveryUncommittedCorryptedCheckpoint() throws IOException -->Line_21 $$ Checkpoint read = Checkpoint.read(ckp)[ CD ]
Line_2 $$ public void testRecoveryUncommittedCorryptedCheckpoint() throws IOException -->Line_23 $$ Checkpoint.write(config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)), corrupted, StandardOpenOption.WRITE, StandardOpenOption.CREATE_NEW)[ CD ]
Line_8 $$ for (int op = 0; op < translogOperations; op++) -->Line_9 $$ locations.add(translog.add(new Translog.Index("test", "" + op, Integer.toString(op).getBytes(Charset.forName("UTF-8")))))[ CD ]
Line_37 $$ Translog.Operation next = snapshot.next()-->Line_39 $$ assertEquals("payload missmatch, synced: " + sync, i, Integer.parseInt(next.getSource().source.toUtf8()))[ FD ]
Line_10 $$ if (op == prepareOp) -->Line_13 $$ assertEquals("expected this to be the first commit", 1l, translogGeneration.translogFileGeneration)[ CD ]
Line_4 $$ int translogOperations = 100-->Line_8 $$ for (int op = 0; op < translogOperations; op++) [ FD ]
Line_2 $$ public void testRecoveryUncommittedCorryptedCheckpoint() throws IOException -->Line_17 $$ translog.sync()[ CD ]
Line_35 $$ int upTo = sync ? translogOperations : prepareOp-->Line_36 $$ for (int i = 0; i < upTo; i++) [ FD ]
Line_20 $$ Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME)-->Line_21 $$ Checkpoint read = Checkpoint.read(ckp)[ FD ]
Line_36 $$ for (int i = 0; i < upTo; i++) -->Line_38 $$ assertNotNull("operation " + i + " must be non-null synced: " + sync, next)[ CD ]
Line_6 $$ Translog.TranslogGeneration translogGeneration = null-->Line_31 $$ assertNotNull(translogGeneration)[ FD ]
Line_6 $$ Translog.TranslogGeneration translogGeneration = null-->Line_11 $$ translogGeneration = translog.getGeneration()[ FD ]
Line_2 $$ public void testRecoveryUncommittedCorryptedCheckpoint() throws IOException -->Line_29 $$ Checkpoint.write(config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)), read, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING)[ CD ]
Line_8 $$ for (int op = 0; op < translogOperations; op++) -->Line_9 $$ locations.add(translog.add(new Translog.Index("test", "" + op, Integer.toString(op).getBytes(Charset.forName("UTF-8")))))[ FD ]
Line_18 $$ TranslogConfig config = translog.getConfig()-->Line_20 $$ Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME)[ FD ]
Line_2 $$ public void testRecoveryUncommittedCorryptedCheckpoint() throws IOException -->Line_18 $$ TranslogConfig config = translog.getConfig()[ CD ]
Line_11 $$ translogGeneration = translog.getGeneration()-->Line_19 $$ config.setTranslogGeneration(translogGeneration)[ FD ]
Line_2 $$ public void testRecoveryUncommittedCorryptedCheckpoint() throws IOException -->Line_7 $$ final boolean sync = randomBoolean()[ CD ]
Line_2 $$ public void testRecoveryUncommittedCorryptedCheckpoint() throws IOException -->Line_19 $$ config.setTranslogGeneration(translogGeneration)[ CD ]
Line_2 $$ public void testRecoveryUncommittedCorryptedCheckpoint() throws IOException -->Line_20 $$ Path ckp = config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME)[ CD ]
Line_24 $$ try (Translog translog = new Translog(config)) -->Line_33 $$ assertFalse(translog.syncNeeded())[ FD ]
Line_3 $$ List<Translog.Location> locations = new ArrayList()-->Line_9 $$ locations.add(translog.add(new Translog.Index("test", "" + op, Integer.toString(op).getBytes(Charset.forName("UTF-8")))))[ FD ]
Line_2 $$ public void testRecoveryUncommittedCorryptedCheckpoint() throws IOException -->Line_5 $$ final int prepareOp = 44[ CD ]
Line_6 $$ Translog.TranslogGeneration translogGeneration = null-->Line_19 $$ config.setTranslogGeneration(translogGeneration)[ FD ]
Line_2 $$ public void testRecoveryUncommittedCorryptedCheckpoint() throws IOException -->Line_22 $$ Checkpoint corrupted = new Checkpoint(0, 0, 0)[ CD ]
Line_24 $$ try (Translog translog = new Translog(config)) -->Line_32 $$ assertEquals("lastCommitted must be 2 less than current - we never finished the commit", translogGeneration.translogFileGeneration + 2, translog.currentFileGeneration())[ FD ]
Line_36 $$ for (int i = 0; i < upTo; i++) -->Line_39 $$ assertEquals("payload missmatch, synced: " + sync, i, Integer.parseInt(next.getSource().source.toUtf8()))[ CD ]
Line_2 $$ public void testRecoveryUncommittedCorryptedCheckpoint() throws IOException -->Line_3 $$ List<Translog.Location> locations = new ArrayList()[ CD ]
Line_2 $$ public void testRecoveryUncommittedCorryptedCheckpoint() throws IOException -->Line_6 $$ Translog.TranslogGeneration translogGeneration = null[ CD ]
Line_21 $$ Checkpoint read = Checkpoint.read(ckp)-->Line_29 $$ Checkpoint.write(config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)), read, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING)[ FD ]
Line_22 $$ Checkpoint corrupted = new Checkpoint(0, 0, 0)-->Line_23 $$ Checkpoint.write(config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)), corrupted, StandardOpenOption.WRITE, StandardOpenOption.CREATE_NEW)[ FD ]
Line_34 $$ try (Translog.Snapshot snapshot = translog.newSnapshot()) -->Line_37 $$ Translog.Operation next = snapshot.next()[ FD ]
Line_18 $$ TranslogConfig config = translog.getConfig()-->Line_23 $$ Checkpoint.write(config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)), corrupted, StandardOpenOption.WRITE, StandardOpenOption.CREATE_NEW)[ FD ]
Line_8 $$ for (int op = 0; op < translogOperations; op++) -->Line_10 $$ if (op == prepareOp) [ CD ]
Line_5 $$ final int prepareOp = 44-->Line_10 $$ if (op == prepareOp) [ FD ]
Line_11 $$ translogGeneration = translog.getGeneration()-->Line_31 $$ assertNotNull(translogGeneration)[ FD ]
Line_36 $$ for (int i = 0; i < upTo; i++) -->Line_39 $$ assertEquals("payload missmatch, synced: " + sync, i, Integer.parseInt(next.getSource().source.toUtf8()))[ FD ]
Line_8 $$ for (int op = 0; op < translogOperations; op++) -->Line_10 $$ if (op == prepareOp) [ FD ]
Line_2 $$ public void testRecoveryUncommittedCorryptedCheckpoint() throws IOException -->Line_4 $$ int translogOperations = 100[ CD ]
Line_24 $$ try (Translog translog = new Translog(config)) -->Line_34 $$ try (Translog.Snapshot snapshot = translog.newSnapshot()) [ FD ]
Line_37 $$ Translog.Operation next = snapshot.next()-->Line_38 $$ assertNotNull("operation " + i + " must be non-null synced: " + sync, next)[ FD ]
Line_18 $$ TranslogConfig config = translog.getConfig()-->Line_19 $$ config.setTranslogGeneration(translogGeneration)[ FD ]
Line_2 $$ public void testRecoveryUncommittedCorryptedCheckpoint() throws IOException -->Line_8 $$ for (int op = 0; op < translogOperations; op++) [ CD ]
