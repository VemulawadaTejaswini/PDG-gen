Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_69 $$ retryRecovery(recoveryStatus, cause, recoverySettings.retryDelayStateSync(), request)[ FD ]
Line_5 $$ Store.MetadataSnapshot metadataSnapshot = null-->Line_10 $$ metadataSnapshot = Store.MetadataSnapshot.EMPTY[ FD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_3 $$ assert recoveryStatus.sourceNode() != null : "can't do a recovery without a source node"[ FD ]
Line_34 $$ if (logger.isTraceEnabled()) -->Line_40 $$ sb.append("   phase2: start took [").append(timeValueMillis(recoveryResponse.startTime)).append("]\n")[ CD ]
Line_34 $$ if (logger.isTraceEnabled()) -->Line_37 $$ sb.append("recovery completed from ").append(request.sourceNode()).append(", took[").append(recoveryTime).append("]\n")[ CD ]
Line_77 $$ if (cause instanceof IndexShardClosedException) -->Line_79 $$ return[ CD ]
Line_16 $$ final StartRecoveryRequest request = new StartRecoveryRequest(recoveryStatus.shardId(), recoveryStatus.sourceNode(), clusterService.localNode(), false, metadataSnapshot, recoveryStatus.state().getType(), recoveryStatus.recoveryId())-->Line_74 $$ retryRecovery(recoveryStatus, cause.getMessage(), recoverySettings.retryDelayNetwork(), request)[ FD ]
Line_34 $$ if (logger.isTraceEnabled()) -->Line_41 $$ sb.append("         : recovered [").append(recoveryResponse.phase2Operations).append("]").append(" transaction log operations").append(", took [").append(timeValueMillis(recoveryResponse.phase2Time)).append("]").append("\n")[ CD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_17 $$ final AtomicReference<RecoveryResponse> responseHolder = new AtomicReference()[ CD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_20 $$ recoveryStatus.indexShard().prepareForIndexRecovery()[ FD ]
Line_16 $$ final StartRecoveryRequest request = new StartRecoveryRequest(recoveryStatus.shardId(), recoveryStatus.sourceNode(), clusterService.localNode(), false, metadataSnapshot, recoveryStatus.state().getType(), recoveryStatus.recoveryId())-->Line_65 $$ retryRecovery(recoveryStatus, "remote shard not ready", recoverySettings.retryDelayStateSync(), request)[ FD ]
Line_72 $$ if (cause instanceof ConnectTransportException) -->Line_74 $$ retryRecovery(recoveryStatus, cause.getMessage(), recoverySettings.retryDelayNetwork(), request)[ CD ]
Line_34 $$ if (logger.isTraceEnabled()) -->Line_36 $$ sb.append('[').append(request.shardId().index().name()).append(']').append('[').append(request.shardId().id()).append("] ")[ CD ]
Line_53 $$ if (cause instanceof CancellableThreads.ExecutionCancelledException) -->Line_55 $$ return[ CD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_16 $$ final StartRecoveryRequest request = new StartRecoveryRequest(recoveryStatus.shardId(), recoveryStatus.sourceNode(), clusterService.localNode(), false, metadataSnapshot, recoveryStatus.state().getType(), recoveryStatus.recoveryId())[ FD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_73 $$ logger.debug("delaying recovery of [ FD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_82 $$ onGoingRecoveries.failRecovery(recoveryStatus.recoveryId(), new RecoveryFailedException(request, "source shard is closed", cause), false)[ FD ]
Line_17 $$ final AtomicReference<RecoveryResponse> responseHolder = new AtomicReference()-->Line_30 $$ final RecoveryResponse recoveryResponse = responseHolder.get()[ FD ]
Line_16 $$ final StartRecoveryRequest request = new StartRecoveryRequest(recoveryStatus.shardId(), recoveryStatus.sourceNode(), clusterService.localNode(), false, metadataSnapshot, recoveryStatus.state().getType(), recoveryStatus.recoveryId())-->Line_19 $$ logger.trace("[[ FD ]
Line_68 $$ if (cause instanceof DelayRecoveryException) -->Line_70 $$ return[ CD ]
Line_16 $$ final StartRecoveryRequest request = new StartRecoveryRequest(recoveryStatus.shardId(), recoveryStatus.sourceNode(), clusterService.localNode(), false, metadataSnapshot, recoveryStatus.state().getType(), recoveryStatus.recoveryId())-->Line_36 $$ sb.append('[').append(request.shardId().index().name()).append(']').append('[').append(request.shardId().id()).append("] ")[ FD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_7 $$ metadataSnapshot = recoveryStatus.store().getMetadataOrEmpty()[ FD ]
Line_61 $$ if (cause instanceof RecoveryEngineException) -->Line_62 $$ cause = cause.getCause()[ CD ]
Line_17 $$ final AtomicReference<RecoveryResponse> responseHolder = new AtomicReference()-->Line_23 $$ responseHolder.set(transportService.submitRequest(request.sourceNode(), RecoverySource.Actions.START_RECOVERY, request, new FutureTransportResponseHandler<RecoveryResponse>() [ FD ]
Line_77 $$ if (cause instanceof IndexShardClosedException) -->Line_78 $$ onGoingRecoveries.failRecovery(recoveryStatus.recoveryId(), new RecoveryFailedException(request, "source shard is closed", cause), false)[ CD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_16 $$ final StartRecoveryRequest request = new StartRecoveryRequest(recoveryStatus.shardId(), recoveryStatus.sourceNode(), clusterService.localNode(), false, metadataSnapshot, recoveryStatus.state().getType(), recoveryStatus.recoveryId())[ CD ]
Line_81 $$ if (cause instanceof AlreadyClosedException) -->Line_83 $$ return[ CD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_74 $$ retryRecovery(recoveryStatus, cause.getMessage(), recoverySettings.retryDelayNetwork(), request)[ FD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_4 $$ logger.trace("collecting local files for [ FD ]
Line_64 $$ if (cause instanceof IllegalIndexShardStateException || cause instanceof IndexNotFoundException || cause instanceof ShardNotFoundException) -->Line_65 $$ retryRecovery(recoveryStatus, "remote shard not ready", recoverySettings.retryDelayStateSync(), request)[ CD ]
Line_23 $$ responseHolder.set(transportService.submitRequest(request.sourceNode(), RecoverySource.Actions.START_RECOVERY, request, new FutureTransportResponseHandler<RecoveryResponse>() -->Line_25 $$ return new RecoveryResponse()[ CD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_33 $$ onGoingRecoveries.markRecoveryAsDone(recoveryStatus.recoveryId())[ FD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_65 $$ retryRecovery(recoveryStatus, "remote shard not ready", recoverySettings.retryDelayStateSync(), request)[ FD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_54 $$ onGoingRecoveries.failRecovery(recoveryStatus.recoveryId(), new RecoveryFailedException(request, "source has canceled the recovery", cause), false)[ FD ]
Line_34 $$ if (logger.isTraceEnabled()) -->Line_39 $$ sb.append("         : reusing_files   [").append(recoveryResponse.phase1ExistingFileNames.size()).append("] with total_size of [").append(new ByteSizeValue(recoveryResponse.phase1ExistingTotalSize)).append("]\n")[ CD ]
Line_64 $$ if (cause instanceof IllegalIndexShardStateException || cause instanceof IndexNotFoundException || cause instanceof ShardNotFoundException) -->Line_66 $$ return[ CD ]
Line_16 $$ final StartRecoveryRequest request = new StartRecoveryRequest(recoveryStatus.shardId(), recoveryStatus.sourceNode(), clusterService.localNode(), false, metadataSnapshot, recoveryStatus.state().getType(), recoveryStatus.recoveryId())-->Line_50 $$ logger.trace("[[ FD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_78 $$ onGoingRecoveries.failRecovery(recoveryStatus.recoveryId(), new RecoveryFailedException(request, "source shard is closed", cause), false)[ FD ]
Line_81 $$ if (cause instanceof AlreadyClosedException) -->Line_82 $$ onGoingRecoveries.failRecovery(recoveryStatus.recoveryId(), new RecoveryFailedException(request, "source shard is closed", cause), false)[ CD ]
Line_68 $$ if (cause instanceof DelayRecoveryException) -->Line_69 $$ retryRecovery(recoveryStatus, cause, recoverySettings.retryDelayStateSync(), request)[ CD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_5 $$ Store.MetadataSnapshot metadataSnapshot = null[ CD ]
Line_34 $$ if (logger.isTraceEnabled()) -->Line_38 $$ sb.append("   phase1: recovered_files [").append(recoveryResponse.phase1FileNames.size()).append("]").append(" with total_size of [").append(new ByteSizeValue(recoveryResponse.phase1TotalSize)).append("]").append(", took [").append(timeValueMillis(recoveryResponse.phase1Time)).append("], throttling_wait [").append(timeValueMillis(recoveryResponse.phase1ThrottlingWaitTime)).append(']').append("\n")[ CD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_85 $$ onGoingRecoveries.failRecovery(recoveryStatus.recoveryId(), new RecoveryFailedException(request, e), true)[ FD ]
Line_16 $$ final StartRecoveryRequest request = new StartRecoveryRequest(recoveryStatus.shardId(), recoveryStatus.sourceNode(), clusterService.localNode(), false, metadataSnapshot, recoveryStatus.state().getType(), recoveryStatus.recoveryId())-->Line_44 $$ logger.debug("[ FD ]
Line_49 $$ if (logger.isTraceEnabled()) -->Line_50 $$ logger.trace("[[ CD ]
Line_7 $$ metadataSnapshot = recoveryStatus.store().getMetadataOrEmpty()-->Line_10 $$ metadataSnapshot = Store.MetadataSnapshot.EMPTY[ FD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_32 $$ final TimeValue recoveryTime = new TimeValue(recoveryStatus.state().getTimer().time())[ FD ]
Line_53 $$ if (cause instanceof CancellableThreads.ExecutionCancelledException) -->Line_54 $$ onGoingRecoveries.failRecovery(recoveryStatus.recoveryId(), new RecoveryFailedException(request, "source has canceled the recovery", cause), false)[ CD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_4 $$ logger.trace("collecting local files for [ CD ]
Line_34 $$ if (logger.isTraceEnabled()) -->Line_42 $$ logger.trace(sb.toString())[ CD ]
Line_34 $$ if (logger.isTraceEnabled()) -->Line_44 $$ logger.debug("[ CD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_21 $$ recoveryStatus.CancellableThreads().execute(new CancellableThreads.Interruptable() [ FD ]
Line_57 $$ if (cause instanceof RecoveryEngineException) -->Line_58 $$ cause = cause.getCause()[ CD ]
Line_21 $$ recoveryStatus.CancellableThreads().execute(new CancellableThreads.Interruptable() -->Line_23 $$ responseHolder.set(transportService.submitRequest(request.sourceNode(), RecoverySource.Actions.START_RECOVERY, request, new FutureTransportResponseHandler<RecoveryResponse>() [ CD ]
Line_16 $$ final StartRecoveryRequest request = new StartRecoveryRequest(recoveryStatus.shardId(), recoveryStatus.sourceNode(), clusterService.localNode(), false, metadataSnapshot, recoveryStatus.state().getType(), recoveryStatus.recoveryId())-->Line_69 $$ retryRecovery(recoveryStatus, cause, recoverySettings.retryDelayStateSync(), request)[ FD ]
Line_72 $$ if (cause instanceof ConnectTransportException) -->Line_73 $$ logger.debug("delaying recovery of [ CD ]
Line_72 $$ if (cause instanceof ConnectTransportException) -->Line_75 $$ return[ CD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_44 $$ logger.debug("[ FD ]
Line_16 $$ final StartRecoveryRequest request = new StartRecoveryRequest(recoveryStatus.shardId(), recoveryStatus.sourceNode(), clusterService.localNode(), false, metadataSnapshot, recoveryStatus.state().getType(), recoveryStatus.recoveryId())-->Line_23 $$ responseHolder.set(transportService.submitRequest(request.sourceNode(), RecoverySource.Actions.START_RECOVERY, request, new FutureTransportResponseHandler<RecoveryResponse>() [ FD ]
Line_16 $$ final StartRecoveryRequest request = new StartRecoveryRequest(recoveryStatus.shardId(), recoveryStatus.sourceNode(), clusterService.localNode(), false, metadataSnapshot, recoveryStatus.state().getType(), recoveryStatus.recoveryId())-->Line_37 $$ sb.append("recovery completed from ").append(request.sourceNode()).append(", took[").append(recoveryTime).append("]\n")[ FD ]
Line_2 $$ private void doRecovery(final RecoveryStatus recoveryStatus) -->Line_13 $$ onGoingRecoveries.failRecovery(recoveryStatus.recoveryId(), new RecoveryFailedException(recoveryStatus.state(), "failed to list local files", e), true)[ FD ]
Line_5 $$ Store.MetadataSnapshot metadataSnapshot = null-->Line_7 $$ metadataSnapshot = recoveryStatus.store().getMetadataOrEmpty()[ FD ]
