Line_5 $$ ArrayList<DatanodeInfo> ignored = new ArrayList<DatanodeInfo>()-->Line_13 $$ chosenNode = chooseDataNode(block, ignored)[ FD ]
Line_36 $$ chosenNode = getBestNodeDNAddrPair(block.getLocations(), ignored)-->Line_15 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)[ FD ]
Line_5 $$ ArrayList<DatanodeInfo> ignored = new ArrayList<DatanodeInfo>()-->Line_36 $$ chosenNode = getBestNodeDNAddrPair(block.getLocations(), ignored)[ FD ]
Line_4 $$ CompletionService<ByteBuffer> hedgedService = new ExecutorCompletionService<ByteBuffer>(dfsClient.getHedgedReadsThreadPool())-->Line_19 $$ Future<ByteBuffer> future = hedgedService.poll(dfsClient.getHedgedReadTimeout(), TimeUnit.MILLISECONDS)[ FD ]
Line_20 $$ if (future != null) -->Line_21 $$ future.get()[ CD ]
Line_2 $$ private void hedgedFetchBlockByteRange(LocatedBlock block, long start, long end, byte[] buf, int offset, Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap) throws IOException -->Line_5 $$ ArrayList<DatanodeInfo> ignored = new ArrayList<DatanodeInfo>()[ CD ]
Line_11 $$ DNAddrPair chosenNode = null-->Line_36 $$ chosenNode = getBestNodeDNAddrPair(block.getLocations(), ignored)[ FD ]
Line_8 $$ block = getBlockAt(block.getStartOffset(), false)-->Line_41 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)[ FD ]
Line_13 $$ chosenNode = chooseDataNode(block, ignored)-->Line_15 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)[ FD ]
Line_24 $$ if (DFSClient.LOG.isDebugEnabled()) -->Line_25 $$ DFSClient.LOG.debug("Waited " + dfsClient.getHedgedReadTimeout() + "ms to read from " + chosenNode.info + "; spawning hedged read")[ CD ]
Line_11 $$ DNAddrPair chosenNode = null-->Line_15 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)[ FD ]
Line_4 $$ CompletionService<ByteBuffer> hedgedService = new ExecutorCompletionService<ByteBuffer>(dfsClient.getHedgedReadsThreadPool())-->Line_42 $$ Future<ByteBuffer> oneMoreRequest = hedgedService.submit(getFromDataNodeCallable)[ FD ]
Line_42 $$ Future<ByteBuffer> oneMoreRequest = hedgedService.submit(getFromDataNodeCallable)-->Line_43 $$ futures.add(oneMoreRequest)[ FD ]
Line_8 $$ block = getBlockAt(block.getStartOffset(), false)-->Line_13 $$ chosenNode = chooseDataNode(block, ignored)[ FD ]
Line_2 $$ private void hedgedFetchBlockByteRange(LocatedBlock block, long start, long end, byte[] buf, int offset, Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap) throws IOException -->Line_8 $$ block = getBlockAt(block.getStartOffset(), false)[ FD ]
Line_8 $$ block = getBlockAt(block.getStartOffset(), false)-->Line_38 $$ chosenNode = chooseDataNode(block, ignored)[ FD ]
Line_13 $$ chosenNode = chooseDataNode(block, ignored)-->Line_41 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)[ FD ]
Line_52 $$ if (result.array() != buf) -->Line_53 $$ dfsClient.getHedgedReadMetrics().incHedgedReadWins()[ CD ]
Line_19 $$ Future<ByteBuffer> future = hedgedService.poll(dfsClient.getHedgedReadTimeout(), TimeUnit.MILLISECONDS)-->Line_20 $$ if (future != null) [ FD ]
Line_2 $$ private void hedgedFetchBlockByteRange(LocatedBlock block, long start, long end, byte[] buf, int offset, Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap) throws IOException -->Line_14 $$ bb = ByteBuffer.wrap(buf, offset, len)[ FD ]
Line_12 $$ if (futures.isEmpty()) -->Line_14 $$ bb = ByteBuffer.wrap(buf, offset, len)[ CD ]
Line_36 $$ chosenNode = getBestNodeDNAddrPair(block.getLocations(), ignored)-->Line_38 $$ chosenNode = chooseDataNode(block, ignored)[ FD ]
Line_50 $$ ByteBuffer result = getFirstToComplete(hedgedService, futures)-->Line_52 $$ if (result.array() != buf) [ FD ]
Line_2 $$ private void hedgedFetchBlockByteRange(LocatedBlock block, long start, long end, byte[] buf, int offset, Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap) throws IOException -->Line_36 $$ chosenNode = getBestNodeDNAddrPair(block.getLocations(), ignored)[ FD ]
Line_12 $$ if (futures.isEmpty()) -->Line_61 $$ if (chosenNode != null && chosenNode.info != null) [ CD ]
Line_2 $$ private void hedgedFetchBlockByteRange(LocatedBlock block, long start, long end, byte[] buf, int offset, Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap) throws IOException -->Line_9 $$ while (true) [ CD ]
Line_11 $$ DNAddrPair chosenNode = null-->Line_38 $$ chosenNode = chooseDataNode(block, ignored)[ FD ]
Line_14 $$ bb = ByteBuffer.wrap(buf, offset, len)-->Line_15 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)[ FD ]
Line_52 $$ if (result.array() != buf) -->Line_54 $$ System.arraycopy(result.array(), result.position(), buf, offset, len)[ CD ]
Line_2 $$ private void hedgedFetchBlockByteRange(LocatedBlock block, long start, long end, byte[] buf, int offset, Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap) throws IOException -->Line_52 $$ if (result.array() != buf) [ FD ]
Line_6 $$ ByteBuffer bb = null-->Line_41 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)[ FD ]
Line_13 $$ chosenNode = chooseDataNode(block, ignored)-->Line_38 $$ chosenNode = chooseDataNode(block, ignored)[ FD ]
Line_2 $$ private void hedgedFetchBlockByteRange(LocatedBlock block, long start, long end, byte[] buf, int offset, Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap) throws IOException -->Line_7 $$ int len = (int) (end - start + 1)[ CD ]
Line_3 $$ ArrayList<Future<ByteBuffer>> futures = new ArrayList<Future<ByteBuffer>>()-->Line_50 $$ ByteBuffer result = getFirstToComplete(hedgedService, futures)[ FD ]
Line_4 $$ CompletionService<ByteBuffer> hedgedService = new ExecutorCompletionService<ByteBuffer>(dfsClient.getHedgedReadsThreadPool())-->Line_50 $$ ByteBuffer result = getFirstToComplete(hedgedService, futures)[ FD ]
Line_38 $$ chosenNode = chooseDataNode(block, ignored)-->Line_41 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)[ FD ]
Line_12 $$ if (futures.isEmpty()) -->Line_15 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)[ CD ]
Line_2 $$ private void hedgedFetchBlockByteRange(LocatedBlock block, long start, long end, byte[] buf, int offset, Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap) throws IOException -->Line_38 $$ chosenNode = chooseDataNode(block, ignored)[ FD ]
Line_5 $$ ArrayList<DatanodeInfo> ignored = new ArrayList<DatanodeInfo>()-->Line_38 $$ chosenNode = chooseDataNode(block, ignored)[ FD ]
Line_12 $$ if (futures.isEmpty()) -->Line_13 $$ chosenNode = chooseDataNode(block, ignored)[ CD ]
Line_2 $$ private void hedgedFetchBlockByteRange(LocatedBlock block, long start, long end, byte[] buf, int offset, Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap) throws IOException -->Line_6 $$ ByteBuffer bb = null[ CD ]
Line_61 $$ if (chosenNode != null && chosenNode.info != null) -->Line_62 $$ ignored.add(chosenNode.info)[ CD ]
Line_45 $$ if (DFSClient.LOG.isDebugEnabled()) -->Line_46 $$ DFSClient.LOG.debug("Failed getting node for hedged read: " + ioe.getMessage())[ CD ]
Line_2 $$ private void hedgedFetchBlockByteRange(LocatedBlock block, long start, long end, byte[] buf, int offset, Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap) throws IOException -->Line_13 $$ chosenNode = chooseDataNode(block, ignored)[ FD ]
Line_5 $$ ArrayList<DatanodeInfo> ignored = new ArrayList<DatanodeInfo>()-->Line_62 $$ ignored.add(chosenNode.info)[ FD ]
Line_15 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)-->Line_42 $$ Future<ByteBuffer> oneMoreRequest = hedgedService.submit(getFromDataNodeCallable)[ FD ]
Line_6 $$ ByteBuffer bb = null-->Line_40 $$ bb = ByteBuffer.allocate(len)[ FD ]
Line_19 $$ Future<ByteBuffer> future = hedgedService.poll(dfsClient.getHedgedReadTimeout(), TimeUnit.MILLISECONDS)-->Line_21 $$ future.get()[ FD ]
Line_3 $$ ArrayList<Future<ByteBuffer>> futures = new ArrayList<Future<ByteBuffer>>()-->Line_17 $$ futures.add(firstRequest)[ FD ]
Line_2 $$ private void hedgedFetchBlockByteRange(LocatedBlock block, long start, long end, byte[] buf, int offset, Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap) throws IOException -->Line_8 $$ block = getBlockAt(block.getStartOffset(), false)[ CD ]
Line_14 $$ bb = ByteBuffer.wrap(buf, offset, len)-->Line_41 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)[ FD ]
Line_20 $$ if (future != null) -->Line_22 $$ return[ CD ]
Line_8 $$ block = getBlockAt(block.getStartOffset(), false)-->Line_36 $$ chosenNode = getBestNodeDNAddrPair(block.getLocations(), ignored)[ FD ]
Line_11 $$ DNAddrPair chosenNode = null-->Line_41 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)[ FD ]
Line_36 $$ chosenNode = getBestNodeDNAddrPair(block.getLocations(), ignored)-->Line_41 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)[ FD ]
Line_9 $$ while (true) -->Line_11 $$ DNAddrPair chosenNode = null[ CD ]
Line_3 $$ ArrayList<Future<ByteBuffer>> futures = new ArrayList<Future<ByteBuffer>>()-->Line_51 $$ cancelAll(futures)[ FD ]
Line_2 $$ private void hedgedFetchBlockByteRange(LocatedBlock block, long start, long end, byte[] buf, int offset, Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap) throws IOException -->Line_54 $$ System.arraycopy(result.array(), result.position(), buf, offset, len)[ FD ]
Line_8 $$ block = getBlockAt(block.getStartOffset(), false)-->Line_15 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)[ FD ]
Line_40 $$ bb = ByteBuffer.allocate(len)-->Line_41 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)[ FD ]
Line_2 $$ private void hedgedFetchBlockByteRange(LocatedBlock block, long start, long end, byte[] buf, int offset, Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap) throws IOException -->Line_4 $$ CompletionService<ByteBuffer> hedgedService = new ExecutorCompletionService<ByteBuffer>(dfsClient.getHedgedReadsThreadPool())[ CD ]
Line_13 $$ chosenNode = chooseDataNode(block, ignored)-->Line_36 $$ chosenNode = getBestNodeDNAddrPair(block.getLocations(), ignored)[ FD ]
Line_38 $$ chosenNode = chooseDataNode(block, ignored)-->Line_15 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)[ FD ]
Line_52 $$ if (result.array() != buf) -->Line_56 $$ dfsClient.getHedgedReadMetrics().incHedgedReadOps()[ CD ]
Line_9 $$ while (true) -->Line_12 $$ if (futures.isEmpty()) [ CD ]
Line_4 $$ CompletionService<ByteBuffer> hedgedService = new ExecutorCompletionService<ByteBuffer>(dfsClient.getHedgedReadsThreadPool())-->Line_16 $$ Future<ByteBuffer> firstRequest = hedgedService.submit(getFromDataNodeCallable)[ FD ]
Line_50 $$ ByteBuffer result = getFirstToComplete(hedgedService, futures)-->Line_54 $$ System.arraycopy(result.array(), result.position(), buf, offset, len)[ FD ]
Line_5 $$ ArrayList<DatanodeInfo> ignored = new ArrayList<DatanodeInfo>()-->Line_27 $$ ignored.add(chosenNode.info)[ FD ]
Line_40 $$ bb = ByteBuffer.allocate(len)-->Line_15 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)[ FD ]
Line_16 $$ Future<ByteBuffer> firstRequest = hedgedService.submit(getFromDataNodeCallable)-->Line_17 $$ futures.add(firstRequest)[ FD ]
Line_14 $$ bb = ByteBuffer.wrap(buf, offset, len)-->Line_40 $$ bb = ByteBuffer.allocate(len)[ FD ]
Line_12 $$ if (futures.isEmpty()) -->Line_16 $$ Future<ByteBuffer> firstRequest = hedgedService.submit(getFromDataNodeCallable)[ CD ]
Line_6 $$ ByteBuffer bb = null-->Line_14 $$ bb = ByteBuffer.wrap(buf, offset, len)[ FD ]
Line_2 $$ private void hedgedFetchBlockByteRange(LocatedBlock block, long start, long end, byte[] buf, int offset, Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap) throws IOException -->Line_3 $$ ArrayList<Future<ByteBuffer>> futures = new ArrayList<Future<ByteBuffer>>()[ CD ]
Line_11 $$ DNAddrPair chosenNode = null-->Line_13 $$ chosenNode = chooseDataNode(block, ignored)[ FD ]
Line_2 $$ private void hedgedFetchBlockByteRange(LocatedBlock block, long start, long end, byte[] buf, int offset, Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap) throws IOException -->Line_15 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)[ FD ]
Line_6 $$ ByteBuffer bb = null-->Line_15 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)[ FD ]
Line_7 $$ int len = (int) (end - start + 1)-->Line_54 $$ System.arraycopy(result.array(), result.position(), buf, offset, len)[ FD ]
Line_12 $$ if (futures.isEmpty()) -->Line_17 $$ futures.add(firstRequest)[ CD ]
Line_7 $$ int len = (int) (end - start + 1)-->Line_14 $$ bb = ByteBuffer.wrap(buf, offset, len)[ FD ]
Line_2 $$ private void hedgedFetchBlockByteRange(LocatedBlock block, long start, long end, byte[] buf, int offset, Map<ExtendedBlock, Set<DatanodeInfo>> corruptedBlockMap) throws IOException -->Line_41 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)[ FD ]
Line_15 $$ Callable<ByteBuffer> getFromDataNodeCallable = getFromOneDataNode(chosenNode, block, start, end, bb, corruptedBlockMap)-->Line_16 $$ Future<ByteBuffer> firstRequest = hedgedService.submit(getFromDataNodeCallable)[ FD ]
Line_7 $$ int len = (int) (end - start + 1)-->Line_40 $$ bb = ByteBuffer.allocate(len)[ FD ]
Line_3 $$ ArrayList<Future<ByteBuffer>> futures = new ArrayList<Future<ByteBuffer>>()-->Line_12 $$ if (futures.isEmpty()) [ FD ]
Line_3 $$ ArrayList<Future<ByteBuffer>> futures = new ArrayList<Future<ByteBuffer>>()-->Line_43 $$ futures.add(oneMoreRequest)[ FD ]
