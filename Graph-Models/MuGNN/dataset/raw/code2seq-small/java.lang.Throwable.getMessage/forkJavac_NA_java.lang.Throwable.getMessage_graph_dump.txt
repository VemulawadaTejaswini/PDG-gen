Line_2 $$ public boolean forkJavac(final String javaHome, final int heapSize, List<String> vmOptions, List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, Map<File, Set<File>> outs, final DiagnosticOutputConsumer diagnosticSink, OutputFileConsumer outputSink, final JavaCompilingTool compilingTool, final CanceledStatus cancelStatus) -->Line_4 $$ final JavacRemoteProto.Message.Request request = JavacProtoUtil.createCompilationRequest(options, files, classpath, platformCp, sourcePath, outs)[ CD ]
Line_2 $$ public boolean forkJavac(final String javaHome, final int heapSize, List<String> vmOptions, List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, Map<File, Set<File>> outs, final DiagnosticOutputConsumer diagnosticSink, OutputFileConsumer outputSink, final JavaCompilingTool compilingTool, final CanceledStatus cancelStatus) -->Line_5 $$ final UUID uuid = UUID.randomUUID()[ CD ]
Line_3 $$ final ExternalJavacMessageHandler rh = new ExternalJavacMessageHandler(diagnosticSink, outputSink, getEncodingName(options))-->Line_38 $$ return rh.isTerminatedSuccessfully()[ FD ]
Line_30 $$ if (processHandler.isProcessTerminated() && processDescriptor.channel == null && processHandler.getExitCode() != 0) -->Line_31 $$ processDescriptor.setDone()[ CD ]
Line_11 $$ final ExternalJavacProcessHandler processHandler = launchExternalJavacProcess(uuid, javaHome, heapSize, myListenPort, myWorkingDir, vmOptions, compilingTool)-->Line_28 $$ processHandler.startNotify()[ FD ]
Line_2 $$ public boolean forkJavac(final String javaHome, final int heapSize, List<String> vmOptions, List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, Map<File, Set<File>> outs, final DiagnosticOutputConsumer diagnosticSink, OutputFileConsumer outputSink, final JavaCompilingTool compilingTool, final CanceledStatus cancelStatus) -->Line_45 $$ return false[ CD ]
Line_2 $$ public boolean forkJavac(final String javaHome, final int heapSize, List<String> vmOptions, List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, Map<File, Set<File>> outs, final DiagnosticOutputConsumer diagnosticSink, OutputFileConsumer outputSink, final JavaCompilingTool compilingTool, final CanceledStatus cancelStatus) -->Line_23 $$ diagnosticSink.outputLineAvailable(prefix + ": " + text)[ FD ]
Line_5 $$ final UUID uuid = UUID.randomUUID()-->Line_43 $$ unregisterMessageHandler(uuid)[ FD ]
Line_5 $$ final UUID uuid = UUID.randomUUID()-->Line_8 $$ myMessageHandlers.put(uuid, processDescriptor)[ FD ]
Line_5 $$ final UUID uuid = UUID.randomUUID()-->Line_11 $$ final ExternalJavacProcessHandler processHandler = launchExternalJavacProcess(uuid, javaHome, heapSize, myListenPort, myWorkingDir, vmOptions, compilingTool)[ FD ]
Line_12 $$ processHandler.addProcessListener(new ProcessAdapter() -->Line_14 $$ final String text = event.getText()[ CD ]
Line_15 $$ if (!StringUtil.isEmptyOrSpaces(text)) -->Line_16 $$ String prefix = null[ CD ]
Line_6 $$ final JavacProcessDescriptor processDescriptor = new JavacProcessDescriptor(uuid, rh, request)-->Line_29 $$ while (!processDescriptor.waitFor(300L)) [ FD ]
Line_14 $$ final String text = event.getText()-->Line_15 $$ if (!StringUtil.isEmptyOrSpaces(text)) [ FD ]
Line_2 $$ public boolean forkJavac(final String javaHome, final int heapSize, List<String> vmOptions, List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, Map<File, Set<File>> outs, final DiagnosticOutputConsumer diagnosticSink, OutputFileConsumer outputSink, final JavaCompilingTool compilingTool, final CanceledStatus cancelStatus) -->Line_34 $$ if (cancelStatus.isCanceled()) [ FD ]
Line_12 $$ processHandler.addProcessListener(new ProcessAdapter() -->Line_19 $$ if (outputType == ProcessOutputTypes.STDERR) [ FD ]
Line_11 $$ final ExternalJavacProcessHandler processHandler = launchExternalJavacProcess(uuid, javaHome, heapSize, myListenPort, myWorkingDir, vmOptions, compilingTool)-->Line_12 $$ processHandler.addProcessListener(new ProcessAdapter() [ FD ]
Line_29 $$ while (!processDescriptor.waitFor(300L)) -->Line_30 $$ if (processHandler.isProcessTerminated() && processDescriptor.channel == null && processHandler.getExitCode() != 0) [ CD ]
Line_18 $$ prefix = STDOUT_LINE_PREFIX-->Line_22 $$ if (prefix != null) [ FD ]
Line_2 $$ public boolean forkJavac(final String javaHome, final int heapSize, List<String> vmOptions, List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, Map<File, Set<File>> outs, final DiagnosticOutputConsumer diagnosticSink, OutputFileConsumer outputSink, final JavaCompilingTool compilingTool, final CanceledStatus cancelStatus) -->Line_4 $$ final JavacRemoteProto.Message.Request request = JavacProtoUtil.createCompilationRequest(options, files, classpath, platformCp, sourcePath, outs)[ FD ]
Line_16 $$ String prefix = null-->Line_18 $$ prefix = STDOUT_LINE_PREFIX[ FD ]
Line_16 $$ String prefix = null-->Line_20 $$ prefix = STDERR_LINE_PREFIX[ FD ]
Line_2 $$ public boolean forkJavac(final String javaHome, final int heapSize, List<String> vmOptions, List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, Map<File, Set<File>> outs, final DiagnosticOutputConsumer diagnosticSink, OutputFileConsumer outputSink, final JavaCompilingTool compilingTool, final CanceledStatus cancelStatus) -->Line_11 $$ final ExternalJavacProcessHandler processHandler = launchExternalJavacProcess(uuid, javaHome, heapSize, myListenPort, myWorkingDir, vmOptions, compilingTool)[ FD ]
Line_12 $$ processHandler.addProcessListener(new ProcessAdapter() -->Line_17 $$ if (outputType == ProcessOutputTypes.STDOUT) [ FD ]
Line_2 $$ public boolean forkJavac(final String javaHome, final int heapSize, List<String> vmOptions, List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, Map<File, Set<File>> outs, final DiagnosticOutputConsumer diagnosticSink, OutputFileConsumer outputSink, final JavaCompilingTool compilingTool, final CanceledStatus cancelStatus) -->Line_6 $$ final JavacProcessDescriptor processDescriptor = new JavacProcessDescriptor(uuid, rh, request)[ CD ]
Line_19 $$ if (outputType == ProcessOutputTypes.STDERR) -->Line_20 $$ prefix = STDERR_LINE_PREFIX[ CD ]
Line_12 $$ processHandler.addProcessListener(new ProcessAdapter() -->Line_14 $$ final String text = event.getText()[ FD ]
Line_6 $$ final JavacProcessDescriptor processDescriptor = new JavacProcessDescriptor(uuid, rh, request)-->Line_8 $$ myMessageHandlers.put(uuid, processDescriptor)[ FD ]
Line_29 $$ while (!processDescriptor.waitFor(300L)) -->Line_34 $$ if (cancelStatus.isCanceled()) [ CD ]
Line_17 $$ if (outputType == ProcessOutputTypes.STDOUT) -->Line_18 $$ prefix = STDOUT_LINE_PREFIX[ CD ]
Line_6 $$ final JavacProcessDescriptor processDescriptor = new JavacProcessDescriptor(uuid, rh, request)-->Line_31 $$ processDescriptor.setDone()[ FD ]
Line_12 $$ processHandler.addProcessListener(new ProcessAdapter() -->Line_15 $$ if (!StringUtil.isEmptyOrSpaces(text)) [ CD ]
Line_16 $$ String prefix = null-->Line_22 $$ if (prefix != null) [ FD ]
Line_17 $$ if (outputType == ProcessOutputTypes.STDOUT) -->Line_19 $$ if (outputType == ProcessOutputTypes.STDERR) [ CD ]
Line_22 $$ if (prefix != null) -->Line_23 $$ diagnosticSink.outputLineAvailable(prefix + ": " + text)[ CD ]
Line_6 $$ final JavacProcessDescriptor processDescriptor = new JavacProcessDescriptor(uuid, rh, request)-->Line_35 $$ processDescriptor.cancelBuild()[ FD ]
Line_11 $$ final ExternalJavacProcessHandler processHandler = launchExternalJavacProcess(uuid, javaHome, heapSize, myListenPort, myWorkingDir, vmOptions, compilingTool)-->Line_30 $$ if (processHandler.isProcessTerminated() && processDescriptor.channel == null && processHandler.getExitCode() != 0) [ FD ]
Line_34 $$ if (cancelStatus.isCanceled()) -->Line_35 $$ processDescriptor.cancelBuild()[ CD ]
Line_2 $$ public boolean forkJavac(final String javaHome, final int heapSize, List<String> vmOptions, List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, Map<File, Set<File>> outs, final DiagnosticOutputConsumer diagnosticSink, OutputFileConsumer outputSink, final JavaCompilingTool compilingTool, final CanceledStatus cancelStatus) -->Line_3 $$ final ExternalJavacMessageHandler rh = new ExternalJavacMessageHandler(diagnosticSink, outputSink, getEncodingName(options))[ FD ]
Line_2 $$ public boolean forkJavac(final String javaHome, final int heapSize, List<String> vmOptions, List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, Map<File, Set<File>> outs, final DiagnosticOutputConsumer diagnosticSink, OutputFileConsumer outputSink, final JavaCompilingTool compilingTool, final CanceledStatus cancelStatus) -->Line_3 $$ final ExternalJavacMessageHandler rh = new ExternalJavacMessageHandler(diagnosticSink, outputSink, getEncodingName(options))[ CD ]
Line_18 $$ prefix = STDOUT_LINE_PREFIX-->Line_20 $$ prefix = STDERR_LINE_PREFIX[ FD ]
Line_2 $$ public boolean forkJavac(final String javaHome, final int heapSize, List<String> vmOptions, List<String> options, Collection<File> platformCp, Collection<File> classpath, Collection<File> sourcePath, Collection<File> files, Map<File, Set<File>> outs, final DiagnosticOutputConsumer diagnosticSink, OutputFileConsumer outputSink, final JavaCompilingTool compilingTool, final CanceledStatus cancelStatus) -->Line_41 $$ diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, e.getMessage()))[ FD ]
Line_20 $$ prefix = STDERR_LINE_PREFIX-->Line_22 $$ if (prefix != null) [ FD ]
Line_15 $$ if (!StringUtil.isEmptyOrSpaces(text)) -->Line_22 $$ if (prefix != null) [ CD ]
Line_15 $$ if (!StringUtil.isEmptyOrSpaces(text)) -->Line_17 $$ if (outputType == ProcessOutputTypes.STDOUT) [ CD ]
