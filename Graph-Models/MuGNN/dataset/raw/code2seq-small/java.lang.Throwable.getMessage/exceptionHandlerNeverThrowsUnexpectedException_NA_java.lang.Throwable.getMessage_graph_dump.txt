Line_4 $$ TestableAsyncUncaughtExceptionHandler exceptionHandler = new TestableAsyncUncaughtExceptionHandler(true)-->Line_11 $$ exceptionHandler.await(3000)[ FD ]
Line_3 $$ Method m = ReflectionUtils.findMethod(ClassWithException.class, "failWithVoid")-->Line_12 $$ exceptionHandler.assertCalledWith(m, UnsupportedOperationException.class)[ FD ]
Line_8 $$ ClassWithException obj = new ClassWithException()-->Line_10 $$ obj.failWithVoid()[ FD ]
Line_4 $$ TestableAsyncUncaughtExceptionHandler exceptionHandler = new TestableAsyncUncaughtExceptionHandler(true)-->Line_5 $$ AnnotationAsyncExecutionAspect.aspectOf().setExceptionHandler(exceptionHandler)[ FD ]
Line_4 $$ TestableAsyncUncaughtExceptionHandler exceptionHandler = new TestableAsyncUncaughtExceptionHandler(true)-->Line_12 $$ exceptionHandler.assertCalledWith(m, UnsupportedOperationException.class)[ FD ]
Line_2 $$ public void exceptionHandlerNeverThrowsUnexpectedException() -->Line_3 $$ Method m = ReflectionUtils.findMethod(ClassWithException.class, "failWithVoid")[ CD ]
Line_2 $$ public void exceptionHandlerNeverThrowsUnexpectedException() -->Line_4 $$ TestableAsyncUncaughtExceptionHandler exceptionHandler = new TestableAsyncUncaughtExceptionHandler(true)[ CD ]
Line_4 $$ TestableAsyncUncaughtExceptionHandler exceptionHandler = new TestableAsyncUncaughtExceptionHandler(true)-->Line_7 $$ assertFalse("Handler should not have been called", exceptionHandler.isCalled())[ FD ]
Line_2 $$ public void exceptionHandlerNeverThrowsUnexpectedException() -->Line_5 $$ AnnotationAsyncExecutionAspect.aspectOf().setExceptionHandler(exceptionHandler)[ CD ]
