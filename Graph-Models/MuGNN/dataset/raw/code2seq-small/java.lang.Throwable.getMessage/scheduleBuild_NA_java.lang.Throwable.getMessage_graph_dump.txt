Line_76 $$ CharSequence errorsOnLaunch-->Line_114 $$ msg.append("\n").append(errorsOnLaunch)[ FD ]
Line_2 $$ public TaskFuture scheduleBuild(final Project project, final boolean isRebuild, final boolean isMake, final boolean onlyCheckUpToDate, final List<TargetTypeBuildScope> scopes, final Collection<String> paths, final Map<String, String> userData, final DefaultMessageHandler messageHandler) -->Line_104 $$ messageHandler.handleCompileMessage(sessionId, CmdlineProtoUtil.createCompileProgressMessageResponse(message).getCompileMessage())[ FD ]
Line_19 $$ final boolean usingPreloadedProcess = preloadedFuture != null-->Line_30 $$ if (!usingPreloadedProcess && (future.isCancelled() || project.isDisposed())) [ FD ]
Line_51 $$ final CmdlineRemoteProto.Message.ControllerMessage params-->Line_78 $$ final boolean paramsSent = myMessageDispatcher.sendBuildParameters(future.getRequestID(), params)[ FD ]
Line_14 $$ final DelegateFuture<BuilderMessageHandler> _future = new DelegateFuture<BuilderMessageHandler>()-->Line_29 $$ _future.setDelegate(future)[ FD ]
Line_82 $$ processHandler = preloaded.second-->Line_83 $$ errorsOnLaunch = STDERR_OUTPUT.get(processHandler)[ FD ]
Line_53 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, Collections.<String>emptyList(), userData, globals, null)-->Line_55 $$ params = CmdlineProtoUtil.createUpToDateCheckRequest(projectPath, scopes, paths, userData, globals, currentFSChanges)[ FD ]
Line_28 $$ final RequestFuture<? extends BuilderMessageHandler> future = usingPreloadedProcess ? preloadedFuture : new RequestFuture<BuilderMessageHandler>(handler, sessionId, new CancelBuildSessionAction<BuilderMessageHandler>())-->Line_60 $$ myMessageDispatcher.registerBuildMessageHandler(future, params)[ FD ]
Line_26 $$ sessionId = UUID.randomUUID()-->Line_121 $$ handler.handleFailure(sessionId, CmdlineProtoUtil.createFailure(msg.toString(), null))[ FD ]
Line_35 $$ final CmdlineRemoteProto.Message.ControllerMessage.GlobalSettings globals = CmdlineRemoteProto.Message.ControllerMessage.GlobalSettings.newBuilder().setGlobalOptionsPath(PathManager.getOptionsPath()).build()-->Line_57 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, isMake ? Collections.<String>emptyList() : paths, userData, globals, currentFSChanges)[ FD ]
Line_23 $$ sessionId = preloadedFuture.getRequestID()-->Line_121 $$ handler.handleFailure(sessionId, CmdlineProtoUtil.createFailure(msg.toString(), null))[ FD ]
Line_9 $$ final UUID sessionId = UUID.randomUUID()-->Line_26 $$ sessionId = UUID.randomUUID()[ FD ]
Line_36 $$ CmdlineRemoteProto.Message.ControllerMessage.FSEvent currentFSChanges-->Line_48 $$ currentFSChanges = needRescan ? null : data.createNextEvent()[ FD ]
Line_3 $$ final String projectPath = getProjectPath(project)-->Line_53 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, Collections.<String>emptyList(), userData, globals, null)[ FD ]
Line_18 $$ final RequestFuture<PreloadedProcessMessageHandler> preloadedFuture = preloaded != null ? preloaded.first : null-->Line_24 $$ preloadedFuture.getMessageHandler().setDelegateHandler(handler)[ FD ]
Line_68 $$ if (usingPreloadedProcess) -->Line_69 $$ future.cancel(false)[ CD ]
Line_47 $$ needRescan = data.getAndResetRescanFlag()-->Line_85 $$ if (isAutomake && needRescan) [ FD ]
Line_15 $$ runCommand(new Runnable() -->Line_18 $$ final RequestFuture<PreloadedProcessMessageHandler> preloadedFuture = preloaded != null ? preloaded.first : null[ CD ]
Line_36 $$ CmdlineRemoteProto.Message.ControllerMessage.FSEvent currentFSChanges-->Line_57 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, isMake ? Collections.<String>emptyList() : paths, userData, globals, currentFSChanges)[ FD ]
Line_5 $$ final BuilderMessageHandler handler = new NotifyingMessageHandler(project, messageHandler, isAutomake)-->Line_31 $$ handler.sessionTerminated(sessionId)[ FD ]
Line_53 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, Collections.<String>emptyList(), userData, globals, null)-->Line_78 $$ final boolean paramsSent = myMessageDispatcher.sendBuildParameters(future.getRequestID(), params)[ FD ]
Line_113 $$ if (errorsOnLaunch != null && errorsOnLaunch.length() > 0) -->Line_119 $$ msg.append("unknown error")[ CD ]
Line_75 $$ final OSProcessHandler processHandler-->Line_98 $$ processHandler.addProcessListener(new StdOutputCollector((StringBuffer) errorsOnLaunch))[ FD ]
Line_9 $$ final UUID sessionId = UUID.randomUUID()-->Line_146 $$ handleProcessExecutionFailure(sessionId, e)[ FD ]
Line_110 $$ if (exitValue != 0) -->Line_112 $$ msg.append("Abnormal build process termination: ")[ CD ]
Line_41 $$ if (isRebuild) -->Line_42 $$ data.dropChanges()[ CD ]
Line_38 $$ final boolean needRescan-->Line_85 $$ if (isAutomake && needRescan) [ FD ]
Line_3 $$ final String projectPath = getProjectPath(project)-->Line_57 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, isMake ? Collections.<String>emptyList() : paths, userData, globals, currentFSChanges)[ FD ]
Line_82 $$ processHandler = preloaded.second-->Line_99 $$ processHandler.startNotify()[ FD ]
Line_2 $$ public TaskFuture scheduleBuild(final Project project, final boolean isRebuild, final boolean isMake, final boolean onlyCheckUpToDate, final List<TargetTypeBuildScope> scopes, final Collection<String> paths, final Map<String, String> userData, final DefaultMessageHandler messageHandler) -->Line_67 $$ if (project.isDisposed()) [ FD ]
Line_57 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, isMake ? Collections.<String>emptyList() : paths, userData, globals, currentFSChanges)-->Line_78 $$ final boolean paramsSent = myMessageDispatcher.sendBuildParameters(future.getRequestID(), params)[ FD ]
Line_82 $$ processHandler = preloaded.second-->Line_101 $$ Integer debugPort = processHandler.getUserData(COMPILER_PROCESS_DEBUG_PORT)[ FD ]
Line_9 $$ final UUID sessionId = UUID.randomUUID()-->Line_104 $$ messageHandler.handleCompileMessage(sessionId, CmdlineProtoUtil.createCompileProgressMessageResponse(message).getCompileMessage())[ FD ]
Line_23 $$ sessionId = preloadedFuture.getRequestID()-->Line_104 $$ messageHandler.handleCompileMessage(sessionId, CmdlineProtoUtil.createCompileProgressMessageResponse(message).getCompileMessage())[ FD ]
Line_83 $$ errorsOnLaunch = STDERR_OUTPUT.get(processHandler)-->Line_113 $$ if (errorsOnLaunch != null && errorsOnLaunch.length() > 0) [ FD ]
Line_113 $$ if (errorsOnLaunch != null && errorsOnLaunch.length() > 0) -->Line_114 $$ msg.append("\n").append(errorsOnLaunch)[ CD ]
Line_75 $$ final OSProcessHandler processHandler-->Line_82 $$ processHandler = preloaded.second[ FD ]
Line_9 $$ final UUID sessionId = UUID.randomUUID()-->Line_121 $$ handler.handleFailure(sessionId, CmdlineProtoUtil.createFailure(msg.toString(), null))[ FD ]
Line_20 $$ final UUID sessionId-->Line_31 $$ handler.sessionTerminated(sessionId)[ FD ]
Line_75 $$ final OSProcessHandler processHandler-->Line_99 $$ processHandler.startNotify()[ FD ]
Line_54 $$ if (onlyCheckUpToDate) -->Line_55 $$ params = CmdlineProtoUtil.createUpToDateCheckRequest(projectPath, scopes, paths, userData, globals, currentFSChanges)[ CD ]
Line_75 $$ final OSProcessHandler processHandler-->Line_101 $$ Integer debugPort = processHandler.getUserData(COMPILER_PROCESS_DEBUG_PORT)[ FD ]
Line_2 $$ public TaskFuture scheduleBuild(final Project project, final boolean isRebuild, final boolean isMake, final boolean onlyCheckUpToDate, final List<TargetTypeBuildScope> scopes, final Collection<String> paths, final Map<String, String> userData, final DefaultMessageHandler messageHandler) -->Line_96 $$ processHandler = launchBuildProcess(project, myListenPort, sessionId, false)[ FD ]
Line_5 $$ final BuilderMessageHandler handler = new NotifyingMessageHandler(project, messageHandler, isAutomake)-->Line_11 $$ handler.sessionTerminated(sessionId)[ FD ]
Line_76 $$ CharSequence errorsOnLaunch-->Line_83 $$ errorsOnLaunch = STDERR_OUTPUT.get(processHandler)[ FD ]
Line_110 $$ if (exitValue != 0) -->Line_113 $$ if (errorsOnLaunch != null && errorsOnLaunch.length() > 0) [ CD ]
Line_9 $$ final UUID sessionId = UUID.randomUUID()-->Line_10 $$ handler.handleFailure(sessionId, CmdlineProtoUtil.createFailure(e.getMessage(), null))[ FD ]
Line_28 $$ final RequestFuture<? extends BuilderMessageHandler> future = usingPreloadedProcess ? preloadedFuture : new RequestFuture<BuilderMessageHandler>(handler, sessionId, new CancelBuildSessionAction<BuilderMessageHandler>())-->Line_30 $$ if (!usingPreloadedProcess && (future.isCancelled() || project.isDisposed())) [ FD ]
Line_87 $$ SwingUtilities.invokeAndWait(new Runnable() -->Line_89 $$ project.save()[ CD ]
Line_20 $$ final UUID sessionId-->Line_96 $$ processHandler = launchBuildProcess(project, myListenPort, sessionId, false)[ FD ]
Line_28 $$ final RequestFuture<? extends BuilderMessageHandler> future = usingPreloadedProcess ? preloadedFuture : new RequestFuture<BuilderMessageHandler>(handler, sessionId, new CancelBuildSessionAction<BuilderMessageHandler>())-->Line_78 $$ final boolean paramsSent = myMessageDispatcher.sendBuildParameters(future.getRequestID(), params)[ FD ]
Line_26 $$ sessionId = UUID.randomUUID()-->Line_96 $$ processHandler = launchBuildProcess(project, myListenPort, sessionId, false)[ FD ]
Line_23 $$ sessionId = preloadedFuture.getRequestID()-->Line_31 $$ handler.sessionTerminated(sessionId)[ FD ]
Line_20 $$ final UUID sessionId-->Line_104 $$ messageHandler.handleCompileMessage(sessionId, CmdlineProtoUtil.createCompileProgressMessageResponse(message).getCompileMessage())[ FD ]
Line_28 $$ final RequestFuture<? extends BuilderMessageHandler> future = usingPreloadedProcess ? preloadedFuture : new RequestFuture<BuilderMessageHandler>(handler, sessionId, new CancelBuildSessionAction<BuilderMessageHandler>())-->Line_29 $$ _future.setDelegate(future)[ FD ]
Line_2 $$ public TaskFuture scheduleBuild(final Project project, final boolean isRebuild, final boolean isMake, final boolean onlyCheckUpToDate, final List<TargetTypeBuildScope> scopes, final Collection<String> paths, final Map<String, String> userData, final DefaultMessageHandler messageHandler) -->Line_53 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, Collections.<String>emptyList(), userData, globals, null)[ FD ]
Line_48 $$ currentFSChanges = needRescan ? null : data.createNextEvent()-->Line_55 $$ params = CmdlineProtoUtil.createUpToDateCheckRequest(projectPath, scopes, paths, userData, globals, currentFSChanges)[ FD ]
Line_3 $$ final String projectPath = getProjectPath(project)-->Line_126 $$ myBuildsInProgress.remove(projectPath)[ FD ]
Line_26 $$ sessionId = UUID.randomUUID()-->Line_31 $$ handler.sessionTerminated(sessionId)[ FD ]
Line_20 $$ final UUID sessionId-->Line_121 $$ handler.handleFailure(sessionId, CmdlineProtoUtil.createFailure(msg.toString(), null))[ FD ]
Line_30 $$ if (!usingPreloadedProcess && (future.isCancelled() || project.isDisposed())) -->Line_32 $$ ((BasicFuture) future).setDone()[ CD ]
Line_23 $$ sessionId = preloadedFuture.getRequestID()-->Line_96 $$ processHandler = launchBuildProcess(project, myListenPort, sessionId, false)[ FD ]
Line_48 $$ currentFSChanges = needRescan ? null : data.createNextEvent()-->Line_57 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, isMake ? Collections.<String>emptyList() : paths, userData, globals, currentFSChanges)[ FD ]
Line_30 $$ if (!usingPreloadedProcess && (future.isCancelled() || project.isDisposed())) -->Line_33 $$ return[ CD ]
Line_3 $$ final String projectPath = getProjectPath(project)-->Line_17 $$ final Pair<RequestFuture<PreloadedProcessMessageHandler>, OSProcessHandler> preloaded = takePreloadedProcess(projectPath)[ FD ]
Line_40 $$ final ProjectData data = getProjectData(projectPath)-->Line_42 $$ data.dropChanges()[ FD ]
Line_37 $$ final SequentialTaskExecutor projectTaskQueue-->Line_133 $$ final Future<Pair<RequestFuture<PreloadedProcessMessageHandler>, OSProcessHandler>> preloadResult = launchPreloadedBuildProcess(project, projectTaskQueue)[ FD ]
Line_49 $$ projectTaskQueue = data.taskQueue-->Line_63 $$ projectTaskQueue.submit(new Runnable() [ FD ]
Line_15 $$ runCommand(new Runnable() -->Line_17 $$ final Pair<RequestFuture<PreloadedProcessMessageHandler>, OSProcessHandler> preloaded = takePreloadedProcess(projectPath)[ CD ]
Line_3 $$ final String projectPath = getProjectPath(project)-->Line_55 $$ params = CmdlineProtoUtil.createUpToDateCheckRequest(projectPath, scopes, paths, userData, globals, currentFSChanges)[ FD ]
Line_23 $$ sessionId = preloadedFuture.getRequestID()-->Line_26 $$ sessionId = UUID.randomUUID()[ FD ]
Line_76 $$ CharSequence errorsOnLaunch-->Line_115 $$ if (StringUtil.contains(errorsOnLaunch, "java.lang.NoSuchMethodError")) [ FD ]
Line_2 $$ public TaskFuture scheduleBuild(final Project project, final boolean isRebuild, final boolean isMake, final boolean onlyCheckUpToDate, final List<TargetTypeBuildScope> scopes, final Collection<String> paths, final Map<String, String> userData, final DefaultMessageHandler messageHandler) -->Line_30 $$ if (!usingPreloadedProcess && (future.isCancelled() || project.isDisposed())) [ FD ]
Line_19 $$ final boolean usingPreloadedProcess = preloadedFuture != null-->Line_59 $$ if (!usingPreloadedProcess) [ FD ]
Line_2 $$ public TaskFuture scheduleBuild(final Project project, final boolean isRebuild, final boolean isMake, final boolean onlyCheckUpToDate, final List<TargetTypeBuildScope> scopes, final Collection<String> paths, final Map<String, String> userData, final DefaultMessageHandler messageHandler) -->Line_5 $$ final BuilderMessageHandler handler = new NotifyingMessageHandler(project, messageHandler, isAutomake)[ CD ]
Line_52 $$ if (isRebuild) -->Line_53 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, Collections.<String>emptyList(), userData, globals, null)[ CD ]
Line_21 $$ if (usingPreloadedProcess) -->Line_26 $$ sessionId = UUID.randomUUID()[ CD ]
Line_37 $$ final SequentialTaskExecutor projectTaskQueue-->Line_63 $$ projectTaskQueue.submit(new Runnable() [ FD ]
Line_52 $$ if (isRebuild) -->Line_54 $$ if (onlyCheckUpToDate) [ CD ]
Line_40 $$ final ProjectData data = getProjectData(projectPath)-->Line_48 $$ currentFSChanges = needRescan ? null : data.createNextEvent()[ FD ]
Line_18 $$ final RequestFuture<PreloadedProcessMessageHandler> preloadedFuture = preloaded != null ? preloaded.first : null-->Line_23 $$ sessionId = preloadedFuture.getRequestID()[ FD ]
Line_2 $$ public TaskFuture scheduleBuild(final Project project, final boolean isRebuild, final boolean isMake, final boolean onlyCheckUpToDate, final List<TargetTypeBuildScope> scopes, final Collection<String> paths, final Map<String, String> userData, final DefaultMessageHandler messageHandler) -->Line_15 $$ runCommand(new Runnable() [ CD ]
Line_15 $$ runCommand(new Runnable() -->Line_29 $$ _future.setDelegate(future)[ CD ]
Line_77 $$ if (usingPreloadedProcess) -->Line_78 $$ final boolean paramsSent = myMessageDispatcher.sendBuildParameters(future.getRequestID(), params)[ CD ]
Line_15 $$ runCommand(new Runnable() -->Line_59 $$ if (!usingPreloadedProcess) [ CD ]
Line_79 $$ if (!paramsSent) -->Line_80 $$ myMessageDispatcher.cancelSession(future.getRequestID())[ CD ]
Line_21 $$ if (usingPreloadedProcess) -->Line_23 $$ sessionId = preloadedFuture.getRequestID()[ CD ]
Line_30 $$ if (!usingPreloadedProcess && (future.isCancelled() || project.isDisposed())) -->Line_31 $$ handler.sessionTerminated(sessionId)[ CD ]
Line_2 $$ public TaskFuture scheduleBuild(final Project project, final boolean isRebuild, final boolean isMake, final boolean onlyCheckUpToDate, final List<TargetTypeBuildScope> scopes, final Collection<String> paths, final Map<String, String> userData, final DefaultMessageHandler messageHandler) -->Line_14 $$ final DelegateFuture<BuilderMessageHandler> _future = new DelegateFuture<BuilderMessageHandler>()[ CD ]
Line_51 $$ final CmdlineRemoteProto.Message.ControllerMessage params-->Line_60 $$ myMessageDispatcher.registerBuildMessageHandler(future, params)[ FD ]
Line_9 $$ final UUID sessionId = UUID.randomUUID()-->Line_31 $$ handler.sessionTerminated(sessionId)[ FD ]
Line_9 $$ final UUID sessionId = UUID.randomUUID()-->Line_23 $$ sessionId = preloadedFuture.getRequestID()[ FD ]
Line_38 $$ final boolean needRescan-->Line_47 $$ needRescan = data.getAndResetRescanFlag()[ FD ]
Line_77 $$ if (usingPreloadedProcess) -->Line_96 $$ processHandler = launchBuildProcess(project, myListenPort, sessionId, false)[ CD ]
Line_5 $$ final BuilderMessageHandler handler = new NotifyingMessageHandler(project, messageHandler, isAutomake)-->Line_121 $$ handler.handleFailure(sessionId, CmdlineProtoUtil.createFailure(msg.toString(), null))[ FD ]
Line_51 $$ final CmdlineRemoteProto.Message.ControllerMessage params-->Line_55 $$ params = CmdlineProtoUtil.createUpToDateCheckRequest(projectPath, scopes, paths, userData, globals, currentFSChanges)[ FD ]
Line_51 $$ final CmdlineRemoteProto.Message.ControllerMessage params-->Line_57 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, isMake ? Collections.<String>emptyList() : paths, userData, globals, currentFSChanges)[ FD ]
Line_2 $$ public TaskFuture scheduleBuild(final Project project, final boolean isRebuild, final boolean isMake, final boolean onlyCheckUpToDate, final List<TargetTypeBuildScope> scopes, final Collection<String> paths, final Map<String, String> userData, final DefaultMessageHandler messageHandler) -->Line_150 $$ return _future[ CD ]
Line_21 $$ if (usingPreloadedProcess) -->Line_22 $$ LOG.info("Using preloaded build process to compile " + projectPath)[ CD ]
Line_15 $$ runCommand(new Runnable() -->Line_30 $$ if (!usingPreloadedProcess && (future.isCancelled() || project.isDisposed())) [ CD ]
Line_26 $$ sessionId = UUID.randomUUID()-->Line_104 $$ messageHandler.handleCompileMessage(sessionId, CmdlineProtoUtil.createCompileProgressMessageResponse(message).getCompileMessage())[ FD ]
Line_59 $$ if (!usingPreloadedProcess) -->Line_60 $$ myMessageDispatcher.registerBuildMessageHandler(future, params)[ CD ]
Line_55 $$ params = CmdlineProtoUtil.createUpToDateCheckRequest(projectPath, scopes, paths, userData, globals, currentFSChanges)-->Line_78 $$ final boolean paramsSent = myMessageDispatcher.sendBuildParameters(future.getRequestID(), params)[ FD ]
Line_55 $$ params = CmdlineProtoUtil.createUpToDateCheckRequest(projectPath, scopes, paths, userData, globals, currentFSChanges)-->Line_60 $$ myMessageDispatcher.registerBuildMessageHandler(future, params)[ FD ]
Line_2 $$ public TaskFuture scheduleBuild(final Project project, final boolean isRebuild, final boolean isMake, final boolean onlyCheckUpToDate, final List<TargetTypeBuildScope> scopes, final Collection<String> paths, final Map<String, String> userData, final DefaultMessageHandler messageHandler) -->Line_57 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, isMake ? Collections.<String>emptyList() : paths, userData, globals, currentFSChanges)[ FD ]
Line_82 $$ processHandler = preloaded.second-->Line_106 $$ while (!processHandler.waitFor()) [ FD ]
Line_83 $$ errorsOnLaunch = STDERR_OUTPUT.get(processHandler)-->Line_114 $$ msg.append("\n").append(errorsOnLaunch)[ FD ]
Line_102 $$ if (debugPort != null) -->Line_104 $$ messageHandler.handleCompileMessage(sessionId, CmdlineProtoUtil.createCompileProgressMessageResponse(message).getCompileMessage())[ CD ]
Line_75 $$ final OSProcessHandler processHandler-->Line_109 $$ final int exitValue = processHandler.getProcess().exitValue()[ FD ]
Line_78 $$ final boolean paramsSent = myMessageDispatcher.sendBuildParameters(future.getRequestID(), params)-->Line_79 $$ if (!paramsSent) [ FD ]
Line_77 $$ if (usingPreloadedProcess) -->Line_85 $$ if (isAutomake && needRescan) [ CD ]
Line_23 $$ sessionId = preloadedFuture.getRequestID()-->Line_127 $$ notifySessionTerminationIfNeeded(sessionId, execFailure)[ FD ]
Line_9 $$ final UUID sessionId = UUID.randomUUID()-->Line_127 $$ notifySessionTerminationIfNeeded(sessionId, execFailure)[ FD ]
Line_2 $$ public TaskFuture scheduleBuild(final Project project, final boolean isRebuild, final boolean isMake, final boolean onlyCheckUpToDate, final List<TargetTypeBuildScope> scopes, final Collection<String> paths, final Map<String, String> userData, final DefaultMessageHandler messageHandler) -->Line_128 $$ if (isProcessPreloadingEnabled(project)) [ FD ]
Line_5 $$ final BuilderMessageHandler handler = new NotifyingMessageHandler(project, messageHandler, isAutomake)-->Line_24 $$ preloadedFuture.getMessageHandler().setDelegateHandler(handler)[ FD ]
Line_49 $$ projectTaskQueue = data.taskQueue-->Line_133 $$ final Future<Pair<RequestFuture<PreloadedProcessMessageHandler>, OSProcessHandler>> preloadResult = launchPreloadedBuildProcess(project, projectTaskQueue)[ FD ]
Line_55 $$ params = CmdlineProtoUtil.createUpToDateCheckRequest(projectPath, scopes, paths, userData, globals, currentFSChanges)-->Line_57 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, isMake ? Collections.<String>emptyList() : paths, userData, globals, currentFSChanges)[ FD ]
Line_77 $$ if (usingPreloadedProcess) -->Line_83 $$ errorsOnLaunch = STDERR_OUTPUT.get(processHandler)[ CD ]
Line_2 $$ public TaskFuture scheduleBuild(final Project project, final boolean isRebuild, final boolean isMake, final boolean onlyCheckUpToDate, final List<TargetTypeBuildScope> scopes, final Collection<String> paths, final Map<String, String> userData, final DefaultMessageHandler messageHandler) -->Line_89 $$ project.save()[ FD ]
Line_21 $$ if (usingPreloadedProcess) -->Line_24 $$ preloadedFuture.getMessageHandler().setDelegateHandler(handler)[ CD ]
Line_36 $$ CmdlineRemoteProto.Message.ControllerMessage.FSEvent currentFSChanges-->Line_55 $$ params = CmdlineProtoUtil.createUpToDateCheckRequest(projectPath, scopes, paths, userData, globals, currentFSChanges)[ FD ]
Line_9 $$ final UUID sessionId = UUID.randomUUID()-->Line_96 $$ processHandler = launchBuildProcess(project, myListenPort, sessionId, false)[ FD ]
Line_2 $$ public TaskFuture scheduleBuild(final Project project, final boolean isRebuild, final boolean isMake, final boolean onlyCheckUpToDate, final List<TargetTypeBuildScope> scopes, final Collection<String> paths, final Map<String, String> userData, final DefaultMessageHandler messageHandler) -->Line_3 $$ final String projectPath = getProjectPath(project)[ CD ]
Line_77 $$ if (usingPreloadedProcess) -->Line_82 $$ processHandler = preloaded.second[ CD ]
Line_35 $$ final CmdlineRemoteProto.Message.ControllerMessage.GlobalSettings globals = CmdlineRemoteProto.Message.ControllerMessage.GlobalSettings.newBuilder().setGlobalOptionsPath(PathManager.getOptionsPath()).build()-->Line_53 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, Collections.<String>emptyList(), userData, globals, null)[ FD ]
Line_20 $$ final UUID sessionId-->Line_26 $$ sessionId = UUID.randomUUID()[ FD ]
Line_133 $$ final Future<Pair<RequestFuture<PreloadedProcessMessageHandler>, OSProcessHandler>> preloadResult = launchPreloadedBuildProcess(project, projectTaskQueue)-->Line_134 $$ myPreloadedBuilds.put(projectPath, preloadResult)[ FD ]
Line_82 $$ processHandler = preloaded.second-->Line_98 $$ processHandler.addProcessListener(new StdOutputCollector((StringBuffer) errorsOnLaunch))[ FD ]
Line_113 $$ if (errorsOnLaunch != null && errorsOnLaunch.length() > 0) -->Line_115 $$ if (StringUtil.contains(errorsOnLaunch, "java.lang.NoSuchMethodError")) [ CD ]
Line_23 $$ sessionId = preloadedFuture.getRequestID()-->Line_146 $$ handleProcessExecutionFailure(sessionId, e)[ FD ]
Line_28 $$ final RequestFuture<? extends BuilderMessageHandler> future = usingPreloadedProcess ? preloadedFuture : new RequestFuture<BuilderMessageHandler>(handler, sessionId, new CancelBuildSessionAction<BuilderMessageHandler>())-->Line_74 $$ myBuildsInProgress.put(projectPath, future)[ FD ]
Line_65 $$ Throwable execFailure = null-->Line_127 $$ notifySessionTerminationIfNeeded(sessionId, execFailure)[ FD ]
Line_15 $$ runCommand(new Runnable() -->Line_51 $$ final CmdlineRemoteProto.Message.ControllerMessage params[ CD ]
Line_68 $$ if (usingPreloadedProcess) -->Line_71 $$ return[ CD ]
Line_82 $$ processHandler = preloaded.second-->Line_109 $$ final int exitValue = processHandler.getProcess().exitValue()[ FD ]
Line_3 $$ final String projectPath = getProjectPath(project)-->Line_40 $$ final ProjectData data = getProjectData(projectPath)[ FD ]
Line_77 $$ if (usingPreloadedProcess) -->Line_98 $$ processHandler.addProcessListener(new StdOutputCollector((StringBuffer) errorsOnLaunch))[ CD ]
Line_83 $$ errorsOnLaunch = STDERR_OUTPUT.get(processHandler)-->Line_115 $$ if (StringUtil.contains(errorsOnLaunch, "java.lang.NoSuchMethodError")) [ FD ]
Line_57 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, isMake ? Collections.<String>emptyList() : paths, userData, globals, currentFSChanges)-->Line_60 $$ myMessageDispatcher.registerBuildMessageHandler(future, params)[ FD ]
Line_9 $$ final UUID sessionId = UUID.randomUUID()-->Line_11 $$ handler.sessionTerminated(sessionId)[ FD ]
Line_15 $$ runCommand(new Runnable() -->Line_52 $$ if (isRebuild) [ CD ]
Line_3 $$ final String projectPath = getProjectPath(project)-->Line_131 $$ if (!myPreloadedBuilds.containsKey(projectPath)) [ FD ]
Line_44 $$ if (IS_UNIT_TEST_MODE) -->Line_45 $$ LOG.info("Scheduling build for " + projectPath + "; CHANGED: " + new HashSet<String>(convertToStringPaths(data.myChanged)) + "; DELETED: " + new HashSet<String>(convertToStringPaths(data.myDeleted)))[ CD ]
Line_35 $$ final CmdlineRemoteProto.Message.ControllerMessage.GlobalSettings globals = CmdlineRemoteProto.Message.ControllerMessage.GlobalSettings.newBuilder().setGlobalOptionsPath(PathManager.getOptionsPath()).build()-->Line_55 $$ params = CmdlineProtoUtil.createUpToDateCheckRequest(projectPath, scopes, paths, userData, globals, currentFSChanges)[ FD ]
Line_20 $$ final UUID sessionId-->Line_127 $$ notifySessionTerminationIfNeeded(sessionId, execFailure)[ FD ]
Line_28 $$ final RequestFuture<? extends BuilderMessageHandler> future = usingPreloadedProcess ? preloadedFuture : new RequestFuture<BuilderMessageHandler>(handler, sessionId, new CancelBuildSessionAction<BuilderMessageHandler>())-->Line_69 $$ future.cancel(false)[ FD ]
Line_75 $$ final OSProcessHandler processHandler-->Line_106 $$ while (!processHandler.waitFor()) [ FD ]
Line_15 $$ runCommand(new Runnable() -->Line_19 $$ final boolean usingPreloadedProcess = preloadedFuture != null[ CD ]
Line_76 $$ CharSequence errorsOnLaunch-->Line_113 $$ if (errorsOnLaunch != null && errorsOnLaunch.length() > 0) [ FD ]
Line_115 $$ if (StringUtil.contains(errorsOnLaunch, "java.lang.NoSuchMethodError")) -->Line_116 $$ msg.append("\nThe error may be caused by JARs in Java Extensions directory which conflicts with libraries used by the external build process.").append("\nTry adding -Djava.ext.dirs=\"\" argument to 'Build process VM options' in File | Settings | Build, Execution, Deployment | Compiler to fix the problem.")[ CD ]
Line_2 $$ public TaskFuture scheduleBuild(final Project project, final boolean isRebuild, final boolean isMake, final boolean onlyCheckUpToDate, final List<TargetTypeBuildScope> scopes, final Collection<String> paths, final Map<String, String> userData, final DefaultMessageHandler messageHandler) -->Line_3 $$ final String projectPath = getProjectPath(project)[ FD ]
Line_53 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, Collections.<String>emptyList(), userData, globals, null)-->Line_60 $$ myMessageDispatcher.registerBuildMessageHandler(future, params)[ FD ]
Line_75 $$ final OSProcessHandler processHandler-->Line_83 $$ errorsOnLaunch = STDERR_OUTPUT.get(processHandler)[ FD ]
Line_15 $$ runCommand(new Runnable() -->Line_38 $$ final boolean needRescan[ CD ]
Line_2 $$ public TaskFuture scheduleBuild(final Project project, final boolean isRebuild, final boolean isMake, final boolean onlyCheckUpToDate, final List<TargetTypeBuildScope> scopes, final Collection<String> paths, final Map<String, String> userData, final DefaultMessageHandler messageHandler) -->Line_133 $$ final Future<Pair<RequestFuture<PreloadedProcessMessageHandler>, OSProcessHandler>> preloadResult = launchPreloadedBuildProcess(project, projectTaskQueue)[ FD ]
Line_128 $$ if (isProcessPreloadingEnabled(project)) -->Line_129 $$ runCommand(new Runnable() [ CD ]
Line_51 $$ final CmdlineRemoteProto.Message.ControllerMessage params-->Line_53 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, Collections.<String>emptyList(), userData, globals, null)[ FD ]
Line_15 $$ runCommand(new Runnable() -->Line_36 $$ CmdlineRemoteProto.Message.ControllerMessage.FSEvent currentFSChanges[ CD ]
Line_54 $$ if (onlyCheckUpToDate) -->Line_57 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, isMake ? Collections.<String>emptyList() : paths, userData, globals, currentFSChanges)[ CD ]
Line_5 $$ final BuilderMessageHandler handler = new NotifyingMessageHandler(project, messageHandler, isAutomake)-->Line_10 $$ handler.handleFailure(sessionId, CmdlineProtoUtil.createFailure(e.getMessage(), null))[ FD ]
Line_3 $$ final String projectPath = getProjectPath(project)-->Line_74 $$ myBuildsInProgress.put(projectPath, future)[ FD ]
Line_2 $$ public TaskFuture scheduleBuild(final Project project, final boolean isRebuild, final boolean isMake, final boolean onlyCheckUpToDate, final List<TargetTypeBuildScope> scopes, final Collection<String> paths, final Map<String, String> userData, final DefaultMessageHandler messageHandler) -->Line_52 $$ if (isRebuild) [ FD ]
Line_77 $$ if (usingPreloadedProcess) -->Line_79 $$ if (!paramsSent) [ CD ]
Line_77 $$ if (usingPreloadedProcess) -->Line_99 $$ processHandler.startNotify()[ CD ]
Line_26 $$ sessionId = UUID.randomUUID()-->Line_127 $$ notifySessionTerminationIfNeeded(sessionId, execFailure)[ FD ]
Line_15 $$ runCommand(new Runnable() -->Line_28 $$ final RequestFuture<? extends BuilderMessageHandler> future = usingPreloadedProcess ? preloadedFuture : new RequestFuture<BuilderMessageHandler>(handler, sessionId, new CancelBuildSessionAction<BuilderMessageHandler>())[ CD ]
Line_26 $$ sessionId = UUID.randomUUID()-->Line_146 $$ handleProcessExecutionFailure(sessionId, e)[ FD ]
Line_4 $$ final boolean isAutomake = messageHandler instanceof AutoMakeMessageHandler-->Line_85 $$ if (isAutomake && needRescan) [ FD ]
Line_67 $$ if (project.isDisposed()) -->Line_68 $$ if (usingPreloadedProcess) [ CD ]
Line_15 $$ runCommand(new Runnable() -->Line_20 $$ final UUID sessionId[ CD ]
Line_129 $$ runCommand(new Runnable() -->Line_131 $$ if (!myPreloadedBuilds.containsKey(projectPath)) [ CD ]
Line_106 $$ while (!processHandler.waitFor()) -->Line_107 $$ LOG.info("processHandler.waitFor() returned false for session " + sessionId + ", continue waiting")[ CD ]
Line_15 $$ runCommand(new Runnable() -->Line_21 $$ if (usingPreloadedProcess) [ CD ]
Line_37 $$ final SequentialTaskExecutor projectTaskQueue-->Line_49 $$ projectTaskQueue = data.taskQueue[ FD ]
Line_2 $$ public TaskFuture scheduleBuild(final Project project, final boolean isRebuild, final boolean isMake, final boolean onlyCheckUpToDate, final List<TargetTypeBuildScope> scopes, final Collection<String> paths, final Map<String, String> userData, final DefaultMessageHandler messageHandler) -->Line_4 $$ final boolean isAutomake = messageHandler instanceof AutoMakeMessageHandler[ CD ]
Line_28 $$ final RequestFuture<? extends BuilderMessageHandler> future = usingPreloadedProcess ? preloadedFuture : new RequestFuture<BuilderMessageHandler>(handler, sessionId, new CancelBuildSessionAction<BuilderMessageHandler>())-->Line_80 $$ myMessageDispatcher.cancelSession(future.getRequestID())[ FD ]
Line_53 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, Collections.<String>emptyList(), userData, globals, null)-->Line_57 $$ params = CmdlineProtoUtil.createBuildRequest(projectPath, scopes, isMake ? Collections.<String>emptyList() : paths, userData, globals, currentFSChanges)[ FD ]
Line_15 $$ runCommand(new Runnable() -->Line_37 $$ final SequentialTaskExecutor projectTaskQueue[ CD ]
Line_2 $$ public TaskFuture scheduleBuild(final Project project, final boolean isRebuild, final boolean isMake, final boolean onlyCheckUpToDate, final List<TargetTypeBuildScope> scopes, final Collection<String> paths, final Map<String, String> userData, final DefaultMessageHandler messageHandler) -->Line_55 $$ params = CmdlineProtoUtil.createUpToDateCheckRequest(projectPath, scopes, paths, userData, globals, currentFSChanges)[ FD ]
Line_40 $$ final ProjectData data = getProjectData(projectPath)-->Line_47 $$ needRescan = data.getAndResetRescanFlag()[ FD ]
Line_63 $$ projectTaskQueue.submit(new Runnable() -->Line_65 $$ Throwable execFailure = null[ CD ]
Line_3 $$ final String projectPath = getProjectPath(project)-->Line_134 $$ myPreloadedBuilds.put(projectPath, preloadResult)[ FD ]
Line_20 $$ final UUID sessionId-->Line_23 $$ sessionId = preloadedFuture.getRequestID()[ FD ]
Line_15 $$ runCommand(new Runnable() -->Line_35 $$ final CmdlineRemoteProto.Message.ControllerMessage.GlobalSettings globals = CmdlineRemoteProto.Message.ControllerMessage.GlobalSettings.newBuilder().setGlobalOptionsPath(PathManager.getOptionsPath()).build()[ CD ]
Line_20 $$ final UUID sessionId-->Line_146 $$ handleProcessExecutionFailure(sessionId, e)[ FD ]
Line_110 $$ if (exitValue != 0) -->Line_121 $$ handler.handleFailure(sessionId, CmdlineProtoUtil.createFailure(msg.toString(), null))[ CD ]
