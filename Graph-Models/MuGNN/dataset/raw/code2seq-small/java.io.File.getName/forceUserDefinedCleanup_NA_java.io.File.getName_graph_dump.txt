Line_11 $$ ColumnFamilyStore cfs = Keyspace.open(desc.ksname).getColumnFamilyStore(desc.cfname)-->Line_21 $$ SSTableReader sstable = lookupSSTable(cfs, entry.getValue())[ FD ]
Line_16 $$ for (Map.Entry<ColumnFamilyStore, Descriptor> entry : descriptors.entrySet()) -->Line_21 $$ SSTableReader sstable = lookupSSTable(cfs, entry.getValue())[ FD ]
Line_7 $$ if (Schema.instance.getCFMetaData(desc) == null) -->Line_8 $$ logger.warn("Schema does not exist for file [ CD ]
Line_4 $$ HashMap<ColumnFamilyStore, Descriptor> descriptors = Maps.newHashMap()-->Line_16 $$ for (Map.Entry<ColumnFamilyStore, Descriptor> entry : descriptors.entrySet()) [ FD ]
Line_2 $$ public void forceUserDefinedCleanup(String dataFiles) -->Line_3 $$ String[] filenames = dataFiles.split(",")[ CD ]
Line_30 $$ CleanupStrategy cleanupStrategy = CleanupStrategy.get(cfs, ranges, FBUtilities.nowInSeconds())-->Line_32 $$ doCleanupOne(cfs, txn, cleanupStrategy, ranges, hasIndexes)[ FD ]
Line_19 $$ Collection<Range<Token>> ranges = StorageService.instance.getLocalRanges(keyspace.getName())-->Line_32 $$ doCleanupOne(cfs, txn, cleanupStrategy, ranges, hasIndexes)[ FD ]
Line_5 $$ for (String filename : filenames) -->Line_6 $$ Descriptor desc = Descriptor.fromFilename(filename.trim())[ FD ]
Line_18 $$ Keyspace keyspace = cfs.keyspace-->Line_19 $$ Collection<Range<Token>> ranges = StorageService.instance.getLocalRanges(keyspace.getName())[ FD ]
Line_21 $$ SSTableReader sstable = lookupSSTable(cfs, entry.getValue())-->Line_29 $$ LifecycleTransaction txn = cfs.getTracker().tryModify(sstable, OperationType.CLEANUP)[ FD ]
Line_22 $$ if (ranges.isEmpty()) -->Line_23 $$ logger.error("Cleanup cannot run before a node has joined the ring")[ CD ]
Line_11 $$ ColumnFamilyStore cfs = Keyspace.open(desc.ksname).getColumnFamilyStore(desc.cfname)-->Line_30 $$ CleanupStrategy cleanupStrategy = CleanupStrategy.get(cfs, ranges, FBUtilities.nowInSeconds())[ FD ]
Line_19 $$ Collection<Range<Token>> ranges = StorageService.instance.getLocalRanges(keyspace.getName())-->Line_30 $$ CleanupStrategy cleanupStrategy = CleanupStrategy.get(cfs, ranges, FBUtilities.nowInSeconds())[ FD ]
Line_22 $$ if (ranges.isEmpty()) -->Line_24 $$ return[ CD ]
Line_26 $$ if (sstable == null) -->Line_30 $$ CleanupStrategy cleanupStrategy = CleanupStrategy.get(cfs, ranges, FBUtilities.nowInSeconds())[ CD ]
Line_29 $$ LifecycleTransaction txn = cfs.getTracker().tryModify(sstable, OperationType.CLEANUP)-->Line_32 $$ doCleanupOne(cfs, txn, cleanupStrategy, ranges, hasIndexes)[ FD ]
Line_6 $$ Descriptor desc = Descriptor.fromFilename(filename.trim())-->Line_14 $$ descriptors.put(cfs, desc)[ FD ]
Line_13 $$ if (desc != null)-->Line_14 $$ descriptors.put(cfs, desc)[ CD ]
Line_26 $$ if (sstable == null) -->Line_29 $$ LifecycleTransaction txn = cfs.getTracker().tryModify(sstable, OperationType.CLEANUP)[ CD ]
Line_12 $$ desc = cfs.getDirectories().find(new File(filename.trim()).getName())-->Line_14 $$ descriptors.put(cfs, desc)[ FD ]
Line_2 $$ public void forceUserDefinedCleanup(String dataFiles) -->Line_3 $$ String[] filenames = dataFiles.split(",")[ FD ]
Line_6 $$ Descriptor desc = Descriptor.fromFilename(filename.trim())-->Line_13 $$ if (desc != null)[ FD ]
Line_6 $$ Descriptor desc = Descriptor.fromFilename(filename.trim())-->Line_12 $$ desc = cfs.getDirectories().find(new File(filename.trim()).getName())[ FD ]
Line_26 $$ if (sstable == null) -->Line_27 $$ logger.warn("Will not clean [ CD ]
Line_20 $$ boolean hasIndexes = cfs.indexManager.hasIndexes()-->Line_32 $$ doCleanupOne(cfs, txn, cleanupStrategy, ranges, hasIndexes)[ FD ]
Line_4 $$ HashMap<ColumnFamilyStore, Descriptor> descriptors = Maps.newHashMap()-->Line_14 $$ descriptors.put(cfs, desc)[ FD ]
Line_19 $$ Collection<Range<Token>> ranges = StorageService.instance.getLocalRanges(keyspace.getName())-->Line_22 $$ if (ranges.isEmpty()) [ FD ]
Line_16 $$ for (Map.Entry<ColumnFamilyStore, Descriptor> entry : descriptors.entrySet()) -->Line_17 $$ ColumnFamilyStore cfs = entry.getKey()[ FD ]
Line_11 $$ ColumnFamilyStore cfs = Keyspace.open(desc.ksname).getColumnFamilyStore(desc.cfname)-->Line_32 $$ doCleanupOne(cfs, txn, cleanupStrategy, ranges, hasIndexes)[ FD ]
Line_2 $$ public void forceUserDefinedCleanup(String dataFiles) -->Line_4 $$ HashMap<ColumnFamilyStore, Descriptor> descriptors = Maps.newHashMap()[ CD ]
Line_11 $$ ColumnFamilyStore cfs = Keyspace.open(desc.ksname).getColumnFamilyStore(desc.cfname)-->Line_14 $$ descriptors.put(cfs, desc)[ FD ]
Line_21 $$ SSTableReader sstable = lookupSSTable(cfs, entry.getValue())-->Line_26 $$ if (sstable == null) [ FD ]
Line_11 $$ ColumnFamilyStore cfs = Keyspace.open(desc.ksname).getColumnFamilyStore(desc.cfname)-->Line_29 $$ LifecycleTransaction txn = cfs.getTracker().tryModify(sstable, OperationType.CLEANUP)[ FD ]
Line_12 $$ desc = cfs.getDirectories().find(new File(filename.trim()).getName())-->Line_13 $$ if (desc != null)[ FD ]
Line_6 $$ Descriptor desc = Descriptor.fromFilename(filename.trim())-->Line_7 $$ if (Schema.instance.getCFMetaData(desc) == null) [ FD ]
Line_11 $$ ColumnFamilyStore cfs = Keyspace.open(desc.ksname).getColumnFamilyStore(desc.cfname)-->Line_12 $$ desc = cfs.getDirectories().find(new File(filename.trim()).getName())[ FD ]
Line_16 $$ for (Map.Entry<ColumnFamilyStore, Descriptor> entry : descriptors.entrySet()) -->Line_27 $$ logger.warn("Will not clean [ FD ]
Line_5 $$ for (String filename : filenames) -->Line_8 $$ logger.warn("Schema does not exist for file [ FD ]
Line_5 $$ for (String filename : filenames) -->Line_12 $$ desc = cfs.getDirectories().find(new File(filename.trim()).getName())[ FD ]
