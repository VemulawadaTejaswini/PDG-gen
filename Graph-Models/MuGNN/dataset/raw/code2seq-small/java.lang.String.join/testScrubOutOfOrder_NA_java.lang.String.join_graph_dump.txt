Line_39 $$ SSTableReader sstable = SSTableReader.openNoValidation(desc, components, cfs)-->Line_42 $$ try (LifecycleTransaction scrubTxn = LifecycleTransaction.offline(OperationType.SCRUB, sstable);[ FD ]
Line_18 $$ try (SSTableTxnWriter writer = new SSTableTxnWriter(txn, createTestWriter(desc, (long) keys.size(), cfs.metadata, txn))) -->Line_23 $$ writer.finish(false)[ FD ]
Line_30 $$ Set<Component> components = new HashSet()-->Line_32 $$ components.add(Component.COMPRESSION_INFO)[ FD ]
Line_17 $$ LifecycleTransaction txn = LifecycleTransaction.offline(OperationType.WRITE)-->Line_18 $$ try (SSTableTxnWriter writer = new SSTableTxnWriter(txn, createTestWriter(desc, (long) keys.size(), cfs.metadata, txn))) [ FD ]
Line_20 $$ PartitionUpdate update = UpdateBuilder.create(cfs.metadata, Util.dk(k)).newRow("someName").add("val", "someValue").build()-->Line_21 $$ writer.append(update.unfilteredIterator())[ FD ]
Line_2 $$ public void testScrubOutOfOrder() throws Exception -->Line_3 $$ IPartitioner oldPartitioner = DatabaseDescriptor.getPartitioner()[ CD ]
Line_15 $$ String filename = cfs.getSSTablePath(tempDataDir)-->Line_16 $$ Descriptor desc = Descriptor.fromFilename(filename)[ FD ]
Line_3 $$ IPartitioner oldPartitioner = DatabaseDescriptor.getPartitioner()-->Line_51 $$ DatabaseDescriptor.setPartitionerUnsafe(oldPartitioner)[ FD ]
Line_6 $$ File tempDataDir = new File(tempDir, String.join(File.separator, KEYSPACE, CF3))-->Line_7 $$ tempDataDir.mkdirs()[ FD ]
Line_16 $$ Descriptor desc = Descriptor.fromFilename(filename)-->Line_39 $$ SSTableReader sstable = SSTableReader.openNoValidation(desc, components, cfs)[ FD ]
Line_18 $$ try (SSTableTxnWriter writer = new SSTableTxnWriter(txn, createTestWriter(desc, (long) keys.size(), cfs.metadata, txn))) -->Line_21 $$ writer.append(update.unfilteredIterator())[ FD ]
Line_6 $$ File tempDataDir = new File(tempDir, String.join(File.separator, KEYSPACE, CF3))-->Line_50 $$ FileUtils.deleteRecursive(tempDataDir)[ FD ]
Line_10 $$ Keyspace keyspace = Keyspace.open(KEYSPACE)-->Line_12 $$ ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(columnFamily)[ FD ]
Line_12 $$ ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(columnFamily)-->Line_39 $$ SSTableReader sstable = SSTableReader.openNoValidation(desc, components, cfs)[ FD ]
Line_30 $$ Set<Component> components = new HashSet()-->Line_34 $$ components.add(Component.PRIMARY_INDEX)[ FD ]
Line_12 $$ ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(columnFamily)-->Line_47 $$ cfs.loadNewSSTables()[ FD ]
Line_2 $$ public void testScrubOutOfOrder() throws Exception -->Line_7 $$ tempDataDir.mkdirs()[ CD ]
Line_6 $$ File tempDataDir = new File(tempDir, String.join(File.separator, KEYSPACE, CF3))-->Line_15 $$ String filename = cfs.getSSTablePath(tempDataDir)[ FD ]
Line_30 $$ Set<Component> components = new HashSet()-->Line_35 $$ components.add(Component.FILTER)[ FD ]
Line_30 $$ Set<Component> components = new HashSet()-->Line_39 $$ SSTableReader sstable = SSTableReader.openNoValidation(desc, components, cfs)[ FD ]
Line_12 $$ ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(columnFamily)-->Line_13 $$ cfs.clearUnsafe()[ FD ]
Line_19 $$ for (String k : keys) -->Line_20 $$ PartitionUpdate update = UpdateBuilder.create(cfs.metadata, Util.dk(k)).newRow("someName").add("val", "someValue").build()[ FD ]
Line_14 $$ List<String> keys = Arrays.asList("t", "a", "b", "z", "c", "y", "d")-->Line_18 $$ try (SSTableTxnWriter writer = new SSTableTxnWriter(txn, createTestWriter(desc, (long) keys.size(), cfs.metadata, txn))) [ FD ]
Line_42 $$ try (LifecycleTransaction scrubTxn = LifecycleTransaction.offline(OperationType.SCRUB, sstable);-->Line_44 $$ scrubber.scrub()[ FD ]
Line_30 $$ Set<Component> components = new HashSet()-->Line_36 $$ components.add(Component.STATS)[ FD ]
Line_16 $$ Descriptor desc = Descriptor.fromFilename(filename)-->Line_31 $$ if (new File(desc.filenameFor(Component.COMPRESSION_INFO)).exists())[ FD ]
Line_16 $$ Descriptor desc = Descriptor.fromFilename(filename)-->Line_26 $$ SSTableReader.open(desc, cfs.metadata)[ FD ]
Line_30 $$ Set<Component> components = new HashSet()-->Line_38 $$ components.add(Component.TOC)[ FD ]
Line_12 $$ ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(columnFamily)-->Line_48 $$ assertOrderedAll(cfs, 7)[ FD ]
Line_31 $$ if (new File(desc.filenameFor(Component.COMPRESSION_INFO)).exists())-->Line_32 $$ components.add(Component.COMPRESSION_INFO)[ CD ]
Line_2 $$ public void testScrubOutOfOrder() throws Exception -->Line_5 $$ File tempDir = File.createTempFile("ScrubTest.testScrubOutOfOrder", "").getParentFile()[ CD ]
Line_2 $$ public void testScrubOutOfOrder() throws Exception -->Line_6 $$ File tempDataDir = new File(tempDir, String.join(File.separator, KEYSPACE, CF3))[ CD ]
Line_2 $$ public void testScrubOutOfOrder() throws Exception -->Line_4 $$ DatabaseDescriptor.setPartitionerUnsafe(new ByteOrderedPartitioner())[ CD ]
Line_12 $$ ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(columnFamily)-->Line_15 $$ String filename = cfs.getSSTablePath(tempDataDir)[ FD ]
Line_30 $$ Set<Component> components = new HashSet()-->Line_37 $$ components.add(Component.SUMMARY)[ FD ]
Line_16 $$ Descriptor desc = Descriptor.fromFilename(filename)-->Line_18 $$ try (SSTableTxnWriter writer = new SSTableTxnWriter(txn, createTestWriter(desc, (long) keys.size(), cfs.metadata, txn))) [ FD ]
Line_11 $$ String columnFamily = CF3-->Line_12 $$ ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(columnFamily)[ FD ]
Line_30 $$ Set<Component> components = new HashSet()-->Line_33 $$ components.add(Component.DATA)[ FD ]
Line_40 $$ if (sstable.last.compareTo(sstable.first) < 0)-->Line_41 $$ sstable.last = sstable.first[ CD ]
