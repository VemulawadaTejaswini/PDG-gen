Line_23 $$ for (int i = 0; i < implementations.size(); i++) -->Line_26 $$ if (o instanceof Collection) [ CD ]
Line_43 $$ if (o instanceof Collection) -->Line_44 $$ map.addAll((Collection<Object>) o)[ CD ]
Line_23 $$ for (int i = 0; i < implementations.size(); i++) -->Line_24 $$ Object t = implementations.get(i)[ CD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_24 $$ Object t = implementations.get(i)[ FD ]
Line_3 $$ final List<Object> results = new ArrayList<Object>()-->Line_31 $$ addToMaps(o, counts, map, i, results, true, intersect)[ FD ]
Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() -->Line_28 $$ addToMaps(o1, counts, map, i, results, false, intersect)[ FD ]
Line_45 $$ if (o != null) -->Line_46 $$ map.add(o)[ CD ]
Line_23 $$ for (int i = 0; i < implementations.size(); i++) -->Line_24 $$ Object t = implementations.get(i)[ FD ]
Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() -->Line_46 $$ map.add(o)[ FD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_25 $$ final Object o = method.invoke(t, args)[ FD ]
Line_4 $$ if (returnType.isInterface()) -->Line_5 $$ final List<Object> orderedPrimaryKeys = new SmartList<Object>()[ CD ]
Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() -->Line_11 $$ orderedPrimaryKeys.add(key)[ FD ]
Line_4 $$ if (returnType.isInterface()) -->Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() [ CD ]
Line_15 $$ final FactoryMap<Object, int[]> counts = new FactoryMap<Object, int[]>() -->Line_20 $$ return new int[implementations.size()][ CD ]
Line_4 $$ if (returnType.isInterface()) -->Line_23 $$ for (int i = 0; i < implementations.size(); i++) [ CD ]
Line_26 $$ if (o instanceof Collection) -->Line_30 $$ if (o != null) [ CD ]
Line_24 $$ Object t = implementations.get(i)-->Line_25 $$ final Object o = method.invoke(t, args)[ FD ]
Line_25 $$ final Object o = method.invoke(t, args)-->Line_31 $$ addToMaps(o, counts, map, i, results, true, intersect)[ FD ]
Line_23 $$ for (int i = 0; i < implementations.size(); i++) -->Line_28 $$ addToMaps(o1, counts, map, i, results, false, intersect)[ FD ]
Line_3 $$ final List<Object> results = new ArrayList<Object>()-->Line_36 $$ results.add(mergeImplementations(returnType, new ArrayList<Object>(objects)))[ FD ]
Line_24 $$ Object t = implementations.get(i)-->Line_42 $$ final Object o = method.invoke(t, args)[ FD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_31 $$ addToMaps(o, counts, map, i, results, true, intersect)[ FD ]
Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() -->Line_12 $$ return new SmartList<Set<Object>>()[ CD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_28 $$ addToMaps(o1, counts, map, i, results, false, intersect)[ FD ]
Line_4 $$ if (returnType.isInterface()) -->Line_50 $$ results.addAll(map)[ CD ]
Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() -->Line_31 $$ addToMaps(o, counts, map, i, results, true, intersect)[ FD ]
Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() -->Line_11 $$ orderedPrimaryKeys.add(key)[ CD ]
Line_25 $$ final Object o = method.invoke(t, args)-->Line_46 $$ map.add(o)[ FD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_52 $$ return results[ CD ]
Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() -->Line_44 $$ map.addAll((Collection<Object>) o)[ FD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_3 $$ final List<Object> results = new ArrayList<Object>()[ CD ]
Line_23 $$ for (int i = 0; i < implementations.size(); i++) -->Line_31 $$ addToMaps(o, counts, map, i, results, true, intersect)[ FD ]
Line_43 $$ if (o instanceof Collection) -->Line_45 $$ if (o != null) [ CD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_20 $$ return new int[implementations.size()][ FD ]
Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() -->Line_35 $$ for (final Set<Object> objects : map.get(primaryKey)) [ FD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_23 $$ for (int i = 0; i < implementations.size(); i++) [ FD ]
Line_30 $$ if (o != null) -->Line_31 $$ addToMaps(o, counts, map, i, results, true, intersect)[ CD ]
Line_3 $$ final List<Object> results = new ArrayList<Object>()-->Line_50 $$ results.addAll(map)[ FD ]
Line_25 $$ final Object o = method.invoke(t, args)-->Line_26 $$ if (o instanceof Collection) [ FD ]
Line_3 $$ final List<Object> results = new ArrayList<Object>()-->Line_28 $$ addToMaps(o1, counts, map, i, results, false, intersect)[ FD ]
Line_27 $$ for (final Object o1 : (Collection) o) -->Line_28 $$ addToMaps(o1, counts, map, i, results, false, intersect)[ FD ]
Line_25 $$ final Object o = method.invoke(t, args)-->Line_45 $$ if (o != null) [ FD ]
Line_6 $$ final FactoryMap<Object, List<Set<Object>>> map = new FactoryMap<Object, List<Set<Object>>>() -->Line_50 $$ results.addAll(map)[ FD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_4 $$ if (returnType.isInterface()) [ CD ]
Line_23 $$ for (int i = 0; i < implementations.size(); i++) -->Line_25 $$ final Object o = method.invoke(t, args)[ CD ]
Line_5 $$ final List<Object> orderedPrimaryKeys = new SmartList<Object>()-->Line_11 $$ orderedPrimaryKeys.add(key)[ FD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_36 $$ results.add(mergeImplementations(returnType, new ArrayList<Object>(objects)))[ FD ]
Line_25 $$ final Object o = method.invoke(t, args)-->Line_30 $$ if (o != null) [ FD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_4 $$ if (returnType.isInterface()) [ FD ]
Line_2 $$ private List<Object> getMergedImplementations(final Method method, final Object[] args, final Class returnType, final List<Object> implementations, final boolean intersect) throws IllegalAccessException, InvocationTargetException -->Line_42 $$ final Object o = method.invoke(t, args)[ FD ]
Line_25 $$ final Object o = method.invoke(t, args)-->Line_43 $$ if (o instanceof Collection) [ FD ]
