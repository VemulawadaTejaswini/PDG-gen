Line_8 $$ final ContentRevision afterRevision = change.getAfterRevision()-->Line_13 $$ files.put(key, afterRevision.getFile())[ FD ]
Line_4 $$ final Set<String> alsoReverted = new HashSet<String>()-->Line_16 $$ alsoReverted.add(key)[ FD ]
Line_11 $$ final File beforeFile = beforeRevision.getFile().getIOFile()-->Line_14 $$ myCollector.markRename(beforeFile, afterRevision.getFile().getIOFile())[ FD ]
Line_10 $$ if (SvnRollbackEnvironment.isMoveRenameReplace(change)) -->Line_15 $$ if (afterRevision != null) [ CD ]
Line_8 $$ final ContentRevision afterRevision = change.getAfterRevision()-->Line_15 $$ if (afterRevision != null) [ FD ]
Line_10 $$ if (SvnRollbackEnvironment.isMoveRenameReplace(change)) -->Line_13 $$ files.put(key, afterRevision.getFile())[ CD ]
Line_3 $$ final TreeMap<String, File> renames = new TreeMap<String, File>()-->Line_20 $$ final ArrayList<String> paths = new ArrayList<String>(renames.keySet())[ FD ]
Line_6 $$ for (Change change : changes) -->Line_37 $$ final ContentRevision afterRevision = change.getAfterRevision()[ FD ]
Line_6 $$ for (Change change : changes) -->Line_39 $$ checked |= myForDeletes.accept(change)[ FD ]
Line_3 $$ final TreeMap<String, File> renames = new TreeMap<String, File>()-->Line_12 $$ renames.put(key, beforeFile)[ FD ]
Line_8 $$ final ContentRevision afterRevision = change.getAfterRevision()-->Line_14 $$ myCollector.markRename(beforeFile, afterRevision.getFile().getIOFile())[ FD ]
Line_38 $$ boolean checked = myForAdds.accept(change)-->Line_40 $$ if (!checked) [ FD ]
Line_20 $$ final ArrayList<String> paths = new ArrayList<String>(renames.keySet())-->Line_22 $$ FilterFilePathStrings.getInstance().doFilter(paths)[ FD ]
Line_26 $$ for (String path : paths) -->Line_28 $$ myChangeProvider.getChanges(files.get(path), true, myCollector)[ FD ]
Line_3 $$ final TreeMap<String, File> renames = new TreeMap<String, File>()-->Line_19 $$ if (!renames.isEmpty()) [ FD ]
Line_10 $$ if (SvnRollbackEnvironment.isMoveRenameReplace(change)) -->Line_11 $$ final File beforeFile = beforeRevision.getFile().getIOFile()[ CD ]
Line_8 $$ final ContentRevision afterRevision = change.getAfterRevision()-->Line_41 $$ myForEdits.add(afterRevision.getFile().getIOFile())[ FD ]
Line_2 $$ public void gather(final List<Change> changes) -->Line_5 $$ final Map<String, FilePath> files = new HashMap<String, FilePath>()[ CD ]
Line_20 $$ final ArrayList<String> paths = new ArrayList<String>(renames.keySet())-->Line_21 $$ if (paths.size() > 1) [ FD ]
Line_39 $$ checked |= myForDeletes.accept(change)-->Line_40 $$ if (!checked) [ FD ]
Line_9 $$ final String key = afterRevision == null ? null : FilePathsHelper.convertWithLastSeparator(afterRevision.getFile())-->Line_13 $$ files.put(key, afterRevision.getFile())[ FD ]
Line_6 $$ for (Change change : changes) -->Line_7 $$ final ContentRevision beforeRevision = change.getBeforeRevision()[ FD ]
Line_6 $$ for (Change change : changes) -->Line_10 $$ if (SvnRollbackEnvironment.isMoveRenameReplace(change)) [ FD ]
Line_4 $$ final Set<String> alsoReverted = new HashSet<String>()-->Line_25 $$ myCollector.setAlsoReverted(alsoReverted)[ FD ]
Line_3 $$ final TreeMap<String, File> renames = new TreeMap<String, File>()-->Line_24 $$ myCollector.setRenamesMap(renames)[ FD ]
Line_6 $$ for (Change change : changes) -->Line_8 $$ final ContentRevision afterRevision = change.getAfterRevision()[ FD ]
Line_10 $$ if (SvnRollbackEnvironment.isMoveRenameReplace(change)) -->Line_12 $$ renames.put(key, beforeFile)[ CD ]
Line_5 $$ final Map<String, FilePath> files = new HashMap<String, FilePath>()-->Line_13 $$ files.put(key, afterRevision.getFile())[ FD ]
Line_11 $$ final File beforeFile = beforeRevision.getFile().getIOFile()-->Line_12 $$ renames.put(key, beforeFile)[ FD ]
Line_9 $$ final String key = afterRevision == null ? null : FilePathsHelper.convertWithLastSeparator(afterRevision.getFile())-->Line_16 $$ alsoReverted.add(key)[ FD ]
Line_10 $$ if (SvnRollbackEnvironment.isMoveRenameReplace(change)) -->Line_14 $$ myCollector.markRename(beforeFile, afterRevision.getFile().getIOFile())[ CD ]
Line_19 $$ if (!renames.isEmpty()) -->Line_21 $$ if (paths.size() > 1) [ CD ]
Line_2 $$ public void gather(final List<Change> changes) -->Line_3 $$ final TreeMap<String, File> renames = new TreeMap<String, File>()[ CD ]
Line_6 $$ for (Change change : changes) -->Line_38 $$ boolean checked = myForAdds.accept(change)[ FD ]
Line_38 $$ boolean checked = myForAdds.accept(change)-->Line_39 $$ checked |= myForDeletes.accept(change)[ FD ]
Line_19 $$ if (!renames.isEmpty()) -->Line_24 $$ myCollector.setRenamesMap(renames)[ CD ]
Line_15 $$ if (afterRevision != null) -->Line_16 $$ alsoReverted.add(key)[ CD ]
Line_9 $$ final String key = afterRevision == null ? null : FilePathsHelper.convertWithLastSeparator(afterRevision.getFile())-->Line_12 $$ renames.put(key, beforeFile)[ FD ]
Line_19 $$ if (!renames.isEmpty()) -->Line_25 $$ myCollector.setAlsoReverted(alsoReverted)[ CD ]
Line_7 $$ final ContentRevision beforeRevision = change.getBeforeRevision()-->Line_11 $$ final File beforeFile = beforeRevision.getFile().getIOFile()[ FD ]
Line_40 $$ if (!checked) -->Line_41 $$ myForEdits.add(afterRevision.getFile().getIOFile())[ CD ]
Line_2 $$ public void gather(final List<Change> changes) -->Line_4 $$ final Set<String> alsoReverted = new HashSet<String>()[ CD ]
Line_2 $$ public void gather(final List<Change> changes) -->Line_19 $$ if (!renames.isEmpty()) [ CD ]
Line_5 $$ final Map<String, FilePath> files = new HashMap<String, FilePath>()-->Line_28 $$ myChangeProvider.getChanges(files.get(path), true, myCollector)[ FD ]
Line_19 $$ if (!renames.isEmpty()) -->Line_20 $$ final ArrayList<String> paths = new ArrayList<String>(renames.keySet())[ CD ]
Line_21 $$ if (paths.size() > 1) -->Line_22 $$ FilterFilePathStrings.getInstance().doFilter(paths)[ CD ]
Line_8 $$ final ContentRevision afterRevision = change.getAfterRevision()-->Line_9 $$ final String key = afterRevision == null ? null : FilePathsHelper.convertWithLastSeparator(afterRevision.getFile())[ FD ]
