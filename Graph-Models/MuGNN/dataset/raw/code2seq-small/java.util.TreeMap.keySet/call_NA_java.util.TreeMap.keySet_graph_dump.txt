Line_8 $$ for (int i = 0; i < iterations; i++) -->Line_9 $$ buffer.clear()[ CD ]
Line_7 $$ ThreadLocalRandom rnd = ThreadLocalRandom.current()-->Line_12 $$ int v = rnd.nextInt(upperBound)[ FD ]
Line_2 $$ public List<ListenableFuture<?>> call() -->Line_8 $$ for (int i = 0; i < iterations; i++) [ CD ]
Line_11 $$ while (mods > 0) -->Line_19 $$ mods -= c[ CD ]
Line_8 $$ for (int i = 0; i < iterations; i++) -->Line_28 $$ btree = next[ CD ]
Line_12 $$ int v = rnd.nextInt(upperBound)-->Line_17 $$ v++[ FD ]
Line_8 $$ for (int i = 0; i < iterations; i++) -->Line_34 $$ if (quickEquality)[ CD ]
Line_5 $$ Object[] btree = BTree.empty()-->Line_30 $$ if (!BTree.isWellFormed(btree, naturalOrder())) [ FD ]
Line_11 $$ while (mods > 0) -->Line_13 $$ int rc = Math.max(0, Math.min(mods, maxRunLength) - 1)[ CD ]
Line_34 $$ if (quickEquality)-->Line_35 $$ testEqual("", BTree.iterator(btree), canon.keySet().iterator())[ CD ]
Line_15 $$ for (int j = 0; j < c; j++) -->Line_17 $$ v++[ CD ]
Line_11 $$ while (mods > 0) -->Line_15 $$ for (int j = 0; j < c; j++) [ CD ]
Line_8 $$ for (int i = 0; i < iterations; i++) -->Line_25 $$ ctxt = BTREE_TIMER.time()[ CD ]
Line_7 $$ ThreadLocalRandom rnd = ThreadLocalRandom.current()-->Line_14 $$ int c = 1 + (rc <= 0 ? 0 : rnd.nextInt(rc))[ FD ]
Line_6 $$ final TreeMap<Integer, Integer> buffer = new TreeMap()-->Line_23 $$ canon.putAll(buffer)[ FD ]
Line_8 $$ for (int i = 0; i < iterations; i++) -->Line_22 $$ ctxt = TREE_TIMER.time()[ CD ]
Line_2 $$ public List<ListenableFuture<?>> call() -->Line_3 $$ final List<ListenableFuture<?>> r = new ArrayList()[ CD ]
Line_5 $$ Object[] btree = BTree.empty()-->Line_35 $$ testEqual("", BTree.iterator(btree), canon.keySet().iterator())[ FD ]
Line_34 $$ if (quickEquality)-->Line_37 $$ r.addAll(testAllSlices("RND", btree, new TreeSet(canon.keySet())))[ CD ]
Line_10 $$ int mods = rnd.nextInt(1, averageModsPerIteration * 2)-->Line_13 $$ int rc = Math.max(0, Math.min(mods, maxRunLength) - 1)[ FD ]
Line_14 $$ int c = 1 + (rc <= 0 ? 0 : rnd.nextInt(rc))-->Line_15 $$ for (int j = 0; j < c; j++) [ FD ]
Line_14 $$ int c = 1 + (rc <= 0 ? 0 : rnd.nextInt(rc))-->Line_19 $$ mods -= c[ FD ]
Line_5 $$ Object[] btree = BTree.empty()-->Line_27 $$ next = BTree.update(btree, naturalOrder(), buffer.keySet(), SPORADIC_ABORT)[ FD ]
Line_28 $$ btree = next-->Line_30 $$ if (!BTree.isWellFormed(btree, naturalOrder())) [ FD ]
Line_8 $$ for (int i = 0; i < iterations; i++) -->Line_24 $$ ctxt.stop()[ CD ]
Line_13 $$ int rc = Math.max(0, Math.min(mods, maxRunLength) - 1)-->Line_14 $$ int c = 1 + (rc <= 0 ? 0 : rnd.nextInt(rc))[ FD ]
Line_12 $$ int v = rnd.nextInt(upperBound)-->Line_16 $$ buffer.put(v, v)[ FD ]
Line_6 $$ final TreeMap<Integer, Integer> buffer = new TreeMap()-->Line_9 $$ buffer.clear()[ FD ]
Line_10 $$ int mods = rnd.nextInt(1, averageModsPerIteration * 2)-->Line_11 $$ while (mods > 0) [ FD ]
Line_8 $$ for (int i = 0; i < iterations; i++) -->Line_29 $$ ctxt.stop()[ CD ]
Line_2 $$ public List<ListenableFuture<?>> call() -->Line_5 $$ Object[] btree = BTree.empty()[ CD ]
Line_5 $$ Object[] btree = BTree.empty()-->Line_28 $$ btree = next[ FD ]
Line_4 $$ NavigableMap<Integer, Integer> canon = new TreeMap()-->Line_35 $$ testEqual("", BTree.iterator(btree), canon.keySet().iterator())[ FD ]
Line_2 $$ public List<ListenableFuture<?>> call() -->Line_39 $$ return r[ CD ]
Line_11 $$ while (mods > 0) -->Line_12 $$ int v = rnd.nextInt(upperBound)[ CD ]
Line_6 $$ final TreeMap<Integer, Integer> buffer = new TreeMap()-->Line_16 $$ buffer.put(v, v)[ FD ]
Line_19 $$ mods -= c-->Line_11 $$ while (mods > 0) [ FD ]
Line_4 $$ NavigableMap<Integer, Integer> canon = new TreeMap()-->Line_37 $$ r.addAll(testAllSlices("RND", btree, new TreeSet(canon.keySet())))[ FD ]
Line_2 $$ public List<ListenableFuture<?>> call() -->Line_4 $$ NavigableMap<Integer, Integer> canon = new TreeMap()[ CD ]
Line_28 $$ btree = next-->Line_37 $$ r.addAll(testAllSlices("RND", btree, new TreeSet(canon.keySet())))[ FD ]
Line_7 $$ ThreadLocalRandom rnd = ThreadLocalRandom.current()-->Line_10 $$ int mods = rnd.nextInt(1, averageModsPerIteration * 2)[ FD ]
Line_8 $$ for (int i = 0; i < iterations; i++) -->Line_23 $$ canon.putAll(buffer)[ CD ]
Line_11 $$ while (mods > 0) -->Line_14 $$ int c = 1 + (rc <= 0 ? 0 : rnd.nextInt(rc))[ CD ]
Line_6 $$ final TreeMap<Integer, Integer> buffer = new TreeMap()-->Line_27 $$ next = BTree.update(btree, naturalOrder(), buffer.keySet(), SPORADIC_ABORT)[ FD ]
Line_30 $$ if (!BTree.isWellFormed(btree, naturalOrder())) -->Line_31 $$ log("ERROR: Not well formed")[ CD ]
Line_2 $$ public List<ListenableFuture<?>> call() -->Line_6 $$ final TreeMap<Integer, Integer> buffer = new TreeMap()[ CD ]
Line_19 $$ mods -= c-->Line_13 $$ int rc = Math.max(0, Math.min(mods, maxRunLength) - 1)[ FD ]
Line_15 $$ for (int j = 0; j < c; j++) -->Line_16 $$ buffer.put(v, v)[ CD ]
Line_8 $$ for (int i = 0; i < iterations; i++) -->Line_30 $$ if (!BTree.isWellFormed(btree, naturalOrder())) [ CD ]
Line_8 $$ for (int i = 0; i < iterations; i++) -->Line_10 $$ int mods = rnd.nextInt(1, averageModsPerIteration * 2)[ CD ]
Line_10 $$ int mods = rnd.nextInt(1, averageModsPerIteration * 2)-->Line_19 $$ mods -= c[ FD ]
Line_8 $$ for (int i = 0; i < iterations; i++) -->Line_27 $$ while (next == null) next = BTree.update(btree, naturalOrder(), buffer.keySet(), SPORADIC_ABORT)[ CD ]
Line_5 $$ Object[] btree = BTree.empty()-->Line_37 $$ r.addAll(testAllSlices("RND", btree, new TreeSet(canon.keySet())))[ FD ]
Line_4 $$ NavigableMap<Integer, Integer> canon = new TreeMap()-->Line_23 $$ canon.putAll(buffer)[ FD ]
Line_28 $$ btree = next-->Line_35 $$ testEqual("", BTree.iterator(btree), canon.keySet().iterator())[ FD ]
Line_8 $$ for (int i = 0; i < iterations; i++) -->Line_11 $$ while (mods > 0) [ CD ]
Line_2 $$ public List<ListenableFuture<?>> call() -->Line_7 $$ ThreadLocalRandom rnd = ThreadLocalRandom.current()[ CD ]
Line_3 $$ final List<ListenableFuture<?>> r = new ArrayList()-->Line_37 $$ r.addAll(testAllSlices("RND", btree, new TreeSet(canon.keySet())))[ FD ]
