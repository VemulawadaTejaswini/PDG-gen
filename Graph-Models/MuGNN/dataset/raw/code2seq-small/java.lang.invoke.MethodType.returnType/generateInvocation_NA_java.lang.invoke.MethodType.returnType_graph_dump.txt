Line_7 $$ ByteCodeBlock block = new ByteCodeBlock().setDescription("invoke " + name)-->Line_28 $$ block.append(boxPrimitiveIfNecessary(scope, type))[ FD ]
Line_14 $$ for (Class<?> type : methodType.parameterArray()) -->Line_17 $$ checkState(type.equals(function.getInstanceFactory().get().type().returnType()), "Mismatched type for instance parameter")[ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_3 $$ MethodType methodType = binding.getType()[ FD ]
Line_12 $$ int index = 0-->Line_24 $$ if (!function.getNullableArguments().get(index)) [ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_28 $$ block.append(boxPrimitiveIfNecessary(scope, type))[ FD ]
Line_35 $$ if (function.isNullable()) -->Line_36 $$ block.append(unboxPrimitiveIfNecessary(scope, returnType))[ CD ]
Line_7 $$ ByteCodeBlock block = new ByteCodeBlock().setDescription("invoke " + name)-->Line_23 $$ block.append(arguments.get(index))[ FD ]
Line_14 $$ for (Class<?> type : methodType.parameterArray()) -->Line_25 $$ checkArgument(!Primitives.isWrapperType(type), "Non-nullable argument must not be primitive wrapper type")[ FD ]
Line_24 $$ if (!function.getNullableArguments().get(index)) -->Line_29 $$ block.append(scope.getVariable("wasNull").set(constantFalse()))[ CD ]
Line_24 $$ if (!function.getNullableArguments().get(index)) -->Line_25 $$ checkArgument(!Primitives.isWrapperType(type), "Non-nullable argument must not be primitive wrapper type")[ CD ]
Line_7 $$ ByteCodeBlock block = new ByteCodeBlock().setDescription("invoke " + name)-->Line_29 $$ block.append(scope.getVariable("wasNull").set(constantFalse()))[ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_7 $$ ByteCodeBlock block = new ByteCodeBlock().setDescription("invoke " + name)[ CD ]
Line_4 $$ Class<?> returnType = methodType.returnType()-->Line_5 $$ Class<?> unboxedReturnType = Primitives.unwrap(returnType)[ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_12 $$ int index = 0[ CD ]
Line_16 $$ if (function.getInstanceFactory().isPresent() && !boundInstance) -->Line_20 $$ if (type == ConnectorSession.class) [ CD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_36 $$ block.append(unboxPrimitiveIfNecessary(scope, returnType))[ FD ]
Line_12 $$ int index = 0-->Line_23 $$ block.append(arguments.get(index))[ FD ]
Line_12 $$ int index = 0-->Line_31 $$ index++[ FD ]
Line_13 $$ boolean boundInstance = false-->Line_19 $$ boundInstance = true[ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_21 $$ block.append(scope.getVariable("session"))[ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_10 $$ checkArgument(instance.isPresent())[ FD ]
Line_24 $$ if (!function.getNullableArguments().get(index)) -->Line_26 $$ block.append(ifWasNullPopAndGoto(scope, end, unboxedReturnType, Lists.reverse(stackTypes)))[ CD ]
Line_5 $$ Class<?> unboxedReturnType = Primitives.unwrap(returnType)-->Line_26 $$ block.append(ifWasNullPopAndGoto(scope, end, unboxedReturnType, Lists.reverse(stackTypes)))[ FD ]
Line_6 $$ LabelNode end = new LabelNode("end")-->Line_38 $$ block.visitLabel(end)[ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_24 $$ if (!function.getNullableArguments().get(index)) [ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_38 $$ block.visitLabel(end)[ CD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_35 $$ if (function.isNullable()) [ CD ]
Line_14 $$ for (Class<?> type : methodType.parameterArray()) -->Line_28 $$ block.append(boxPrimitiveIfNecessary(scope, type))[ FD ]
Line_14 $$ for (Class<?> type : methodType.parameterArray()) -->Line_15 $$ stackTypes.add(type)[ FD ]
Line_20 $$ if (type == ConnectorSession.class) -->Line_23 $$ block.append(arguments.get(index))[ CD ]
Line_9 $$ if (function.getInstanceFactory().isPresent()) -->Line_10 $$ checkArgument(instance.isPresent())[ CD ]
Line_7 $$ ByteCodeBlock block = new ByteCodeBlock().setDescription("invoke " + name)-->Line_26 $$ block.append(ifWasNullPopAndGoto(scope, end, unboxedReturnType, Lists.reverse(stackTypes)))[ FD ]
Line_14 $$ for (Class<?> type : methodType.parameterArray()) -->Line_20 $$ if (type == ConnectorSession.class) [ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_9 $$ if (function.getInstanceFactory().isPresent()) [ FD ]
Line_8 $$ List<Class<?>> stackTypes = new ArrayList()-->Line_26 $$ block.append(ifWasNullPopAndGoto(scope, end, unboxedReturnType, Lists.reverse(stackTypes)))[ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_29 $$ block.append(scope.getVariable("wasNull").set(constantFalse()))[ FD ]
Line_20 $$ if (type == ConnectorSession.class) -->Line_24 $$ if (!function.getNullableArguments().get(index)) [ CD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_23 $$ block.append(arguments.get(index))[ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_9 $$ if (function.getInstanceFactory().isPresent()) [ CD ]
Line_7 $$ ByteCodeBlock block = new ByteCodeBlock().setDescription("invoke " + name)-->Line_36 $$ block.append(unboxPrimitiveIfNecessary(scope, returnType))[ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_39 $$ return block[ CD ]
Line_16 $$ if (function.getInstanceFactory().isPresent() && !boundInstance) -->Line_18 $$ block.append(instance.get())[ CD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_34 $$ block.append(invoke(binding, name))[ CD ]
Line_6 $$ LabelNode end = new LabelNode("end")-->Line_26 $$ block.append(ifWasNullPopAndGoto(scope, end, unboxedReturnType, Lists.reverse(stackTypes)))[ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_8 $$ List<Class<?>> stackTypes = new ArrayList()[ CD ]
Line_13 $$ boolean boundInstance = false-->Line_16 $$ if (function.getInstanceFactory().isPresent() && !boundInstance) [ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_18 $$ block.append(instance.get())[ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_16 $$ if (function.getInstanceFactory().isPresent() && !boundInstance) [ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_13 $$ boolean boundInstance = false[ CD ]
Line_7 $$ ByteCodeBlock block = new ByteCodeBlock().setDescription("invoke " + name)-->Line_34 $$ block.append(invoke(binding, name))[ FD ]
Line_3 $$ MethodType methodType = binding.getType()-->Line_4 $$ Class<?> returnType = methodType.returnType()[ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_5 $$ Class<?> unboxedReturnType = Primitives.unwrap(returnType)[ CD ]
Line_16 $$ if (function.getInstanceFactory().isPresent() && !boundInstance) -->Line_17 $$ checkState(type.equals(function.getInstanceFactory().get().type().returnType()), "Mismatched type for instance parameter")[ CD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_3 $$ MethodType methodType = binding.getType()[ CD ]
Line_16 $$ if (function.getInstanceFactory().isPresent() && !boundInstance) -->Line_19 $$ boundInstance = true[ CD ]
Line_7 $$ ByteCodeBlock block = new ByteCodeBlock().setDescription("invoke " + name)-->Line_38 $$ block.visitLabel(end)[ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_26 $$ block.append(ifWasNullPopAndGoto(scope, end, unboxedReturnType, Lists.reverse(stackTypes)))[ FD ]
Line_4 $$ Class<?> returnType = methodType.returnType()-->Line_36 $$ block.append(unboxPrimitiveIfNecessary(scope, returnType))[ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_35 $$ if (function.isNullable()) [ FD ]
Line_20 $$ if (type == ConnectorSession.class) -->Line_21 $$ block.append(scope.getVariable("session"))[ CD ]
Line_20 $$ if (type == ConnectorSession.class) -->Line_31 $$ index++[ CD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_17 $$ checkState(type.equals(function.getInstanceFactory().get().type().returnType()), "Mismatched type for instance parameter")[ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_4 $$ Class<?> returnType = methodType.returnType()[ CD ]
Line_8 $$ List<Class<?>> stackTypes = new ArrayList()-->Line_15 $$ stackTypes.add(type)[ FD ]
Line_7 $$ ByteCodeBlock block = new ByteCodeBlock().setDescription("invoke " + name)-->Line_21 $$ block.append(scope.getVariable("session"))[ FD ]
Line_3 $$ MethodType methodType = binding.getType()-->Line_14 $$ for (Class<?> type : methodType.parameterArray()) [ FD ]
Line_24 $$ if (!function.getNullableArguments().get(index)) -->Line_28 $$ block.append(boxPrimitiveIfNecessary(scope, type))[ CD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_34 $$ block.append(invoke(binding, name))[ FD ]
Line_7 $$ ByteCodeBlock block = new ByteCodeBlock().setDescription("invoke " + name)-->Line_18 $$ block.append(instance.get())[ FD ]
Line_2 $$ public static ByteCodeNode generateInvocation(Scope scope, String name, ScalarFunctionImplementation function, Optional<ByteCodeNode> instance, List<ByteCodeNode> arguments, Binding binding) -->Line_6 $$ LabelNode end = new LabelNode("end")[ CD ]
