Line_50 $$ Map<String, Class<?>> classes = classLoader.defineClasses(byteCodes)-->Line_52 $$ for (Class<?> clazz : classes.values()) [ FD ]
Line_34 $$ File file = new File(dumpClassPath, ParameterizedType.typeFromJavaClassName(entry.getKey()).getClassName() + ".class")-->Line_40 $$ log.error(e, "Failed to write generated class file to: %s" + file.getAbsolutePath())[ FD ]
Line_4 $$ if (DUMP_BYTE_CODE_TREE) -->Line_10 $$ System.out.println(new String(out.toByteArray(), StandardCharsets.UTF_8))[ CD ]
Line_2 $$ private static Map<String, Class<?>> defineClasses(List<ClassDefinition> classDefinitions, DynamicClassLoader classLoader) -->Line_27 $$ CheckClassAdapter.verify(reader, classLoader, true, new PrintWriter(System.out))[ FD ]
Line_19 $$ StringWriter stringWriter = new StringWriter()-->Line_22 $$ throw new IllegalArgumentException("An error occurred while processing classDefinition:" + System.lineSeparator() + stringWriter.toString(), e)[ FD ]
Line_25 $$ if (RUN_ASM_VERIFIER) -->Line_27 $$ CheckClassAdapter.verify(reader, classLoader, true, new PrintWriter(System.out))[ CD ]
Line_2 $$ private static Map<String, Class<?>> defineClasses(List<ClassDefinition> classDefinitions, DynamicClassLoader classLoader) -->Line_12 $$ Map<String, byte[]> byteCodes = new LinkedHashMap()[ CD ]
Line_52 $$ for (Class<?> clazz : classes.values()) -->Line_53 $$ Reflection.initialize(clazz)[ FD ]
Line_12 $$ Map<String, byte[]> byteCodes = new LinkedHashMap()-->Line_50 $$ Map<String, Class<?>> classes = classLoader.defineClasses(byteCodes)[ FD ]
Line_24 $$ byte[] byteCode = cw.toByteArray()-->Line_29 $$ byteCodes.put(classDefinition.getType().getJavaClassName(), byteCode)[ FD ]
Line_2 $$ private static Map<String, Class<?>> defineClasses(List<ClassDefinition> classDefinitions, DynamicClassLoader classLoader) -->Line_31 $$ String dumpClassPath = DUMP_CLASS_FILES_TO.get()[ CD ]
Line_12 $$ Map<String, byte[]> byteCodes = new LinkedHashMap()-->Line_29 $$ byteCodes.put(classDefinition.getType().getJavaClassName(), byteCode)[ FD ]
Line_2 $$ private static Map<String, Class<?>> defineClasses(List<ClassDefinition> classDefinitions, DynamicClassLoader classLoader) -->Line_50 $$ Map<String, Class<?>> classes = classLoader.defineClasses(byteCodes)[ CD ]
Line_2 $$ private static Map<String, Class<?>> defineClasses(List<ClassDefinition> classDefinitions, DynamicClassLoader classLoader) -->Line_32 $$ if (dumpClassPath != null) [ CD ]
Line_4 $$ if (DUMP_BYTE_CODE_TREE) -->Line_5 $$ ByteArrayOutputStream out = new ByteArrayOutputStream()[ CD ]
Line_12 $$ Map<String, byte[]> byteCodes = new LinkedHashMap()-->Line_45 $$ for (byte[] byteCode : byteCodes.values()) [ FD ]
Line_2 $$ private static Map<String, Class<?>> defineClasses(List<ClassDefinition> classDefinitions, DynamicClassLoader classLoader) -->Line_58 $$ return classes[ CD ]
Line_4 $$ if (DUMP_BYTE_CODE_TREE) -->Line_6 $$ DumpByteCodeVisitor dumpByteCode = new DumpByteCodeVisitor(new PrintStream(out))[ CD ]
Line_7 $$ for (ClassDefinition classDefinition : classDefinitions) -->Line_8 $$ dumpByteCode.visitClass(classDefinition)[ FD ]
Line_7 $$ for (ClassDefinition classDefinition : classDefinitions) -->Line_16 $$ classDefinition.visit(ADD_FAKE_LINE_NUMBER ? new AddFakeLineNumberClassVisitor(cw) : cw)[ FD ]
Line_34 $$ File file = new File(dumpClassPath, ParameterizedType.typeFromJavaClassName(entry.getKey()).getClassName() + ".class")-->Line_37 $$ Files.createParentDirs(file)[ FD ]
Line_5 $$ ByteArrayOutputStream out = new ByteArrayOutputStream()-->Line_10 $$ System.out.println(new String(out.toByteArray(), StandardCharsets.UTF_8))[ FD ]
Line_31 $$ String dumpClassPath = DUMP_CLASS_FILES_TO.get()-->Line_32 $$ if (dumpClassPath != null) [ FD ]
Line_34 $$ File file = new File(dumpClassPath, ParameterizedType.typeFromJavaClassName(entry.getKey()).getClassName() + ".class")-->Line_36 $$ log.debug("ClassFile: " + file.getAbsolutePath())[ FD ]
Line_7 $$ for (ClassDefinition classDefinition : classDefinitions) -->Line_29 $$ byteCodes.put(classDefinition.getType().getJavaClassName(), byteCode)[ FD ]
Line_6 $$ DumpByteCodeVisitor dumpByteCode = new DumpByteCodeVisitor(new PrintStream(out))-->Line_8 $$ dumpByteCode.visitClass(classDefinition)[ FD ]
Line_46 $$ ClassReader classReader = new ClassReader(byteCode)-->Line_47 $$ classReader.accept(new TraceClassVisitor(new PrintWriter(System.err)), ClassReader.EXPAND_FRAMES)[ FD ]
Line_2 $$ private static Map<String, Class<?>> defineClasses(List<ClassDefinition> classDefinitions, DynamicClassLoader classLoader) -->Line_3 $$ ClassInfoLoader classInfoLoader = ClassInfoLoader.createClassInfoLoader(classDefinitions, classLoader)[ CD ]
Line_25 $$ if (RUN_ASM_VERIFIER) -->Line_26 $$ ClassReader reader = new ClassReader(byteCode)[ CD ]
Line_33 $$ for (Map.Entry<String, byte[]> entry : byteCodes.entrySet()) -->Line_38 $$ Files.write(entry.getValue(), file)[ FD ]
Line_2 $$ private static Map<String, Class<?>> defineClasses(List<ClassDefinition> classDefinitions, DynamicClassLoader classLoader) -->Line_44 $$ if (DUMP_BYTE_CODE_RAW) [ CD ]
Line_14 $$ ClassWriter cw = new SmartClassWriter(classInfoLoader)-->Line_24 $$ byte[] byteCode = cw.toByteArray()[ FD ]
Line_2 $$ private static Map<String, Class<?>> defineClasses(List<ClassDefinition> classDefinitions, DynamicClassLoader classLoader) -->Line_4 $$ if (DUMP_BYTE_CODE_TREE) [ CD ]
Line_34 $$ File file = new File(dumpClassPath, ParameterizedType.typeFromJavaClassName(entry.getKey()).getClassName() + ".class")-->Line_38 $$ Files.write(entry.getValue(), file)[ FD ]
Line_2 $$ private static Map<String, Class<?>> defineClasses(List<ClassDefinition> classDefinitions, DynamicClassLoader classLoader) -->Line_50 $$ Map<String, Class<?>> classes = classLoader.defineClasses(byteCodes)[ FD ]
Line_7 $$ for (ClassDefinition classDefinition : classDefinitions) -->Line_21 $$ classDefinition.visit(tcv)[ FD ]
Line_20 $$ TraceClassVisitor tcv = new TraceClassVisitor(null, printer, new PrintWriter(stringWriter))-->Line_21 $$ classDefinition.visit(tcv)[ FD ]
Line_2 $$ private static Map<String, Class<?>> defineClasses(List<ClassDefinition> classDefinitions, DynamicClassLoader classLoader) -->Line_3 $$ ClassInfoLoader classInfoLoader = ClassInfoLoader.createClassInfoLoader(classDefinitions, classLoader)[ FD ]
Line_26 $$ ClassReader reader = new ClassReader(byteCode)-->Line_27 $$ CheckClassAdapter.verify(reader, classLoader, true, new PrintWriter(System.out))[ FD ]
Line_33 $$ for (Map.Entry<String, byte[]> entry : byteCodes.entrySet()) -->Line_34 $$ File file = new File(dumpClassPath, ParameterizedType.typeFromJavaClassName(entry.getKey()).getClassName() + ".class")[ FD ]
Line_12 $$ Map<String, byte[]> byteCodes = new LinkedHashMap()-->Line_33 $$ for (Map.Entry<String, byte[]> entry : byteCodes.entrySet()) [ FD ]
