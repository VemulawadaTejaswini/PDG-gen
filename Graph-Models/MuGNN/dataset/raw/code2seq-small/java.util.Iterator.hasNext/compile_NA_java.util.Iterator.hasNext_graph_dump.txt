Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_25 $$ final Collection<String> _options = prepareOptions(options, compilingTool)[ CD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_16 $$ if (!platformClasspath.isEmpty()) [ CD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_82 $$ final JavaCompiler.CompilationTask task = compiler.getTask(out, fileManager, diagnosticConsumer, _options, null, fileManager.getJavaFileObjectsFromFiles(sources))[ FD ]
Line_104 $$ if (usingJavac) -->Line_105 $$ cleanupJavacNameTable()[ CD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_48 $$ fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage())[ FD ]
Line_14 $$ final boolean usingJavac = compilingTool instanceof JavacCompilerTool-->Line_43 $$ if (!usingJavac && !isOptionSet(options, "-processorpath")) [ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_42 $$ fileManager.setLocation(StandardLocation.CLASS_PATH, classpath)[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_76 $$ diagnosticConsumer.outputLineAvailable(line)[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_82 $$ final JavaCompiler.CompilationTask task = compiler.getTask(out, fileManager, diagnosticConsumer, _options, null, fileManager.getJavaFileObjectsFromFiles(sources))[ FD ]
Line_25 $$ final Collection<String> _options = prepareOptions(options, compilingTool)-->Line_83 $$ compilingTool.prepareCompilationTask(task, _options)[ FD ]
Line_3 $$ JavaCompiler compiler-->Line_5 $$ compiler = compilingTool.createCompiler()[ FD ]
Line_3 $$ JavaCompiler compiler-->Line_82 $$ final JavaCompiler.CompilationTask task = compiler.getTask(out, fileManager, diagnosticConsumer, _options, null, fileManager.getJavaFileObjectsFromFiles(sources))[ FD ]
Line_10 $$ for (File outputDir : outputDirToRoots.keySet()) -->Line_11 $$ outputDir.mkdirs()[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_108 $$ return false[ CD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_42 $$ fileManager.setLocation(StandardLocation.CLASS_PATH, classpath)[ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_32 $$ fileManager.handleOption(iterator.next(), iterator)[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_43 $$ if (!usingJavac && !isOptionSet(options, "-processorpath")) [ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_56 $$ fileManager.setLocation(StandardLocation.PLATFORM_CLASS_PATH, buildPlatformClasspath(platformClasspath, _options))[ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_103 $$ fileManager.close()[ FD ]
Line_25 $$ final Collection<String> _options = prepareOptions(options, compilingTool)-->Line_82 $$ final JavaCompiler.CompilationTask task = compiler.getTask(out, fileManager, diagnosticConsumer, _options, null, fileManager.getJavaFileObjectsFromFiles(sources))[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_94 $$ handleCancelException(diagnosticConsumer)[ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_68 $$ fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage())[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_14 $$ final boolean usingJavac = compilingTool instanceof JavacCompilerTool[ CD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_7 $$ diagnosticConsumer.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, e.getMessage()))[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_56 $$ fileManager.setLocation(StandardLocation.PLATFORM_CLASS_PATH, buildPlatformClasspath(platformClasspath, _options))[ FD ]
Line_25 $$ final Collection<String> _options = prepareOptions(options, compilingTool)-->Line_56 $$ fileManager.setLocation(StandardLocation.PLATFORM_CLASS_PATH, buildPlatformClasspath(platformClasspath, _options))[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)[ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_37 $$ fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage())[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_5 $$ compiler = compilingTool.createCompiler()[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_98 $$ handleCancelException(diagnosticConsumer)[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_35 $$ fileManager.setOutputDirectories(outputDirToRoots)[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_92 $$ diagnosticConsumer.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, e.getMessage()))[ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_35 $$ fileManager.setOutputDirectories(outputDirToRoots)[ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_58 $$ fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage())[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_40 $$ if (!classpath.isEmpty()) [ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_13 $$ final List<JavaSourceTransformer> transformers = getSourceTransformers()[ CD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_3 $$ JavaCompiler compiler[ CD ]
Line_75 $$ if (usingJavac) -->Line_76 $$ diagnosticConsumer.outputLineAvailable(line)[ CD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_10 $$ for (File outputDir : outputDirToRoots.keySet()) [ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_16 $$ if (!platformClasspath.isEmpty()) [ FD ]
Line_97 $$ if (cause instanceof CompilationCanceledException) -->Line_98 $$ handleCancelException(diagnosticConsumer)[ CD ]
Line_5 $$ compiler = compilingTool.createCompiler()-->Line_82 $$ final JavaCompiler.CompilationTask task = compiler.getTask(out, fileManager, diagnosticConsumer, _options, null, fileManager.getJavaFileObjectsFromFiles(sources))[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)[ CD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_52 $$ if (!platformClasspath.isEmpty()) [ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_25 $$ final Collection<String> _options = prepareOptions(options, compilingTool)[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_83 $$ compilingTool.prepareCompilationTask(task, _options)[ FD ]
