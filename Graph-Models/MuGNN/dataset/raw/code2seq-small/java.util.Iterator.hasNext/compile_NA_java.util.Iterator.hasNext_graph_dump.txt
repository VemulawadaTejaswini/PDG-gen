Line_58 $$ final LineOutputWriter out = new LineOutputWriter() -->Line_60 $$ if (usingJavac) [ CD ]
Line_21 $$ final Collection<String> _options = prepareOptions(options, compilingTool)-->Line_46 $$ fileManager.setLocation(StandardLocation.PLATFORM_CLASS_PATH, buildPlatformClasspath(platformClasspath, _options))[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_14 $$ final boolean usingJavac = compilingTool instanceof JavacCompilerTool[ CD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_67 $$ compilingTool.prepareCompilationTask(task, _options)[ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_17 $$ fileManager.handleOption("-bootclasspath", Collections.singleton("").iterator())[ FD ]
Line_58 $$ final LineOutputWriter out = new LineOutputWriter() -->Line_66 $$ final JavaCompiler.CompilationTask task = compiler.getTask(out, fileManager, diagnosticConsumer, _options, null, fileManager.getJavaFileObjectsFromFiles(sources))[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_76 $$ handleCancelException(diagnosticConsumer)[ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_55 $$ fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage())[ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_27 $$ fileManager.setOutputDirectories(outputDirToRoots)[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_35 $$ if (!usingJavac && !isOptionSet(options, "-processorpath")) [ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_34 $$ fileManager.setLocation(StandardLocation.CLASS_PATH, classpath)[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_21 $$ final Collection<String> _options = prepareOptions(options, compilingTool)[ CD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_53 $$ fileManager.setLocation(StandardLocation.SOURCE_PATH, sourcePath)[ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_19 $$ fileManager.handleOption("-extdirs", Collections.singleton("").iterator())[ FD ]
Line_23 $$ for (Iterator<String> iterator = _options.iterator(); iterator.hasNext(); ) -->Line_24 $$ fileManager.handleOption(iterator.next(), iterator)[ CD ]
Line_5 $$ compiler = compilingTool.createCompiler()-->Line_66 $$ final JavaCompiler.CompilationTask task = compiler.getTask(out, fileManager, diagnosticConsumer, _options, null, fileManager.getJavaFileObjectsFromFiles(sources))[ FD ]
Line_60 $$ if (usingJavac) -->Line_61 $$ diagnosticConsumer.outputLineAvailable(line)[ CD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_32 $$ if (!classpath.isEmpty()) [ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_70 $$ diagnosticConsumer.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, e.getMessage()))[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_27 $$ fileManager.setOutputDirectories(outputDirToRoots)[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_72 $$ handleCancelException(diagnosticConsumer)[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_46 $$ fileManager.setLocation(StandardLocation.PLATFORM_CLASS_PATH, buildPlatformClasspath(platformClasspath, _options))[ FD ]
Line_16 $$ if (!platformClasspath.isEmpty()) -->Line_17 $$ fileManager.handleOption("-bootclasspath", Collections.singleton("").iterator())[ CD ]
Line_35 $$ if (!usingJavac && !isOptionSet(options, "-processorpath")) -->Line_36 $$ fileManager.setLocation(StandardLocation.ANNOTATION_PROCESSOR_PATH, classpath)[ CD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_61 $$ diagnosticConsumer.outputLineAvailable(line)[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_19 $$ fileManager.handleOption("-extdirs", Collections.singleton("").iterator())[ CD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_36 $$ fileManager.setLocation(StandardLocation.ANNOTATION_PROCESSOR_PATH, classpath)[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_5 $$ compiler = compilingTool.createCompiler()[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)[ CD ]
Line_21 $$ final Collection<String> _options = prepareOptions(options, compilingTool)-->Line_23 $$ for (Iterator<String> iterator = _options.iterator(); iterator.hasNext(); ) [ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_43 $$ if (!platformClasspath.isEmpty()) [ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_46 $$ fileManager.setLocation(StandardLocation.PLATFORM_CLASS_PATH, buildPlatformClasspath(platformClasspath, _options))[ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_48 $$ fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage())[ FD ]
Line_21 $$ final Collection<String> _options = prepareOptions(options, compilingTool)-->Line_66 $$ final JavaCompiler.CompilationTask task = compiler.getTask(out, fileManager, diagnosticConsumer, _options, null, fileManager.getJavaFileObjectsFromFiles(sources))[ FD ]
Line_21 $$ final Collection<String> _options = prepareOptions(options, compilingTool)-->Line_67 $$ compilingTool.prepareCompilationTask(task, _options)[ FD ]
Line_10 $$ for (File outputDir : outputDirToRoots.keySet()) -->Line_11 $$ outputDir.mkdirs()[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_66 $$ final JavaCompiler.CompilationTask task = compiler.getTask(out, fileManager, diagnosticConsumer, _options, null, fileManager.getJavaFileObjectsFromFiles(sources))[ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_66 $$ final JavaCompiler.CompilationTask task = compiler.getTask(out, fileManager, diagnosticConsumer, _options, null, fileManager.getJavaFileObjectsFromFiles(sources))[ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_81 $$ fileManager.close()[ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_29 $$ fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage())[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_16 $$ if (!platformClasspath.isEmpty()) [ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_20 $$ fileManager.handleOption("-endorseddirs", Collections.singleton("").iterator())[ CD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_21 $$ final Collection<String> _options = prepareOptions(options, compilingTool)[ FD ]
Line_23 $$ for (Iterator<String> iterator = _options.iterator(); iterator.hasNext(); ) -->Line_24 $$ fileManager.handleOption(iterator.next(), iterator)[ FD ]
Line_58 $$ final LineOutputWriter out = new LineOutputWriter() -->Line_61 $$ diagnosticConsumer.outputLineAvailable(line)[ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_45 $$ fileManager.handleOption("-bootclasspath", Collections.singleton("").iterator())[ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_39 $$ fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage())[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_53 $$ fileManager.setLocation(StandardLocation.SOURCE_PATH, sourcePath)[ FD ]
Line_82 $$ if (usingJavac) -->Line_83 $$ cleanupJavacNameTable()[ CD ]
Line_14 $$ final boolean usingJavac = compilingTool instanceof JavacCompilerTool-->Line_35 $$ if (!usingJavac && !isOptionSet(options, "-processorpath")) [ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_16 $$ if (!platformClasspath.isEmpty()) [ CD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_86 $$ return false[ CD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_36 $$ fileManager.setLocation(StandardLocation.ANNOTATION_PROCESSOR_PATH, classpath)[ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_20 $$ fileManager.handleOption("-endorseddirs", Collections.singleton("").iterator())[ FD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_24 $$ fileManager.handleOption(iterator.next(), iterator)[ FD ]
Line_3 $$ JavaCompiler compiler-->Line_5 $$ compiler = compilingTool.createCompiler()[ FD ]
Line_3 $$ JavaCompiler compiler-->Line_66 $$ final JavaCompiler.CompilationTask task = compiler.getTask(out, fileManager, diagnosticConsumer, _options, null, fileManager.getJavaFileObjectsFromFiles(sources))[ FD ]
Line_75 $$ if (cause instanceof CompilationCanceledException) -->Line_76 $$ handleCancelException(diagnosticConsumer)[ CD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_3 $$ JavaCompiler compiler[ CD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_13 $$ final List<JavaSourceTransformer> transformers = getSourceTransformers()[ CD ]
Line_15 $$ final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers)-->Line_34 $$ fileManager.setLocation(StandardLocation.CLASS_PATH, classpath)[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_7 $$ diagnosticConsumer.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, e.getMessage()))[ FD ]
Line_2 $$ public static boolean compile(Collection<String> options, final Collection<File> sources, Collection<File> classpath, Collection<File> platformClasspath, Collection<File> sourcePath, Map<File, Set<File>> outputDirToRoots, final DiagnosticOutputConsumer diagnosticConsumer, final OutputFileConsumer outputSink, CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) -->Line_10 $$ for (File outputDir : outputDirToRoots.keySet()) [ FD ]
