Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) -->Line_5 $$ Map.Entry<String, Object> entry = iterator.next()[ CD ]
Line_39 $$ if (propName.equals("omit_term_freq_and_positions")) -->Line_45 $$ iterator.remove()[ CD ]
Line_76 $$ if (indexVersionCreated.before(Version.V_2_2_0)) -->Line_77 $$ parseAnalyzersAndTermVectors(builder, name, fieldNode, parserContext)[ CD ]
Line_64 $$ if (parserContext.isWithinMultiField()) -->Line_71 $$ parseCopyFields(propNode, builder)[ CD ]
Line_6 $$ final String propName = Strings.toUnderscoreCase(entry.getKey())-->Line_63 $$ if (propName.equals("copy_to")) [ FD ]
Line_7 $$ final Object propNode = entry.getValue()-->Line_71 $$ parseCopyFields(propNode, builder)[ FD ]
Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) -->Line_51 $$ iterator.remove()[ FD ]
Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) -->Line_10 $$ iterator.remove()[ FD ]
Line_56 $$ if (propName.equals("similarity")) -->Line_57 $$ builder.similarity(parserContext.getSimilarity(propNode.toString()))[ CD ]
Line_20 $$ if (propName.equals("omit_norms")) -->Line_21 $$ builder.omitNorms(nodeBooleanValue(propNode))[ CD ]
Line_23 $$ if (propName.equals("norms")) -->Line_37 $$ DocumentMapperParser.checkNoRemainingFields(propName, properties, parserContext.indexVersionCreated())[ CD ]
Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) -->Line_55 $$ iterator.remove()[ FD ]
Line_8 $$ if (propName.equals("store")) -->Line_9 $$ builder.store(parseStore(name, propNode.toString()))[ CD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_47 $$ builder.indexOptions(nodeIndexOptionValue(propNode))[ FD ]
Line_25 $$ for (Iterator<Entry<String, Object>> propsIterator = properties.entrySet().iterator(); propsIterator.hasNext(); ) -->Line_26 $$ Entry<String, Object> entry2 = propsIterator.next()[ CD ]
Line_59 $$ if (propName.equals("fielddata")) -->Line_63 $$ if (propName.equals("copy_to")) [ CD ]
Line_7 $$ final Object propNode = entry.getValue()-->Line_40 $$ final IndexOptions op = nodeBooleanValue(propNode) ? IndexOptions.DOCS : IndexOptions.DOCS_AND_FREQS_AND_POSITIONS[ FD ]
Line_39 $$ if (propName.equals("omit_term_freq_and_positions")) -->Line_41 $$ if (indexVersionCreated.onOrAfter(Version.V_1_0_0_RC2)) [ CD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) [ CD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_61 $$ builder.fieldDataSettings(settings)[ FD ]
Line_49 $$ if (propName.equals("include_in_all")) -->Line_50 $$ builder.includeInAll(nodeBooleanValue(propNode))[ CD ]
Line_25 $$ for (Iterator<Entry<String, Object>> propsIterator = properties.entrySet().iterator(); propsIterator.hasNext(); ) -->Line_27 $$ final String propName2 = Strings.toUnderscoreCase(entry2.getKey())[ CD ]
Line_46 $$ if (propName.equals("index_options")) -->Line_49 $$ if (propName.equals("include_in_all")) [ CD ]
Line_7 $$ final Object propNode = entry.getValue()-->Line_60 $$ final Settings settings = Settings.builder().put(SettingsLoader.Helper.loadNestedFromMap(nodeMapValue(propNode, "fielddata"))).build()[ FD ]
Line_59 $$ if (propName.equals("fielddata")) -->Line_61 $$ builder.fieldDataSettings(settings)[ CD ]
Line_7 $$ final Object propNode = entry.getValue()-->Line_50 $$ builder.includeInAll(nodeBooleanValue(propNode))[ FD ]
Line_32 $$ if (propName2.equals(Loading.KEY)) -->Line_34 $$ propsIterator.remove()[ CD ]
Line_7 $$ final Object propNode = entry.getValue()-->Line_18 $$ builder.boost(nodeFloatValue(propNode))[ FD ]
Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) -->Line_5 $$ Map.Entry<String, Object> entry = iterator.next()[ FD ]
Line_6 $$ final String propName = Strings.toUnderscoreCase(entry.getKey())-->Line_39 $$ if (propName.equals("omit_term_freq_and_positions")) [ FD ]
Line_49 $$ if (propName.equals("include_in_all")) -->Line_51 $$ iterator.remove()[ CD ]
Line_6 $$ final String propName = Strings.toUnderscoreCase(entry.getKey())-->Line_17 $$ if (propName.equals("boost")) [ FD ]
Line_8 $$ if (propName.equals("store")) -->Line_11 $$ if (propName.equals("index")) [ CD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_30 $$ builder.omitNorms(!nodeBooleanValue(propNode2))[ FD ]
Line_7 $$ final Object propNode = entry.getValue()-->Line_57 $$ builder.similarity(parserContext.getSimilarity(propNode.toString()))[ FD ]
Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) -->Line_73 $$ iterator.remove()[ FD ]
Line_20 $$ if (propName.equals("omit_norms")) -->Line_22 $$ iterator.remove()[ CD ]
Line_20 $$ if (propName.equals("omit_norms")) -->Line_23 $$ if (propName.equals("norms")) [ CD ]
Line_14 $$ if (propName.equals(DOC_VALUES)) -->Line_15 $$ builder.docValues(nodeBooleanValue(propNode))[ CD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_68 $$ ESLoggerFactory.getLogger("mapping [" + parserContext.type() + "]").warn("Found a copy_to in field [" + name + "] which is within a multi field. This feature has been removed and the copy_to will be removed from the mapping.")[ FD ]
Line_3 $$ Version indexVersionCreated = parserContext.indexVersionCreated()-->Line_65 $$ if (indexVersionCreated.after(Version.V_2_1_0) || (indexVersionCreated.after(Version.V_2_0_1) && indexVersionCreated.before(Version.V_2_1_0))) [ FD ]
Line_59 $$ if (propName.equals("fielddata")) -->Line_60 $$ final Settings settings = Settings.builder().put(SettingsLoader.Helper.loadNestedFromMap(nodeMapValue(propNode, "fielddata"))).build()[ CD ]
Line_28 $$ final Object propNode2 = entry2.getValue()-->Line_33 $$ builder.normsLoading(Loading.parse(nodeStringValue(propNode2, null), null))[ FD ]
Line_23 $$ if (propName.equals("norms")) -->Line_38 $$ iterator.remove()[ CD ]
Line_7 $$ final Object propNode = entry.getValue()-->Line_15 $$ builder.docValues(nodeBooleanValue(propNode))[ FD ]
Line_11 $$ if (propName.equals("index")) -->Line_12 $$ parseIndex(name, propNode.toString(), builder)[ CD ]
Line_65 $$ if (indexVersionCreated.after(Version.V_2_1_0) || (indexVersionCreated.after(Version.V_2_0_1) && indexVersionCreated.before(Version.V_2_1_0))) -->Line_68 $$ ESLoggerFactory.getLogger("mapping [" + parserContext.type() + "]").warn("Found a copy_to in field [" + name + "] which is within a multi field. This feature has been removed and the copy_to will be removed from the mapping.")[ CD ]
Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) -->Line_58 $$ iterator.remove()[ FD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_12 $$ parseIndex(name, propNode.toString(), builder)[ FD ]
Line_8 $$ if (propName.equals("store")) -->Line_10 $$ iterator.remove()[ CD ]
Line_6 $$ final String propName = Strings.toUnderscoreCase(entry.getKey())-->Line_54 $$ if (propName.equals("doc_values_format") && indexVersionCreated.before(Version.V_2_0_0_beta1)) [ FD ]
Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) -->Line_8 $$ if (propName.equals("store")) [ CD ]
Line_17 $$ if (propName.equals("boost")) -->Line_20 $$ if (propName.equals("omit_norms")) [ CD ]
Line_3 $$ Version indexVersionCreated = parserContext.indexVersionCreated()-->Line_54 $$ if (propName.equals("doc_values_format") && indexVersionCreated.before(Version.V_2_0_0_beta1)) [ FD ]
Line_52 $$ if (propName.equals("postings_format") && indexVersionCreated.before(Version.V_2_0_0_beta1)) -->Line_53 $$ iterator.remove()[ CD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_18 $$ builder.boost(nodeFloatValue(propNode))[ FD ]
Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) -->Line_19 $$ iterator.remove()[ FD ]
Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) -->Line_45 $$ iterator.remove()[ FD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_50 $$ builder.includeInAll(nodeBooleanValue(propNode))[ FD ]
Line_63 $$ if (propName.equals("copy_to")) -->Line_73 $$ iterator.remove()[ CD ]
Line_29 $$ if (propName2.equals("enabled")) -->Line_30 $$ builder.omitNorms(!nodeBooleanValue(propNode2))[ CD ]
Line_14 $$ if (propName.equals(DOC_VALUES)) -->Line_17 $$ if (propName.equals("boost")) [ CD ]
Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) -->Line_22 $$ iterator.remove()[ FD ]
Line_29 $$ if (propName2.equals("enabled")) -->Line_31 $$ propsIterator.remove()[ CD ]
Line_6 $$ final String propName = Strings.toUnderscoreCase(entry.getKey())-->Line_46 $$ if (propName.equals("index_options")) [ FD ]
Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) -->Line_13 $$ iterator.remove()[ FD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_44 $$ builder.indexOptions(op)[ FD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_37 $$ DocumentMapperParser.checkNoRemainingFields(propName, properties, parserContext.indexVersionCreated())[ FD ]
Line_56 $$ if (propName.equals("similarity")) -->Line_59 $$ if (propName.equals("fielddata")) [ CD ]
Line_6 $$ final String propName = Strings.toUnderscoreCase(entry.getKey())-->Line_11 $$ if (propName.equals("index")) [ FD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_21 $$ builder.omitNorms(nodeBooleanValue(propNode))[ FD ]
Line_27 $$ final String propName2 = Strings.toUnderscoreCase(entry2.getKey())-->Line_29 $$ if (propName2.equals("enabled")) [ FD ]
Line_54 $$ if (propName.equals("doc_values_format") && indexVersionCreated.before(Version.V_2_0_0_beta1)) -->Line_55 $$ iterator.remove()[ CD ]
Line_26 $$ Entry<String, Object> entry2 = propsIterator.next()-->Line_27 $$ final String propName2 = Strings.toUnderscoreCase(entry2.getKey())[ FD ]
Line_7 $$ final Object propNode = entry.getValue()-->Line_21 $$ builder.omitNorms(nodeBooleanValue(propNode))[ FD ]
Line_6 $$ final String propName = Strings.toUnderscoreCase(entry.getKey())-->Line_37 $$ DocumentMapperParser.checkNoRemainingFields(propName, properties, parserContext.indexVersionCreated())[ FD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_3 $$ Version indexVersionCreated = parserContext.indexVersionCreated()[ FD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_3 $$ Version indexVersionCreated = parserContext.indexVersionCreated()[ CD ]
Line_3 $$ Version indexVersionCreated = parserContext.indexVersionCreated()-->Line_76 $$ if (indexVersionCreated.before(Version.V_2_2_0)) [ FD ]
Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) -->Line_38 $$ iterator.remove()[ FD ]
Line_52 $$ if (propName.equals("postings_format") && indexVersionCreated.before(Version.V_2_0_0_beta1)) -->Line_54 $$ if (propName.equals("doc_values_format") && indexVersionCreated.before(Version.V_2_0_0_beta1)) [ CD ]
Line_25 $$ for (Iterator<Entry<String, Object>> propsIterator = properties.entrySet().iterator(); propsIterator.hasNext(); ) -->Line_26 $$ Entry<String, Object> entry2 = propsIterator.next()[ FD ]
Line_23 $$ if (propName.equals("norms")) -->Line_39 $$ if (propName.equals("omit_term_freq_and_positions")) [ CD ]
Line_56 $$ if (propName.equals("similarity")) -->Line_58 $$ iterator.remove()[ CD ]
Line_25 $$ for (Iterator<Entry<String, Object>> propsIterator = properties.entrySet().iterator(); propsIterator.hasNext(); ) -->Line_28 $$ final Object propNode2 = entry2.getValue()[ CD ]
Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) -->Line_48 $$ iterator.remove()[ FD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_9 $$ builder.store(parseStore(name, propNode.toString()))[ FD ]
Line_11 $$ if (propName.equals("index")) -->Line_13 $$ iterator.remove()[ CD ]
Line_27 $$ final String propName2 = Strings.toUnderscoreCase(entry2.getKey())-->Line_32 $$ if (propName2.equals(Loading.KEY)) [ FD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_33 $$ builder.normsLoading(Loading.parse(nodeStringValue(propNode2, null), null))[ FD ]
Line_6 $$ final String propName = Strings.toUnderscoreCase(entry.getKey())-->Line_8 $$ if (propName.equals("store")) [ FD ]
Line_24 $$ final Map<String, Object> properties = nodeMapValue(propNode, "norms")-->Line_37 $$ DocumentMapperParser.checkNoRemainingFields(propName, properties, parserContext.indexVersionCreated())[ FD ]
Line_28 $$ final Object propNode2 = entry2.getValue()-->Line_30 $$ builder.omitNorms(!nodeBooleanValue(propNode2))[ FD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_77 $$ parseAnalyzersAndTermVectors(builder, name, fieldNode, parserContext)[ FD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_64 $$ if (parserContext.isWithinMultiField()) [ FD ]
Line_39 $$ if (propName.equals("omit_term_freq_and_positions")) -->Line_44 $$ builder.indexOptions(op)[ CD ]
Line_7 $$ final Object propNode = entry.getValue()-->Line_24 $$ final Map<String, Object> properties = nodeMapValue(propNode, "norms")[ FD ]
Line_39 $$ if (propName.equals("omit_term_freq_and_positions")) -->Line_46 $$ if (propName.equals("index_options")) [ CD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_57 $$ builder.similarity(parserContext.getSimilarity(propNode.toString()))[ FD ]
Line_5 $$ Map.Entry<String, Object> entry = iterator.next()-->Line_6 $$ final String propName = Strings.toUnderscoreCase(entry.getKey())[ FD ]
Line_6 $$ final String propName = Strings.toUnderscoreCase(entry.getKey())-->Line_20 $$ if (propName.equals("omit_norms")) [ FD ]
Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) -->Line_62 $$ iterator.remove()[ FD ]
Line_6 $$ final String propName = Strings.toUnderscoreCase(entry.getKey())-->Line_14 $$ if (propName.equals(DOC_VALUES)) [ FD ]
Line_26 $$ Entry<String, Object> entry2 = propsIterator.next()-->Line_28 $$ final Object propNode2 = entry2.getValue()[ FD ]
Line_46 $$ if (propName.equals("index_options")) -->Line_48 $$ iterator.remove()[ CD ]
Line_63 $$ if (propName.equals("copy_to")) -->Line_64 $$ if (parserContext.isWithinMultiField()) [ CD ]
Line_49 $$ if (propName.equals("include_in_all")) -->Line_52 $$ if (propName.equals("postings_format") && indexVersionCreated.before(Version.V_2_0_0_beta1)) [ CD ]
Line_25 $$ for (Iterator<Entry<String, Object>> propsIterator = properties.entrySet().iterator(); propsIterator.hasNext(); ) -->Line_29 $$ if (propName2.equals("enabled")) [ CD ]
Line_6 $$ final String propName = Strings.toUnderscoreCase(entry.getKey())-->Line_59 $$ if (propName.equals("fielddata")) [ FD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_76 $$ if (indexVersionCreated.before(Version.V_2_2_0)) [ CD ]
Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) -->Line_16 $$ iterator.remove()[ FD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_15 $$ builder.docValues(nodeBooleanValue(propNode))[ FD ]
Line_23 $$ if (propName.equals("norms")) -->Line_25 $$ for (Iterator<Entry<String, Object>> propsIterator = properties.entrySet().iterator(); propsIterator.hasNext(); ) [ CD ]
Line_23 $$ if (propName.equals("norms")) -->Line_24 $$ final Map<String, Object> properties = nodeMapValue(propNode, "norms")[ CD ]
Line_3 $$ Version indexVersionCreated = parserContext.indexVersionCreated()-->Line_41 $$ if (indexVersionCreated.onOrAfter(Version.V_1_0_0_RC2)) [ FD ]
Line_29 $$ if (propName2.equals("enabled")) -->Line_32 $$ if (propName2.equals(Loading.KEY)) [ CD ]
Line_24 $$ final Map<String, Object> properties = nodeMapValue(propNode, "norms")-->Line_25 $$ for (Iterator<Entry<String, Object>> propsIterator = properties.entrySet().iterator(); propsIterator.hasNext(); ) [ FD ]
Line_25 $$ for (Iterator<Entry<String, Object>> propsIterator = properties.entrySet().iterator(); propsIterator.hasNext(); ) -->Line_34 $$ propsIterator.remove()[ FD ]
Line_46 $$ if (propName.equals("index_options")) -->Line_47 $$ builder.indexOptions(nodeIndexOptionValue(propNode))[ CD ]
Line_7 $$ final Object propNode = entry.getValue()-->Line_9 $$ builder.store(parseStore(name, propNode.toString()))[ FD ]
Line_3 $$ Version indexVersionCreated = parserContext.indexVersionCreated()-->Line_52 $$ if (propName.equals("postings_format") && indexVersionCreated.before(Version.V_2_0_0_beta1)) [ FD ]
Line_64 $$ if (parserContext.isWithinMultiField()) -->Line_65 $$ if (indexVersionCreated.after(Version.V_2_1_0) || (indexVersionCreated.after(Version.V_2_0_1) && indexVersionCreated.before(Version.V_2_1_0))) [ CD ]
Line_17 $$ if (propName.equals("boost")) -->Line_19 $$ iterator.remove()[ CD ]
Line_6 $$ final String propName = Strings.toUnderscoreCase(entry.getKey())-->Line_23 $$ if (propName.equals("norms")) [ FD ]
Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) -->Line_6 $$ final String propName = Strings.toUnderscoreCase(entry.getKey())[ CD ]
Line_5 $$ Map.Entry<String, Object> entry = iterator.next()-->Line_7 $$ final Object propNode = entry.getValue()[ FD ]
Line_6 $$ final String propName = Strings.toUnderscoreCase(entry.getKey())-->Line_52 $$ if (propName.equals("postings_format") && indexVersionCreated.before(Version.V_2_0_0_beta1)) [ FD ]
Line_14 $$ if (propName.equals(DOC_VALUES)) -->Line_16 $$ iterator.remove()[ CD ]
Line_54 $$ if (propName.equals("doc_values_format") && indexVersionCreated.before(Version.V_2_0_0_beta1)) -->Line_56 $$ if (propName.equals("similarity")) [ CD ]
Line_25 $$ for (Iterator<Entry<String, Object>> propsIterator = properties.entrySet().iterator(); propsIterator.hasNext(); ) -->Line_31 $$ propsIterator.remove()[ FD ]
Line_7 $$ final Object propNode = entry.getValue()-->Line_12 $$ parseIndex(name, propNode.toString(), builder)[ FD ]
Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) -->Line_53 $$ iterator.remove()[ FD ]
Line_7 $$ final Object propNode = entry.getValue()-->Line_47 $$ builder.indexOptions(nodeIndexOptionValue(propNode))[ FD ]
Line_17 $$ if (propName.equals("boost")) -->Line_18 $$ builder.boost(nodeFloatValue(propNode))[ CD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_71 $$ parseCopyFields(propNode, builder)[ FD ]
Line_32 $$ if (propName2.equals(Loading.KEY)) -->Line_33 $$ builder.normsLoading(Loading.parse(nodeStringValue(propNode2, null), null))[ CD ]
Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) -->Line_7 $$ final Object propNode = entry.getValue()[ CD ]
Line_59 $$ if (propName.equals("fielddata")) -->Line_62 $$ iterator.remove()[ CD ]
Line_11 $$ if (propName.equals("index")) -->Line_14 $$ if (propName.equals(DOC_VALUES)) [ CD ]
Line_2 $$ public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) -->Line_4 $$ for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext(); ) [ FD ]
Line_6 $$ final String propName = Strings.toUnderscoreCase(entry.getKey())-->Line_49 $$ if (propName.equals("include_in_all")) [ FD ]
Line_6 $$ final String propName = Strings.toUnderscoreCase(entry.getKey())-->Line_56 $$ if (propName.equals("similarity")) [ FD ]
