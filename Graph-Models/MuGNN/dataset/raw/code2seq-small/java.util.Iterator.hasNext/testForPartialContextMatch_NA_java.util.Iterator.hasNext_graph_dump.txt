Line_29 $$ if (!list.isEmpty()) -->Line_32 $$ fragmentResult.setContainAlreadyApplied(fragmentResult.isContainAlreadyApplied() || checker.isUsesAlreadyApplied())[ CD ]
Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_25 $$ fragmentResult.setStartAtEdge(backChecker.getDistance() == 0)[ FD ]
Line_30 $$ final SequentialStepsChecker checker = new SequentialStepsChecker(fragmentResult.getEnd() + 1, true)-->Line_35 $$ fragmentResult.setEndAtEdge(checker.getDistance() == 0)[ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_55 $$ if (!mismatchSolver.isAllowMismatch()) [ FD ]
Line_52 $$ final Point pointPoint = betterPoint.getPoint()-->Line_56 $$ if (pointPoint.getDistance() > 0)[ FD ]
Line_13 $$ final Integer lineNumber = matchingIterator.next()-->Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())[ FD ]
Line_8 $$ final Iterator<FirstLineDescriptor> iterator = mismatchSolver.getStartLineVariationsIterator()-->Line_9 $$ while (iterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) [ FD ]
Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_41 $$ final int commonPart = fragmentResult.getEnd() - fragmentResult.getStart() + 1[ FD ]
Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_17 $$ if (descriptor.getStepNumber() > 0 && fragmentResult.isStartAtEdge()) [ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_6 $$ if (splitHunk.isInsertion())[ FD ]
Line_11 $$ final Iterator<Integer> matchingIterator = getMatchingIterator(descriptor.getLine(), splitHunk.getStartLineBefore() + descriptor.getOffset(), maxWalkFromBinding)-->Line_12 $$ while (matchingIterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) [ FD ]
Line_30 $$ final SequentialStepsChecker checker = new SequentialStepsChecker(fragmentResult.getEnd() + 1, true)-->Line_34 $$ fragmentResult.addDistance(checker.getDistance())[ FD ]
Line_42 $$ int contextDistance = 0-->Line_46 $$ contextDistance = distanceBack + distanceInContextAfter[ FD ]
Line_17 $$ if (descriptor.getStepNumber() > 0 && fragmentResult.isStartAtEdge()) -->Line_19 $$ int offsetForStart = -descriptor.getOffsetInStep() - 1[ CD ]
Line_8 $$ final Iterator<FirstLineDescriptor> iterator = mismatchSolver.getStartLineVariationsIterator()-->Line_10 $$ final FirstLineDescriptor descriptor = iterator.next()[ FD ]
Line_9 $$ while (iterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) -->Line_12 $$ while (matchingIterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) [ CD ]
Line_12 $$ while (matchingIterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) -->Line_13 $$ final Integer lineNumber = matchingIterator.next()[ CD ]
Line_12 $$ while (matchingIterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) -->Line_39 $$ if (pointCanBeUsed(textRangeInOldDocument)) [ CD ]
Line_20 $$ final SequentialStepsChecker backChecker = new SequentialStepsChecker(lineNumber + offsetForStart, false)-->Line_24 $$ fragmentResult.addDistance(backChecker.getDistance())[ FD ]
Line_12 $$ while (matchingIterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) -->Line_14 $$ final List<BeforeAfter<List<String>>> patchSteps = splitHunk.getPatchSteps()[ CD ]
Line_17 $$ if (descriptor.getStepNumber() > 0 && fragmentResult.isStartAtEdge()) -->Line_23 $$ fragmentResult.setStart(fragmentResult.getStart() - backChecker.getSizeOfFragmentToBeReplaced())[ CD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_14 $$ final List<BeforeAfter<List<String>>> patchSteps = splitHunk.getPatchSteps()[ FD ]
Line_14 $$ final List<BeforeAfter<List<String>>> patchSteps = splitHunk.getPatchSteps()-->Line_18 $$ final List<BeforeAfter<List<String>>> list = Collections.unmodifiableList(patchSteps.subList(0, descriptor.getStepNumber()))[ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_45 $$ final int distanceInContextAfter = getDistance(fragmentResult.getEnd() + 1, splitHunk.getContextAfter())[ FD ]
Line_17 $$ if (descriptor.getStepNumber() > 0 && fragmentResult.isStartAtEdge()) -->Line_21 $$ backChecker.go(list)[ CD ]
Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_38 $$ final TextRange textRangeInOldDocument = new UnfairTextRange(fragmentResult.getStart(), fragmentResult.getEnd())[ FD ]
Line_10 $$ final FirstLineDescriptor descriptor = iterator.next()-->Line_11 $$ final Iterator<Integer> matchingIterator = getMatchingIterator(descriptor.getLine(), splitHunk.getStartLineBefore() + descriptor.getOffset(), maxWalkFromBinding)[ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_65 $$ return true[ CD ]
Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_23 $$ fragmentResult.setStart(fragmentResult.getStart() - backChecker.getSizeOfFragmentToBeReplaced())[ FD ]
Line_10 $$ final FirstLineDescriptor descriptor = iterator.next()-->Line_15 $$ final BeforeAfter<List<String>> step = patchSteps.get(descriptor.getStepNumber())[ FD ]
Line_9 $$ while (iterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) -->Line_11 $$ final Iterator<Integer> matchingIterator = getMatchingIterator(descriptor.getLine(), splitHunk.getStartLineBefore() + descriptor.getOffset(), maxWalkFromBinding)[ CD ]
Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_33 $$ fragmentResult.setEnd(fragmentResult.getEnd() + checker.getSizeOfFragmentToBeReplaced())[ FD ]
Line_10 $$ final FirstLineDescriptor descriptor = iterator.next()-->Line_17 $$ if (descriptor.getStepNumber() > 0 && fragmentResult.isStartAtEdge()) [ FD ]
Line_5 $$ final BetterPoint betterPoint = new BetterPoint()-->Line_52 $$ final Point pointPoint = betterPoint.getPoint()[ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_55 $$ if (!mismatchSolver.isAllowMismatch()) [ CD ]
Line_20 $$ final SequentialStepsChecker backChecker = new SequentialStepsChecker(lineNumber + offsetForStart, false)-->Line_22 $$ fragmentResult.setContainAlreadyApplied(fragmentResult.isContainAlreadyApplied() || backChecker.isUsesAlreadyApplied())[ FD ]
Line_12 $$ while (matchingIterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) -->Line_15 $$ final BeforeAfter<List<String>> step = patchSteps.get(descriptor.getStepNumber())[ CD ]
Line_55 $$ if (!mismatchSolver.isAllowMismatch()) -->Line_58 $$ if (pointPoint.myCommon < 2) [ CD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_59 $$ final int contextCommon = splitHunk.getContextBefore().size() + splitHunk.getContextAfter().size() - pointPoint.myContextDistance[ FD ]
Line_30 $$ final SequentialStepsChecker checker = new SequentialStepsChecker(fragmentResult.getEnd() + 1, true)-->Line_32 $$ fragmentResult.setContainAlreadyApplied(fragmentResult.isContainAlreadyApplied() || checker.isUsesAlreadyApplied())[ FD ]
Line_52 $$ final Point pointPoint = betterPoint.getPoint()-->Line_53 $$ if (pointPoint == null)[ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_44 $$ final int distanceBack = getDistanceBack(fragmentResult.getStart() - 1, splitHunk.getContextBefore())[ FD ]
Line_27 $$ if (steps.size() > descriptor.getStepNumber() + 1 && fragmentResult.isEndAtEdge()) -->Line_29 $$ if (!list.isEmpty()) [ CD ]
Line_29 $$ if (!list.isEmpty()) -->Line_34 $$ fragmentResult.addDistance(checker.getDistance())[ CD ]
Line_60 $$ if (contextCommon == 0)-->Line_61 $$ return false[ CD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_9 $$ while (iterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) [ CD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_3 $$ final List<BeforeAfter<List<String>>> steps = splitHunk.getPatchSteps()[ CD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_5 $$ final BetterPoint betterPoint = new BetterPoint()[ CD ]
Line_10 $$ final FirstLineDescriptor descriptor = iterator.next()-->Line_27 $$ if (steps.size() > descriptor.getStepNumber() + 1 && fragmentResult.isEndAtEdge()) [ FD ]
Line_56 $$ if (pointPoint.getDistance() > 0)-->Line_57 $$ return false[ CD ]
Line_52 $$ final Point pointPoint = betterPoint.getPoint()-->Line_64 $$ putCutIntoTransformations(pointPoint.getInOldDocument(), new MyAppliedData(splitHunk.getAfterAll(), pointPoint.myUsesAlreadyApplied, false, pointPoint.getDistance() == 0, ChangeType.REPLACE))[ FD ]
Line_18 $$ final List<BeforeAfter<List<String>>> list = Collections.unmodifiableList(patchSteps.subList(0, descriptor.getStepNumber()))-->Line_21 $$ backChecker.go(list)[ FD ]
Line_39 $$ if (pointCanBeUsed(textRangeInOldDocument)) -->Line_48 $$ betterPoint.feed(new Point(distance, textRangeInOldDocument, fragmentResult.isContainAlreadyApplied(), contextDistance, commonPart))[ CD ]
Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_30 $$ final SequentialStepsChecker checker = new SequentialStepsChecker(fragmentResult.getEnd() + 1, true)[ FD ]
Line_43 $$ if (distance == 0 || commonPart < 2) -->Line_46 $$ contextDistance = distanceBack + distanceInContextAfter[ CD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_64 $$ putCutIntoTransformations(pointPoint.getInOldDocument(), new MyAppliedData(splitHunk.getAfterAll(), pointPoint.myUsesAlreadyApplied, false, pointPoint.getDistance() == 0, ChangeType.REPLACE))[ FD ]
Line_3 $$ final List<BeforeAfter<List<String>>> steps = splitHunk.getPatchSteps()-->Line_4 $$ final BeforeAfter<List<String>> first = steps.get(0)[ FD ]
Line_53 $$ if (pointPoint == null)-->Line_54 $$ return false[ CD ]
Line_11 $$ final Iterator<Integer> matchingIterator = getMatchingIterator(descriptor.getLine(), splitHunk.getStartLineBefore() + descriptor.getOffset(), maxWalkFromBinding)-->Line_13 $$ final Integer lineNumber = matchingIterator.next()[ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_11 $$ final Iterator<Integer> matchingIterator = getMatchingIterator(descriptor.getLine(), splitHunk.getStartLineBefore() + descriptor.getOffset(), maxWalkFromBinding)[ FD ]
Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_22 $$ fragmentResult.setContainAlreadyApplied(fragmentResult.isContainAlreadyApplied() || backChecker.isUsesAlreadyApplied())[ FD ]
Line_20 $$ final SequentialStepsChecker backChecker = new SequentialStepsChecker(lineNumber + offsetForStart, false)-->Line_23 $$ fragmentResult.setStart(fragmentResult.getStart() - backChecker.getSizeOfFragmentToBeReplaced())[ FD ]
Line_18 $$ final List<BeforeAfter<List<String>>> list = Collections.unmodifiableList(patchSteps.subList(0, descriptor.getStepNumber()))-->Line_29 $$ if (!list.isEmpty()) [ FD ]
Line_12 $$ while (matchingIterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) -->Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())[ CD ]
Line_58 $$ if (pointPoint.myCommon < 2) -->Line_59 $$ final int contextCommon = splitHunk.getContextBefore().size() + splitHunk.getContextAfter().size() - pointPoint.myContextDistance[ CD ]
Line_3 $$ final List<BeforeAfter<List<String>>> steps = splitHunk.getPatchSteps()-->Line_27 $$ if (steps.size() > descriptor.getStepNumber() + 1 && fragmentResult.isEndAtEdge()) [ FD ]
Line_10 $$ final FirstLineDescriptor descriptor = iterator.next()-->Line_19 $$ int offsetForStart = -descriptor.getOffsetInStep() - 1[ FD ]
Line_58 $$ if (pointPoint.myCommon < 2) -->Line_60 $$ if (contextCommon == 0)[ CD ]
Line_14 $$ final List<BeforeAfter<List<String>>> patchSteps = splitHunk.getPatchSteps()-->Line_15 $$ final BeforeAfter<List<String>> step = patchSteps.get(descriptor.getStepNumber())[ FD ]
Line_5 $$ final BetterPoint betterPoint = new BetterPoint()-->Line_12 $$ while (matchingIterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) [ FD ]
Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_35 $$ fragmentResult.setEndAtEdge(checker.getDistance() == 0)[ FD ]
Line_20 $$ final SequentialStepsChecker backChecker = new SequentialStepsChecker(lineNumber + offsetForStart, false)-->Line_25 $$ fragmentResult.setStartAtEdge(backChecker.getDistance() == 0)[ FD ]
Line_10 $$ final FirstLineDescriptor descriptor = iterator.next()-->Line_28 $$ final List<BeforeAfter<List<String>>> list = Collections.unmodifiableList(patchSteps.subList(descriptor.getStepNumber() + 1, patchSteps.size()))[ FD ]
Line_45 $$ final int distanceInContextAfter = getDistance(fragmentResult.getEnd() + 1, splitHunk.getContextAfter())-->Line_46 $$ contextDistance = distanceBack + distanceInContextAfter[ FD ]
Line_39 $$ if (pointCanBeUsed(textRangeInOldDocument)) -->Line_43 $$ if (distance == 0 || commonPart < 2) [ CD ]
Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_34 $$ fragmentResult.addDistance(checker.getDistance())[ FD ]
Line_30 $$ final SequentialStepsChecker checker = new SequentialStepsChecker(fragmentResult.getEnd() + 1, true)-->Line_33 $$ fragmentResult.setEnd(fragmentResult.getEnd() + checker.getSizeOfFragmentToBeReplaced())[ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_53 $$ if (pointPoint == null)[ CD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_4 $$ final BeforeAfter<List<String>> first = steps.get(0)[ CD ]
Line_18 $$ final List<BeforeAfter<List<String>>> list = Collections.unmodifiableList(patchSteps.subList(0, descriptor.getStepNumber()))-->Line_31 $$ checker.go(list)[ FD ]
Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_48 $$ betterPoint.feed(new Point(distance, textRangeInOldDocument, fragmentResult.isContainAlreadyApplied(), contextDistance, commonPart))[ FD ]
Line_5 $$ final BetterPoint betterPoint = new BetterPoint()-->Line_9 $$ while (iterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) [ FD ]
Line_38 $$ final TextRange textRangeInOldDocument = new UnfairTextRange(fragmentResult.getStart(), fragmentResult.getEnd())-->Line_39 $$ if (pointCanBeUsed(textRangeInOldDocument)) [ FD ]
Line_17 $$ if (descriptor.getStepNumber() > 0 && fragmentResult.isStartAtEdge()) -->Line_25 $$ fragmentResult.setStartAtEdge(backChecker.getDistance() == 0)[ CD ]
Line_12 $$ while (matchingIterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) -->Line_17 $$ if (descriptor.getStepNumber() > 0 && fragmentResult.isStartAtEdge()) [ CD ]
Line_10 $$ final FirstLineDescriptor descriptor = iterator.next()-->Line_18 $$ final List<BeforeAfter<List<String>>> list = Collections.unmodifiableList(patchSteps.subList(0, descriptor.getStepNumber()))[ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_3 $$ final List<BeforeAfter<List<String>>> steps = splitHunk.getPatchSteps()[ FD ]
Line_5 $$ final BetterPoint betterPoint = new BetterPoint()-->Line_48 $$ betterPoint.feed(new Point(distance, textRangeInOldDocument, fragmentResult.isContainAlreadyApplied(), contextDistance, commonPart))[ FD ]
Line_14 $$ final List<BeforeAfter<List<String>>> patchSteps = splitHunk.getPatchSteps()-->Line_28 $$ final List<BeforeAfter<List<String>>> list = Collections.unmodifiableList(patchSteps.subList(descriptor.getStepNumber() + 1, patchSteps.size()))[ FD ]
Line_39 $$ if (pointCanBeUsed(textRangeInOldDocument)) -->Line_42 $$ int contextDistance = 0[ CD ]
Line_55 $$ if (!mismatchSolver.isAllowMismatch()) -->Line_56 $$ if (pointPoint.getDistance() > 0)[ CD ]
Line_44 $$ final int distanceBack = getDistanceBack(fragmentResult.getStart() - 1, splitHunk.getContextBefore())-->Line_46 $$ contextDistance = distanceBack + distanceInContextAfter[ FD ]
Line_10 $$ final FirstLineDescriptor descriptor = iterator.next()-->Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())[ FD ]
Line_29 $$ if (!list.isEmpty()) -->Line_30 $$ final SequentialStepsChecker checker = new SequentialStepsChecker(fragmentResult.getEnd() + 1, true)[ CD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_52 $$ final Point pointPoint = betterPoint.getPoint()[ CD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_8 $$ final Iterator<FirstLineDescriptor> iterator = mismatchSolver.getStartLineVariationsIterator()[ FD ]
Line_6 $$ if (splitHunk.isInsertion())-->Line_7 $$ return false[ CD ]
Line_30 $$ final SequentialStepsChecker checker = new SequentialStepsChecker(fragmentResult.getEnd() + 1, true)-->Line_31 $$ checker.go(list)[ FD ]
Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_24 $$ fragmentResult.addDistance(backChecker.getDistance())[ FD ]
Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_45 $$ final int distanceInContextAfter = getDistance(fragmentResult.getEnd() + 1, splitHunk.getContextAfter())[ FD ]
Line_12 $$ while (matchingIterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) -->Line_38 $$ final TextRange textRangeInOldDocument = new UnfairTextRange(fragmentResult.getStart(), fragmentResult.getEnd())[ CD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_64 $$ putCutIntoTransformations(pointPoint.getInOldDocument(), new MyAppliedData(splitHunk.getAfterAll(), pointPoint.myUsesAlreadyApplied, false, pointPoint.getDistance() == 0, ChangeType.REPLACE))[ CD ]
Line_39 $$ if (pointCanBeUsed(textRangeInOldDocument)) -->Line_40 $$ final int distance = fragmentResult.myDistance[ CD ]
Line_15 $$ final BeforeAfter<List<String>> step = patchSteps.get(descriptor.getStepNumber())-->Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())[ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_6 $$ if (splitHunk.isInsertion())[ CD ]
Line_17 $$ if (descriptor.getStepNumber() > 0 && fragmentResult.isStartAtEdge()) -->Line_24 $$ fragmentResult.addDistance(backChecker.getDistance())[ CD ]
Line_43 $$ if (distance == 0 || commonPart < 2) -->Line_45 $$ final int distanceInContextAfter = getDistance(fragmentResult.getEnd() + 1, splitHunk.getContextAfter())[ CD ]
Line_17 $$ if (descriptor.getStepNumber() > 0 && fragmentResult.isStartAtEdge()) -->Line_22 $$ fragmentResult.setContainAlreadyApplied(fragmentResult.isContainAlreadyApplied() || backChecker.isUsesAlreadyApplied())[ CD ]
Line_9 $$ while (iterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) -->Line_10 $$ final FirstLineDescriptor descriptor = iterator.next()[ CD ]
Line_17 $$ if (descriptor.getStepNumber() > 0 && fragmentResult.isStartAtEdge()) -->Line_20 $$ final SequentialStepsChecker backChecker = new SequentialStepsChecker(lineNumber + offsetForStart, false)[ CD ]
Line_20 $$ final SequentialStepsChecker backChecker = new SequentialStepsChecker(lineNumber + offsetForStart, false)-->Line_21 $$ backChecker.go(list)[ FD ]
Line_29 $$ if (!list.isEmpty()) -->Line_33 $$ fragmentResult.setEnd(fragmentResult.getEnd() + checker.getSizeOfFragmentToBeReplaced())[ CD ]
Line_27 $$ if (steps.size() > descriptor.getStepNumber() + 1 && fragmentResult.isEndAtEdge()) -->Line_28 $$ final List<BeforeAfter<List<String>>> list = Collections.unmodifiableList(patchSteps.subList(descriptor.getStepNumber() + 1, patchSteps.size()))[ CD ]
Line_59 $$ final int contextCommon = splitHunk.getContextBefore().size() + splitHunk.getContextAfter().size() - pointPoint.myContextDistance-->Line_60 $$ if (contextCommon == 0)[ FD ]
Line_17 $$ if (descriptor.getStepNumber() > 0 && fragmentResult.isStartAtEdge()) -->Line_18 $$ final List<BeforeAfter<List<String>>> list = Collections.unmodifiableList(patchSteps.subList(0, descriptor.getStepNumber()))[ CD ]
Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_32 $$ fragmentResult.setContainAlreadyApplied(fragmentResult.isContainAlreadyApplied() || checker.isUsesAlreadyApplied())[ FD ]
Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_44 $$ final int distanceBack = getDistanceBack(fragmentResult.getStart() - 1, splitHunk.getContextBefore())[ FD ]
Line_12 $$ while (matchingIterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) -->Line_27 $$ if (steps.size() > descriptor.getStepNumber() + 1 && fragmentResult.isEndAtEdge()) [ CD ]
Line_29 $$ if (!list.isEmpty()) -->Line_35 $$ fragmentResult.setEndAtEdge(checker.getDistance() == 0)[ CD ]
Line_39 $$ if (pointCanBeUsed(textRangeInOldDocument)) -->Line_41 $$ final int commonPart = fragmentResult.getEnd() - fragmentResult.getStart() + 1[ CD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_8 $$ final Iterator<FirstLineDescriptor> iterator = mismatchSolver.getStartLineVariationsIterator()[ CD ]
Line_29 $$ if (!list.isEmpty()) -->Line_31 $$ checker.go(list)[ CD ]
Line_43 $$ if (distance == 0 || commonPart < 2) -->Line_44 $$ final int distanceBack = getDistanceBack(fragmentResult.getStart() - 1, splitHunk.getContextBefore())[ CD ]
Line_16 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_27 $$ if (steps.size() > descriptor.getStepNumber() + 1 && fragmentResult.isEndAtEdge()) [ FD ]
