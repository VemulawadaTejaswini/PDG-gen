Line_18 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_51 $$ final int distanceBack = getDistanceBack(fragmentResult.getStart() - 1, splitHunk.getContextBefore())[ FD ]
Line_31 $$ if (steps.size() > descriptor.getStepNumber() + 1 && fragmentResult.isEndAtEdge()) -->Line_34 $$ if (!list.isEmpty()) [ CD ]
Line_5 $$ final BetterPoint betterPoint = new BetterPoint()-->Line_13 $$ while (matchingIterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) [ FD ]
Line_59 $$ final Point pointPoint = betterPoint.getPoint()-->Line_60 $$ if (pointPoint == null)[ FD ]
Line_60 $$ if (pointPoint == null)-->Line_61 $$ return false[ CD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_4 $$ final BeforeAfter<List<String>> first = steps.get(0)[ CD ]
Line_17 $$ final BeforeAfter<List<String>> step = patchSteps.get(descriptor.getStepNumber())-->Line_18 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())[ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_59 $$ final Point pointPoint = betterPoint.getPoint()[ CD ]
Line_13 $$ while (matchingIterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) -->Line_31 $$ if (steps.size() > descriptor.getStepNumber() + 1 && fragmentResult.isEndAtEdge()) [ CD ]
Line_34 $$ if (!list.isEmpty()) -->Line_37 $$ fragmentResult.setContainAlreadyApplied(fragmentResult.isContainAlreadyApplied() || checker.isUsesAlreadyApplied())[ CD ]
Line_50 $$ if (distance == 0 || commonPart < 2) -->Line_52 $$ final int distanceInContextAfter = getDistance(fragmentResult.getEnd() + 1, splitHunk.getContextAfter())[ CD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_52 $$ final int distanceInContextAfter = getDistance(fragmentResult.getEnd() + 1, splitHunk.getContextAfter())[ FD ]
Line_18 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_31 $$ if (steps.size() > descriptor.getStepNumber() + 1 && fragmentResult.isEndAtEdge()) [ FD ]
Line_6 $$ if (splitHunk.isInsertion())-->Line_7 $$ return false[ CD ]
Line_18 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_48 $$ final int commonPart = fragmentResult.getEnd() - fragmentResult.getStart() + 1[ FD ]
Line_24 $$ final SequentialStepsChecker backChecker = new SequentialStepsChecker(lineNumber + offsetForStart, false)-->Line_26 $$ fragmentResult.setContainAlreadyApplied(fragmentResult.isContainAlreadyApplied() || backChecker.isUsesAlreadyApplied())[ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_3 $$ final List<BeforeAfter<List<String>>> steps = splitHunk.getPatchSteps()[ CD ]
Line_14 $$ final Integer lineNumber = matchingIterator.next()-->Line_18 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())[ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_51 $$ final int distanceBack = getDistanceBack(fragmentResult.getStart() - 1, splitHunk.getContextBefore())[ FD ]
Line_3 $$ final List<BeforeAfter<List<String>>> steps = splitHunk.getPatchSteps()-->Line_31 $$ if (steps.size() > descriptor.getStepNumber() + 1 && fragmentResult.isEndAtEdge()) [ FD ]
Line_24 $$ final SequentialStepsChecker backChecker = new SequentialStepsChecker(lineNumber + offsetForStart, false)-->Line_27 $$ fragmentResult.setStart(fragmentResult.getStart() - backChecker.getSizeOfFragmentToBeReplaced())[ FD ]
Line_34 $$ if (!list.isEmpty()) -->Line_36 $$ checker.go(list)[ CD ]
Line_10 $$ while (iterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) -->Line_13 $$ while (matchingIterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) [ CD ]
Line_65 $$ if (pointPoint.myCommon < 2) -->Line_66 $$ final int contextCommon = splitHunk.getContextBefore().size() + splitHunk.getContextAfter().size() - pointPoint.myContextDistance[ CD ]
Line_49 $$ int contextDistance = 0-->Line_53 $$ contextDistance = distanceBack + distanceInContextAfter[ FD ]
Line_18 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_26 $$ fragmentResult.setContainAlreadyApplied(fragmentResult.isContainAlreadyApplied() || backChecker.isUsesAlreadyApplied())[ FD ]
Line_13 $$ while (matchingIterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) -->Line_17 $$ final BeforeAfter<List<String>> step = patchSteps.get(descriptor.getStepNumber())[ CD ]
Line_18 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_37 $$ fragmentResult.setContainAlreadyApplied(fragmentResult.isContainAlreadyApplied() || checker.isUsesAlreadyApplied())[ FD ]
Line_18 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_39 $$ fragmentResult.addDistance(checker.getDistance())[ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_66 $$ final int contextCommon = splitHunk.getContextBefore().size() + splitHunk.getContextAfter().size() - pointPoint.myContextDistance[ FD ]
Line_10 $$ while (iterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) -->Line_12 $$ final Iterator<Integer> matchingIterator = getMatchingIterator(descriptor.getLine(), splitHunk.getStartLineBefore() + descriptor.getOffset(), maxWalkFromBinding)[ CD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_6 $$ if (splitHunk.isInsertion())[ CD ]
Line_18 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_38 $$ fragmentResult.setEnd(fragmentResult.getEnd() + checker.getSizeOfFragmentToBeReplaced())[ FD ]
Line_34 $$ if (!list.isEmpty()) -->Line_35 $$ final SequentialStepsChecker checker = new SequentialStepsChecker(fragmentResult.getEnd() + 1, true)[ CD ]
Line_3 $$ final List<BeforeAfter<List<String>>> steps = splitHunk.getPatchSteps()-->Line_4 $$ final BeforeAfter<List<String>> first = steps.get(0)[ FD ]
Line_67 $$ if (contextCommon == 0)-->Line_68 $$ return false[ CD ]
Line_18 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_29 $$ fragmentResult.setStartAtEdge(backChecker.getDistance() == 0)[ FD ]
Line_11 $$ final FirstLineDescriptor descriptor = iterator.next()-->Line_12 $$ final Iterator<Integer> matchingIterator = getMatchingIterator(descriptor.getLine(), splitHunk.getStartLineBefore() + descriptor.getOffset(), maxWalkFromBinding)[ FD ]
Line_18 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_40 $$ fragmentResult.setEndAtEdge(checker.getDistance() == 0)[ FD ]
Line_35 $$ final SequentialStepsChecker checker = new SequentialStepsChecker(fragmentResult.getEnd() + 1, true)-->Line_40 $$ fragmentResult.setEndAtEdge(checker.getDistance() == 0)[ FD ]
Line_18 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_43 $$ final TextRange textRangeInOldDocument = new UnfairTextRange(fragmentResult.getStart(), fragmentResult.getEnd())[ FD ]
Line_5 $$ final BetterPoint betterPoint = new BetterPoint()-->Line_10 $$ while (iterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) [ FD ]
Line_18 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_35 $$ final SequentialStepsChecker checker = new SequentialStepsChecker(fragmentResult.getEnd() + 1, true)[ FD ]
Line_34 $$ if (!list.isEmpty()) -->Line_39 $$ fragmentResult.addDistance(checker.getDistance())[ CD ]
Line_63 $$ if (pointPoint.getDistance() > 0)-->Line_64 $$ return false[ CD ]
Line_35 $$ final SequentialStepsChecker checker = new SequentialStepsChecker(fragmentResult.getEnd() + 1, true)-->Line_39 $$ fragmentResult.addDistance(checker.getDistance())[ FD ]
Line_65 $$ if (pointPoint.myCommon < 2) -->Line_67 $$ if (contextCommon == 0)[ CD ]
Line_62 $$ if (!mismatchSolver.isAllowMismatch()) -->Line_65 $$ if (pointPoint.myCommon < 2) [ CD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_72 $$ return true[ CD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_10 $$ while (iterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) [ CD ]
Line_11 $$ final FirstLineDescriptor descriptor = iterator.next()-->Line_31 $$ if (steps.size() > descriptor.getStepNumber() + 1 && fragmentResult.isEndAtEdge()) [ FD ]
Line_34 $$ if (!list.isEmpty()) -->Line_38 $$ fragmentResult.setEnd(fragmentResult.getEnd() + checker.getSizeOfFragmentToBeReplaced())[ CD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_71 $$ putCutIntoTransformations(pointPoint.getInOldDocument(), new MyAppliedData(splitHunk.getAfterAll(), pointPoint.myUsesAlreadyApplied, false, pointPoint.getDistance() == 0, ChangeType.REPLACE))[ CD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_62 $$ if (!mismatchSolver.isAllowMismatch()) [ CD ]
Line_24 $$ final SequentialStepsChecker backChecker = new SequentialStepsChecker(lineNumber + offsetForStart, false)-->Line_25 $$ backChecker.go(list)[ FD ]
Line_50 $$ if (distance == 0 || commonPart < 2) -->Line_51 $$ final int distanceBack = getDistanceBack(fragmentResult.getStart() - 1, splitHunk.getContextBefore())[ CD ]
Line_12 $$ final Iterator<Integer> matchingIterator = getMatchingIterator(descriptor.getLine(), splitHunk.getStartLineBefore() + descriptor.getOffset(), maxWalkFromBinding)-->Line_14 $$ final Integer lineNumber = matchingIterator.next()[ FD ]
Line_62 $$ if (!mismatchSolver.isAllowMismatch()) -->Line_63 $$ if (pointPoint.getDistance() > 0)[ CD ]
Line_35 $$ final SequentialStepsChecker checker = new SequentialStepsChecker(fragmentResult.getEnd() + 1, true)-->Line_37 $$ fragmentResult.setContainAlreadyApplied(fragmentResult.isContainAlreadyApplied() || checker.isUsesAlreadyApplied())[ FD ]
Line_50 $$ if (distance == 0 || commonPart < 2) -->Line_53 $$ contextDistance = distanceBack + distanceInContextAfter[ CD ]
Line_18 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_28 $$ fragmentResult.addDistance(backChecker.getDistance())[ FD ]
Line_10 $$ while (iterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) -->Line_11 $$ final FirstLineDescriptor descriptor = iterator.next()[ CD ]
Line_59 $$ final Point pointPoint = betterPoint.getPoint()-->Line_63 $$ if (pointPoint.getDistance() > 0)[ FD ]
Line_24 $$ final SequentialStepsChecker backChecker = new SequentialStepsChecker(lineNumber + offsetForStart, false)-->Line_29 $$ fragmentResult.setStartAtEdge(backChecker.getDistance() == 0)[ FD ]
Line_59 $$ final Point pointPoint = betterPoint.getPoint()-->Line_71 $$ putCutIntoTransformations(pointPoint.getInOldDocument(), new MyAppliedData(splitHunk.getAfterAll(), pointPoint.myUsesAlreadyApplied, false, pointPoint.getDistance() == 0, ChangeType.REPLACE))[ FD ]
Line_13 $$ while (matchingIterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) -->Line_43 $$ final TextRange textRangeInOldDocument = new UnfairTextRange(fragmentResult.getStart(), fragmentResult.getEnd())[ CD ]
Line_11 $$ final FirstLineDescriptor descriptor = iterator.next()-->Line_23 $$ int offsetForStart = -descriptor.getOffsetInStep() - 1[ FD ]
Line_51 $$ final int distanceBack = getDistanceBack(fragmentResult.getStart() - 1, splitHunk.getContextBefore())-->Line_53 $$ contextDistance = distanceBack + distanceInContextAfter[ FD ]
Line_18 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_27 $$ fragmentResult.setStart(fragmentResult.getStart() - backChecker.getSizeOfFragmentToBeReplaced())[ FD ]
Line_35 $$ final SequentialStepsChecker checker = new SequentialStepsChecker(fragmentResult.getEnd() + 1, true)-->Line_36 $$ checker.go(list)[ FD ]
Line_34 $$ if (!list.isEmpty()) -->Line_40 $$ fragmentResult.setEndAtEdge(checker.getDistance() == 0)[ CD ]
Line_66 $$ final int contextCommon = splitHunk.getContextBefore().size() + splitHunk.getContextAfter().size() - pointPoint.myContextDistance-->Line_67 $$ if (contextCommon == 0)[ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_3 $$ final List<BeforeAfter<List<String>>> steps = splitHunk.getPatchSteps()[ FD ]
Line_5 $$ final BetterPoint betterPoint = new BetterPoint()-->Line_55 $$ betterPoint.feed(new Point(distance, textRangeInOldDocument, fragmentResult.isContainAlreadyApplied(), contextDistance, commonPart))[ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_5 $$ final BetterPoint betterPoint = new BetterPoint()[ CD ]
Line_18 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_52 $$ final int distanceInContextAfter = getDistance(fragmentResult.getEnd() + 1, splitHunk.getContextAfter())[ FD ]
Line_24 $$ final SequentialStepsChecker backChecker = new SequentialStepsChecker(lineNumber + offsetForStart, false)-->Line_28 $$ fragmentResult.addDistance(backChecker.getDistance())[ FD ]
Line_5 $$ final BetterPoint betterPoint = new BetterPoint()-->Line_59 $$ final Point pointPoint = betterPoint.getPoint()[ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_6 $$ if (splitHunk.isInsertion())[ FD ]
Line_11 $$ final FirstLineDescriptor descriptor = iterator.next()-->Line_17 $$ final BeforeAfter<List<String>> step = patchSteps.get(descriptor.getStepNumber())[ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_62 $$ if (!mismatchSolver.isAllowMismatch()) [ FD ]
Line_12 $$ final Iterator<Integer> matchingIterator = getMatchingIterator(descriptor.getLine(), splitHunk.getStartLineBefore() + descriptor.getOffset(), maxWalkFromBinding)-->Line_13 $$ while (matchingIterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) [ FD ]
Line_13 $$ while (matchingIterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) -->Line_14 $$ final Integer lineNumber = matchingIterator.next()[ CD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_60 $$ if (pointPoint == null)[ CD ]
Line_52 $$ final int distanceInContextAfter = getDistance(fragmentResult.getEnd() + 1, splitHunk.getContextAfter())-->Line_53 $$ contextDistance = distanceBack + distanceInContextAfter[ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_71 $$ putCutIntoTransformations(pointPoint.getInOldDocument(), new MyAppliedData(splitHunk.getAfterAll(), pointPoint.myUsesAlreadyApplied, false, pointPoint.getDistance() == 0, ChangeType.REPLACE))[ FD ]
Line_2 $$ private boolean testForPartialContextMatch(final SplitHunk splitHunk, final MismatchSolver mismatchSolver, final int maxWalkFromBinding) -->Line_12 $$ final Iterator<Integer> matchingIterator = getMatchingIterator(descriptor.getLine(), splitHunk.getStartLineBefore() + descriptor.getOffset(), maxWalkFromBinding)[ FD ]
Line_18 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())-->Line_55 $$ betterPoint.feed(new Point(distance, textRangeInOldDocument, fragmentResult.isContainAlreadyApplied(), contextDistance, commonPart))[ FD ]
Line_35 $$ final SequentialStepsChecker checker = new SequentialStepsChecker(fragmentResult.getEnd() + 1, true)-->Line_38 $$ fragmentResult.setEnd(fragmentResult.getEnd() + checker.getSizeOfFragmentToBeReplaced())[ FD ]
Line_13 $$ while (matchingIterator.hasNext() && (betterPoint.getPoint() == null || !betterPoint.getPoint().idealFound())) -->Line_18 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())[ CD ]
Line_11 $$ final FirstLineDescriptor descriptor = iterator.next()-->Line_18 $$ final FragmentResult fragmentResult = checkFragmented(lineNumber, descriptor.getOffsetInStep(), step, descriptor.isIsInBefore())[ FD ]
