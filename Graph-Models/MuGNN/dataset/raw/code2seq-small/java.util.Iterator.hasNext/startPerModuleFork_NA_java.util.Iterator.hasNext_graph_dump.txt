Line_13 $$ final boolean forkTillMethod = myForkMode.equalsIgnoreCase("method")-->Line_14 $$ return splitChildren(children, result, forkTillMethod, new File(workingDir), classpath)[ FD ]
Line_8 $$ for (Iterator iterator = children.iterator(); iterator.hasNext(); ) -->Line_9 $$ if (!classNames.contains(getTestClassName(iterator.next()))) [ CD ]
Line_7 $$ final List children = new ArrayList(getChildren(myRootDescription))-->Line_14 $$ return splitChildren(children, result, forkTillMethod, new File(workingDir), classpath)[ FD ]
Line_2 $$ protected int startPerModuleFork(String moduleName, List classNames, String packageName, String workingDir, String classpath, int result) throws Exception -->Line_9 $$ if (!classNames.contains(getTestClassName(iterator.next()))) [ FD ]
Line_2 $$ protected int startPerModuleFork(String moduleName, List classNames, String packageName, String workingDir, String classpath, int result) throws Exception -->Line_3 $$ if (myForkMode.equals("none")) [ CD ]
Line_3 $$ if (myForkMode.equals("none")) -->Line_4 $$ final List childArgs = createPerModuleArgs(packageName, workingDir, classNames, myRootDescription)[ CD ]
Line_8 $$ for (Iterator iterator = children.iterator(); iterator.hasNext(); ) -->Line_9 $$ if (!classNames.contains(getTestClassName(iterator.next()))) [ FD ]
Line_8 $$ for (Iterator iterator = children.iterator(); iterator.hasNext(); ) -->Line_10 $$ iterator.remove()[ FD ]
Line_7 $$ final List children = new ArrayList(getChildren(myRootDescription))-->Line_8 $$ for (Iterator iterator = children.iterator(); iterator.hasNext(); ) [ FD ]
Line_2 $$ protected int startPerModuleFork(String moduleName, List classNames, String packageName, String workingDir, String classpath, int result) throws Exception -->Line_5 $$ return startChildFork(childArgs, new File(workingDir), classpath)[ FD ]
Line_3 $$ if (myForkMode.equals("none")) -->Line_5 $$ return startChildFork(childArgs, new File(workingDir), classpath)[ CD ]
Line_4 $$ final List childArgs = createPerModuleArgs(packageName, workingDir, classNames, myRootDescription)-->Line_5 $$ return startChildFork(childArgs, new File(workingDir), classpath)[ FD ]
Line_3 $$ if (myForkMode.equals("none")) -->Line_8 $$ for (Iterator iterator = children.iterator(); iterator.hasNext(); ) [ CD ]
Line_2 $$ protected int startPerModuleFork(String moduleName, List classNames, String packageName, String workingDir, String classpath, int result) throws Exception -->Line_14 $$ return splitChildren(children, result, forkTillMethod, new File(workingDir), classpath)[ FD ]
Line_9 $$ if (!classNames.contains(getTestClassName(iterator.next()))) -->Line_10 $$ iterator.remove()[ CD ]
Line_2 $$ protected int startPerModuleFork(String moduleName, List classNames, String packageName, String workingDir, String classpath, int result) throws Exception -->Line_4 $$ final List childArgs = createPerModuleArgs(packageName, workingDir, classNames, myRootDescription)[ FD ]
Line_3 $$ if (myForkMode.equals("none")) -->Line_14 $$ return splitChildren(children, result, forkTillMethod, new File(workingDir), classpath)[ CD ]
Line_3 $$ if (myForkMode.equals("none")) -->Line_7 $$ final List children = new ArrayList(getChildren(myRootDescription))[ CD ]
Line_3 $$ if (myForkMode.equals("none")) -->Line_13 $$ final boolean forkTillMethod = myForkMode.equalsIgnoreCase("method")[ CD ]
