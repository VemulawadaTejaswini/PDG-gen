Line_2 $$ void recoverTransitionRead(DataNode datanode, NamespaceInfo nsInfo, Collection<File> dataDirs, StartupOption startOpt) throws IOException -->Line_4 $$ Set<String> existingStorageDirs = new HashSet<String>()[ CD ]
Line_9 $$ for (Iterator<File> it = dataDirs.iterator(); it.hasNext(); ) -->Line_10 $$ File dataDir = it.next()[ CD ]
Line_9 $$ for (Iterator<File> it = dataDirs.iterator(); it.hasNext(); ) -->Line_17 $$ StorageState curState[ CD ]
Line_11 $$ if (existingStorageDirs.contains(dataDir.getAbsolutePath())) -->Line_12 $$ LOG.info("Storage directory " + dataDir + " has already been used.")[ CD ]
Line_2 $$ void recoverTransitionRead(DataNode datanode, NamespaceInfo nsInfo, Collection<File> dataDirs, StartupOption startOpt) throws IOException -->Line_50 $$ this.writeAll()[ CD ]
Line_9 $$ for (Iterator<File> it = dataDirs.iterator(); it.hasNext(); ) -->Line_41 $$ dataDirStates.add(curState)[ CD ]
Line_2 $$ void recoverTransitionRead(DataNode datanode, NamespaceInfo nsInfo, Collection<File> dataDirs, StartupOption startOpt) throws IOException -->Line_31 $$ format(sd, nsInfo)[ FD ]
Line_9 $$ for (Iterator<File> it = dataDirs.iterator(); it.hasNext(); ) -->Line_11 $$ if (existingStorageDirs.contains(dataDir.getAbsolutePath())) [ CD ]
Line_2 $$ void recoverTransitionRead(DataNode datanode, NamespaceInfo nsInfo, Collection<File> dataDirs, StartupOption startOpt) throws IOException -->Line_8 $$ ArrayList<StorageState> dataDirStates = new ArrayList<StorageState>(dataDirs.size())[ CD ]
Line_10 $$ File dataDir = it.next()-->Line_11 $$ if (existingStorageDirs.contains(dataDir.getAbsolutePath())) [ FD ]
Line_9 $$ for (Iterator<File> it = dataDirs.iterator(); it.hasNext(); ) -->Line_16 $$ StorageDirectory sd = new StorageDirectory(dataDir, null, true)[ CD ]
Line_2 $$ void recoverTransitionRead(DataNode datanode, NamespaceInfo nsInfo, Collection<File> dataDirs, StartupOption startOpt) throws IOException -->Line_47 $$ doTransition(datanode, getStorageDir(idx), nsInfo, startOpt)[ FD ]
Line_2 $$ void recoverTransitionRead(DataNode datanode, NamespaceInfo nsInfo, Collection<File> dataDirs, StartupOption startOpt) throws IOException -->Line_48 $$ assert getCTime() == nsInfo.getCTime() : "Data-node and name-node CTimes must be the same."[ FD ]
Line_16 $$ StorageDirectory sd = new StorageDirectory(dataDir, null, true)-->Line_34 $$ sd.doRecover(curState)[ FD ]
Line_9 $$ for (Iterator<File> it = dataDirs.iterator(); it.hasNext(); ) -->Line_13 $$ it.remove()[ FD ]
Line_2 $$ void recoverTransitionRead(DataNode datanode, NamespaceInfo nsInfo, Collection<File> dataDirs, StartupOption startOpt) throws IOException -->Line_9 $$ for (Iterator<File> it = dataDirs.iterator(); it.hasNext(); ) [ CD ]
Line_19 $$ curState = sd.analyzeStorage(startOpt, this)-->Line_34 $$ sd.doRecover(curState)[ FD ]
Line_5 $$ for (int i = 0; i < getNumStorageDirs(); i++) -->Line_6 $$ existingStorageDirs.add(getStorageDir(i).getRoot().getAbsolutePath())[ CD ]
Line_2 $$ void recoverTransitionRead(DataNode datanode, NamespaceInfo nsInfo, Collection<File> dataDirs, StartupOption startOpt) throws IOException -->Line_9 $$ for (Iterator<File> it = dataDirs.iterator(); it.hasNext(); ) [ FD ]
Line_2 $$ void recoverTransitionRead(DataNode datanode, NamespaceInfo nsInfo, Collection<File> dataDirs, StartupOption startOpt) throws IOException -->Line_43 $$ if (dataDirs.size() == 0)[ FD ]
Line_9 $$ for (Iterator<File> it = dataDirs.iterator(); it.hasNext(); ) -->Line_10 $$ File dataDir = it.next()[ FD ]
Line_16 $$ StorageDirectory sd = new StorageDirectory(dataDir, null, true)-->Line_31 $$ format(sd, nsInfo)[ FD ]
Line_2 $$ void recoverTransitionRead(DataNode datanode, NamespaceInfo nsInfo, Collection<File> dataDirs, StartupOption startOpt) throws IOException -->Line_8 $$ ArrayList<StorageState> dataDirStates = new ArrayList<StorageState>(dataDirs.size())[ FD ]
Line_17 $$ StorageState curState-->Line_41 $$ dataDirStates.add(curState)[ FD ]
Line_17 $$ StorageState curState-->Line_19 $$ curState = sd.analyzeStorage(startOpt, this)[ FD ]
Line_2 $$ void recoverTransitionRead(DataNode datanode, NamespaceInfo nsInfo, Collection<File> dataDirs, StartupOption startOpt) throws IOException -->Line_5 $$ for (int i = 0; i < getNumStorageDirs(); i++) [ CD ]
Line_2 $$ void recoverTransitionRead(DataNode datanode, NamespaceInfo nsInfo, Collection<File> dataDirs, StartupOption startOpt) throws IOException -->Line_43 $$ if (dataDirs.size() == 0)[ CD ]
Line_2 $$ void recoverTransitionRead(DataNode datanode, NamespaceInfo nsInfo, Collection<File> dataDirs, StartupOption startOpt) throws IOException -->Line_3 $$ LOG.info("Analyzing storage directories for bpid " + nsInfo.getBlockPoolID())[ CD ]
Line_2 $$ void recoverTransitionRead(DataNode datanode, NamespaceInfo nsInfo, Collection<File> dataDirs, StartupOption startOpt) throws IOException -->Line_19 $$ curState = sd.analyzeStorage(startOpt, this)[ FD ]
Line_8 $$ ArrayList<StorageState> dataDirStates = new ArrayList<StorageState>(dataDirs.size())-->Line_41 $$ dataDirStates.add(curState)[ FD ]
Line_2 $$ void recoverTransitionRead(DataNode datanode, NamespaceInfo nsInfo, Collection<File> dataDirs, StartupOption startOpt) throws IOException -->Line_46 $$ for (int idx = 0; idx < getNumStorageDirs(); idx++) [ CD ]
Line_16 $$ StorageDirectory sd = new StorageDirectory(dataDir, null, true)-->Line_19 $$ curState = sd.analyzeStorage(startOpt, this)[ FD ]
Line_9 $$ for (Iterator<File> it = dataDirs.iterator(); it.hasNext(); ) -->Line_25 $$ it.remove()[ FD ]
Line_17 $$ StorageState curState-->Line_34 $$ sd.doRecover(curState)[ FD ]
Line_4 $$ Set<String> existingStorageDirs = new HashSet<String>()-->Line_6 $$ existingStorageDirs.add(getStorageDir(i).getRoot().getAbsolutePath())[ FD ]
Line_4 $$ Set<String> existingStorageDirs = new HashSet<String>()-->Line_11 $$ if (existingStorageDirs.contains(dataDir.getAbsolutePath())) [ FD ]
Line_11 $$ if (existingStorageDirs.contains(dataDir.getAbsolutePath())) -->Line_13 $$ it.remove()[ CD ]
Line_2 $$ void recoverTransitionRead(DataNode datanode, NamespaceInfo nsInfo, Collection<File> dataDirs, StartupOption startOpt) throws IOException -->Line_3 $$ LOG.info("Analyzing storage directories for bpid " + nsInfo.getBlockPoolID())[ FD ]
Line_16 $$ StorageDirectory sd = new StorageDirectory(dataDir, null, true)-->Line_37 $$ sd.unlock()[ FD ]
Line_9 $$ for (Iterator<File> it = dataDirs.iterator(); it.hasNext(); ) -->Line_40 $$ addStorageDir(sd)[ CD ]
Line_16 $$ StorageDirectory sd = new StorageDirectory(dataDir, null, true)-->Line_40 $$ addStorageDir(sd)[ FD ]
Line_5 $$ for (int i = 0; i < getNumStorageDirs(); i++) -->Line_6 $$ existingStorageDirs.add(getStorageDir(i).getRoot().getAbsolutePath())[ FD ]
Line_46 $$ for (int idx = 0; idx < getNumStorageDirs(); idx++) -->Line_47 $$ doTransition(datanode, getStorageDir(idx), nsInfo, startOpt)[ FD ]
Line_46 $$ for (int idx = 0; idx < getNumStorageDirs(); idx++) -->Line_47 $$ doTransition(datanode, getStorageDir(idx), nsInfo, startOpt)[ CD ]
Line_19 $$ curState = sd.analyzeStorage(startOpt, this)-->Line_41 $$ dataDirStates.add(curState)[ FD ]
