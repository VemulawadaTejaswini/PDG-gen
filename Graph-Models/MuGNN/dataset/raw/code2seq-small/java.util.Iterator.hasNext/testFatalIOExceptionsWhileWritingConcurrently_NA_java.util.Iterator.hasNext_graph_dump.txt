Line_83 $$ Translog.Operation next = snapshot.next()-->Line_84 $$ assertNotNull("operation " + i + " must be non-null", next)[ FD ]
Line_41 $$ for (int i = 0; i < threadCount; i++) -->Line_42 $$ threads[i].join()[ CD ]
Line_75 $$ for (int i = 0; i < threadCount; i++) -->Line_81 $$ for (int i = 0; i < writtenOperations.size(); i++) [ FD ]
Line_5 $$ TranslogConfig config = getTranslogConfig(tempDir)-->Line_6 $$ Translog translog = getFailableTranslog(fail, config)[ FD ]
Line_41 $$ for (int i = 0; i < threadCount; i++) -->Line_82 $$ assertEquals("expected operation" + i + " to be in the previous translog but wasn't", tlog.currentFileGeneration() - 1, writtenOperations.get(i).location.generation)[ FD ]
Line_12 $$ List<LocationOperation> writtenOperations = Collections.synchronizedList(new ArrayList())-->Line_81 $$ for (int i = 0; i < writtenOperations.size(); i++) [ FD ]
Line_75 $$ for (int i = 0; i < threadCount; i++) -->Line_85 $$ assertEquals(next, writtenOperations.get(i).operation)[ FD ]
Line_7 $$ final int threadCount = randomIntBetween(1, 5)-->Line_75 $$ for (int i = 0; i < threadCount; i++) [ FD ]
Line_76 $$ if (threadExceptions[i] != null)-->Line_77 $$ threadExceptions[i].printStackTrace()[ CD ]
Line_12 $$ List<LocationOperation> writtenOperations = Collections.synchronizedList(new ArrayList())-->Line_63 $$ Iterator<LocationOperation> iterator = writtenOperations.iterator()[ FD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_8 $$ Thread[] threads = new Thread[threadCount][ CD ]
Line_4 $$ final AtomicBoolean fail = new AtomicBoolean(false)-->Line_6 $$ Translog translog = getFailableTranslog(fail, config)[ FD ]
Line_11 $$ final CountDownLatch added = new CountDownLatch(randomIntBetween(10, 100))-->Line_20 $$ added.countDown()[ FD ]
Line_6 $$ Translog translog = getFailableTranslog(fail, config)-->Line_71 $$ config.setTranslogGeneration(translog.getGeneration())[ FD ]
Line_81 $$ for (int i = 0; i < writtenOperations.size(); i++) -->Line_82 $$ assertEquals("expected operation" + i + " to be in the previous translog but wasn't", tlog.currentFileGeneration() - 1, writtenOperations.get(i).location.generation)[ FD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_13 $$ for (int i = 0; i < threadCount; i++) [ CD ]
Line_15 $$ threads[i] = new TranslogThread(translog, downLatch, 200, threadId, writtenOperations, threadExceptions) -->Line_21 $$ return add[ CD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_9 $$ final Throwable[] threadExceptions = new Throwable[threadCount][ CD ]
Line_13 $$ for (int i = 0; i < threadCount; i++) -->Line_41 $$ for (int i = 0; i < threadCount; i++) [ FD ]
Line_12 $$ List<LocationOperation> writtenOperations = Collections.synchronizedList(new ArrayList())-->Line_80 $$ assertEquals(writtenOperations.size(), snapshot.estimatedTotalOperations())[ FD ]
Line_81 $$ for (int i = 0; i < writtenOperations.size(); i++) -->Line_83 $$ Translog.Operation next = snapshot.next()[ CD ]
Line_15 $$ threads[i] = new TranslogThread(translog, downLatch, 200, threadId, writtenOperations, threadExceptions) -->Line_26 $$ if (randomBoolean()) [ CD ]
Line_26 $$ if (randomBoolean()) -->Line_27 $$ translog.sync()[ CD ]
Line_83 $$ Translog.Operation next = snapshot.next()-->Line_85 $$ assertEquals(next, writtenOperations.get(i).operation)[ FD ]
Line_41 $$ for (int i = 0; i < threadCount; i++) -->Line_85 $$ assertEquals(next, writtenOperations.get(i).operation)[ FD ]
Line_81 $$ for (int i = 0; i < writtenOperations.size(); i++) -->Line_82 $$ assertEquals("expected operation" + i + " to be in the previous translog but wasn't", tlog.currentFileGeneration() - 1, writtenOperations.get(i).location.generation)[ CD ]
Line_6 $$ Translog translog = getFailableTranslog(fail, config)-->Line_53 $$ boolean syncNeeded = translog.syncNeeded()[ FD ]
Line_64 $$ while (iterator.hasNext()) -->Line_65 $$ LocationOperation next = iterator.next()[ CD ]
Line_13 $$ for (int i = 0; i < threadCount; i++) -->Line_75 $$ for (int i = 0; i < threadCount; i++) [ FD ]
Line_5 $$ TranslogConfig config = getTranslogConfig(tempDir)-->Line_62 $$ final Checkpoint checkpoint = Checkpoint.read(config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME))[ FD ]
Line_75 $$ for (int i = 0; i < threadCount; i++) -->Line_82 $$ assertEquals("expected operation" + i + " to be in the previous translog but wasn't", tlog.currentFileGeneration() - 1, writtenOperations.get(i).location.generation)[ FD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_4 $$ final AtomicBoolean fail = new AtomicBoolean(false)[ CD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_5 $$ TranslogConfig config = getTranslogConfig(tempDir)[ CD ]
Line_15 $$ threads[i] = new TranslogThread(translog, downLatch, 200, threadId, writtenOperations, threadExceptions) -->Line_20 $$ added.countDown()[ CD ]
Line_64 $$ while (iterator.hasNext()) -->Line_66 $$ if (checkpoint.offset < (next.location.translogLocation + next.location.size)) [ CD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_11 $$ final CountDownLatch added = new CountDownLatch(randomIntBetween(10, 100))[ CD ]
Line_81 $$ for (int i = 0; i < writtenOperations.size(); i++) -->Line_84 $$ assertNotNull("operation " + i + " must be non-null", next)[ CD ]
Line_13 $$ for (int i = 0; i < threadCount; i++) -->Line_31 $$ threads[i].setDaemon(true)[ CD ]
Line_6 $$ Translog translog = getFailableTranslog(fail, config)-->Line_54 $$ translog.close()[ FD ]
Line_13 $$ for (int i = 0; i < threadCount; i++) -->Line_15 $$ threads[i] = new TranslogThread(translog, downLatch, 200, threadId, writtenOperations, threadExceptions) [ CD ]
Line_13 $$ for (int i = 0; i < threadCount; i++) -->Line_14 $$ final int threadId = i[ CD ]
Line_13 $$ for (int i = 0; i < threadCount; i++) -->Line_85 $$ assertEquals(next, writtenOperations.get(i).operation)[ FD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_6 $$ Translog translog = getFailableTranslog(fail, config)[ CD ]
Line_81 $$ for (int i = 0; i < writtenOperations.size(); i++) -->Line_85 $$ assertEquals(next, writtenOperations.get(i).operation)[ CD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_3 $$ Path tempDir = createTempDir()[ CD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_7 $$ final int threadCount = randomIntBetween(1, 5)[ CD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_35 $$ added.await()[ CD ]
Line_81 $$ for (int i = 0; i < writtenOperations.size(); i++) -->Line_85 $$ assertEquals(next, writtenOperations.get(i).operation)[ FD ]
Line_74 $$ if (writtenOperations.size() != snapshot.estimatedTotalOperations()) -->Line_75 $$ for (int i = 0; i < threadCount; i++) [ CD ]
Line_41 $$ for (int i = 0; i < threadCount; i++) -->Line_75 $$ for (int i = 0; i < threadCount; i++) [ FD ]
Line_7 $$ final int threadCount = randomIntBetween(1, 5)-->Line_13 $$ for (int i = 0; i < threadCount; i++) [ FD ]
Line_12 $$ List<LocationOperation> writtenOperations = Collections.synchronizedList(new ArrayList())-->Line_85 $$ assertEquals(next, writtenOperations.get(i).operation)[ FD ]
Line_5 $$ TranslogConfig config = getTranslogConfig(tempDir)-->Line_71 $$ config.setTranslogGeneration(translog.getGeneration())[ FD ]
Line_75 $$ for (int i = 0; i < threadCount; i++) -->Line_76 $$ if (threadExceptions[i] != null)[ CD ]
Line_15 $$ threads[i] = new TranslogThread(translog, downLatch, 200, threadId, writtenOperations, threadExceptions) -->Line_19 $$ Translog.Location add = super.add(op)[ FD ]
Line_13 $$ for (int i = 0; i < threadCount; i++) -->Line_32 $$ threads[i].start()[ CD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_34 $$ downLatch.countDown()[ CD ]
Line_3 $$ Path tempDir = createTempDir()-->Line_5 $$ TranslogConfig config = getTranslogConfig(tempDir)[ FD ]
Line_13 $$ for (int i = 0; i < threadCount; i++) -->Line_82 $$ assertEquals("expected operation" + i + " to be in the previous translog but wasn't", tlog.currentFileGeneration() - 1, writtenOperations.get(i).location.generation)[ FD ]
Line_13 $$ for (int i = 0; i < threadCount; i++) -->Line_81 $$ for (int i = 0; i < writtenOperations.size(); i++) [ FD ]
Line_12 $$ List<LocationOperation> writtenOperations = Collections.synchronizedList(new ArrayList())-->Line_82 $$ assertEquals("expected operation" + i + " to be in the previous translog but wasn't", tlog.currentFileGeneration() - 1, writtenOperations.get(i).location.generation)[ FD ]
Line_65 $$ LocationOperation next = iterator.next()-->Line_85 $$ assertEquals(next, writtenOperations.get(i).operation)[ FD ]
Line_7 $$ final int threadCount = randomIntBetween(1, 5)-->Line_41 $$ for (int i = 0; i < threadCount; i++) [ FD ]
Line_12 $$ List<LocationOperation> writtenOperations = Collections.synchronizedList(new ArrayList())-->Line_74 $$ if (writtenOperations.size() != snapshot.estimatedTotalOperations()) [ FD ]
Line_10 $$ final CountDownLatch downLatch = new CountDownLatch(1)-->Line_34 $$ downLatch.countDown()[ FD ]
Line_15 $$ threads[i] = new TranslogThread(translog, downLatch, 200, threadId, writtenOperations, threadExceptions) -->Line_19 $$ Translog.Location add = super.add(op)[ CD ]
Line_6 $$ Translog translog = getFailableTranslog(fail, config)-->Line_36 $$ try (Translog.View view = translog.newView()) [ FD ]
Line_65 $$ LocationOperation next = iterator.next()-->Line_84 $$ assertNotNull("operation " + i + " must be non-null", next)[ FD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_12 $$ List<LocationOperation> writtenOperations = Collections.synchronizedList(new ArrayList())[ CD ]
Line_12 $$ List<LocationOperation> writtenOperations = Collections.synchronizedList(new ArrayList())-->Line_60 $$ Collections.sort(writtenOperations, ( a,  b) -> a.location.compareTo(b.location))[ FD ]
Line_6 $$ Translog translog = getFailableTranslog(fail, config)-->Line_27 $$ translog.sync()[ FD ]
Line_11 $$ final CountDownLatch added = new CountDownLatch(randomIntBetween(10, 100))-->Line_35 $$ added.await()[ FD ]
Line_6 $$ Translog translog = getFailableTranslog(fail, config)-->Line_61 $$ assertFalse(translog.isOpen())[ FD ]
Line_41 $$ for (int i = 0; i < threadCount; i++) -->Line_81 $$ for (int i = 0; i < writtenOperations.size(); i++) [ FD ]
Line_2 $$ public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException -->Line_10 $$ final CountDownLatch downLatch = new CountDownLatch(1)[ CD ]
