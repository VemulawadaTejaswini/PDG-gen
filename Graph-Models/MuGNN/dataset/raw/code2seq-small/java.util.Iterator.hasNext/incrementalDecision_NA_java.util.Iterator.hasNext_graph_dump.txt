Line_21 $$ if (fileNames != null) -->Line_25 $$ toRecompile.addAll(fileNames)[ CD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_31 $$ final String packageName = ClassRepr.getPackageName(myContext.getValue(isField ? owner : member.name))[ CD ]
Line_52 $$ for (Iterator<File> it = toRecompile.iterator(); it.hasNext(); ) -->Line_54 $$ if (!file.exists()) [ CD ]
Line_10 $$ final THashSet<File> toRecompile = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_52 $$ for (Iterator<File> it = toRecompile.iterator(); it.hasNext(); ) [ FD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_10 $$ final THashSet<File> toRecompile = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)[ CD ]
Line_41 $$ if (filter == null || filter.accept(fileName)) -->Line_42 $$ debug("Adding: ", fileName)[ CD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_58 $$ affectedFiles.addAll(toRecompile)[ CD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_14 $$ debug("Root class: ", owner)[ FD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_33 $$ debug("Package name: ", packageName)[ CD ]
Line_22 $$ for (File fileName : fileNames) -->Line_43 $$ toRecompile.add(fileName)[ FD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_59 $$ return true[ CD ]
Line_53 $$ final File file = it.next()-->Line_54 $$ if (!file.exists()) [ FD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_3 $$ final boolean isField = member instanceof FieldRepr[ CD ]
Line_40 $$ for (File fileName : fileNames) -->Line_43 $$ toRecompile.add(fileName)[ FD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_32 $$ debug("Softening non-incremental decision: adding all package classes for a recompilation")[ CD ]
Line_22 $$ for (File fileName : fileNames) -->Line_41 $$ if (filter == null || filter.accept(fileName)) [ FD ]
Line_40 $$ for (File fileName : fileNames) -->Line_42 $$ debug("Adding: ", fileName)[ FD ]
Line_4 $$ final Util self = new Util()-->Line_15 $$ final TIntHashSet propagated = self.propagateFieldAccess(isField ? member.name : myEmptyName, owner)[ FD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_58 $$ affectedFiles.addAll(toRecompile)[ FD ]
Line_16 $$ propagated.forEach(new TIntProcedure() -->Line_27 $$ return true[ CD ]
Line_52 $$ for (Iterator<File> it = toRecompile.iterator(); it.hasNext(); ) -->Line_53 $$ final File file = it.next()[ CD ]
Line_10 $$ final THashSet<File> toRecompile = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_25 $$ toRecompile.addAll(fileNames)[ FD ]
Line_15 $$ final TIntHashSet propagated = self.propagateFieldAccess(isField ? member.name : myEmptyName, owner)-->Line_16 $$ propagated.forEach(new TIntProcedure() [ FD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_52 $$ for (Iterator<File> it = toRecompile.iterator(); it.hasNext(); ) [ CD ]
Line_41 $$ if (filter == null || filter.accept(fileName)) -->Line_43 $$ toRecompile.add(fileName)[ CD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_41 $$ if (filter == null || filter.accept(fileName)) [ FD ]
Line_16 $$ propagated.forEach(new TIntProcedure() -->Line_20 $$ final Collection<File> fileNames = myClassToSourceFile.get(className)[ CD ]
Line_52 $$ for (Iterator<File> it = toRecompile.iterator(); it.hasNext(); ) -->Line_55 $$ it.remove()[ FD ]
Line_10 $$ final THashSet<File> toRecompile = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_58 $$ affectedFiles.addAll(toRecompile)[ FD ]
Line_52 $$ for (Iterator<File> it = toRecompile.iterator(); it.hasNext(); ) -->Line_53 $$ final File file = it.next()[ FD ]
Line_40 $$ for (File fileName : fileNames) -->Line_41 $$ if (filter == null || filter.accept(fileName)) [ FD ]
Line_22 $$ for (File fileName : fileNames) -->Line_42 $$ debug("Adding: ", fileName)[ FD ]
Line_22 $$ for (File fileName : fileNames) -->Line_23 $$ debug("Adding ", fileName)[ FD ]
Line_20 $$ final Collection<File> fileNames = myClassToSourceFile.get(className)-->Line_25 $$ toRecompile.addAll(fileNames)[ FD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_4 $$ final Util self = new Util()[ CD ]
Line_10 $$ final THashSet<File> toRecompile = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_43 $$ toRecompile.add(fileName)[ FD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_15 $$ final TIntHashSet propagated = self.propagateFieldAccess(isField ? member.name : myEmptyName, owner)[ FD ]
Line_54 $$ if (!file.exists()) -->Line_55 $$ it.remove()[ CD ]
Line_20 $$ final Collection<File> fileNames = myClassToSourceFile.get(className)-->Line_21 $$ if (fileNames != null) [ FD ]
Line_16 $$ propagated.forEach(new TIntProcedure() -->Line_21 $$ if (fileNames != null) [ CD ]
Line_16 $$ propagated.forEach(new TIntProcedure() -->Line_39 $$ if (ClassRepr.getPackageName(myContext.getValue(className)).equals(packageName)) [ FD ]
Line_16 $$ propagated.forEach(new TIntProcedure() -->Line_20 $$ final Collection<File> fileNames = myClassToSourceFile.get(className)[ FD ]
