Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_43 $$ toRecompile.removeAll(currentlyCompiled)[ FD ]
Line_34 $$ if (filter == null || filter.accept(fileName)) -->Line_36 $$ toRecompile.add(fileName)[ CD ]
Line_30 $$ myClassToSourceFile.forEachEntry(new TIntObjectProcedure<Collection<File>>() -->Line_40 $$ return true[ CD ]
Line_14 $$ propagated.forEach(new TIntProcedure() -->Line_17 $$ if (fileNames != null) [ CD ]
Line_44 $$ for (Iterator<File> it = toRecompile.iterator(); it.hasNext(); ) -->Line_46 $$ if (!file.exists()) [ CD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_51 $$ return true[ CD ]
Line_18 $$ for (File fileName : fileNames) -->Line_19 $$ debug("Adding ", fileName)[ FD ]
Line_9 $$ final THashSet<File> toRecompile = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_36 $$ toRecompile.add(fileName)[ FD ]
Line_33 $$ for (File fileName : fileNames) -->Line_36 $$ toRecompile.add(fileName)[ FD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_5 $$ if (member.isPublic()) [ CD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_10 $$ if (member.isProtected()) [ FD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_5 $$ if (member.isPublic()) [ FD ]
Line_18 $$ for (File fileName : fileNames) -->Line_35 $$ debug("Adding: ", fileName)[ FD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_3 $$ final boolean isField = member instanceof FieldRepr[ CD ]
Line_14 $$ propagated.forEach(new TIntProcedure() -->Line_16 $$ final Collection<File> fileNames = myClassToSourceFile.get(className)[ CD ]
Line_14 $$ propagated.forEach(new TIntProcedure() -->Line_32 $$ if (ClassRepr.getPackageName(myContext.getValue(className)).equals(packageName)) [ FD ]
Line_16 $$ final Collection<File> fileNames = myClassToSourceFile.get(className)-->Line_21 $$ toRecompile.addAll(fileNames)[ FD ]
Line_30 $$ myClassToSourceFile.forEachEntry(new TIntObjectProcedure<Collection<File>>() -->Line_32 $$ if (ClassRepr.getPackageName(myContext.getValue(className)).equals(packageName)) [ CD ]
Line_10 $$ if (member.isProtected()) -->Line_14 $$ propagated.forEach(new TIntProcedure() [ CD ]
Line_18 $$ for (File fileName : fileNames) -->Line_36 $$ toRecompile.add(fileName)[ FD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_43 $$ toRecompile.removeAll(currentlyCompiled)[ CD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_50 $$ affectedFiles.addAll(toRecompile)[ CD ]
Line_10 $$ if (member.isProtected()) -->Line_12 $$ debug("Root class: ", owner)[ CD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_12 $$ debug("Root class: ", owner)[ FD ]
Line_18 $$ for (File fileName : fileNames) -->Line_34 $$ if (filter == null || filter.accept(fileName)) [ FD ]
Line_10 $$ if (member.isProtected()) -->Line_11 $$ debug("Protected access, softening non-incremental decision: adding all relevant subclasses for a recompilation")[ CD ]
Line_9 $$ final THashSet<File> toRecompile = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_21 $$ toRecompile.addAll(fileNames)[ FD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_50 $$ affectedFiles.addAll(toRecompile)[ FD ]
Line_10 $$ if (member.isProtected()) -->Line_13 $$ final TIntHashSet propagated = self.propagateFieldAccess(isField ? member.name : myEmptyName, owner)[ CD ]
Line_5 $$ if (member.isPublic()) -->Line_6 $$ debug("Public access, switching to a non-incremental mode")[ CD ]
Line_45 $$ final File file = it.next()-->Line_46 $$ if (!file.exists()) [ FD ]
Line_33 $$ for (File fileName : fileNames) -->Line_35 $$ debug("Adding: ", fileName)[ FD ]
Line_9 $$ final THashSet<File> toRecompile = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_43 $$ toRecompile.removeAll(currentlyCompiled)[ FD ]
Line_30 $$ myClassToSourceFile.forEachEntry(new TIntObjectProcedure<Collection<File>>() -->Line_32 $$ if (ClassRepr.getPackageName(myContext.getValue(className)).equals(packageName)) [ FD ]
Line_46 $$ if (!file.exists()) -->Line_47 $$ it.remove()[ CD ]
Line_16 $$ final Collection<File> fileNames = myClassToSourceFile.get(className)-->Line_17 $$ if (fileNames != null) [ FD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_27 $$ final String packageName = ClassRepr.getPackageName(myContext.getValue(isField ? owner : member.name))[ CD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_4 $$ final Util self = new Util()[ CD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_30 $$ myClassToSourceFile.forEachEntry(new TIntObjectProcedure<Collection<File>>() [ CD ]
Line_44 $$ for (Iterator<File> it = toRecompile.iterator(); it.hasNext(); ) -->Line_45 $$ final File file = it.next()[ FD ]
Line_33 $$ for (File fileName : fileNames) -->Line_34 $$ if (filter == null || filter.accept(fileName)) [ FD ]
Line_14 $$ propagated.forEach(new TIntProcedure() -->Line_16 $$ final Collection<File> fileNames = myClassToSourceFile.get(className)[ FD ]
Line_13 $$ final TIntHashSet propagated = self.propagateFieldAccess(isField ? member.name : myEmptyName, owner)-->Line_14 $$ propagated.forEach(new TIntProcedure() [ FD ]
Line_4 $$ final Util self = new Util()-->Line_13 $$ final TIntHashSet propagated = self.propagateFieldAccess(isField ? member.name : myEmptyName, owner)[ FD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_29 $$ debug("Package name: ", packageName)[ CD ]
Line_44 $$ for (Iterator<File> it = toRecompile.iterator(); it.hasNext(); ) -->Line_45 $$ final File file = it.next()[ CD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_34 $$ if (filter == null || filter.accept(fileName)) [ FD ]
Line_44 $$ for (Iterator<File> it = toRecompile.iterator(); it.hasNext(); ) -->Line_47 $$ it.remove()[ FD ]
Line_9 $$ final THashSet<File> toRecompile = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_50 $$ affectedFiles.addAll(toRecompile)[ FD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_28 $$ debug("Softening non-incremental decision: adding all package classes for a recompilation")[ CD ]
Line_5 $$ if (member.isPublic()) -->Line_7 $$ return false[ CD ]
Line_17 $$ if (fileNames != null) -->Line_21 $$ toRecompile.addAll(fileNames)[ CD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_9 $$ final THashSet<File> toRecompile = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)[ CD ]
Line_9 $$ final THashSet<File> toRecompile = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY)-->Line_44 $$ for (Iterator<File> it = toRecompile.iterator(); it.hasNext(); ) [ FD ]
Line_34 $$ if (filter == null || filter.accept(fileName)) -->Line_35 $$ debug("Adding: ", fileName)[ CD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_13 $$ final TIntHashSet propagated = self.propagateFieldAccess(isField ? member.name : myEmptyName, owner)[ FD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_44 $$ for (Iterator<File> it = toRecompile.iterator(); it.hasNext(); ) [ CD ]
Line_14 $$ propagated.forEach(new TIntProcedure() -->Line_23 $$ return true[ CD ]
Line_2 $$ private boolean incrementalDecision(final int owner, final Proto member, final Collection<File> affectedFiles, final Collection<File> currentlyCompiled, @Nullable final DependentFilesFilter filter) -->Line_10 $$ if (member.isProtected()) [ CD ]
