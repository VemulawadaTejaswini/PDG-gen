Line_67 $$ if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0 || (d.addedModifiers() & Opcodes.ACC_PUBLIC) > 0 || (d.addedModifiers() & Opcodes.ACC_ABSTRACT) > 0) -->Line_68 $$ debug("Added final, public or abstract specifier --- affecting subclasses")[ CD ]
Line_12 $$ final MethodRepr.Diff d = (MethodRepr.Diff) mr.second-->Line_56 $$ if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 || (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 || (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0) [ FD ]
Line_16 $$ if (d.defaultRemoved()) -->Line_18 $$ final TIntHashSet l = new TIntHashSet(DEFAULT_SET_CAPACITY, DEFAULT_SET_LOAD_FACTOR)[ CD ]
Line_11 $$ final MethodRepr m = mr.first-->Line_24 $$ final TIntHashSet propagated = myFuture.propagateMethodAccess(m, it.name)[ FD ]
Line_25 $$ boolean affected = false-->Line_57 $$ if (!affected) [ FD ]
Line_28 $$ if (d.packageLocalOn()) -->Line_30 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, state.myDependants)[ CD ]
Line_12 $$ final MethodRepr.Diff d = (MethodRepr.Diff) mr.second-->Line_38 $$ if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0 || throwsChanged) [ FD ]
Line_12 $$ final MethodRepr.Diff d = (MethodRepr.Diff) mr.second-->Line_13 $$ final boolean throwsChanged = !d.exceptions().unchanged()[ FD ]
Line_12 $$ final MethodRepr.Diff d = (MethodRepr.Diff) mr.second-->Line_71 $$ if ((d.addedModifiers() & Opcodes.ACC_PROTECTED) > 0 && !((d.removedModifiers() & Opcodes.ACC_PRIVATE) > 0)) [ FD ]
Line_27 $$ final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>()-->Line_41 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, state.myDependants)[ FD ]
Line_2 $$ private void processChangedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_3 $$ final Collection<Pair<MethodRepr, Difference>> changed = diff.methods().changed()[ CD ]
Line_38 $$ if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0 || throwsChanged) -->Line_55 $$ if ((d.base() & Difference.ACCESS) > 0) [ CD ]
Line_23 $$ if (d.base() != Difference.NONE || throwsChanged) -->Line_26 $$ boolean constrained = false[ CD ]
Line_31 $$ for (final UsageRepr.Usage usage : usages) -->Line_32 $$ state.myUsageConstraints.put(usage, myFuture.new InheritanceConstraint(it.name))[ FD ]
Line_25 $$ boolean affected = false-->Line_35 $$ affected = true[ FD ]
Line_20 $$ final UsageRepr.AnnotationUsage annotationUsage = (UsageRepr.AnnotationUsage) UsageRepr.createAnnotationUsage(myContext, TypeRepr.createClassType(myContext, it.name), l, null)-->Line_21 $$ state.myAnnotationQuery.add(annotationUsage)[ FD ]
Line_57 $$ if (!affected) -->Line_58 $$ debug("Added static or private specifier or removed static specifier --- affecting method usages")[ CD ]
Line_3 $$ final Collection<Pair<MethodRepr, Difference>> changed = diff.methods().changed()-->Line_4 $$ if (changed.isEmpty()) [ FD ]
Line_28 $$ if (d.packageLocalOn()) -->Line_29 $$ debug("Method became package-local, affecting method usages outside the package")[ CD ]
Line_11 $$ final MethodRepr m = mr.first-->Line_30 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, state.myDependants)[ FD ]
Line_39 $$ if (!affected) -->Line_53 $$ state.myAffectedUsages.addAll(usages)[ CD ]
Line_39 $$ if (!affected) -->Line_43 $$ myFuture.addOverridingMethods(m, it, MethodRepr.equalByJavaRules(m), overridingMethods, null)[ CD ]
Line_24 $$ final TIntHashSet propagated = myFuture.propagateMethodAccess(m, it.name)-->Line_75 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, state.myDependants)[ FD ]
Line_27 $$ final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>()-->Line_53 $$ state.myAffectedUsages.addAll(usages)[ FD ]
Line_35 $$ affected = true-->Line_74 $$ if (!affected) [ FD ]
Line_26 $$ boolean constrained = false-->Line_72 $$ if (!constrained) [ FD ]
Line_2 $$ private void processChangedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_87 $$ debug("End of changed methods processing")[ CD ]
Line_47 $$ final Collection<File> fileNames = myClassToSourceFile.get(aClass.name)-->Line_48 $$ if (fileNames != null) [ FD ]
Line_12 $$ final MethodRepr.Diff d = (MethodRepr.Diff) mr.second-->Line_62 $$ if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0) [ FD ]
Line_16 $$ if (d.defaultRemoved()) -->Line_20 $$ final UsageRepr.AnnotationUsage annotationUsage = (UsageRepr.AnnotationUsage) UsageRepr.createAnnotationUsage(myContext, TypeRepr.createClassType(myContext, it.name), l, null)[ CD ]
Line_27 $$ final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>()-->Line_76 $$ state.myAffectedUsages.addAll(usages)[ FD ]
Line_16 $$ if (d.defaultRemoved()) -->Line_19 $$ l.add(m.name)[ CD ]
Line_45 $$ final ClassRepr aClass = p.getSecond()-->Line_46 $$ if (aClass != MOCK_CLASS) [ FD ]
Line_24 $$ final TIntHashSet propagated = myFuture.propagateMethodAccess(m, it.name)-->Line_41 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, state.myDependants)[ FD ]
Line_27 $$ final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>()-->Line_75 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, state.myDependants)[ FD ]
Line_46 $$ if (aClass != MOCK_CLASS) -->Line_47 $$ final Collection<File> fileNames = myClassToSourceFile.get(aClass.name)[ CD ]
Line_23 $$ if (d.base() != Difference.NONE || throwsChanged) -->Line_24 $$ final TIntHashSet propagated = myFuture.propagateMethodAccess(m, it.name)[ CD ]
Line_56 $$ if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 || (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 || (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0) -->Line_67 $$ if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0 || (d.addedModifiers() & Opcodes.ACC_PUBLIC) > 0 || (d.addedModifiers() & Opcodes.ACC_ABSTRACT) > 0) [ CD ]
Line_16 $$ if (d.defaultRemoved()) -->Line_21 $$ state.myAnnotationQuery.add(annotationUsage)[ CD ]
Line_42 $$ final List<Pair<MethodRepr, ClassRepr>> overridingMethods = new LinkedList<Pair<MethodRepr, ClassRepr>>()-->Line_43 $$ myFuture.addOverridingMethods(m, it, MethodRepr.equalByJavaRules(m), overridingMethods, null)[ FD ]
Line_67 $$ if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0 || (d.addedModifiers() & Opcodes.ACC_PUBLIC) > 0 || (d.addedModifiers() & Opcodes.ACC_ABSTRACT) > 0) -->Line_69 $$ myFuture.affectSubclasses(it.name, myAffectedFiles, state.myAffectedUsages, state.myDependants, false, myCompiledFiles, null)[ CD ]
Line_25 $$ boolean affected = false-->Line_74 $$ if (!affected) [ FD ]
Line_11 $$ final MethodRepr m = mr.first-->Line_75 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, state.myDependants)[ FD ]
Line_12 $$ final MethodRepr.Diff d = (MethodRepr.Diff) mr.second-->Line_67 $$ if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0 || (d.addedModifiers() & Opcodes.ACC_PUBLIC) > 0 || (d.addedModifiers() & Opcodes.ACC_ABSTRACT) > 0) [ FD ]
Line_13 $$ final boolean throwsChanged = !d.exceptions().unchanged()-->Line_38 $$ if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0 || throwsChanged) [ FD ]
Line_38 $$ if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0 || throwsChanged) -->Line_39 $$ if (!affected) [ CD ]
Line_11 $$ final MethodRepr m = mr.first-->Line_41 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, state.myDependants)[ FD ]
Line_72 $$ if (!constrained) -->Line_73 $$ debug("Added public or package-local method became protected --- affect method usages with protected constraint")[ CD ]
Line_56 $$ if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 || (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 || (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0) -->Line_71 $$ if ((d.addedModifiers() & Opcodes.ACC_PROTECTED) > 0 && !((d.removedModifiers() & Opcodes.ACC_PRIVATE) > 0)) [ CD ]
Line_44 $$ for (final Pair<MethodRepr, ClassRepr> p : overridingMethods) -->Line_45 $$ final ClassRepr aClass = p.getSecond()[ FD ]
Line_16 $$ if (d.defaultRemoved()) -->Line_17 $$ debug("Class is annotation, default value is removed => adding annotation query")[ CD ]
Line_28 $$ if (d.packageLocalOn()) -->Line_36 $$ constrained = true[ CD ]
Line_55 $$ if ((d.base() & Difference.ACCESS) > 0) -->Line_56 $$ if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 || (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 || (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0) [ CD ]
Line_35 $$ affected = true-->Line_57 $$ if (!affected) [ FD ]
Line_56 $$ if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 || (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 || (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0) -->Line_62 $$ if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0) [ CD ]
Line_71 $$ if ((d.addedModifiers() & Opcodes.ACC_PROTECTED) > 0 && !((d.removedModifiers() & Opcodes.ACC_PRIVATE) > 0)) -->Line_72 $$ if (!constrained) [ CD ]
Line_27 $$ final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>()-->Line_60 $$ state.myAffectedUsages.addAll(usages)[ FD ]
Line_2 $$ private void processChangedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_7 $$ debug("Processing changed methods:")[ CD ]
Line_31 $$ for (final UsageRepr.Usage usage : usages) -->Line_79 $$ state.myUsageConstraints.put(usage, myFuture.new InheritanceConstraint(it.name))[ FD ]
Line_2 $$ private void processChangedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_43 $$ myFuture.addOverridingMethods(m, it, MethodRepr.equalByJavaRules(m), overridingMethods, null)[ FD ]
Line_46 $$ if (aClass != MOCK_CLASS) -->Line_48 $$ if (fileNames != null) [ CD ]
Line_28 $$ if (d.packageLocalOn()) -->Line_35 $$ affected = true[ CD ]
Line_12 $$ final MethodRepr.Diff d = (MethodRepr.Diff) mr.second-->Line_28 $$ if (d.packageLocalOn()) [ FD ]
Line_39 $$ if (!affected) -->Line_40 $$ debug("Return type, throws list or signature changed --- affecting method usages")[ CD ]
Line_72 $$ if (!constrained) -->Line_74 $$ if (!affected) [ CD ]
Line_11 $$ final MethodRepr m = mr.first-->Line_43 $$ myFuture.addOverridingMethods(m, it, MethodRepr.equalByJavaRules(m), overridingMethods, null)[ FD ]
Line_2 $$ private void processChangedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_3 $$ final Collection<Pair<MethodRepr, Difference>> changed = diff.methods().changed()[ FD ]
Line_39 $$ if (!affected) -->Line_41 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, state.myDependants)[ CD ]
Line_36 $$ constrained = true-->Line_72 $$ if (!constrained) [ FD ]
Line_56 $$ if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 || (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 || (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0) -->Line_57 $$ if (!affected) [ CD ]
Line_23 $$ if (d.base() != Difference.NONE || throwsChanged) -->Line_38 $$ if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0 || throwsChanged) [ CD ]
Line_12 $$ final MethodRepr.Diff d = (MethodRepr.Diff) mr.second-->Line_55 $$ if ((d.base() & Difference.ACCESS) > 0) [ FD ]
Line_25 $$ boolean affected = false-->Line_39 $$ if (!affected) [ FD ]
Line_12 $$ final MethodRepr.Diff d = (MethodRepr.Diff) mr.second-->Line_23 $$ if (d.base() != Difference.NONE || throwsChanged) [ FD ]
Line_74 $$ if (!affected) -->Line_76 $$ state.myAffectedUsages.addAll(usages)[ CD ]
Line_4 $$ if (changed.isEmpty()) -->Line_5 $$ return[ CD ]
Line_15 $$ if (it.isAnnotation()) -->Line_16 $$ if (d.defaultRemoved()) [ CD ]
Line_24 $$ final TIntHashSet propagated = myFuture.propagateMethodAccess(m, it.name)-->Line_30 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, state.myDependants)[ FD ]
Line_13 $$ final boolean throwsChanged = !d.exceptions().unchanged()-->Line_23 $$ if (d.base() != Difference.NONE || throwsChanged) [ FD ]
Line_48 $$ if (fileNames != null) -->Line_49 $$ myAffectedFiles.addAll(fileNames)[ CD ]
Line_12 $$ final MethodRepr.Diff d = (MethodRepr.Diff) mr.second-->Line_16 $$ if (d.defaultRemoved()) [ FD ]
Line_23 $$ if (d.base() != Difference.NONE || throwsChanged) -->Line_27 $$ final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>()[ CD ]
Line_27 $$ final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>()-->Line_30 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, state.myDependants)[ FD ]
Line_57 $$ if (!affected) -->Line_60 $$ state.myAffectedUsages.addAll(usages)[ CD ]
Line_28 $$ if (d.packageLocalOn()) -->Line_34 $$ state.myAffectedUsages.addAll(usages)[ CD ]
Line_39 $$ if (!affected) -->Line_42 $$ final List<Pair<MethodRepr, ClassRepr>> overridingMethods = new LinkedList<Pair<MethodRepr, ClassRepr>>()[ CD ]
Line_27 $$ final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>()-->Line_59 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, state.myDependants)[ FD ]
Line_47 $$ final Collection<File> fileNames = myClassToSourceFile.get(aClass.name)-->Line_49 $$ myAffectedFiles.addAll(fileNames)[ FD ]
Line_18 $$ final TIntHashSet l = new TIntHashSet(DEFAULT_SET_CAPACITY, DEFAULT_SET_LOAD_FACTOR)-->Line_19 $$ l.add(m.name)[ FD ]
Line_62 $$ if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0) -->Line_64 $$ myFuture.affectSubclasses(it.name, myAffectedFiles, state.myAffectedUsages, state.myDependants, false, myCompiledFiles, null)[ CD ]
Line_26 $$ boolean constrained = false-->Line_36 $$ constrained = true[ FD ]
Line_2 $$ private void processChangedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_4 $$ if (changed.isEmpty()) [ CD ]
Line_24 $$ final TIntHashSet propagated = myFuture.propagateMethodAccess(m, it.name)-->Line_59 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, state.myDependants)[ FD ]
Line_18 $$ final TIntHashSet l = new TIntHashSet(DEFAULT_SET_CAPACITY, DEFAULT_SET_LOAD_FACTOR)-->Line_20 $$ final UsageRepr.AnnotationUsage annotationUsage = (UsageRepr.AnnotationUsage) UsageRepr.createAnnotationUsage(myContext, TypeRepr.createClassType(myContext, it.name), l, null)[ FD ]
Line_57 $$ if (!affected) -->Line_59 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, state.myDependants)[ CD ]
Line_23 $$ if (d.base() != Difference.NONE || throwsChanged) -->Line_28 $$ if (d.packageLocalOn()) [ CD ]
Line_2 $$ private void processChangedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_15 $$ if (it.isAnnotation()) [ FD ]
Line_23 $$ if (d.base() != Difference.NONE || throwsChanged) -->Line_25 $$ boolean affected = false[ CD ]
Line_35 $$ affected = true-->Line_39 $$ if (!affected) [ FD ]
Line_62 $$ if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0) -->Line_63 $$ debug("Added static specifier --- affecting subclasses")[ CD ]
Line_11 $$ final MethodRepr m = mr.first-->Line_59 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, state.myDependants)[ FD ]
Line_74 $$ if (!affected) -->Line_75 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, state.myDependants)[ CD ]
Line_27 $$ final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>()-->Line_34 $$ state.myAffectedUsages.addAll(usages)[ FD ]
Line_15 $$ if (it.isAnnotation()) -->Line_23 $$ if (d.base() != Difference.NONE || throwsChanged) [ CD ]
