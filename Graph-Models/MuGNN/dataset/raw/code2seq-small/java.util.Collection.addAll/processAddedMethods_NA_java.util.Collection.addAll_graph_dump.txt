Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_8 $$ if (it.isAnnotation()) [ CD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_111 $$ debug("End of added methods processing")[ CD ]
Line_94 $$ if (sourceFileNames != null && !myCompiledFiles.containsAll(sourceFileNames)) -->Line_95 $$ final int outerClass = r.getOuterClassName()[ CD ]
Line_95 $$ final int outerClass = r.getOuterClassName()-->Line_97 $$ final ClassRepr outerClassRepr = myFuture.reprByName(outerClass)[ FD ]
Line_89 $$ final ClassRepr r = myFuture.reprByName(subClass)-->Line_90 $$ if (r == null) [ FD ]
Line_23 $$ if (!m.isPrivate() && m.name != myInitName) -->Line_28 $$ final ClassRepr oldIt = oldItRef.get()[ CD ]
Line_37 $$ if (!m.isPrivate()) -->Line_85 $$ subClasses.forEach(new TIntProcedure() [ CD ]
Line_93 $$ final Collection<File> sourceFileNames = myClassToSourceFile.get(subClass)-->Line_94 $$ if (sourceFileNames != null && !myCompiledFiles.containsAll(sourceFileNames)) [ FD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_29 $$ if (oldIt == null || !myPresent.hasOverriddenMethods(oldIt, MethodRepr.equalByJavaRules(m), null)) [ FD ]
Line_31 $$ propagated = myFuture.propagateMethodAccess(m, it.name)-->Line_47 $$ myFuture.affectMethodUsages(mm, propagated, mm.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_61 $$ if (overrides.satisfy(method) && isInheritor) -->Line_73 $$ if (isInheritor) [ CD ]
Line_30 $$ if (m.myArgumentTypes.length > 0) -->Line_33 $$ myFuture.affectMethodUsages(m, propagated, m.createMetaUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ CD ]
Line_90 $$ if (r == null) -->Line_91 $$ return true[ CD ]
Line_28 $$ final ClassRepr oldIt = oldItRef.get()-->Line_29 $$ if (oldIt == null || !myPresent.hasOverriddenMethods(oldIt, MethodRepr.equalByJavaRules(m), null)) [ FD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_45 $$ if (!mm.equals(m)) [ FD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_3 $$ final Collection<MethodRepr> added = diff.methods().added()[ FD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_33 $$ myFuture.affectMethodUsages(m, propagated, m.createMetaUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_63 $$ final Collection<File> files = myClassToSourceFile.get(methodClass.name)-->Line_65 $$ myAffectedFiles.addAll(files)[ FD ]
Line_63 $$ final Collection<File> files = myClassToSourceFile.get(methodClass.name)-->Line_64 $$ if (files != null) [ FD ]
Line_15 $$ Ref<ClassRepr> oldItRef = null-->Line_28 $$ final ClassRepr oldIt = oldItRef.get()[ FD ]
Line_74 $$ final TIntHashSet deps = myClassToClassDependency.get(methodClass.name)-->Line_76 $$ addAll(state.myDependants, deps)[ FD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_18 $$ if (it.isInterface() || it.isAbstract() || m.isAbstract()) [ FD ]
Line_61 $$ if (overrides.satisfy(method) && isInheritor) -->Line_62 $$ debug("Current method overrides that found")[ CD ]
Line_95 $$ final int outerClass = r.getOuterClassName()-->Line_96 $$ if (!isEmpty(outerClass)) [ FD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_15 $$ Ref<ClassRepr> oldItRef = null[ CD ]
Line_61 $$ if (overrides.satisfy(method) && isInheritor) -->Line_63 $$ final Collection<File> files = myClassToSourceFile.get(methodClass.name)[ CD ]
Line_37 $$ if (!m.isPrivate()) -->Line_38 $$ final Collection<Pair<MethodRepr, ClassRepr>> affectedMethods = myFuture.findAllMethodsBySpecificity(m, it)[ CD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_23 $$ if (!m.isPrivate() && m.name != myInitName) [ FD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_31 $$ propagated = myFuture.propagateMethodAccess(m, it.name)[ FD ]
Line_31 $$ propagated = myFuture.propagateMethodAccess(m, it.name)-->Line_40 $$ if (propagated == null) [ FD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_38 $$ final Collection<Pair<MethodRepr, ClassRepr>> affectedMethods = myFuture.findAllMethodsBySpecificity(m, it)[ FD ]
Line_37 $$ if (!m.isPrivate()) -->Line_39 $$ final MethodRepr.Predicate overrides = MethodRepr.equalByJavaRules(m)[ CD ]
Line_45 $$ if (!mm.equals(m)) -->Line_46 $$ debug("Found less specific method, affecting method usages")[ CD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_3 $$ final Collection<MethodRepr> added = diff.methods().added()[ CD ]
Line_52 $$ final MethodRepr method = pair.first-->Line_81 $$ myFuture.affectMethodUsages(method, yetPropagated, method.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_52 $$ final MethodRepr method = pair.first-->Line_72 $$ final TIntHashSet yetPropagated = myPresent.propagateMethodAccess(method, it.name)[ FD ]
Line_85 $$ subClasses.forEach(new TIntProcedure() -->Line_94 $$ if (sourceFileNames != null && !myCompiledFiles.containsAll(sourceFileNames)) [ CD ]
Line_85 $$ subClasses.forEach(new TIntProcedure() -->Line_93 $$ final Collection<File> sourceFileNames = myClassToSourceFile.get(subClass)[ FD ]
Line_40 $$ if (propagated == null) -->Line_41 $$ propagated = myFuture.propagateMethodAccess(m, it.name)[ CD ]
Line_61 $$ if (overrides.satisfy(method) && isInheritor) -->Line_80 $$ debug("Affecting method usages for that found")[ CD ]
Line_72 $$ final TIntHashSet yetPropagated = myPresent.propagateMethodAccess(method, it.name)-->Line_78 $$ myFuture.affectMethodUsages(method, yetPropagated, method.createUsage(myContext, methodClass.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_7 $$ debug("Processing added methods: ")[ CD ]
Line_52 $$ final MethodRepr method = pair.first-->Line_78 $$ myFuture.affectMethodUsages(method, yetPropagated, method.createUsage(myContext, methodClass.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_18 $$ if (it.isInterface() || it.isAbstract() || m.isAbstract()) -->Line_19 $$ debug("Class is abstract, or is interface, or added method in abstract => affecting all subclasses")[ CD ]
Line_85 $$ subClasses.forEach(new TIntProcedure() -->Line_89 $$ final ClassRepr r = myFuture.reprByName(subClass)[ FD ]
Line_22 $$ TIntHashSet propagated = null-->Line_33 $$ myFuture.affectMethodUsages(m, propagated, m.createMetaUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_15 $$ Ref<ClassRepr> oldItRef = null-->Line_24 $$ if (oldItRef == null) [ FD ]
Line_37 $$ if (!m.isPrivate()) -->Line_43 $$ final Collection<MethodRepr> lessSpecific = it.findMethods(myFuture.lessSpecific(m))[ CD ]
Line_52 $$ final MethodRepr method = pair.first-->Line_61 $$ if (overrides.satisfy(method) && isInheritor) [ FD ]
Line_8 $$ if (it.isAnnotation()) -->Line_9 $$ debug("Class is annotation, skipping method analysis")[ CD ]
Line_96 $$ if (!isEmpty(outerClass)) -->Line_97 $$ final ClassRepr outerClassRepr = myFuture.reprByName(outerClass)[ CD ]
Line_31 $$ propagated = myFuture.propagateMethodAccess(m, it.name)-->Line_41 $$ propagated = myFuture.propagateMethodAccess(m, it.name)[ FD ]
Line_22 $$ TIntHashSet propagated = null-->Line_31 $$ propagated = myFuture.propagateMethodAccess(m, it.name)[ FD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_41 $$ propagated = myFuture.propagateMethodAccess(m, it.name)[ FD ]
Line_23 $$ if (!m.isPrivate() && m.name != myInitName) -->Line_24 $$ if (oldItRef == null) [ CD ]
Line_72 $$ final TIntHashSet yetPropagated = myPresent.propagateMethodAccess(method, it.name)-->Line_81 $$ myFuture.affectMethodUsages(method, yetPropagated, method.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_3 $$ final Collection<MethodRepr> added = diff.methods().added()-->Line_4 $$ if (added.isEmpty()) [ FD ]
Line_37 $$ if (!m.isPrivate()) -->Line_84 $$ final TIntHashSet subClasses = getAllSubclasses(it.name)[ CD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_98 $$ if (outerClassRepr != null && (myFuture.isMethodVisible(outerClassRepr, m) || myFuture.extendsLibraryClass(outerClassRepr, null))) [ FD ]
Line_94 $$ if (sourceFileNames != null && !myCompiledFiles.containsAll(sourceFileNames)) -->Line_96 $$ if (!isEmpty(outerClass)) [ CD ]
Line_30 $$ if (m.myArgumentTypes.length > 0) -->Line_32 $$ debug("Conservative case on overriding methods, affecting method usages")[ CD ]
Line_73 $$ if (isInheritor) -->Line_78 $$ myFuture.affectMethodUsages(method, yetPropagated, method.createUsage(myContext, methodClass.name), state.myAffectedUsages, state.myDependants)[ CD ]
Line_22 $$ TIntHashSet propagated = null-->Line_47 $$ myFuture.affectMethodUsages(mm, propagated, mm.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_18 $$ if (it.isInterface() || it.isAbstract() || m.isAbstract()) -->Line_20 $$ myFuture.affectSubclasses(it.name, myAffectedFiles, state.myAffectedUsages, state.myDependants, false, myCompiledFiles, null)[ CD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_18 $$ if (it.isInterface() || it.isAbstract() || m.isAbstract()) [ FD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_8 $$ if (it.isAnnotation()) [ FD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_4 $$ if (added.isEmpty()) [ CD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_39 $$ final MethodRepr.Predicate overrides = MethodRepr.equalByJavaRules(m)[ FD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_38 $$ final Collection<Pair<MethodRepr, ClassRepr>> affectedMethods = myFuture.findAllMethodsBySpecificity(m, it)[ FD ]
Line_97 $$ final ClassRepr outerClassRepr = myFuture.reprByName(outerClass)-->Line_98 $$ if (outerClassRepr != null && (myFuture.isMethodVisible(outerClassRepr, m) || myFuture.extendsLibraryClass(outerClassRepr, null))) [ FD ]
Line_53 $$ final ClassRepr methodClass = pair.second-->Line_54 $$ if (methodClass == MOCK_CLASS) [ FD ]
Line_85 $$ subClasses.forEach(new TIntProcedure() -->Line_89 $$ final ClassRepr r = myFuture.reprByName(subClass)[ CD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_43 $$ final Collection<MethodRepr> lessSpecific = it.findMethods(myFuture.lessSpecific(m))[ FD ]
Line_41 $$ propagated = myFuture.propagateMethodAccess(m, it.name)-->Line_47 $$ myFuture.affectMethodUsages(mm, propagated, mm.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_66 $$ for (File file : files) -->Line_67 $$ debug("Affecting file ", file)[ FD ]
Line_100 $$ for (File sourceFileName : sourceFileNames) -->Line_101 $$ debug("Affecting file due to local overriding: ", sourceFileName)[ FD ]
Line_44 $$ for (final MethodRepr mm : lessSpecific) -->Line_45 $$ if (!mm.equals(m)) [ FD ]
Line_85 $$ subClasses.forEach(new TIntProcedure() -->Line_90 $$ if (r == null) [ CD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_37 $$ if (!m.isPrivate()) [ FD ]
Line_30 $$ if (m.myArgumentTypes.length > 0) -->Line_31 $$ propagated = myFuture.propagateMethodAccess(m, it.name)[ CD ]
Line_29 $$ if (oldIt == null || !myPresent.hasOverriddenMethods(oldIt, MethodRepr.equalByJavaRules(m), null)) -->Line_30 $$ if (m.myArgumentTypes.length > 0) [ CD ]
Line_96 $$ if (!isEmpty(outerClass)) -->Line_98 $$ if (outerClassRepr != null && (myFuture.isMethodVisible(outerClassRepr, m) || myFuture.extendsLibraryClass(outerClassRepr, null))) [ CD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_43 $$ final Collection<MethodRepr> lessSpecific = it.findMethods(myFuture.lessSpecific(m))[ FD ]
Line_44 $$ for (final MethodRepr mm : lessSpecific) -->Line_47 $$ myFuture.affectMethodUsages(mm, propagated, mm.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_61 $$ if (overrides.satisfy(method) && isInheritor) -->Line_71 $$ debug("Current method does not override that found")[ CD ]
Line_75 $$ if (deps != null) -->Line_76 $$ addAll(state.myDependants, deps)[ CD ]
Line_37 $$ if (!m.isPrivate()) -->Line_40 $$ if (propagated == null) [ CD ]
Line_8 $$ if (it.isAnnotation()) -->Line_10 $$ return[ CD ]
Line_73 $$ if (isInheritor) -->Line_75 $$ if (deps != null) [ CD ]
Line_31 $$ propagated = myFuture.propagateMethodAccess(m, it.name)-->Line_33 $$ myFuture.affectMethodUsages(m, propagated, m.createMetaUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_93 $$ final Collection<File> sourceFileNames = myClassToSourceFile.get(subClass)-->Line_99 $$ myAffectedFiles.addAll(sourceFileNames)[ FD ]
Line_74 $$ final TIntHashSet deps = myClassToClassDependency.get(methodClass.name)-->Line_75 $$ if (deps != null) [ FD ]
Line_58 $$ final boolean isInheritor = inheritorOf != null && inheritorOf-->Line_61 $$ if (overrides.satisfy(method) && isInheritor) [ FD ]
Line_85 $$ subClasses.forEach(new TIntProcedure() -->Line_93 $$ final Collection<File> sourceFileNames = myClassToSourceFile.get(subClass)[ CD ]
Line_85 $$ subClasses.forEach(new TIntProcedure() -->Line_106 $$ return true[ CD ]
Line_39 $$ final MethodRepr.Predicate overrides = MethodRepr.equalByJavaRules(m)-->Line_61 $$ if (overrides.satisfy(method) && isInheritor) [ FD ]
Line_84 $$ final TIntHashSet subClasses = getAllSubclasses(it.name)-->Line_85 $$ subClasses.forEach(new TIntProcedure() [ FD ]
Line_22 $$ TIntHashSet propagated = null-->Line_40 $$ if (propagated == null) [ FD ]
Line_37 $$ if (!m.isPrivate()) -->Line_50 $$ debug("Processing affected by specificity methods")[ CD ]
Line_98 $$ if (outerClassRepr != null && (myFuture.isMethodVisible(outerClassRepr, m) || myFuture.extendsLibraryClass(outerClassRepr, null))) -->Line_99 $$ myAffectedFiles.addAll(sourceFileNames)[ CD ]
Line_89 $$ final ClassRepr r = myFuture.reprByName(subClass)-->Line_95 $$ final int outerClass = r.getOuterClassName()[ FD ]
Line_23 $$ if (!m.isPrivate() && m.name != myInitName) -->Line_29 $$ if (oldIt == null || !myPresent.hasOverriddenMethods(oldIt, MethodRepr.equalByJavaRules(m), null)) [ CD ]
Line_22 $$ TIntHashSet propagated = null-->Line_41 $$ propagated = myFuture.propagateMethodAccess(m, it.name)[ FD ]
Line_4 $$ if (added.isEmpty()) -->Line_5 $$ return[ CD ]
Line_61 $$ if (overrides.satisfy(method) && isInheritor) -->Line_81 $$ myFuture.affectMethodUsages(method, yetPropagated, method.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ CD ]
Line_61 $$ if (overrides.satisfy(method) && isInheritor) -->Line_64 $$ if (files != null) [ CD ]
Line_73 $$ if (isInheritor) -->Line_74 $$ final TIntHashSet deps = myClassToClassDependency.get(methodClass.name)[ CD ]
Line_61 $$ if (overrides.satisfy(method) && isInheritor) -->Line_72 $$ final TIntHashSet yetPropagated = myPresent.propagateMethodAccess(method, it.name)[ CD ]
Line_45 $$ if (!mm.equals(m)) -->Line_47 $$ myFuture.affectMethodUsages(mm, propagated, mm.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ CD ]
Line_64 $$ if (files != null) -->Line_65 $$ myAffectedFiles.addAll(files)[ CD ]
