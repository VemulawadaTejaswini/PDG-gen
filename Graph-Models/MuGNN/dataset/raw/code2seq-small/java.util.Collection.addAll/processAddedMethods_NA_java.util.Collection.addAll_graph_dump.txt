Line_60 $$ if (overrides.satisfy(method) && isInheritor) -->Line_70 $$ debug("Current method does not override that found")[ CD ]
Line_3 $$ final Collection<MethodRepr> added = diff.methods().added()-->Line_4 $$ if (added.isEmpty()) [ FD ]
Line_39 $$ if (propagated == null) -->Line_40 $$ propagated = myFuture.propagateMethodAccess(m, it.name)[ CD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_3 $$ final Collection<MethodRepr> added = diff.methods().added()[ CD ]
Line_73 $$ final TIntHashSet deps = myClassToClassDependency.get(methodClass.name)-->Line_74 $$ if (deps != null) [ FD ]
Line_36 $$ if (!m.isPrivate()) -->Line_39 $$ if (propagated == null) [ CD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_37 $$ final Collection<Pair<MethodRepr, ClassRepr>> affectedMethods = myFuture.findAllMethodsBySpecificity(m, it)[ FD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_37 $$ final Collection<Pair<MethodRepr, ClassRepr>> affectedMethods = myFuture.findAllMethodsBySpecificity(m, it)[ FD ]
Line_60 $$ if (overrides.satisfy(method) && isInheritor) -->Line_79 $$ debug("Affecting method usages for that found")[ CD ]
Line_84 $$ subClasses.forEach(new TIntProcedure() -->Line_103 $$ return true[ CD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_18 $$ if (it.isInterface() || it.isAbstract() || m.isAbstract()) [ FD ]
Line_25 $$ oldItRef = new Ref<ClassRepr>(getReprByName(null, it.name))-->Line_27 $$ final ClassRepr oldIt = oldItRef.get()[ FD ]
Line_94 $$ final ClassRepr outerClassRepr = myFuture.reprByName(outerClass)-->Line_95 $$ if (outerClassRepr != null && (myFuture.isMethodVisible(outerClassRepr, m) || myFuture.extendsLibraryClass(outerClassRepr, null))) [ FD ]
Line_22 $$ TIntHashSet propagated = null-->Line_46 $$ myFuture.affectMethodUsages(mm, propagated, mm.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_36 $$ if (!m.isPrivate()) -->Line_42 $$ final Collection<MethodRepr> lessSpecific = it.findMethods(myFuture.lessSpecific(m))[ CD ]
Line_60 $$ if (overrides.satisfy(method) && isInheritor) -->Line_61 $$ debug("Current method overrides that found")[ CD ]
Line_92 $$ final int outerClass = r.getOuterClassName()-->Line_93 $$ if (!isEmpty(outerClass)) [ FD ]
Line_29 $$ if (m.myArgumentTypes.length > 0) -->Line_32 $$ myFuture.affectMethodUsages(m, propagated, m.createMetaUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ CD ]
Line_65 $$ for (File file : files) -->Line_66 $$ debug("Affecting file ", file)[ FD ]
Line_91 $$ if (sourceFileNames != null && !myCompiledFiles.containsAll(sourceFileNames)) -->Line_93 $$ if (!isEmpty(outerClass)) [ CD ]
Line_52 $$ final ClassRepr methodClass = pair.second-->Line_53 $$ if (methodClass == MOCK_CLASS) [ FD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_108 $$ debug("End of added methods processing")[ CD ]
Line_95 $$ if (outerClassRepr != null && (myFuture.isMethodVisible(outerClassRepr, m) || myFuture.extendsLibraryClass(outerClassRepr, null))) -->Line_96 $$ myAffectedFiles.addAll(sourceFileNames)[ CD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_36 $$ if (!m.isPrivate()) [ FD ]
Line_23 $$ if (!m.isPrivate() && m.name != myInitName) -->Line_27 $$ final ClassRepr oldIt = oldItRef.get()[ CD ]
Line_15 $$ Ref<ClassRepr> oldItRef = null-->Line_25 $$ oldItRef = new Ref<ClassRepr>(getReprByName(null, it.name))[ FD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_44 $$ if (!mm.equals(m)) [ FD ]
Line_43 $$ for (final MethodRepr mm : lessSpecific) -->Line_44 $$ if (!mm.equals(m)) [ FD ]
Line_38 $$ final MethodRepr.Predicate overrides = MethodRepr.equalByJavaRules(m)-->Line_60 $$ if (overrides.satisfy(method) && isInheritor) [ FD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_8 $$ if (it.isAnnotation()) [ FD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_15 $$ Ref<ClassRepr> oldItRef = null[ CD ]
Line_4 $$ if (added.isEmpty()) -->Line_5 $$ return[ CD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_42 $$ final Collection<MethodRepr> lessSpecific = it.findMethods(myFuture.lessSpecific(m))[ FD ]
Line_74 $$ if (deps != null) -->Line_75 $$ addAll(state.myDependants, deps)[ CD ]
Line_44 $$ if (!mm.equals(m)) -->Line_45 $$ debug("Found less specific method, affecting method usages")[ CD ]
Line_40 $$ propagated = myFuture.propagateMethodAccess(m, it.name)-->Line_46 $$ myFuture.affectMethodUsages(mm, propagated, mm.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_51 $$ final MethodRepr method = pair.first-->Line_80 $$ myFuture.affectMethodUsages(method, yetPropagated, method.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_51 $$ final MethodRepr method = pair.first-->Line_60 $$ if (overrides.satisfy(method) && isInheritor) [ FD ]
Line_30 $$ propagated = myFuture.propagateMethodAccess(m, it.name)-->Line_32 $$ myFuture.affectMethodUsages(m, propagated, m.createMetaUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_91 $$ if (sourceFileNames != null && !myCompiledFiles.containsAll(sourceFileNames)) -->Line_92 $$ final int outerClass = r.getOuterClassName()[ CD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_7 $$ debug("Processing added methods: ")[ CD ]
Line_71 $$ final TIntHashSet yetPropagated = myPresent.propagateMethodAccess(method, it.name)-->Line_80 $$ myFuture.affectMethodUsages(method, yetPropagated, method.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_86 $$ final ClassRepr r = myFuture.reprByName(subClass)-->Line_92 $$ final int outerClass = r.getOuterClassName()[ FD ]
Line_29 $$ if (m.myArgumentTypes.length > 0) -->Line_31 $$ debug("Conservative case on overriding methods, affecting method usages")[ CD ]
Line_84 $$ subClasses.forEach(new TIntProcedure() -->Line_86 $$ final ClassRepr r = myFuture.reprByName(subClass)[ FD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_8 $$ if (it.isAnnotation()) [ CD ]
Line_24 $$ if (oldItRef == null) -->Line_25 $$ oldItRef = new Ref<ClassRepr>(getReprByName(null, it.name))[ CD ]
Line_22 $$ TIntHashSet propagated = null-->Line_40 $$ propagated = myFuture.propagateMethodAccess(m, it.name)[ FD ]
Line_62 $$ final Collection<File> files = myClassToSourceFile.get(methodClass.name)-->Line_63 $$ if (files != null) [ FD ]
Line_72 $$ if (isInheritor) -->Line_77 $$ myFuture.affectMethodUsages(method, yetPropagated, method.createUsage(myContext, methodClass.name), state.myAffectedUsages, state.myDependants)[ CD ]
Line_87 $$ if (r == null) -->Line_88 $$ return true[ CD ]
Line_43 $$ for (final MethodRepr mm : lessSpecific) -->Line_46 $$ myFuture.affectMethodUsages(mm, propagated, mm.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_60 $$ if (overrides.satisfy(method) && isInheritor) -->Line_72 $$ if (isInheritor) [ CD ]
Line_90 $$ final Collection<File> sourceFileNames = myClassToSourceFile.get(subClass)-->Line_91 $$ if (sourceFileNames != null && !myCompiledFiles.containsAll(sourceFileNames)) [ FD ]
Line_15 $$ Ref<ClassRepr> oldItRef = null-->Line_24 $$ if (oldItRef == null) [ FD ]
Line_44 $$ if (!mm.equals(m)) -->Line_46 $$ myFuture.affectMethodUsages(mm, propagated, mm.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ CD ]
Line_51 $$ final MethodRepr method = pair.first-->Line_77 $$ myFuture.affectMethodUsages(method, yetPropagated, method.createUsage(myContext, methodClass.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_72 $$ if (isInheritor) -->Line_73 $$ final TIntHashSet deps = myClassToClassDependency.get(methodClass.name)[ CD ]
Line_51 $$ final MethodRepr method = pair.first-->Line_71 $$ final TIntHashSet yetPropagated = myPresent.propagateMethodAccess(method, it.name)[ FD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_32 $$ myFuture.affectMethodUsages(m, propagated, m.createMetaUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_28 $$ if (oldIt == null || !myPresent.hasOverriddenMethods(oldIt, MethodRepr.equalByJavaRules(m), null)) -->Line_29 $$ if (m.myArgumentTypes.length > 0) [ CD ]
Line_36 $$ if (!m.isPrivate()) -->Line_49 $$ debug("Processing affected by specificity methods")[ CD ]
Line_36 $$ if (!m.isPrivate()) -->Line_37 $$ final Collection<Pair<MethodRepr, ClassRepr>> affectedMethods = myFuture.findAllMethodsBySpecificity(m, it)[ CD ]
Line_27 $$ final ClassRepr oldIt = oldItRef.get()-->Line_28 $$ if (oldIt == null || !myPresent.hasOverriddenMethods(oldIt, MethodRepr.equalByJavaRules(m), null)) [ FD ]
Line_60 $$ if (overrides.satisfy(method) && isInheritor) -->Line_71 $$ final TIntHashSet yetPropagated = myPresent.propagateMethodAccess(method, it.name)[ CD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_40 $$ propagated = myFuture.propagateMethodAccess(m, it.name)[ FD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_28 $$ if (oldIt == null || !myPresent.hasOverriddenMethods(oldIt, MethodRepr.equalByJavaRules(m), null)) [ FD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_30 $$ propagated = myFuture.propagateMethodAccess(m, it.name)[ FD ]
Line_18 $$ if (it.isInterface() || it.isAbstract() || m.isAbstract()) -->Line_20 $$ myFuture.affectSubclasses(it.name, myAffectedFiles, state.myAffectedUsages, state.myDependants, false, myCompiledFiles, null)[ CD ]
Line_63 $$ if (files != null) -->Line_64 $$ myAffectedFiles.addAll(files)[ CD ]
Line_84 $$ subClasses.forEach(new TIntProcedure() -->Line_86 $$ final ClassRepr r = myFuture.reprByName(subClass)[ CD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_3 $$ final Collection<MethodRepr> added = diff.methods().added()[ FD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_23 $$ if (!m.isPrivate() && m.name != myInitName) [ FD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_38 $$ final MethodRepr.Predicate overrides = MethodRepr.equalByJavaRules(m)[ FD ]
Line_15 $$ Ref<ClassRepr> oldItRef = null-->Line_27 $$ final ClassRepr oldIt = oldItRef.get()[ FD ]
Line_16 $$ for (final MethodRepr m : added) -->Line_95 $$ if (outerClassRepr != null && (myFuture.isMethodVisible(outerClassRepr, m) || myFuture.extendsLibraryClass(outerClassRepr, null))) [ FD ]
Line_93 $$ if (!isEmpty(outerClass)) -->Line_94 $$ final ClassRepr outerClassRepr = myFuture.reprByName(outerClass)[ CD ]
Line_84 $$ subClasses.forEach(new TIntProcedure() -->Line_90 $$ final Collection<File> sourceFileNames = myClassToSourceFile.get(subClass)[ FD ]
Line_97 $$ for (File sourceFileName : sourceFileNames) -->Line_98 $$ debug("Affecting file due to local overriding: ", sourceFileName)[ FD ]
Line_84 $$ subClasses.forEach(new TIntProcedure() -->Line_91 $$ if (sourceFileNames != null && !myCompiledFiles.containsAll(sourceFileNames)) [ CD ]
Line_18 $$ if (it.isInterface() || it.isAbstract() || m.isAbstract()) -->Line_19 $$ debug("Class is abstract, or is interface, or added method in abstract => affecting all subclasses")[ CD ]
Line_92 $$ final int outerClass = r.getOuterClassName()-->Line_94 $$ final ClassRepr outerClassRepr = myFuture.reprByName(outerClass)[ FD ]
Line_73 $$ final TIntHashSet deps = myClassToClassDependency.get(methodClass.name)-->Line_75 $$ addAll(state.myDependants, deps)[ FD ]
Line_30 $$ propagated = myFuture.propagateMethodAccess(m, it.name)-->Line_46 $$ myFuture.affectMethodUsages(mm, propagated, mm.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_30 $$ propagated = myFuture.propagateMethodAccess(m, it.name)-->Line_40 $$ propagated = myFuture.propagateMethodAccess(m, it.name)[ FD ]
Line_22 $$ TIntHashSet propagated = null-->Line_32 $$ myFuture.affectMethodUsages(m, propagated, m.createMetaUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_30 $$ propagated = myFuture.propagateMethodAccess(m, it.name)-->Line_39 $$ if (propagated == null) [ FD ]
Line_36 $$ if (!m.isPrivate()) -->Line_83 $$ final TIntHashSet subClasses = getAllSubclasses(it.name)[ CD ]
Line_36 $$ if (!m.isPrivate()) -->Line_84 $$ subClasses.forEach(new TIntProcedure() [ CD ]
Line_84 $$ subClasses.forEach(new TIntProcedure() -->Line_90 $$ final Collection<File> sourceFileNames = myClassToSourceFile.get(subClass)[ CD ]
Line_60 $$ if (overrides.satisfy(method) && isInheritor) -->Line_63 $$ if (files != null) [ CD ]
Line_36 $$ if (!m.isPrivate()) -->Line_38 $$ final MethodRepr.Predicate overrides = MethodRepr.equalByJavaRules(m)[ CD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_18 $$ if (it.isInterface() || it.isAbstract() || m.isAbstract()) [ FD ]
Line_60 $$ if (overrides.satisfy(method) && isInheritor) -->Line_80 $$ myFuture.affectMethodUsages(method, yetPropagated, method.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ CD ]
Line_83 $$ final TIntHashSet subClasses = getAllSubclasses(it.name)-->Line_84 $$ subClasses.forEach(new TIntProcedure() [ FD ]
Line_22 $$ TIntHashSet propagated = null-->Line_30 $$ propagated = myFuture.propagateMethodAccess(m, it.name)[ FD ]
Line_60 $$ if (overrides.satisfy(method) && isInheritor) -->Line_62 $$ final Collection<File> files = myClassToSourceFile.get(methodClass.name)[ CD ]
Line_90 $$ final Collection<File> sourceFileNames = myClassToSourceFile.get(subClass)-->Line_96 $$ myAffectedFiles.addAll(sourceFileNames)[ FD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_42 $$ final Collection<MethodRepr> lessSpecific = it.findMethods(myFuture.lessSpecific(m))[ FD ]
Line_29 $$ if (m.myArgumentTypes.length > 0) -->Line_30 $$ propagated = myFuture.propagateMethodAccess(m, it.name)[ CD ]
Line_93 $$ if (!isEmpty(outerClass)) -->Line_95 $$ if (outerClassRepr != null && (myFuture.isMethodVisible(outerClassRepr, m) || myFuture.extendsLibraryClass(outerClassRepr, null))) [ CD ]
Line_57 $$ final boolean isInheritor = inheritorOf != null && inheritorOf-->Line_60 $$ if (overrides.satisfy(method) && isInheritor) [ FD ]
Line_8 $$ if (it.isAnnotation()) -->Line_10 $$ return[ CD ]
Line_2 $$ private void processAddedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_4 $$ if (added.isEmpty()) [ CD ]
Line_23 $$ if (!m.isPrivate() && m.name != myInitName) -->Line_28 $$ if (oldIt == null || !myPresent.hasOverriddenMethods(oldIt, MethodRepr.equalByJavaRules(m), null)) [ CD ]
Line_8 $$ if (it.isAnnotation()) -->Line_9 $$ debug("Class is annotation, skipping method analysis")[ CD ]
Line_23 $$ if (!m.isPrivate() && m.name != myInitName) -->Line_24 $$ if (oldItRef == null) [ CD ]
Line_72 $$ if (isInheritor) -->Line_74 $$ if (deps != null) [ CD ]
Line_62 $$ final Collection<File> files = myClassToSourceFile.get(methodClass.name)-->Line_64 $$ myAffectedFiles.addAll(files)[ FD ]
Line_84 $$ subClasses.forEach(new TIntProcedure() -->Line_87 $$ if (r == null) [ CD ]
Line_71 $$ final TIntHashSet yetPropagated = myPresent.propagateMethodAccess(method, it.name)-->Line_77 $$ myFuture.affectMethodUsages(method, yetPropagated, method.createUsage(myContext, methodClass.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_22 $$ TIntHashSet propagated = null-->Line_39 $$ if (propagated == null) [ FD ]
Line_86 $$ final ClassRepr r = myFuture.reprByName(subClass)-->Line_87 $$ if (r == null) [ FD ]
