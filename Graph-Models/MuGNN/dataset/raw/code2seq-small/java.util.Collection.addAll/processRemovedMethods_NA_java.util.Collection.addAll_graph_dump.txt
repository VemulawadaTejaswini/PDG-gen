Line_44 $$ propagated.forEach(new TIntProcedure() -->Line_48 $$ if (p != it.name) [ FD ]
Line_27 $$ if (!clear) -->Line_29 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ CD ]
Line_15 $$ if (overridenMethods.size() == 0) -->Line_17 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ CD ]
Line_48 $$ if (p != it.name) -->Line_50 $$ if (s != null) [ CD ]
Line_2 $$ private void processRemovedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_3 $$ final Collection<MethodRepr> removed = diff.methods().removed()[ FD ]
Line_57 $$ if (cc == MOCK_CLASS) -->Line_58 $$ visited = true[ CD ]
Line_15 $$ if (overridenMethods.size() == 0) -->Line_19 $$ boolean clear = true[ CD ]
Line_53 $$ boolean allAbstract = true-->Line_66 $$ if (!allAbstract) [ FD ]
Line_34 $$ for (final Pair<MethodRepr, ClassRepr> p : overridingMethods) -->Line_74 $$ debug("Removed method is not abstract & overrides some abstract method which is not then over-overridden in subclass ", p)[ FD ]
Line_50 $$ if (s != null) -->Line_52 $$ overridenInS.addAll(overridenMethods)[ CD ]
Line_65 $$ allAbstract = pp.first.isAbstract() || cc.isInterface()-->Line_70 $$ if (allAbstract && visited) [ FD ]
Line_54 $$ boolean visited = false-->Line_64 $$ visited = true[ FD ]
Line_71 $$ final Collection<File> sources = myClassToSourceFile.get(p)-->Line_73 $$ myAffectedFiles.addAll(sources)[ FD ]
Line_2 $$ private void processRemovedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_10 $$ debug("Processing removed methods:")[ CD ]
Line_70 $$ if (allAbstract && visited) -->Line_71 $$ final Collection<File> sources = myClassToSourceFile.get(p)[ CD ]
Line_32 $$ final Collection<Pair<MethodRepr, ClassRepr>> overridingMethods = new HashSet<Pair<MethodRepr, ClassRepr>>()-->Line_33 $$ myFuture.addOverridingMethods(m, it, MethodRepr.equalByJavaRules(m), overridingMethods, null)[ FD ]
Line_14 $$ final TIntHashSet propagated = myFuture.propagateMethodAccess(m, it.name)-->Line_29 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_11 $$ for (final MethodRepr m : removed) -->Line_51 $$ final Collection<Pair<MethodRepr, ClassRepr>> overridenInS = myFuture.findOverriddenMethods(m, s)[ FD ]
Line_58 $$ visited = true-->Line_70 $$ if (allAbstract && visited) [ FD ]
Line_11 $$ for (final MethodRepr m : removed) -->Line_22 $$ if (mm == MOCK_METHOD || !mm.myType.equals(m.myType) || !isEmpty(mm.signature) || !isEmpty(m.signature) || m.isMoreAccessibleThan(mm)) [ FD ]
Line_3 $$ final Collection<MethodRepr> removed = diff.methods().removed()-->Line_4 $$ if (removed.isEmpty()) [ FD ]
Line_43 $$ if (!m.isAbstract()) -->Line_44 $$ propagated.forEach(new TIntProcedure() [ CD ]
Line_49 $$ final ClassRepr s = myFuture.reprByName(p)-->Line_50 $$ if (s != null) [ FD ]
Line_64 $$ visited = true-->Line_70 $$ if (allAbstract && visited) [ FD ]
Line_15 $$ if (overridenMethods.size() == 0) -->Line_27 $$ if (!clear) [ CD ]
Line_70 $$ if (allAbstract && visited) -->Line_72 $$ if (sources != null && !myCompiledFiles.containsAll(sources)) [ CD ]
Line_44 $$ propagated.forEach(new TIntProcedure() -->Line_48 $$ if (p != it.name) [ CD ]
Line_14 $$ final TIntHashSet propagated = myFuture.propagateMethodAccess(m, it.name)-->Line_44 $$ propagated.forEach(new TIntProcedure() [ FD ]
Line_35 $$ final Collection<File> fNames = myClassToSourceFile.get(p.second.name)-->Line_37 $$ myAffectedFiles.addAll(fNames)[ FD ]
Line_56 $$ final ClassRepr cc = pp.second-->Line_65 $$ allAbstract = pp.first.isAbstract() || cc.isInterface()[ FD ]
Line_19 $$ boolean clear = true-->Line_23 $$ clear = false[ FD ]
Line_50 $$ if (s != null) -->Line_51 $$ final Collection<Pair<MethodRepr, ClassRepr>> overridenInS = myFuture.findOverriddenMethods(m, s)[ CD ]
Line_56 $$ final ClassRepr cc = pp.second-->Line_57 $$ if (cc == MOCK_CLASS) [ FD ]
Line_44 $$ propagated.forEach(new TIntProcedure() -->Line_82 $$ return true[ CD ]
Line_13 $$ final Collection<Pair<MethodRepr, ClassRepr>> overridenMethods = myFuture.findOverriddenMethods(m, it)-->Line_52 $$ overridenInS.addAll(overridenMethods)[ FD ]
Line_22 $$ if (mm == MOCK_METHOD || !mm.myType.equals(m.myType) || !isEmpty(mm.signature) || !isEmpty(m.signature) || m.isMoreAccessibleThan(mm)) -->Line_23 $$ clear = false[ CD ]
Line_2 $$ private void processRemovedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_33 $$ myFuture.addOverridingMethods(m, it, MethodRepr.equalByJavaRules(m), overridingMethods, null)[ FD ]
Line_34 $$ for (final Pair<MethodRepr, ClassRepr> p : overridingMethods) -->Line_49 $$ final ClassRepr s = myFuture.reprByName(p)[ FD ]
Line_58 $$ visited = true-->Line_64 $$ visited = true[ FD ]
Line_36 $$ if (fNames != null) -->Line_37 $$ myAffectedFiles.addAll(fNames)[ CD ]
Line_2 $$ private void processRemovedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_4 $$ if (removed.isEmpty()) [ CD ]
Line_49 $$ final ClassRepr s = myFuture.reprByName(p)-->Line_51 $$ final Collection<Pair<MethodRepr, ClassRepr>> overridenInS = myFuture.findOverriddenMethods(m, s)[ FD ]
Line_14 $$ final TIntHashSet propagated = myFuture.propagateMethodAccess(m, it.name)-->Line_17 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_34 $$ for (final Pair<MethodRepr, ClassRepr> p : overridingMethods) -->Line_71 $$ final Collection<File> sources = myClassToSourceFile.get(p)[ FD ]
Line_11 $$ for (final MethodRepr m : removed) -->Line_17 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_72 $$ if (sources != null && !myCompiledFiles.containsAll(sources)) -->Line_74 $$ debug("Removed method is not abstract & overrides some abstract method which is not then over-overridden in subclass ", p)[ CD ]
Line_44 $$ propagated.forEach(new TIntProcedure() -->Line_49 $$ final ClassRepr s = myFuture.reprByName(p)[ FD ]
Line_50 $$ if (s != null) -->Line_53 $$ boolean allAbstract = true[ CD ]
Line_38 $$ for (File fName : fNames) -->Line_39 $$ debug("Affecting file by overriding: ", fName)[ FD ]
Line_23 $$ clear = false-->Line_27 $$ if (!clear) [ FD ]
Line_2 $$ private void processRemovedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_87 $$ debug("End of removed methods processing")[ CD ]
Line_34 $$ for (final Pair<MethodRepr, ClassRepr> p : overridingMethods) -->Line_48 $$ if (p != it.name) [ FD ]
Line_11 $$ for (final MethodRepr m : removed) -->Line_33 $$ myFuture.addOverridingMethods(m, it, MethodRepr.equalByJavaRules(m), overridingMethods, null)[ FD ]
Line_75 $$ for (File source : sources) -->Line_76 $$ debug("Affecting subclass source file ", source)[ FD ]
Line_27 $$ if (!clear) -->Line_28 $$ debug("No clearly overridden methods found, affecting method usages")[ CD ]
Line_2 $$ private void processRemovedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_13 $$ final Collection<Pair<MethodRepr, ClassRepr>> overridenMethods = myFuture.findOverriddenMethods(m, it)[ FD ]
Line_54 $$ boolean visited = false-->Line_58 $$ visited = true[ FD ]
Line_44 $$ propagated.forEach(new TIntProcedure() -->Line_74 $$ debug("Removed method is not abstract & overrides some abstract method which is not then over-overridden in subclass ", p)[ FD ]
Line_11 $$ for (final MethodRepr m : removed) -->Line_29 $$ myFuture.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), state.myAffectedUsages, state.myDependants)[ FD ]
Line_71 $$ final Collection<File> sources = myClassToSourceFile.get(p)-->Line_72 $$ if (sources != null && !myCompiledFiles.containsAll(sources)) [ FD ]
Line_50 $$ if (s != null) -->Line_70 $$ if (allAbstract && visited) [ CD ]
Line_48 $$ if (p != it.name) -->Line_49 $$ final ClassRepr s = myFuture.reprByName(p)[ CD ]
Line_54 $$ boolean visited = false-->Line_70 $$ if (allAbstract && visited) [ FD ]
Line_4 $$ if (removed.isEmpty()) -->Line_5 $$ return[ CD ]
Line_65 $$ allAbstract = pp.first.isAbstract() || cc.isInterface()-->Line_66 $$ if (!allAbstract) [ FD ]
Line_11 $$ for (final MethodRepr m : removed) -->Line_43 $$ if (!m.isAbstract()) [ FD ]
Line_13 $$ final Collection<Pair<MethodRepr, ClassRepr>> overridenMethods = myFuture.findOverriddenMethods(m, it)-->Line_15 $$ if (overridenMethods.size() == 0) [ FD ]
Line_21 $$ final MethodRepr mm = overriden.first-->Line_22 $$ if (mm == MOCK_METHOD || !mm.myType.equals(m.myType) || !isEmpty(mm.signature) || !isEmpty(m.signature) || m.isMoreAccessibleThan(mm)) [ FD ]
Line_11 $$ for (final MethodRepr m : removed) -->Line_14 $$ final TIntHashSet propagated = myFuture.propagateMethodAccess(m, it.name)[ FD ]
Line_11 $$ for (final MethodRepr m : removed) -->Line_13 $$ final Collection<Pair<MethodRepr, ClassRepr>> overridenMethods = myFuture.findOverriddenMethods(m, it)[ FD ]
Line_35 $$ final Collection<File> fNames = myClassToSourceFile.get(p.second.name)-->Line_36 $$ if (fNames != null) [ FD ]
Line_2 $$ private void processRemovedMethods(final DiffState state, final ClassRepr.Diff diff, final ClassRepr it) -->Line_3 $$ final Collection<MethodRepr> removed = diff.methods().removed()[ CD ]
Line_19 $$ boolean clear = true-->Line_27 $$ if (!clear) [ FD ]
Line_50 $$ if (s != null) -->Line_54 $$ boolean visited = false[ CD ]
Line_72 $$ if (sources != null && !myCompiledFiles.containsAll(sources)) -->Line_73 $$ myAffectedFiles.addAll(sources)[ CD ]
Line_44 $$ propagated.forEach(new TIntProcedure() -->Line_71 $$ final Collection<File> sources = myClassToSourceFile.get(p)[ FD ]
Line_51 $$ final Collection<Pair<MethodRepr, ClassRepr>> overridenInS = myFuture.findOverriddenMethods(m, s)-->Line_52 $$ overridenInS.addAll(overridenMethods)[ FD ]
Line_53 $$ boolean allAbstract = true-->Line_70 $$ if (allAbstract && visited) [ FD ]
Line_15 $$ if (overridenMethods.size() == 0) -->Line_16 $$ debug("No overridden methods found, affecting method usages")[ CD ]
Line_53 $$ boolean allAbstract = true-->Line_65 $$ allAbstract = pp.first.isAbstract() || cc.isInterface()[ FD ]
