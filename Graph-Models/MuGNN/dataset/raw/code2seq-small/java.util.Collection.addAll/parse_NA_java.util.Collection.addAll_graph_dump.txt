Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_49 $$ String cfStr = options.get(COLUMNFAMILIES_KEY)[ FD ]
Line_51 $$ Collection<String> columnFamilies = new HashSet()-->Line_56 $$ option.getColumnFamilies().addAll(columnFamilies)[ FD ]
Line_32 $$ Collection<String> dataCenters = new HashSet()-->Line_36 $$ dataCenters.add(tokenizer.nextToken().trim())[ FD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_31 $$ String dataCentersStr = options.get(DATACENTERS_KEY)[ FD ]
Line_50 $$ if (cfStr != null) -->Line_51 $$ Collection<String> columnFamilies = new HashSet()[ CD ]
Line_41 $$ Collection<String> hosts = new HashSet()-->Line_61 $$ if (primaryRange && (!dataCenters.isEmpty() || !hosts.isEmpty())) [ FD ]
Line_19 $$ StringTokenizer tokenizer = new StringTokenizer(rangesStr, ",")-->Line_36 $$ dataCenters.add(tokenizer.nextToken().trim())[ FD ]
Line_20 $$ while (tokenizer.hasMoreTokens()) -->Line_26 $$ Token parsedEndToken = partitioner.getTokenFactory().fromString(rangeStr[1].trim())[ CD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_8 $$ if (options.containsKey(JOB_THREADS_KEY)) [ FD ]
Line_41 $$ Collection<String> hosts = new HashSet()-->Line_45 $$ hosts.add(tokenizer.nextToken().trim())[ FD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_6 $$ boolean trace = Boolean.parseBoolean(options.get(TRACE_KEY))[ CD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_5 $$ boolean incremental = Boolean.parseBoolean(options.get(INCREMENTAL_KEY))[ CD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_16 $$ if (rangesStr != null) [ CD ]
Line_19 $$ StringTokenizer tokenizer = new StringTokenizer(rangesStr, ",")-->Line_53 $$ while (tokenizer.hasMoreTokens()) [ FD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_5 $$ boolean incremental = Boolean.parseBoolean(options.get(INCREMENTAL_KEY))[ FD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_41 $$ Collection<String> hosts = new HashSet()[ CD ]
Line_19 $$ StringTokenizer tokenizer = new StringTokenizer(rangesStr, ",")-->Line_45 $$ hosts.add(tokenizer.nextToken().trim())[ FD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_31 $$ String dataCentersStr = options.get(DATACENTERS_KEY)[ CD ]
Line_15 $$ Set<Range<Token>> ranges = new HashSet()-->Line_30 $$ RepairOption option = new RepairOption(parallelism, primaryRange, incremental, trace, jobThreads, ranges, !ranges.isEmpty())[ FD ]
Line_20 $$ while (tokenizer.hasMoreTokens()) -->Line_21 $$ String[] rangeStr = tokenizer.nextToken().split(":", 2)[ CD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_7 $$ int jobThreads = 1[ CD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_15 $$ Set<Range<Token>> ranges = new HashSet()[ CD ]
Line_20 $$ while (tokenizer.hasMoreTokens()) -->Line_25 $$ Token parsedBeginToken = partitioner.getTokenFactory().fromString(rangeStr[0].trim())[ CD ]
Line_50 $$ if (cfStr != null) -->Line_56 $$ option.getColumnFamilies().addAll(columnFamilies)[ CD ]
Line_35 $$ while (tokenizer.hasMoreTokens()) -->Line_36 $$ dataCenters.add(tokenizer.nextToken().trim())[ CD ]
Line_19 $$ StringTokenizer tokenizer = new StringTokenizer(rangesStr, ",")-->Line_54 $$ columnFamilies.add(tokenizer.nextToken().trim())[ FD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_3 $$ RepairParallelism parallelism = RepairParallelism.fromName(options.get(PARALLELISM_KEY))[ CD ]
Line_17 $$ if (incremental)-->Line_18 $$ logger.warn("Incremental repair can't be requested with subrange repair " + "because each subrange repair would generate an anti-compacted table. " + "The repair will occur but without anti-compaction.")[ CD ]
Line_20 $$ while (tokenizer.hasMoreTokens()) -->Line_22 $$ if (rangeStr.length < 2) [ CD ]
Line_31 $$ String dataCentersStr = options.get(DATACENTERS_KEY)-->Line_33 $$ if (dataCentersStr != null) [ FD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_26 $$ Token parsedEndToken = partitioner.getTokenFactory().fromString(rangeStr[1].trim())[ FD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_42 $$ if (hostsStr != null) [ CD ]
Line_30 $$ RepairOption option = new RepairOption(parallelism, primaryRange, incremental, trace, jobThreads, ranges, !ranges.isEmpty())-->Line_38 $$ option.getDataCenters().addAll(dataCenters)[ FD ]
Line_32 $$ Collection<String> dataCenters = new HashSet()-->Line_38 $$ option.getDataCenters().addAll(dataCenters)[ FD ]
Line_16 $$ if (rangesStr != null) -->Line_20 $$ while (tokenizer.hasMoreTokens()) [ CD ]
Line_19 $$ StringTokenizer tokenizer = new StringTokenizer(rangesStr, ",")-->Line_20 $$ while (tokenizer.hasMoreTokens()) [ FD ]
Line_44 $$ while (tokenizer.hasMoreTokens()) -->Line_45 $$ hosts.add(tokenizer.nextToken().trim())[ CD ]
Line_50 $$ if (cfStr != null) -->Line_53 $$ while (tokenizer.hasMoreTokens()) [ CD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_33 $$ if (dataCentersStr != null) [ CD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_4 $$ boolean primaryRange = Boolean.parseBoolean(options.get(PRIMARY_RANGE_KEY))[ FD ]
Line_15 $$ Set<Range<Token>> ranges = new HashSet()-->Line_27 $$ ranges.add(new Range(parsedBeginToken, parsedEndToken))[ FD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_4 $$ boolean primaryRange = Boolean.parseBoolean(options.get(PRIMARY_RANGE_KEY))[ CD ]
Line_33 $$ if (dataCentersStr != null) -->Line_38 $$ option.getDataCenters().addAll(dataCenters)[ CD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_49 $$ String cfStr = options.get(COLUMNFAMILIES_KEY)[ CD ]
Line_19 $$ StringTokenizer tokenizer = new StringTokenizer(rangesStr, ",")-->Line_21 $$ String[] rangeStr = tokenizer.nextToken().split(":", 2)[ FD ]
Line_30 $$ RepairOption option = new RepairOption(parallelism, primaryRange, incremental, trace, jobThreads, ranges, !ranges.isEmpty())-->Line_47 $$ option.getHosts().addAll(hosts)[ FD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_25 $$ Token parsedBeginToken = partitioner.getTokenFactory().fromString(rangeStr[0].trim())[ FD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_50 $$ if (cfStr != null) [ CD ]
Line_10 $$ jobThreads = Integer.parseInt(options.get(JOB_THREADS_KEY))-->Line_58 $$ if (jobThreads > MAX_JOB_THREADS) [ FD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_40 $$ String hostsStr = options.get(HOSTS_KEY)[ CD ]
Line_49 $$ String cfStr = options.get(COLUMNFAMILIES_KEY)-->Line_50 $$ if (cfStr != null) [ FD ]
Line_7 $$ int jobThreads = 1-->Line_58 $$ if (jobThreads > MAX_JOB_THREADS) [ FD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_14 $$ String rangesStr = options.get(RANGES_KEY)[ CD ]
Line_30 $$ RepairOption option = new RepairOption(parallelism, primaryRange, incremental, trace, jobThreads, ranges, !ranges.isEmpty())-->Line_56 $$ option.getColumnFamilies().addAll(columnFamilies)[ FD ]
Line_53 $$ while (tokenizer.hasMoreTokens()) -->Line_54 $$ columnFamilies.add(tokenizer.nextToken().trim())[ CD ]
Line_16 $$ if (rangesStr != null) -->Line_17 $$ if (incremental)[ CD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_10 $$ jobThreads = Integer.parseInt(options.get(JOB_THREADS_KEY))[ FD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_32 $$ Collection<String> dataCenters = new HashSet()[ CD ]
Line_14 $$ String rangesStr = options.get(RANGES_KEY)-->Line_16 $$ if (rangesStr != null) [ FD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_40 $$ String hostsStr = options.get(HOSTS_KEY)[ FD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_3 $$ RepairParallelism parallelism = RepairParallelism.fromName(options.get(PARALLELISM_KEY))[ FD ]
Line_19 $$ StringTokenizer tokenizer = new StringTokenizer(rangesStr, ",")-->Line_35 $$ while (tokenizer.hasMoreTokens()) [ FD ]
Line_42 $$ if (hostsStr != null) -->Line_44 $$ while (tokenizer.hasMoreTokens()) [ CD ]
Line_41 $$ Collection<String> hosts = new HashSet()-->Line_47 $$ option.getHosts().addAll(hosts)[ FD ]
Line_51 $$ Collection<String> columnFamilies = new HashSet()-->Line_54 $$ columnFamilies.add(tokenizer.nextToken().trim())[ FD ]
Line_20 $$ while (tokenizer.hasMoreTokens()) -->Line_27 $$ ranges.add(new Range(parsedBeginToken, parsedEndToken))[ CD ]
Line_7 $$ int jobThreads = 1-->Line_10 $$ jobThreads = Integer.parseInt(options.get(JOB_THREADS_KEY))[ FD ]
Line_40 $$ String hostsStr = options.get(HOSTS_KEY)-->Line_42 $$ if (hostsStr != null) [ FD ]
Line_4 $$ boolean primaryRange = Boolean.parseBoolean(options.get(PRIMARY_RANGE_KEY))-->Line_61 $$ if (primaryRange && (!dataCenters.isEmpty() || !hosts.isEmpty())) [ FD ]
Line_42 $$ if (hostsStr != null) -->Line_47 $$ option.getHosts().addAll(hosts)[ CD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_64 $$ return option[ CD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_61 $$ if (primaryRange && (!dataCenters.isEmpty() || !hosts.isEmpty())) [ CD ]
Line_16 $$ if (rangesStr != null) -->Line_19 $$ StringTokenizer tokenizer = new StringTokenizer(rangesStr, ",")[ CD ]
Line_32 $$ Collection<String> dataCenters = new HashSet()-->Line_61 $$ if (primaryRange && (!dataCenters.isEmpty() || !hosts.isEmpty())) [ FD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_14 $$ String rangesStr = options.get(RANGES_KEY)[ FD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_30 $$ RepairOption option = new RepairOption(parallelism, primaryRange, incremental, trace, jobThreads, ranges, !ranges.isEmpty())[ CD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_58 $$ if (jobThreads > MAX_JOB_THREADS) [ CD ]
Line_33 $$ if (dataCentersStr != null) -->Line_35 $$ while (tokenizer.hasMoreTokens()) [ CD ]
Line_19 $$ StringTokenizer tokenizer = new StringTokenizer(rangesStr, ",")-->Line_44 $$ while (tokenizer.hasMoreTokens()) [ FD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_8 $$ if (options.containsKey(JOB_THREADS_KEY)) [ CD ]
Line_2 $$ public static RepairOption parse(Map<String, String> options, IPartitioner partitioner) -->Line_6 $$ boolean trace = Boolean.parseBoolean(options.get(TRACE_KEY))[ FD ]
