Line_2 $$ public void testReadRandom() throws IOException -->Line_8 $$ for (int i = 0; i < numWriteOps; i++) [ CD ]
Line_42 $$ byte[] buffer = new byte[b.length]-->Line_43 $$ int read = readFully(input, buffer)[ FD ]
Line_7 $$ Random random = new Random(seed)-->Line_36 $$ switch(random.nextInt(5)) [ FD ]
Line_8 $$ for (int i = 0; i < numWriteOps; i++) -->Line_50 $$ for (int i = 0; i < streams.length - 1; i++) [ FD ]
Line_2 $$ public void testReadRandom() throws IOException -->Line_21 $$ int offset = 0[ CD ]
Line_8 $$ for (int i = 0; i < numWriteOps; i++) -->Line_23 $$ for (int i = 0; i < parts; i++) [ FD ]
Line_2 $$ public void testReadRandom() throws IOException -->Line_35 $$ for (int i = 0; i < numWriteOps; i++) [ CD ]
Line_2 $$ public void testReadRandom() throws IOException -->Line_6 $$ final long seed = randomLong()[ CD ]
Line_28 $$ SlicedInputStream input = new SlicedInputStream(parts) -->Line_49 $$ assertThat(input.available(), equalTo(0))[ FD ]
Line_2 $$ public void testReadRandom() throws IOException -->Line_50 $$ for (int i = 0; i < streams.length - 1; i++) [ CD ]
Line_2 $$ public void testReadRandom() throws IOException -->Line_5 $$ int numWriteOps = scaledRandomIntBetween(1000, 10000)[ CD ]
Line_23 $$ for (int i = 0; i < parts; i++) -->Line_24 $$ length = i == parts - 1 ? bytes.length - offset : slice[ CD ]
Line_7 $$ Random random = new Random(seed)-->Line_11 $$ stream.write(random.nextInt(Byte.MAX_VALUE))[ FD ]
Line_5 $$ int numWriteOps = scaledRandomIntBetween(1000, 10000)-->Line_35 $$ for (int i = 0; i < numWriteOps; i++) [ FD ]
Line_2 $$ public void testReadRandom() throws IOException -->Line_34 $$ assertThat(input.available(), equalTo(streams[0].available()))[ CD ]
Line_35 $$ for (int i = 0; i < numWriteOps; i++) -->Line_50 $$ for (int i = 0; i < streams.length - 1; i++) [ FD ]
Line_28 $$ SlicedInputStream input = new SlicedInputStream(parts) -->Line_53 $$ input.close()[ FD ]
Line_2 $$ public void testReadRandom() throws IOException -->Line_4 $$ ByteArrayOutputStream stream = new ByteArrayOutputStream()[ CD ]
Line_7 $$ Random random = new Random(seed)-->Line_9 $$ switch(random.nextInt(5)) [ FD ]
Line_21 $$ int offset = 0-->Line_26 $$ offset += length[ FD ]
Line_22 $$ int length-->Line_26 $$ offset += length[ FD ]
Line_23 $$ for (int i = 0; i < parts; i++) -->Line_26 $$ offset += length[ CD ]
Line_2 $$ public void testReadRandom() throws IOException -->Line_3 $$ int parts = randomIntBetween(1, 20)[ CD ]
Line_23 $$ for (int i = 0; i < parts; i++) -->Line_25 $$ streams[i] = new CheckClosedInputStream(new ByteArrayInputStream(bytes, offset, length))[ CD ]
Line_8 $$ for (int i = 0; i < numWriteOps; i++) -->Line_35 $$ for (int i = 0; i < numWriteOps; i++) [ FD ]
Line_7 $$ Random random = new Random(seed)-->Line_38 $$ assertThat(random.nextInt(Byte.MAX_VALUE), equalTo(input.read()))[ FD ]
Line_28 $$ SlicedInputStream input = new SlicedInputStream(parts) -->Line_30 $$ return streams[(int) slice][ CD ]
Line_4 $$ ByteArrayOutputStream stream = new ByteArrayOutputStream()-->Line_19 $$ byte[] bytes = stream.toByteArray()[ FD ]
Line_2 $$ public void testReadRandom() throws IOException -->Line_28 $$ SlicedInputStream input = new SlicedInputStream(parts) [ CD ]
Line_42 $$ byte[] buffer = new byte[b.length]-->Line_45 $$ assertArrayEquals(b, buffer)[ FD ]
Line_35 $$ for (int i = 0; i < numWriteOps; i++) -->Line_54 $$ for (int i = 0; i < streams.length; i++) [ FD ]
Line_23 $$ for (int i = 0; i < parts; i++) -->Line_35 $$ for (int i = 0; i < numWriteOps; i++) [ FD ]
Line_43 $$ int read = readFully(input, buffer)-->Line_44 $$ assertThat(b.length, equalTo(read))[ FD ]
Line_2 $$ public void testReadRandom() throws IOException -->Line_53 $$ input.close()[ CD ]
Line_2 $$ public void testReadRandom() throws IOException -->Line_54 $$ for (int i = 0; i < streams.length; i++) [ CD ]
Line_23 $$ for (int i = 0; i < parts; i++) -->Line_50 $$ for (int i = 0; i < streams.length - 1; i++) [ FD ]
Line_2 $$ public void testReadRandom() throws IOException -->Line_18 $$ final CheckClosedInputStream[] streams = new CheckClosedInputStream[parts][ CD ]
Line_2 $$ public void testReadRandom() throws IOException -->Line_20 $$ int slice = bytes.length / parts[ CD ]
Line_50 $$ for (int i = 0; i < streams.length - 1; i++) -->Line_51 $$ assertTrue(streams[i].closed)[ CD ]
Line_50 $$ for (int i = 0; i < streams.length - 1; i++) -->Line_54 $$ for (int i = 0; i < streams.length; i++) [ FD ]
Line_2 $$ public void testReadRandom() throws IOException -->Line_22 $$ int length[ CD ]
Line_2 $$ public void testReadRandom() throws IOException -->Line_49 $$ assertThat(input.available(), equalTo(0))[ CD ]
Line_24 $$ length = i == parts - 1 ? bytes.length - offset : slice-->Line_26 $$ offset += length[ FD ]
Line_7 $$ Random random = new Random(seed)-->Line_14 $$ stream.write(randomBytes(random))[ FD ]
Line_8 $$ for (int i = 0; i < numWriteOps; i++) -->Line_54 $$ for (int i = 0; i < streams.length; i++) [ FD ]
Line_3 $$ int parts = randomIntBetween(1, 20)-->Line_23 $$ for (int i = 0; i < parts; i++) [ FD ]
Line_2 $$ public void testReadRandom() throws IOException -->Line_19 $$ byte[] bytes = stream.toByteArray()[ CD ]
Line_7 $$ Random random = new Random(seed)-->Line_41 $$ byte[] b = randomBytes(random)[ FD ]
Line_28 $$ SlicedInputStream input = new SlicedInputStream(parts) -->Line_43 $$ int read = readFully(input, buffer)[ FD ]
Line_2 $$ public void testReadRandom() throws IOException -->Line_7 $$ Random random = new Random(seed)[ CD ]
Line_28 $$ SlicedInputStream input = new SlicedInputStream(parts) -->Line_38 $$ assertThat(random.nextInt(Byte.MAX_VALUE), equalTo(input.read()))[ FD ]
Line_4 $$ ByteArrayOutputStream stream = new ByteArrayOutputStream()-->Line_14 $$ stream.write(randomBytes(random))[ FD ]
Line_28 $$ SlicedInputStream input = new SlicedInputStream(parts) -->Line_34 $$ assertThat(input.available(), equalTo(streams[0].available()))[ FD ]
Line_5 $$ int numWriteOps = scaledRandomIntBetween(1000, 10000)-->Line_8 $$ for (int i = 0; i < numWriteOps; i++) [ FD ]
Line_41 $$ byte[] b = randomBytes(random)-->Line_45 $$ assertArrayEquals(b, buffer)[ FD ]
Line_54 $$ for (int i = 0; i < streams.length; i++) -->Line_55 $$ assertTrue(streams[i].closed)[ CD ]
Line_22 $$ int length-->Line_24 $$ length = i == parts - 1 ? bytes.length - offset : slice[ FD ]
Line_4 $$ ByteArrayOutputStream stream = new ByteArrayOutputStream()-->Line_11 $$ stream.write(random.nextInt(Byte.MAX_VALUE))[ FD ]
Line_23 $$ for (int i = 0; i < parts; i++) -->Line_54 $$ for (int i = 0; i < streams.length; i++) [ FD ]
Line_2 $$ public void testReadRandom() throws IOException -->Line_23 $$ for (int i = 0; i < parts; i++) [ CD ]
