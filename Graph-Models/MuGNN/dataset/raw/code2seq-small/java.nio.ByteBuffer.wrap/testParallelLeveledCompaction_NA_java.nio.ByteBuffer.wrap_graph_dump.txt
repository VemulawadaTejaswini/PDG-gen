Line_22 $$ while (true) -->Line_37 $$ FBUtilities.waitOnFutures(futures)[ CD ]
Line_2 $$ public void testParallelLeveledCompaction() throws Exception -->Line_20 $$ ExecutorService executor = new ThreadPoolExecutor(4, 4, Long.MAX_VALUE, TimeUnit.SECONDS, new LinkedBlockingDeque<Runnable>())[ CD ]
Line_42 $$ for (int level = 0; level < levels; level++) -->Line_47 $$ if (level > 0) [ FD ]
Line_8 $$ LeveledCompactionStrategy lcs = (LeveledCompactionStrategy) store.getCompactionStrategyManager().getStrategies().get(1)-->Line_24 $$ final AbstractCompactionTask nextTask = lcs.getNextBackgroundTask(Integer.MIN_VALUE)[ FD ]
Line_20 $$ ExecutorService executor = new ThreadPoolExecutor(4, 4, Long.MAX_VALUE, TimeUnit.SECONDS, new LinkedBlockingDeque<Runnable>())-->Line_36 $$ futures.add(executor.submit(r))[ FD ]
Line_21 $$ List<Runnable> tasks = new ArrayList<Runnable>()-->Line_33 $$ if (tasks.isEmpty())[ FD ]
Line_24 $$ final AbstractCompactionTask nextTask = lcs.getNextBackgroundTask(Integer.MIN_VALUE)-->Line_25 $$ if (nextTask == null)[ FD ]
Line_12 $$ for (int r = 0; r < rows; r++) -->Line_14 $$ UpdateBuilder builder = UpdateBuilder.create(store.metadata, key)[ CD ]
Line_2 $$ public void testParallelLeveledCompaction() throws Exception -->Line_41 $$ int levels = manifest.getLevelCount()[ CD ]
Line_4 $$ String cfname = "StandardLeveled"-->Line_6 $$ ColumnFamilyStore store = keyspace.getColumnFamilyStore(cfname)[ FD ]
Line_22 $$ while (true) -->Line_38 $$ tasks.clear()[ CD ]
Line_2 $$ public void testParallelLeveledCompaction() throws Exception -->Line_4 $$ String cfname = "StandardLeveled"[ CD ]
Line_43 $$ List<SSTableReader> sstables = manifest.getLevel(level)-->Line_48 $$ Set<SSTableReader> overlaps = LeveledManifest.overlapping(sstable, sstables)[ FD ]
Line_14 $$ UpdateBuilder builder = UpdateBuilder.create(store.metadata, key)-->Line_15 $$ builder.newRow("column" + c).add("val", value)[ FD ]
Line_12 $$ for (int r = 0; r < rows; r++) -->Line_17 $$ rm.apply()[ CD ]
Line_12 $$ for (int r = 0; r < rows; r++) -->Line_13 $$ DecoratedKey key = Util.dk(String.valueOf(r))[ FD ]
Line_48 $$ Set<SSTableReader> overlaps = LeveledManifest.overlapping(sstable, sstables)-->Line_49 $$ assert overlaps.size() == 1 && overlaps.contains(sstable)[ FD ]
Line_3 $$ String ksname = KEYSPACE1-->Line_5 $$ Keyspace keyspace = Keyspace.open(ksname)[ FD ]
Line_9 $$ ByteBuffer value = ByteBuffer.wrap(new byte[100 * 1024])-->Line_15 $$ builder.newRow("column" + c).add("val", value)[ FD ]
Line_47 $$ if (level > 0) -->Line_48 $$ Set<SSTableReader> overlaps = LeveledManifest.overlapping(sstable, sstables)[ CD ]
Line_6 $$ ColumnFamilyStore store = keyspace.getColumnFamilyStore(cfname)-->Line_8 $$ LeveledCompactionStrategy lcs = (LeveledCompactionStrategy) store.getCompactionStrategyManager().getStrategies().get(1)[ FD ]
Line_2 $$ public void testParallelLeveledCompaction() throws Exception -->Line_3 $$ String ksname = KEYSPACE1[ CD ]
Line_2 $$ public void testParallelLeveledCompaction() throws Exception -->Line_12 $$ for (int r = 0; r < rows; r++) [ CD ]
Line_2 $$ public void testParallelLeveledCompaction() throws Exception -->Line_11 $$ int columns = 10[ CD ]
Line_2 $$ public void testParallelLeveledCompaction() throws Exception -->Line_22 $$ while (true) [ CD ]
Line_2 $$ public void testParallelLeveledCompaction() throws Exception -->Line_5 $$ Keyspace keyspace = Keyspace.open(ksname)[ CD ]
Line_22 $$ while (true) -->Line_33 $$ if (tasks.isEmpty())[ CD ]
Line_6 $$ ColumnFamilyStore store = keyspace.getColumnFamilyStore(cfname)-->Line_18 $$ store.forceBlockingFlush()[ FD ]
Line_42 $$ for (int level = 0; level < levels; level++) -->Line_43 $$ List<SSTableReader> sstables = manifest.getLevel(level)[ FD ]
Line_2 $$ public void testParallelLeveledCompaction() throws Exception -->Line_7 $$ store.disableAutoCompaction()[ CD ]
Line_42 $$ for (int level = 0; level < levels; level++) -->Line_44 $$ assert (double) SSTableReader.getTotalBytes(sstables) / LeveledManifest.maxBytesForLevel(level, 1 * 1024 * 1024) < 1.00[ FD ]
Line_22 $$ while (true) -->Line_23 $$ while (true) [ CD ]
Line_23 $$ while (true) -->Line_25 $$ if (nextTask == null)[ CD ]
Line_21 $$ List<Runnable> tasks = new ArrayList<Runnable>()-->Line_27 $$ tasks.add(new Runnable() [ FD ]
Line_2 $$ public void testParallelLeveledCompaction() throws Exception -->Line_9 $$ ByteBuffer value = ByteBuffer.wrap(new byte[100 * 1024])[ CD ]
Line_2 $$ public void testParallelLeveledCompaction() throws Exception -->Line_42 $$ for (int level = 0; level < levels; level++) [ CD ]
Line_12 $$ for (int r = 0; r < rows; r++) -->Line_18 $$ store.forceBlockingFlush()[ CD ]
Line_21 $$ List<Runnable> tasks = new ArrayList<Runnable>()-->Line_35 $$ List<Future<?>> futures = new ArrayList<Future<?>>(tasks.size())[ FD ]
Line_2 $$ public void testParallelLeveledCompaction() throws Exception -->Line_10 $$ int rows = 128[ CD ]
Line_43 $$ List<SSTableReader> sstables = manifest.getLevel(level)-->Line_44 $$ assert (double) SSTableReader.getTotalBytes(sstables) / LeveledManifest.maxBytesForLevel(level, 1 * 1024 * 1024) < 1.00[ FD ]
Line_45 $$ for (SSTableReader sstable : sstables) -->Line_48 $$ Set<SSTableReader> overlaps = LeveledManifest.overlapping(sstable, sstables)[ FD ]
Line_23 $$ while (true) -->Line_24 $$ final AbstractCompactionTask nextTask = lcs.getNextBackgroundTask(Integer.MIN_VALUE)[ CD ]
Line_45 $$ for (SSTableReader sstable : sstables) -->Line_49 $$ assert overlaps.size() == 1 && overlaps.contains(sstable)[ FD ]
Line_2 $$ public void testParallelLeveledCompaction() throws Exception -->Line_8 $$ LeveledCompactionStrategy lcs = (LeveledCompactionStrategy) store.getCompactionStrategyManager().getStrategies().get(1)[ CD ]
Line_45 $$ for (SSTableReader sstable : sstables) -->Line_46 $$ assert level == sstable.getSSTableLevel()[ FD ]
Line_21 $$ List<Runnable> tasks = new ArrayList<Runnable>()-->Line_38 $$ tasks.clear()[ FD ]
Line_6 $$ ColumnFamilyStore store = keyspace.getColumnFamilyStore(cfname)-->Line_7 $$ store.disableAutoCompaction()[ FD ]
Line_13 $$ DecoratedKey key = Util.dk(String.valueOf(r))-->Line_14 $$ UpdateBuilder builder = UpdateBuilder.create(store.metadata, key)[ FD ]
Line_14 $$ UpdateBuilder builder = UpdateBuilder.create(store.metadata, key)-->Line_16 $$ Mutation rm = new Mutation(builder.build())[ FD ]
Line_11 $$ int columns = 10-->Line_15 $$ for (int c = 0; c < columns; c++) builder.newRow("column" + c).add("val", value)[ FD ]
Line_12 $$ for (int r = 0; r < rows; r++) -->Line_15 $$ for (int c = 0; c < columns; c++) builder.newRow("column" + c).add("val", value)[ CD ]
Line_12 $$ for (int r = 0; r < rows; r++) -->Line_13 $$ DecoratedKey key = Util.dk(String.valueOf(r))[ CD ]
Line_2 $$ public void testParallelLeveledCompaction() throws Exception -->Line_6 $$ ColumnFamilyStore store = keyspace.getColumnFamilyStore(cfname)[ CD ]
Line_10 $$ int rows = 128-->Line_12 $$ for (int r = 0; r < rows; r++) [ FD ]
Line_42 $$ for (int level = 0; level < levels; level++) -->Line_43 $$ List<SSTableReader> sstables = manifest.getLevel(level)[ CD ]
Line_12 $$ for (int r = 0; r < rows; r++) -->Line_36 $$ futures.add(executor.submit(r))[ FD ]
Line_2 $$ public void testParallelLeveledCompaction() throws Exception -->Line_21 $$ List<Runnable> tasks = new ArrayList<Runnable>()[ CD ]
Line_5 $$ Keyspace keyspace = Keyspace.open(ksname)-->Line_6 $$ ColumnFamilyStore store = keyspace.getColumnFamilyStore(cfname)[ FD ]
Line_23 $$ while (true) -->Line_27 $$ tasks.add(new Runnable() [ CD ]
Line_24 $$ final AbstractCompactionTask nextTask = lcs.getNextBackgroundTask(Integer.MIN_VALUE)-->Line_29 $$ nextTask.execute(null)[ FD ]
Line_27 $$ tasks.add(new Runnable() -->Line_29 $$ nextTask.execute(null)[ CD ]
