Line_5 $$ final int numIndexThreads = scaledRandomIntBetween(1, 3)-->Line_71 $$ semaphore.release(numIndexThreads)[ FD ]
Line_22 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) -->Line_34 $$ String id = Integer.toString(idGen.getAndIncrement())[ CD ]
Line_9 $$ final Set<String> liveIds = ConcurrentCollections.newConcurrentSet()-->Line_24 $$ do [ FD ]
Line_8 $$ final AtomicInteger idGen = new AtomicInteger(0)-->Line_34 $$ String id = Integer.toString(idGen.getAndIncrement())[ FD ]
Line_23 $$ String id-->Line_31 $$ assertThat(response.getId(), equalTo(id))[ FD ]
Line_12 $$ final Semaphore semaphore = new Semaphore(numIndexThreads, true)-->Line_41 $$ semaphore.release()[ FD ]
Line_14 $$ final Random rand = new Random(getRandom().nextLong())-->Line_22 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) [ FD ]
Line_10 $$ final AtomicBoolean run = new AtomicBoolean(true)-->Line_74 $$ run.set(false)[ FD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_78 $$ assertThat("exceptionHolder should have been empty, but holds: " + exceptionHolder.toString(), exceptionHolder.get(), nullValue())[ CD ]
Line_22 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) -->Line_24 $$ do [ CD ]
Line_23 $$ String id-->Line_30 $$ DeleteResponse response = client().prepareDelete("index", PercolatorService.TYPE_NAME, id).execute().actionGet()[ FD ]
Line_10 $$ final AtomicBoolean run = new AtomicBoolean(true)-->Line_46 $$ run.set(false)[ FD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_12 $$ final Semaphore semaphore = new Semaphore(numIndexThreads, true)[ CD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_6 $$ final int numberPercolateOperation = scaledRandomIntBetween(10, 100)[ CD ]
Line_28 $$ id = Integer.toString(randomInt(idGen.get()))-->Line_31 $$ assertThat(response.getId(), equalTo(id))[ FD ]
Line_5 $$ final int numIndexThreads = scaledRandomIntBetween(1, 3)-->Line_60 $$ semaphore.acquire(numIndexThreads)[ FD ]
Line_22 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) -->Line_30 $$ DeleteResponse response = client().prepareDelete("index", PercolatorService.TYPE_NAME, id).execute().actionGet()[ CD ]
Line_28 $$ id = Integer.toString(randomInt(idGen.get()))-->Line_36 $$ liveIds.add(id)[ FD ]
Line_6 $$ final int numberPercolateOperation = scaledRandomIntBetween(10, 100)-->Line_58 $$ for (int counter = 0; counter < numberPercolateOperation; counter++) [ FD ]
Line_22 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) -->Line_36 $$ liveIds.add(id)[ CD ]
Line_28 $$ id = Integer.toString(randomInt(idGen.get()))-->Line_30 $$ DeleteResponse response = client().prepareDelete("index", PercolatorService.TYPE_NAME, id).execute().actionGet()[ FD ]
Line_28 $$ id = Integer.toString(randomInt(idGen.get()))-->Line_35 $$ IndexResponse response = client().prepareIndex("index", PercolatorService.TYPE_NAME, id).setSource(doc).execute().actionGet()[ FD ]
Line_12 $$ final Semaphore semaphore = new Semaphore(numIndexThreads, true)-->Line_71 $$ semaphore.release(numIndexThreads)[ FD ]
Line_58 $$ for (int counter = 0; counter < numberPercolateOperation; counter++) -->Line_60 $$ semaphore.acquire(numIndexThreads)[ CD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_13 $$ for (int i = 0; i < indexThreads.length; i++) [ CD ]
Line_7 $$ final AtomicReference<Throwable> exceptionHolder = new AtomicReference(null)-->Line_49 $$ exceptionHolder.set(t)[ FD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_5 $$ final int numIndexThreads = scaledRandomIntBetween(1, 3)[ CD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_58 $$ for (int counter = 0; counter < numberPercolateOperation; counter++) [ CD ]
Line_23 $$ String id-->Line_35 $$ IndexResponse response = client().prepareIndex("index", PercolatorService.TYPE_NAME, id).setSource(doc).execute().actionGet()[ FD ]
Line_28 $$ id = Integer.toString(randomInt(idGen.get()))-->Line_38 $$ assertThat(response.getId(), equalTo(id))[ FD ]
Line_28 $$ id = Integer.toString(randomInt(idGen.get()))-->Line_24 $$ do [ FD ]
Line_22 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) -->Line_38 $$ assertThat(response.getId(), equalTo(id))[ CD ]
Line_13 $$ for (int i = 0; i < indexThreads.length; i++) -->Line_15 $$ Runnable r = new Runnable() [ CD ]
Line_22 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) -->Line_23 $$ String id[ CD ]
Line_8 $$ final AtomicInteger idGen = new AtomicInteger(0)-->Line_28 $$ id = Integer.toString(randomInt(idGen.get()))[ FD ]
Line_23 $$ String id-->Line_24 $$ do [ FD ]
Line_65 $$ int atLeastExpected = liveIds.size()-->Line_69 $$ assertThat(response.getMatches().length, equalTo(atLeastExpected))[ FD ]
Line_58 $$ for (int counter = 0; counter < numberPercolateOperation; counter++) -->Line_59 $$ Thread.sleep(5)[ CD ]
Line_13 $$ for (int i = 0; i < indexThreads.length; i++) -->Line_55 $$ indexThreads[i].start()[ CD ]
Line_23 $$ String id-->Line_28 $$ id = Integer.toString(randomInt(idGen.get()))[ FD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_9 $$ final Set<String> liveIds = ConcurrentCollections.newConcurrentSet()[ CD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_74 $$ run.set(false)[ CD ]
Line_19 $$ while (run.get()) -->Line_20 $$ semaphore.acquire()[ CD ]
Line_7 $$ final AtomicReference<Throwable> exceptionHolder = new AtomicReference(null)-->Line_78 $$ assertThat("exceptionHolder should have been empty, but holds: " + exceptionHolder.toString(), exceptionHolder.get(), nullValue())[ FD ]
Line_10 $$ final AtomicBoolean run = new AtomicBoolean(true)-->Line_62 $$ if (!run.get()) [ FD ]
Line_12 $$ final Semaphore semaphore = new Semaphore(numIndexThreads, true)-->Line_60 $$ semaphore.acquire(numIndexThreads)[ FD ]
Line_22 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) -->Line_32 $$ assertThat("doc[" + id + "] should have been deleted, but isn't", response.isFound(), equalTo(true))[ CD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_3 $$ assertAcked(prepareCreate("index").addMapping("type", "field1", "type=string"))[ CD ]
Line_23 $$ String id-->Line_36 $$ liveIds.add(id)[ FD ]
Line_9 $$ final Set<String> liveIds = ConcurrentCollections.newConcurrentSet()-->Line_22 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) [ FD ]
Line_9 $$ final Set<String> liveIds = ConcurrentCollections.newConcurrentSet()-->Line_65 $$ int atLeastExpected = liveIds.size()[ FD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_11 $$ Thread[] indexThreads = new Thread[numIndexThreads][ CD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_7 $$ final AtomicReference<Throwable> exceptionHolder = new AtomicReference(null)[ CD ]
Line_24 $$ do -->Line_25 $$ if (liveIds.isEmpty()) [ CD ]
Line_18 $$ XContentBuilder doc = XContentFactory.jsonBuilder().startObject().field("query", termQuery("field1", "value")).endObject()-->Line_35 $$ IndexResponse response = client().prepareIndex("index", PercolatorService.TYPE_NAME, id).setSource(doc).execute().actionGet()[ FD ]
Line_23 $$ String id-->Line_38 $$ assertThat(response.getId(), equalTo(id))[ FD ]
Line_66 $$ PercolateResponse response = client().preparePercolate().setIndices("index").setDocumentType("type").setSource(percolateDoc).execute().actionGet()-->Line_68 $$ assertThat(response.getSuccessfulShards(), equalTo(response.getTotalShards()))[ FD ]
Line_66 $$ PercolateResponse response = client().preparePercolate().setIndices("index").setDocumentType("type").setSource(percolateDoc).execute().actionGet()-->Line_69 $$ assertThat(response.getMatches().length, equalTo(atLeastExpected))[ FD ]
Line_24 $$ do -->Line_28 $$ id = Integer.toString(randomInt(idGen.get()))[ CD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_10 $$ final AtomicBoolean run = new AtomicBoolean(true)[ CD ]
Line_22 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) -->Line_31 $$ assertThat(response.getId(), equalTo(id))[ CD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_8 $$ final AtomicInteger idGen = new AtomicInteger(0)[ CD ]
Line_22 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) -->Line_35 $$ IndexResponse response = client().prepareIndex("index", PercolatorService.TYPE_NAME, id).setSource(doc).execute().actionGet()[ CD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_57 $$ XContentBuilder percolateDoc = XContentFactory.jsonBuilder().startObject().startObject("doc").field("field1", "value").endObject().endObject()[ CD ]
Line_9 $$ final Set<String> liveIds = ConcurrentCollections.newConcurrentSet()-->Line_36 $$ liveIds.add(id)[ FD ]
Line_13 $$ for (int i = 0; i < indexThreads.length; i++) -->Line_14 $$ final Random rand = new Random(getRandom().nextLong())[ CD ]
Line_2 $$ public void testConcurrentAddingAndRemovingWhilePercolating() throws Exception -->Line_4 $$ ensureGreen()[ CD ]
Line_22 $$ if (!liveIds.isEmpty() && rand.nextInt(100) < 19) -->Line_37 $$ assertThat(response.isCreated(), equalTo(true))[ CD ]
Line_13 $$ for (int i = 0; i < indexThreads.length; i++) -->Line_54 $$ indexThreads[i] = new Thread(r)[ CD ]
Line_10 $$ final AtomicBoolean run = new AtomicBoolean(true)-->Line_48 $$ run.set(false)[ FD ]
Line_12 $$ final Semaphore semaphore = new Semaphore(numIndexThreads, true)-->Line_20 $$ semaphore.acquire()[ FD ]
Line_10 $$ final AtomicBoolean run = new AtomicBoolean(true)-->Line_19 $$ while (run.get()) [ FD ]
Line_66 $$ PercolateResponse response = client().preparePercolate().setIndices("index").setDocumentType("type").setSource(percolateDoc).execute().actionGet()-->Line_67 $$ assertThat(response.getShardFailures(), emptyArray())[ FD ]
Line_9 $$ final Set<String> liveIds = ConcurrentCollections.newConcurrentSet()-->Line_25 $$ if (liveIds.isEmpty()) [ FD ]
