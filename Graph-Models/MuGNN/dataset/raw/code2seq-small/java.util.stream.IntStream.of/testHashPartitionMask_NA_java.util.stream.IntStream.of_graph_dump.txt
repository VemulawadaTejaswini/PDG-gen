Line_8 $$ for (int partition = 0; partition < PARTITION_COUNT; partition++) -->Line_9 $$ Operator operator = operatorFactory.createOperator(createDriverContext())[ CD ]
Line_6 $$ int[] rowPartition = new int[ROW_COUNT]-->Line_7 $$ Arrays.fill(rowPartition, -1)[ FD ]
Line_2 $$ public void testHashPartitionMask(boolean hashEnabled) throws Exception -->Line_24 $$ assertTrue(IntStream.of(rowPartition).noneMatch( partition -> partition == -1))[ CD ]
Line_11 $$ for (int i = 0; i < ROW_COUNT; i++) -->Line_16 $$ expected.row(i, active)[ CD ]
Line_2 $$ public void testHashPartitionMask(boolean hashEnabled) throws Exception -->Line_8 $$ for (int partition = 0; partition < PARTITION_COUNT; partition++) [ CD ]
Line_2 $$ public void testHashPartitionMask(boolean hashEnabled) throws Exception -->Line_4 $$ List<Page> input = rowPagesBuilder.addSequencePage(ROW_COUNT, 0).build()[ CD ]
Line_8 $$ for (int partition = 0; partition < PARTITION_COUNT; partition++) -->Line_19 $$ rowPartition[i] = partition[ FD ]
Line_11 $$ for (int i = 0; i < ROW_COUNT; i++) -->Line_12 $$ int rawHash = (int) BigintOperators.hashCode(i)[ CD ]
Line_9 $$ Operator operator = operatorFactory.createOperator(createDriverContext())-->Line_22 $$ OperatorAssertion.assertOperatorEqualsIgnoreOrder(operator, input, expected.build(), hashEnabled, Optional.of(1))[ FD ]
Line_10 $$ MaterializedResult.Builder expected = resultBuilder(TEST_SESSION, BIGINT, BOOLEAN)-->Line_16 $$ expected.row(i, active)[ FD ]
Line_2 $$ public void testHashPartitionMask(boolean hashEnabled) throws Exception -->Line_22 $$ OperatorAssertion.assertOperatorEqualsIgnoreOrder(operator, input, expected.build(), hashEnabled, Optional.of(1))[ FD ]
Line_5 $$ OperatorFactory operatorFactory = new HashPartitionMaskOperatorFactory(0, PARTITION_COUNT, rowPagesBuilder.getTypes(), ImmutableList.of(), ImmutableList.of(0), rowPagesBuilder.getHashChannel())-->Line_9 $$ Operator operator = operatorFactory.createOperator(createDriverContext())[ FD ]
Line_6 $$ int[] rowPartition = new int[ROW_COUNT]-->Line_24 $$ assertTrue(IntStream.of(rowPartition).noneMatch( partition -> partition == -1))[ FD ]
Line_2 $$ public void testHashPartitionMask(boolean hashEnabled) throws Exception -->Line_5 $$ OperatorFactory operatorFactory = new HashPartitionMaskOperatorFactory(0, PARTITION_COUNT, rowPagesBuilder.getTypes(), ImmutableList.of(), ImmutableList.of(0), rowPagesBuilder.getHashChannel())[ CD ]
Line_11 $$ for (int i = 0; i < ROW_COUNT; i++) -->Line_12 $$ int rawHash = (int) BigintOperators.hashCode(i)[ FD ]
Line_2 $$ public void testHashPartitionMask(boolean hashEnabled) throws Exception -->Line_3 $$ RowPagesBuilder rowPagesBuilder = rowPagesBuilder(hashEnabled, Ints.asList(0), BIGINT)[ CD ]
Line_3 $$ RowPagesBuilder rowPagesBuilder = rowPagesBuilder(hashEnabled, Ints.asList(0), BIGINT)-->Line_4 $$ List<Page> input = rowPagesBuilder.addSequencePage(ROW_COUNT, 0).build()[ FD ]
Line_11 $$ for (int i = 0; i < ROW_COUNT; i++) -->Line_15 $$ boolean active = (rawHash % PARTITION_COUNT == partition)[ CD ]
Line_11 $$ for (int i = 0; i < ROW_COUNT; i++) -->Line_16 $$ expected.row(i, active)[ FD ]
Line_12 $$ int rawHash = (int) BigintOperators.hashCode(i)-->Line_13 $$ rawHash = (int) XxHash64.hash(Integer.reverse(rawHash))[ FD ]
Line_2 $$ public void testHashPartitionMask(boolean hashEnabled) throws Exception -->Line_6 $$ int[] rowPartition = new int[ROW_COUNT][ CD ]
Line_8 $$ for (int partition = 0; partition < PARTITION_COUNT; partition++) -->Line_22 $$ OperatorAssertion.assertOperatorEqualsIgnoreOrder(operator, input, expected.build(), hashEnabled, Optional.of(1))[ CD ]
Line_11 $$ for (int i = 0; i < ROW_COUNT; i++) -->Line_17 $$ if (active) [ CD ]
Line_10 $$ MaterializedResult.Builder expected = resultBuilder(TEST_SESSION, BIGINT, BOOLEAN)-->Line_22 $$ OperatorAssertion.assertOperatorEqualsIgnoreOrder(operator, input, expected.build(), hashEnabled, Optional.of(1))[ FD ]
Line_8 $$ for (int partition = 0; partition < PARTITION_COUNT; partition++) -->Line_11 $$ for (int i = 0; i < ROW_COUNT; i++) [ CD ]
Line_4 $$ List<Page> input = rowPagesBuilder.addSequencePage(ROW_COUNT, 0).build()-->Line_22 $$ OperatorAssertion.assertOperatorEqualsIgnoreOrder(operator, input, expected.build(), hashEnabled, Optional.of(1))[ FD ]
Line_8 $$ for (int partition = 0; partition < PARTITION_COUNT; partition++) -->Line_10 $$ MaterializedResult.Builder expected = resultBuilder(TEST_SESSION, BIGINT, BOOLEAN)[ CD ]
Line_14 $$ rawHash &= Integer.MAX_VALUE-->Line_13 $$ rawHash = (int) XxHash64.hash(Integer.reverse(rawHash))[ FD ]
Line_11 $$ for (int i = 0; i < ROW_COUNT; i++) -->Line_13 $$ rawHash = (int) XxHash64.hash(Integer.reverse(rawHash))[ CD ]
Line_11 $$ for (int i = 0; i < ROW_COUNT; i++) -->Line_14 $$ rawHash &= Integer.MAX_VALUE[ CD ]
Line_3 $$ RowPagesBuilder rowPagesBuilder = rowPagesBuilder(hashEnabled, Ints.asList(0), BIGINT)-->Line_5 $$ OperatorFactory operatorFactory = new HashPartitionMaskOperatorFactory(0, PARTITION_COUNT, rowPagesBuilder.getTypes(), ImmutableList.of(), ImmutableList.of(0), rowPagesBuilder.getHashChannel())[ FD ]
Line_15 $$ boolean active = (rawHash % PARTITION_COUNT == partition)-->Line_16 $$ expected.row(i, active)[ FD ]
Line_2 $$ public void testHashPartitionMask(boolean hashEnabled) throws Exception -->Line_3 $$ RowPagesBuilder rowPagesBuilder = rowPagesBuilder(hashEnabled, Ints.asList(0), BIGINT)[ FD ]
Line_13 $$ rawHash = (int) XxHash64.hash(Integer.reverse(rawHash))-->Line_14 $$ rawHash &= Integer.MAX_VALUE[ FD ]
Line_2 $$ public void testHashPartitionMask(boolean hashEnabled) throws Exception -->Line_7 $$ Arrays.fill(rowPartition, -1)[ CD ]
Line_12 $$ int rawHash = (int) BigintOperators.hashCode(i)-->Line_14 $$ rawHash &= Integer.MAX_VALUE[ FD ]
Line_17 $$ if (active) -->Line_18 $$ assertEquals(rowPartition[i], -1)[ CD ]
Line_17 $$ if (active) -->Line_19 $$ rowPartition[i] = partition[ CD ]
