Line_14 $$ for (int i = 0; i < N_EVENTS; i++) -->Line_15 $$ SwingUtilities.invokeLater(() -> [ CD ]
Line_5 $$ final AtomicInteger jobsStarted = new AtomicInteger()-->Line_10 $$ jobsStarted.incrementAndGet()[ FD ]
Line_5 $$ final AtomicInteger jobsStarted = new AtomicInteger()-->Line_16 $$ int jobs0 = jobsStarted.get()[ FD ]
Line_2 $$ public void testDaemonDoesNotPauseWhenEventDispatcherHasEventsInTheQueue() throws Throwable -->Line_30 $$ while (!job.isDone()) [ CD ]
Line_9 $$ Job<Void> job = JobLauncher.getInstance().submitToJobThread(() -> JobLauncher.getInstance().invokeConcurrentlyUnderProgress(Collections.nCopies(N_JOBS, null), indicator, false,  o -> -->Line_29 $$ job.cancel()[ FD ]
Line_2 $$ public void testDaemonDoesNotPauseWhenEventDispatcherHasEventsInTheQueue() throws Throwable -->Line_4 $$ PlatformTestUtil.dispatchAllInvocationEventsInIdeEventQueue()[ CD ]
Line_2 $$ public void testDaemonDoesNotPauseWhenEventDispatcherHasEventsInTheQueue() throws Throwable -->Line_8 $$ ProgressIndicator indicator = new DaemonProgressIndicator()[ CD ]
Line_2 $$ public void testDaemonDoesNotPauseWhenEventDispatcherHasEventsInTheQueue() throws Throwable -->Line_7 $$ final int N_JOBS = 10000 * JobSchedulerImpl.CORES_COUNT[ CD ]
Line_6 $$ final int N_EVENTS = 50-->Line_14 $$ for (int i = 0; i < N_EVENTS; i++) [ FD ]
Line_2 $$ public void testDaemonDoesNotPauseWhenEventDispatcherHasEventsInTheQueue() throws Throwable -->Line_28 $$ indicator.cancel()[ CD ]
Line_2 $$ public void testDaemonDoesNotPauseWhenEventDispatcherHasEventsInTheQueue() throws Throwable -->Line_9 $$ Job<Void> job = JobLauncher.getInstance().submitToJobThread(() -> JobLauncher.getInstance().invokeConcurrentlyUnderProgress(Collections.nCopies(N_JOBS, null), indicator, false,  o -> [ CD ]
Line_2 $$ public void testDaemonDoesNotPauseWhenEventDispatcherHasEventsInTheQueue() throws Throwable -->Line_29 $$ job.cancel()[ CD ]
Line_9 $$ Job<Void> job = JobLauncher.getInstance().submitToJobThread(() -> JobLauncher.getInstance().invokeConcurrentlyUnderProgress(Collections.nCopies(N_JOBS, null), indicator, false,  o -> -->Line_32 $$ job.waitForCompletion(1000)[ FD ]
Line_8 $$ ProgressIndicator indicator = new DaemonProgressIndicator()-->Line_28 $$ indicator.cancel()[ FD ]
Line_9 $$ Job<Void> job = JobLauncher.getInstance().submitToJobThread(() -> JobLauncher.getInstance().invokeConcurrentlyUnderProgress(Collections.nCopies(N_JOBS, null), indicator, false,  o -> -->Line_30 $$ while (!job.isDone()) [ FD ]
Line_2 $$ public void testDaemonDoesNotPauseWhenEventDispatcherHasEventsInTheQueue() throws Throwable -->Line_3 $$ assertTrue(SwingUtilities.isEventDispatchThread())[ CD ]
Line_19 $$ if (System.currentTimeMillis() > start + 10000) -->Line_21 $$ fail()[ CD ]
Line_2 $$ public void testDaemonDoesNotPauseWhenEventDispatcherHasEventsInTheQueue() throws Throwable -->Line_14 $$ for (int i = 0; i < N_EVENTS; i++) [ CD ]
Line_2 $$ public void testDaemonDoesNotPauseWhenEventDispatcherHasEventsInTheQueue() throws Throwable -->Line_5 $$ final AtomicInteger jobsStarted = new AtomicInteger()[ CD ]
Line_5 $$ final AtomicInteger jobsStarted = new AtomicInteger()-->Line_18 $$ while (jobsStarted.get() < jobs0 + JobSchedulerImpl.CORES_COUNT && jobsStarted.get() < N_JOBS) [ FD ]
Line_7 $$ final int N_JOBS = 10000 * JobSchedulerImpl.CORES_COUNT-->Line_9 $$ JobLauncher.getInstance().invokeConcurrentlyUnderProgress(Collections.nCopies(N_JOBS, null), indicator, false,  o -> [ FD ]
Line_2 $$ public void testDaemonDoesNotPauseWhenEventDispatcherHasEventsInTheQueue() throws Throwable -->Line_6 $$ final int N_EVENTS = 50[ CD ]
Line_14 $$ for (int i = 0; i < N_EVENTS; i++) -->Line_26 $$ UIUtil.dispatchAllInvocationEvents()[ CD ]
Line_19 $$ if (System.currentTimeMillis() > start + 10000) -->Line_20 $$ System.err.println(ThreadDumper.dumpThreadsToString())[ CD ]
Line_18 $$ while (jobsStarted.get() < jobs0 + JobSchedulerImpl.CORES_COUNT && jobsStarted.get() < N_JOBS) -->Line_19 $$ if (System.currentTimeMillis() > start + 10000) [ CD ]
Line_8 $$ ProgressIndicator indicator = new DaemonProgressIndicator()-->Line_9 $$ JobLauncher.getInstance().invokeConcurrentlyUnderProgress(Collections.nCopies(N_JOBS, null), indicator, false,  o -> [ FD ]
