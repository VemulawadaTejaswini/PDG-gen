Line_35 $$ sepLen = 0-->Line_45 $$ sepLen = curSep > 0 ? findSeparatorLength(decoded, curSep) : 0[ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_34 $$ curSep = curSep == wsHead ? curSep + sepLen : wsHead[ CD ]
Line_6 $$ TextRange valueRange-->Line_10 $$ valueRange = ElementManipulators.getValueTextRange(myElement)[ FD ]
Line_5 $$ LiteralTextEscaper<? extends PsiLanguageInjectionHost> escaper-->Line_16 $$ escaper = null[ FD ]
Line_8 $$ if (myElement instanceof PsiLanguageInjectionHost && !StringUtil.startsWith(myElement.getText(), startInElement, str)) -->Line_12 $$ escaper.decode(valueRange, sb)[ CD ]
Line_9 $$ escaper = ((PsiLanguageInjectionHost) myElement).createLiteralTextEscaper()-->Line_12 $$ escaper.decode(valueRange, sb)[ FD ]
Line_6 $$ TextRange valueRange-->Line_14 $$ wsHead += Math.max(0, startInElement - valueRange.getStartOffset())[ FD ]
Line_13 $$ decoded = sb-->Line_24 $$ for (int i = decoded.length() - 1; i >= 0 && Character.isWhitespace(decoded.charAt(i)); i--) [ FD ]
Line_28 $$ int curSep = findSeparatorOffset(decoded, wsHead)-->Line_45 $$ sepLen = curSep > 0 ? findSeparatorLength(decoded, curSep) : 0[ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_47 $$ return referencesList[ CD ]
Line_24 $$ for (int i = decoded.length() - 1; i >= 0 && Character.isWhitespace(decoded.charAt(i)); i--) -->Line_25 $$ wsTail++[ CD ]
Line_8 $$ if (myElement instanceof PsiLanguageInjectionHost && !StringUtil.startsWith(myElement.getText(), startInElement, str)) -->Line_11 $$ StringBuilder sb = new StringBuilder()[ CD ]
Line_16 $$ escaper = null-->Line_42 $$ TextRange r = new TextRange(offset(start, escaper, valueRange), offset(endInclusive, escaper, valueRange) + (nextSep < 0 && refText.length() > 0 ? 1 : 0))[ FD ]
Line_31 $$ TextRange r = TextRange.create(startInElement, offset(curSep + Math.max(0, sepLen - 1), escaper, valueRange) + 1)-->Line_43 $$ referencesList.add(createFileReference(r, index++, refText))[ FD ]
Line_16 $$ escaper = null-->Line_31 $$ TextRange r = TextRange.create(startInElement, offset(curSep + Math.max(0, sepLen - 1), escaper, valueRange) + 1)[ FD ]
Line_28 $$ int curSep = findSeparatorOffset(decoded, wsHead)-->Line_29 $$ int sepLen = curSep >= wsHead ? findSeparatorLength(decoded, curSep) : 0[ FD ]
Line_13 $$ decoded = sb-->Line_18 $$ valueRange = TextRange.from(startInElement, decoded.length())[ FD ]
Line_5 $$ LiteralTextEscaper<? extends PsiLanguageInjectionHost> escaper-->Line_31 $$ TextRange r = TextRange.create(startInElement, offset(curSep + Math.max(0, sepLen - 1), escaper, valueRange) + 1)[ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_17 $$ decoded = str[ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_27 $$ int index = 0[ CD ]
Line_11 $$ StringBuilder sb = new StringBuilder()-->Line_12 $$ escaper.decode(valueRange, sb)[ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_28 $$ int curSep = findSeparatorOffset(decoded, wsHead)[ CD ]
Line_6 $$ TextRange valueRange-->Line_12 $$ escaper.decode(valueRange, sb)[ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_18 $$ valueRange = TextRange.from(startInElement, decoded.length())[ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_36 $$ while (curSep >= 0) [ CD ]
Line_17 $$ decoded = str-->Line_45 $$ sepLen = curSep > 0 ? findSeparatorLength(decoded, curSep) : 0[ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_30 $$ if (curSep >= 0 && decoded.length() == wsHead + sepLen + wsTail) [ CD ]
Line_5 $$ LiteralTextEscaper<? extends PsiLanguageInjectionHost> escaper-->Line_9 $$ escaper = ((PsiLanguageInjectionHost) myElement).createLiteralTextEscaper()[ FD ]
Line_40 $$ int endInclusive = nextSep > 0 ? nextSep : Math.max(start, decoded.length() - 1 - wsTail)-->Line_42 $$ TextRange r = new TextRange(offset(start, escaper, valueRange), offset(endInclusive, escaper, valueRange) + (nextSep < 0 && refText.length() > 0 ? 1 : 0))[ FD ]
Line_17 $$ decoded = str-->Line_18 $$ valueRange = TextRange.from(startInElement, decoded.length())[ FD ]
Line_8 $$ if (myElement instanceof PsiLanguageInjectionHost && !StringUtil.startsWith(myElement.getText(), startInElement, str)) -->Line_13 $$ decoded = sb[ CD ]
Line_17 $$ decoded = str-->Line_24 $$ for (int i = decoded.length() - 1; i >= 0 && Character.isWhitespace(decoded.charAt(i)); i--) [ FD ]
Line_8 $$ if (myElement instanceof PsiLanguageInjectionHost && !StringUtil.startsWith(myElement.getText(), startInElement, str)) -->Line_16 $$ escaper = null[ CD ]
Line_36 $$ while (curSep >= 0) -->Line_42 $$ TextRange r = new TextRange(offset(start, escaper, valueRange), offset(endInclusive, escaper, valueRange) + (nextSep < 0 && refText.length() > 0 ? 1 : 0))[ CD ]
Line_10 $$ valueRange = ElementManipulators.getValueTextRange(myElement)-->Line_42 $$ TextRange r = new TextRange(offset(start, escaper, valueRange), offset(endInclusive, escaper, valueRange) + (nextSep < 0 && refText.length() > 0 ? 1 : 0))[ FD ]
Line_7 $$ CharSequence decoded-->Line_28 $$ int curSep = findSeparatorOffset(decoded, wsHead)[ FD ]
Line_7 $$ CharSequence decoded-->Line_39 $$ int endTrimmed = nextSep > 0 ? nextSep : Math.max(start, decoded.length() - wsTail)[ FD ]
Line_20 $$ List<FileReference> referencesList = ContainerUtil.newArrayList()-->Line_43 $$ referencesList.add(createFileReference(r, index++, refText))[ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_21 $$ for (int i = wsHead; i < decoded.length() && Character.isWhitespace(decoded.charAt(i)); i++) [ CD ]
Line_38 $$ int start = curSep + sepLen-->Line_40 $$ int endInclusive = nextSep > 0 ? nextSep : Math.max(start, decoded.length() - 1 - wsTail)[ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_8 $$ if (myElement instanceof PsiLanguageInjectionHost && !StringUtil.startsWith(myElement.getText(), startInElement, str)) [ CD ]
Line_9 $$ escaper = ((PsiLanguageInjectionHost) myElement).createLiteralTextEscaper()-->Line_31 $$ TextRange r = TextRange.create(startInElement, offset(curSep + Math.max(0, sepLen - 1), escaper, valueRange) + 1)[ FD ]
Line_28 $$ int curSep = findSeparatorOffset(decoded, wsHead)-->Line_32 $$ referencesList.add(createFileReference(r, index++, decoded.subSequence(curSep, curSep + sepLen).toString()))[ FD ]
Line_6 $$ TextRange valueRange-->Line_42 $$ TextRange r = new TextRange(offset(start, escaper, valueRange), offset(endInclusive, escaper, valueRange) + (nextSep < 0 && refText.length() > 0 ? 1 : 0))[ FD ]
Line_14 $$ wsHead += Math.max(0, startInElement - valueRange.getStartOffset())-->Line_28 $$ int curSep = findSeparatorOffset(decoded, wsHead)[ FD ]
Line_5 $$ LiteralTextEscaper<? extends PsiLanguageInjectionHost> escaper-->Line_42 $$ TextRange r = new TextRange(offset(start, escaper, valueRange), offset(endInclusive, escaper, valueRange) + (nextSep < 0 && refText.length() > 0 ? 1 : 0))[ FD ]
Line_20 $$ List<FileReference> referencesList = ContainerUtil.newArrayList()-->Line_32 $$ referencesList.add(createFileReference(r, index++, decoded.subSequence(curSep, curSep + sepLen).toString()))[ FD ]
Line_36 $$ while (curSep >= 0) -->Line_41 $$ String refText = index == 0 && nextSep < 0 && !StringUtil.contains(decoded, str) ? str : decoded.subSequence(start, endTrimmed).toString()[ CD ]
Line_21 $$ for (int i = wsHead; i < decoded.length() && Character.isWhitespace(decoded.charAt(i)); i++) -->Line_22 $$ wsHead++[ CD ]
Line_17 $$ decoded = str-->Line_37 $$ int nextSep = findSeparatorOffset(decoded, curSep + sepLen)[ FD ]
Line_30 $$ if (curSep >= 0 && decoded.length() == wsHead + sepLen + wsTail) -->Line_31 $$ TextRange r = TextRange.create(startInElement, offset(curSep + Math.max(0, sepLen - 1), escaper, valueRange) + 1)[ CD ]
Line_7 $$ CharSequence decoded-->Line_37 $$ int nextSep = findSeparatorOffset(decoded, curSep + sepLen)[ FD ]
Line_3 $$ int wsHead = 0-->Line_22 $$ wsHead++[ FD ]
Line_13 $$ decoded = sb-->Line_45 $$ sepLen = curSep > 0 ? findSeparatorLength(decoded, curSep) : 0[ FD ]
Line_8 $$ if (myElement instanceof PsiLanguageInjectionHost && !StringUtil.startsWith(myElement.getText(), startInElement, str)) -->Line_14 $$ wsHead += Math.max(0, startInElement - valueRange.getStartOffset())[ CD ]
Line_38 $$ int start = curSep + sepLen-->Line_39 $$ int endTrimmed = nextSep > 0 ? nextSep : Math.max(start, decoded.length() - wsTail)[ FD ]
Line_27 $$ int index = 0-->Line_32 $$ referencesList.add(createFileReference(r, index++, decoded.subSequence(curSep, curSep + sepLen).toString()))[ FD ]
Line_44 $$ curSep = nextSep-->Line_36 $$ while (curSep >= 0) [ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_3 $$ int wsHead = 0[ CD ]
Line_34 $$ curSep = curSep == wsHead ? curSep + sepLen : wsHead-->Line_44 $$ curSep = nextSep[ FD ]
Line_7 $$ CharSequence decoded-->Line_17 $$ decoded = str[ FD ]
Line_28 $$ int curSep = findSeparatorOffset(decoded, wsHead)-->Line_34 $$ curSep = curSep == wsHead ? curSep + sepLen : wsHead[ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_31 $$ TextRange r = TextRange.create(startInElement, offset(curSep + Math.max(0, sepLen - 1), escaper, valueRange) + 1)[ FD ]
Line_10 $$ valueRange = ElementManipulators.getValueTextRange(myElement)-->Line_31 $$ TextRange r = TextRange.create(startInElement, offset(curSep + Math.max(0, sepLen - 1), escaper, valueRange) + 1)[ FD ]
Line_7 $$ CharSequence decoded-->Line_40 $$ int endInclusive = nextSep > 0 ? nextSep : Math.max(start, decoded.length() - 1 - wsTail)[ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_35 $$ sepLen = 0[ CD ]
Line_38 $$ int start = curSep + sepLen-->Line_42 $$ TextRange r = new TextRange(offset(start, escaper, valueRange), offset(endInclusive, escaper, valueRange) + (nextSep < 0 && refText.length() > 0 ? 1 : 0))[ FD ]
Line_10 $$ valueRange = ElementManipulators.getValueTextRange(myElement)-->Line_18 $$ valueRange = TextRange.from(startInElement, decoded.length())[ FD ]
Line_44 $$ curSep = nextSep-->Line_45 $$ sepLen = curSep > 0 ? findSeparatorLength(decoded, curSep) : 0[ FD ]
Line_17 $$ decoded = str-->Line_21 $$ for (int i = wsHead; i < decoded.length() && Character.isWhitespace(decoded.charAt(i)); i++) [ FD ]
Line_31 $$ TextRange r = TextRange.create(startInElement, offset(curSep + Math.max(0, sepLen - 1), escaper, valueRange) + 1)-->Line_32 $$ referencesList.add(createFileReference(r, index++, decoded.subSequence(curSep, curSep + sepLen).toString()))[ FD ]
Line_29 $$ int sepLen = curSep >= wsHead ? findSeparatorLength(decoded, curSep) : 0-->Line_45 $$ sepLen = curSep > 0 ? findSeparatorLength(decoded, curSep) : 0[ FD ]
Line_17 $$ decoded = str-->Line_40 $$ int endInclusive = nextSep > 0 ? nextSep : Math.max(start, decoded.length() - 1 - wsTail)[ FD ]
Line_13 $$ decoded = sb-->Line_41 $$ String refText = index == 0 && nextSep < 0 && !StringUtil.contains(decoded, str) ? str : decoded.subSequence(start, endTrimmed).toString()[ FD ]
Line_8 $$ if (myElement instanceof PsiLanguageInjectionHost && !StringUtil.startsWith(myElement.getText(), startInElement, str)) -->Line_10 $$ valueRange = ElementManipulators.getValueTextRange(myElement)[ CD ]
Line_41 $$ String refText = index == 0 && nextSep < 0 && !StringUtil.contains(decoded, str) ? str : decoded.subSequence(start, endTrimmed).toString()-->Line_43 $$ referencesList.add(createFileReference(r, index++, refText))[ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_8 $$ if (myElement instanceof PsiLanguageInjectionHost && !StringUtil.startsWith(myElement.getText(), startInElement, str)) [ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_7 $$ CharSequence decoded[ CD ]
Line_18 $$ valueRange = TextRange.from(startInElement, decoded.length())-->Line_42 $$ TextRange r = new TextRange(offset(start, escaper, valueRange), offset(endInclusive, escaper, valueRange) + (nextSep < 0 && refText.length() > 0 ? 1 : 0))[ FD ]
Line_14 $$ wsHead += Math.max(0, startInElement - valueRange.getStartOffset())-->Line_22 $$ wsHead++[ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_29 $$ int sepLen = curSep >= wsHead ? findSeparatorLength(decoded, curSep) : 0[ CD ]
Line_10 $$ valueRange = ElementManipulators.getValueTextRange(myElement)-->Line_12 $$ escaper.decode(valueRange, sb)[ FD ]
Line_17 $$ decoded = str-->Line_30 $$ if (curSep >= 0 && decoded.length() == wsHead + sepLen + wsTail) [ FD ]
Line_17 $$ decoded = str-->Line_29 $$ int sepLen = curSep >= wsHead ? findSeparatorLength(decoded, curSep) : 0[ FD ]
Line_34 $$ curSep = curSep == wsHead ? curSep + sepLen : wsHead-->Line_36 $$ while (curSep >= 0) [ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_6 $$ TextRange valueRange[ CD ]
Line_10 $$ valueRange = ElementManipulators.getValueTextRange(myElement)-->Line_14 $$ wsHead += Math.max(0, startInElement - valueRange.getStartOffset())[ FD ]
Line_13 $$ decoded = sb-->Line_17 $$ decoded = str[ FD ]
Line_36 $$ while (curSep >= 0) -->Line_40 $$ int endInclusive = nextSep > 0 ? nextSep : Math.max(start, decoded.length() - 1 - wsTail)[ CD ]
Line_30 $$ if (curSep >= 0 && decoded.length() == wsHead + sepLen + wsTail) -->Line_32 $$ referencesList.add(createFileReference(r, index++, decoded.subSequence(curSep, curSep + sepLen).toString()))[ CD ]
Line_13 $$ decoded = sb-->Line_37 $$ int nextSep = findSeparatorOffset(decoded, curSep + sepLen)[ FD ]
Line_13 $$ decoded = sb-->Line_39 $$ int endTrimmed = nextSep > 0 ? nextSep : Math.max(start, decoded.length() - wsTail)[ FD ]
Line_4 $$ int wsTail = 0-->Line_25 $$ wsTail++[ FD ]
Line_8 $$ if (myElement instanceof PsiLanguageInjectionHost && !StringUtil.startsWith(myElement.getText(), startInElement, str)) -->Line_17 $$ decoded = str[ CD ]
Line_9 $$ escaper = ((PsiLanguageInjectionHost) myElement).createLiteralTextEscaper()-->Line_42 $$ TextRange r = new TextRange(offset(start, escaper, valueRange), offset(endInclusive, escaper, valueRange) + (nextSep < 0 && refText.length() > 0 ? 1 : 0))[ FD ]
Line_28 $$ int curSep = findSeparatorOffset(decoded, wsHead)-->Line_36 $$ while (curSep >= 0) [ FD ]
Line_13 $$ decoded = sb-->Line_28 $$ int curSep = findSeparatorOffset(decoded, wsHead)[ FD ]
Line_7 $$ CharSequence decoded-->Line_13 $$ decoded = sb[ FD ]
Line_36 $$ while (curSep >= 0) -->Line_43 $$ referencesList.add(createFileReference(r, index++, refText))[ CD ]
Line_7 $$ CharSequence decoded-->Line_18 $$ valueRange = TextRange.from(startInElement, decoded.length())[ FD ]
Line_5 $$ LiteralTextEscaper<? extends PsiLanguageInjectionHost> escaper-->Line_12 $$ escaper.decode(valueRange, sb)[ FD ]
Line_36 $$ while (curSep >= 0) -->Line_38 $$ int start = curSep + sepLen[ CD ]
Line_36 $$ while (curSep >= 0) -->Line_44 $$ curSep = nextSep[ CD ]
Line_7 $$ CharSequence decoded-->Line_29 $$ int sepLen = curSep >= wsHead ? findSeparatorLength(decoded, curSep) : 0[ FD ]
Line_7 $$ CharSequence decoded-->Line_41 $$ String refText = index == 0 && nextSep < 0 && !StringUtil.contains(decoded, str) ? str : decoded.subSequence(start, endTrimmed).toString()[ FD ]
Line_3 $$ int wsHead = 0-->Line_14 $$ wsHead += Math.max(0, startInElement - valueRange.getStartOffset())[ FD ]
Line_18 $$ valueRange = TextRange.from(startInElement, decoded.length())-->Line_31 $$ TextRange r = TextRange.create(startInElement, offset(curSep + Math.max(0, sepLen - 1), escaper, valueRange) + 1)[ FD ]
Line_41 $$ String refText = index == 0 && nextSep < 0 && !StringUtil.contains(decoded, str) ? str : decoded.subSequence(start, endTrimmed).toString()-->Line_42 $$ TextRange r = new TextRange(offset(start, escaper, valueRange), offset(endInclusive, escaper, valueRange) + (nextSep < 0 && refText.length() > 0 ? 1 : 0))[ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_24 $$ for (int i = decoded.length() - 1; i >= 0 && Character.isWhitespace(decoded.charAt(i)); i--) [ CD ]
Line_13 $$ decoded = sb-->Line_30 $$ if (curSep >= 0 && decoded.length() == wsHead + sepLen + wsTail) [ FD ]
Line_9 $$ escaper = ((PsiLanguageInjectionHost) myElement).createLiteralTextEscaper()-->Line_16 $$ escaper = null[ FD ]
Line_6 $$ TextRange valueRange-->Line_18 $$ valueRange = TextRange.from(startInElement, decoded.length())[ FD ]
Line_11 $$ StringBuilder sb = new StringBuilder()-->Line_13 $$ decoded = sb[ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_5 $$ LiteralTextEscaper<? extends PsiLanguageInjectionHost> escaper[ CD ]
Line_17 $$ decoded = str-->Line_41 $$ String refText = index == 0 && nextSep < 0 && !StringUtil.contains(decoded, str) ? str : decoded.subSequence(start, endTrimmed).toString()[ FD ]
Line_7 $$ CharSequence decoded-->Line_32 $$ referencesList.add(createFileReference(r, index++, decoded.subSequence(curSep, curSep + sepLen).toString()))[ FD ]
Line_36 $$ while (curSep >= 0) -->Line_37 $$ int nextSep = findSeparatorOffset(decoded, curSep + sepLen)[ CD ]
Line_8 $$ if (myElement instanceof PsiLanguageInjectionHost && !StringUtil.startsWith(myElement.getText(), startInElement, str)) -->Line_9 $$ escaper = ((PsiLanguageInjectionHost) myElement).createLiteralTextEscaper()[ CD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_4 $$ int wsTail = 0[ CD ]
Line_8 $$ if (myElement instanceof PsiLanguageInjectionHost && !StringUtil.startsWith(myElement.getText(), startInElement, str)) -->Line_18 $$ valueRange = TextRange.from(startInElement, decoded.length())[ CD ]
Line_7 $$ CharSequence decoded-->Line_24 $$ for (int i = decoded.length() - 1; i >= 0 && Character.isWhitespace(decoded.charAt(i)); i--) [ FD ]
Line_7 $$ CharSequence decoded-->Line_45 $$ sepLen = curSep > 0 ? findSeparatorLength(decoded, curSep) : 0[ FD ]
Line_6 $$ TextRange valueRange-->Line_31 $$ TextRange r = TextRange.create(startInElement, offset(curSep + Math.max(0, sepLen - 1), escaper, valueRange) + 1)[ FD ]
Line_36 $$ while (curSep >= 0) -->Line_45 $$ sepLen = curSep > 0 ? findSeparatorLength(decoded, curSep) : 0[ CD ]
Line_38 $$ int start = curSep + sepLen-->Line_41 $$ String refText = index == 0 && nextSep < 0 && !StringUtil.contains(decoded, str) ? str : decoded.subSequence(start, endTrimmed).toString()[ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_41 $$ String refText = index == 0 && nextSep < 0 && !StringUtil.contains(decoded, str) ? str : decoded.subSequence(start, endTrimmed).toString()[ FD ]
Line_2 $$ protected List<FileReference> reparse(String str, int startInElement) -->Line_20 $$ List<FileReference> referencesList = ContainerUtil.newArrayList()[ CD ]
Line_27 $$ int index = 0-->Line_43 $$ referencesList.add(createFileReference(r, index++, refText))[ FD ]
Line_7 $$ CharSequence decoded-->Line_21 $$ for (int i = wsHead; i < decoded.length() && Character.isWhitespace(decoded.charAt(i)); i++) [ FD ]
Line_17 $$ decoded = str-->Line_39 $$ int endTrimmed = nextSep > 0 ? nextSep : Math.max(start, decoded.length() - wsTail)[ FD ]
Line_34 $$ curSep = curSep == wsHead ? curSep + sepLen : wsHead-->Line_45 $$ sepLen = curSep > 0 ? findSeparatorLength(decoded, curSep) : 0[ FD ]
Line_17 $$ decoded = str-->Line_32 $$ referencesList.add(createFileReference(r, index++, decoded.subSequence(curSep, curSep + sepLen).toString()))[ FD ]
Line_28 $$ int curSep = findSeparatorOffset(decoded, wsHead)-->Line_44 $$ curSep = nextSep[ FD ]
Line_7 $$ CharSequence decoded-->Line_30 $$ if (curSep >= 0 && decoded.length() == wsHead + sepLen + wsTail) [ FD ]
Line_36 $$ while (curSep >= 0) -->Line_39 $$ int endTrimmed = nextSep > 0 ? nextSep : Math.max(start, decoded.length() - wsTail)[ CD ]
Line_17 $$ decoded = str-->Line_28 $$ int curSep = findSeparatorOffset(decoded, wsHead)[ FD ]
Line_13 $$ decoded = sb-->Line_29 $$ int sepLen = curSep >= wsHead ? findSeparatorLength(decoded, curSep) : 0[ FD ]
Line_42 $$ TextRange r = new TextRange(offset(start, escaper, valueRange), offset(endInclusive, escaper, valueRange) + (nextSep < 0 && refText.length() > 0 ? 1 : 0))-->Line_43 $$ referencesList.add(createFileReference(r, index++, refText))[ FD ]
Line_39 $$ int endTrimmed = nextSep > 0 ? nextSep : Math.max(start, decoded.length() - wsTail)-->Line_41 $$ String refText = index == 0 && nextSep < 0 && !StringUtil.contains(decoded, str) ? str : decoded.subSequence(start, endTrimmed).toString()[ FD ]
Line_13 $$ decoded = sb-->Line_21 $$ for (int i = wsHead; i < decoded.length() && Character.isWhitespace(decoded.charAt(i)); i++) [ FD ]
Line_3 $$ int wsHead = 0-->Line_28 $$ int curSep = findSeparatorOffset(decoded, wsHead)[ FD ]
Line_13 $$ decoded = sb-->Line_40 $$ int endInclusive = nextSep > 0 ? nextSep : Math.max(start, decoded.length() - 1 - wsTail)[ FD ]
Line_29 $$ int sepLen = curSep >= wsHead ? findSeparatorLength(decoded, curSep) : 0-->Line_35 $$ sepLen = 0[ FD ]
Line_37 $$ int nextSep = findSeparatorOffset(decoded, curSep + sepLen)-->Line_44 $$ curSep = nextSep[ FD ]
Line_13 $$ decoded = sb-->Line_32 $$ referencesList.add(createFileReference(r, index++, decoded.subSequence(curSep, curSep + sepLen).toString()))[ FD ]
Line_21 $$ for (int i = wsHead; i < decoded.length() && Character.isWhitespace(decoded.charAt(i)); i++) -->Line_24 $$ for (int i = decoded.length() - 1; i >= 0 && Character.isWhitespace(decoded.charAt(i)); i--) [ FD ]
