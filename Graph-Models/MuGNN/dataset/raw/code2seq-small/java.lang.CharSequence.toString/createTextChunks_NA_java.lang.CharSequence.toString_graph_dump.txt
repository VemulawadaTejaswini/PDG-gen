Line_21 $$ hiStart = Math.max(hiStart, start)-->Line_34 $$ processIntersectingRange(usageInfo2UsageAdapter, chars, hiStart, hiEnd, tokenHighlights, selectUsageWithBold, result)[ FD ]
Line_2 $$ public TextChunk[] createTextChunks(@NotNull UsageInfo2UsageAdapter usageInfo2UsageAdapter, @NotNull CharSequence chars, int start, int end, boolean selectUsageWithBold, @NotNull List<TextChunk> result) -->Line_7 $$ if (i != -1)[ CD ]
Line_16 $$ for (; lexer.getTokenType() != null; lexer.advance()) -->Line_34 $$ processIntersectingRange(usageInfo2UsageAdapter, chars, hiStart, hiEnd, tokenHighlights, selectUsageWithBold, result)[ CD ]
Line_8 $$ end = i-->Line_19 $$ if (hiStart >= end)[ FD ]
Line_18 $$ int hiEnd = lexer.getTokenEnd()-->Line_22 $$ hiEnd = Math.min(hiEnd, end)[ FD ]
Line_17 $$ int hiStart = lexer.getTokenStart()-->Line_21 $$ hiStart = Math.max(hiStart, start)[ FD ]
Line_2 $$ public TextChunk[] createTextChunks(@NotNull UsageInfo2UsageAdapter usageInfo2UsageAdapter, @NotNull CharSequence chars, int start, int end, boolean selectUsageWithBold, @NotNull List<TextChunk> result) -->Line_27 $$ String text = chars.subSequence(hiStart, hiEnd).toString()[ FD ]
Line_17 $$ int hiStart = lexer.getTokenStart()-->Line_19 $$ if (hiStart >= end)[ FD ]
Line_22 $$ hiEnd = Math.min(hiEnd, end)-->Line_27 $$ String text = chars.subSequence(hiStart, hiEnd).toString()[ FD ]
Line_2 $$ public TextChunk[] createTextChunks(@NotNull UsageInfo2UsageAdapter usageInfo2UsageAdapter, @NotNull CharSequence chars, int start, int end, boolean selectUsageWithBold, @NotNull List<TextChunk> result) -->Line_36 $$ return result.toArray(new TextChunk[result.size()])[ CD ]
Line_16 $$ for (; lexer.getTokenType() != null; lexer.advance()) -->Line_17 $$ int hiStart = lexer.getTokenStart()[ CD ]
Line_3 $$ final Lexer lexer = myHighlighter.getHighlightingLexer()-->Line_18 $$ int hiEnd = lexer.getTokenEnd()[ FD ]
Line_16 $$ for (; lexer.getTokenType() != null; lexer.advance()) -->Line_23 $$ if (hiStart >= hiEnd) [ CD ]
Line_27 $$ String text = chars.subSequence(hiStart, hiEnd).toString()-->Line_28 $$ if (text.trim().isEmpty())[ FD ]
Line_3 $$ final Lexer lexer = myHighlighter.getHighlightingLexer()-->Line_12 $$ if (lexer.getTokenType() == null || lexer.getTokenStart() > start) [ FD ]
Line_17 $$ int hiStart = lexer.getTokenStart()-->Line_23 $$ if (hiStart >= hiEnd) [ FD ]
Line_4 $$ final SyntaxHighlighterOverEditorHighlighter highlighter = myHighlighter-->Line_13 $$ highlighter.resetPosition(0)[ FD ]
Line_2 $$ public TextChunk[] createTextChunks(@NotNull UsageInfo2UsageAdapter usageInfo2UsageAdapter, @NotNull CharSequence chars, int start, int end, boolean selectUsageWithBold, @NotNull List<TextChunk> result) -->Line_4 $$ final SyntaxHighlighterOverEditorHighlighter highlighter = myHighlighter[ CD ]
Line_15 $$ boolean isBeginning = true-->Line_31 $$ isBeginning = false[ FD ]
Line_4 $$ final SyntaxHighlighterOverEditorHighlighter highlighter = myHighlighter-->Line_33 $$ TextAttributesKey[] tokenHighlights = highlighter.getTokenHighlights(tokenType)[ FD ]
Line_9 $$ if (myDocumentStamp != myDocument.getModificationStamp()) -->Line_11 $$ myDocumentStamp = myDocument.getModificationStamp()[ CD ]
Line_4 $$ final SyntaxHighlighterOverEditorHighlighter highlighter = myHighlighter-->Line_10 $$ highlighter.restart(chars)[ FD ]
Line_16 $$ for (; lexer.getTokenType() != null; lexer.advance()) -->Line_18 $$ int hiEnd = lexer.getTokenEnd()[ CD ]
Line_2 $$ public TextChunk[] createTextChunks(@NotNull UsageInfo2UsageAdapter usageInfo2UsageAdapter, @NotNull CharSequence chars, int start, int end, boolean selectUsageWithBold, @NotNull List<TextChunk> result) -->Line_10 $$ highlighter.restart(chars)[ FD ]
Line_21 $$ hiStart = Math.max(hiStart, start)-->Line_27 $$ String text = chars.subSequence(hiStart, hiEnd).toString()[ FD ]
Line_18 $$ int hiEnd = lexer.getTokenEnd()-->Line_27 $$ String text = chars.subSequence(hiStart, hiEnd).toString()[ FD ]
Line_32 $$ IElementType tokenType = lexer.getTokenType()-->Line_33 $$ TextAttributesKey[] tokenHighlights = highlighter.getTokenHighlights(tokenType)[ FD ]
Line_2 $$ public TextChunk[] createTextChunks(@NotNull UsageInfo2UsageAdapter usageInfo2UsageAdapter, @NotNull CharSequence chars, int start, int end, boolean selectUsageWithBold, @NotNull List<TextChunk> result) -->Line_16 $$ for (; lexer.getTokenType() != null; lexer.advance()) [ CD ]
Line_18 $$ int hiEnd = lexer.getTokenEnd()-->Line_23 $$ if (hiStart >= hiEnd) [ FD ]
Line_16 $$ for (; lexer.getTokenType() != null; lexer.advance()) -->Line_26 $$ if (isBeginning) [ CD ]
Line_3 $$ final Lexer lexer = myHighlighter.getHighlightingLexer()-->Line_32 $$ IElementType tokenType = lexer.getTokenType()[ FD ]
Line_22 $$ hiEnd = Math.min(hiEnd, end)-->Line_23 $$ if (hiStart >= hiEnd) [ FD ]
Line_21 $$ hiStart = Math.max(hiStart, start)-->Line_23 $$ if (hiStart >= hiEnd) [ FD ]
Line_33 $$ TextAttributesKey[] tokenHighlights = highlighter.getTokenHighlights(tokenType)-->Line_34 $$ processIntersectingRange(usageInfo2UsageAdapter, chars, hiStart, hiEnd, tokenHighlights, selectUsageWithBold, result)[ FD ]
Line_16 $$ for (; lexer.getTokenType() != null; lexer.advance()) -->Line_22 $$ hiEnd = Math.min(hiEnd, end)[ CD ]
Line_2 $$ public TextChunk[] createTextChunks(@NotNull UsageInfo2UsageAdapter usageInfo2UsageAdapter, @NotNull CharSequence chars, int start, int end, boolean selectUsageWithBold, @NotNull List<TextChunk> result) -->Line_3 $$ final Lexer lexer = myHighlighter.getHighlightingLexer()[ CD ]
Line_2 $$ public TextChunk[] createTextChunks(@NotNull UsageInfo2UsageAdapter usageInfo2UsageAdapter, @NotNull CharSequence chars, int start, int end, boolean selectUsageWithBold, @NotNull List<TextChunk> result) -->Line_22 $$ hiEnd = Math.min(hiEnd, end)[ FD ]
Line_2 $$ public TextChunk[] createTextChunks(@NotNull UsageInfo2UsageAdapter usageInfo2UsageAdapter, @NotNull CharSequence chars, int start, int end, boolean selectUsageWithBold, @NotNull List<TextChunk> result) -->Line_5 $$ LOG.assertTrue(start <= end)[ CD ]
Line_7 $$ if (i != -1)-->Line_8 $$ end = i[ CD ]
Line_12 $$ if (lexer.getTokenType() == null || lexer.getTokenStart() > start) -->Line_13 $$ highlighter.resetPosition(0)[ CD ]
Line_26 $$ if (isBeginning) -->Line_27 $$ String text = chars.subSequence(hiStart, hiEnd).toString()[ CD ]
Line_2 $$ public TextChunk[] createTextChunks(@NotNull UsageInfo2UsageAdapter usageInfo2UsageAdapter, @NotNull CharSequence chars, int start, int end, boolean selectUsageWithBold, @NotNull List<TextChunk> result) -->Line_15 $$ boolean isBeginning = true[ CD ]
Line_22 $$ hiEnd = Math.min(hiEnd, end)-->Line_34 $$ processIntersectingRange(usageInfo2UsageAdapter, chars, hiStart, hiEnd, tokenHighlights, selectUsageWithBold, result)[ FD ]
Line_2 $$ public TextChunk[] createTextChunks(@NotNull UsageInfo2UsageAdapter usageInfo2UsageAdapter, @NotNull CharSequence chars, int start, int end, boolean selectUsageWithBold, @NotNull List<TextChunk> result) -->Line_9 $$ if (myDocumentStamp != myDocument.getModificationStamp()) [ CD ]
Line_16 $$ for (; lexer.getTokenType() != null; lexer.advance()) -->Line_31 $$ isBeginning = false[ CD ]
Line_16 $$ for (; lexer.getTokenType() != null; lexer.advance()) -->Line_33 $$ TextAttributesKey[] tokenHighlights = highlighter.getTokenHighlights(tokenType)[ CD ]
Line_2 $$ public TextChunk[] createTextChunks(@NotNull UsageInfo2UsageAdapter usageInfo2UsageAdapter, @NotNull CharSequence chars, int start, int end, boolean selectUsageWithBold, @NotNull List<TextChunk> result) -->Line_8 $$ end = i[ FD ]
Line_3 $$ final Lexer lexer = myHighlighter.getHighlightingLexer()-->Line_16 $$ for (; lexer.getTokenType() != null; lexer.advance()) [ FD ]
Line_16 $$ for (; lexer.getTokenType() != null; lexer.advance()) -->Line_32 $$ IElementType tokenType = lexer.getTokenType()[ CD ]
Line_9 $$ if (myDocumentStamp != myDocument.getModificationStamp()) -->Line_12 $$ if (lexer.getTokenType() == null || lexer.getTokenStart() > start) [ CD ]
Line_2 $$ public TextChunk[] createTextChunks(@NotNull UsageInfo2UsageAdapter usageInfo2UsageAdapter, @NotNull CharSequence chars, int start, int end, boolean selectUsageWithBold, @NotNull List<TextChunk> result) -->Line_6 $$ int i = StringUtil.indexOf(chars, '\n', start, end)[ FD ]
Line_16 $$ for (; lexer.getTokenType() != null; lexer.advance()) -->Line_19 $$ if (hiStart >= end)[ CD ]
Line_17 $$ int hiStart = lexer.getTokenStart()-->Line_34 $$ processIntersectingRange(usageInfo2UsageAdapter, chars, hiStart, hiEnd, tokenHighlights, selectUsageWithBold, result)[ FD ]
Line_18 $$ int hiEnd = lexer.getTokenEnd()-->Line_34 $$ processIntersectingRange(usageInfo2UsageAdapter, chars, hiStart, hiEnd, tokenHighlights, selectUsageWithBold, result)[ FD ]
Line_9 $$ if (myDocumentStamp != myDocument.getModificationStamp()) -->Line_10 $$ highlighter.restart(chars)[ CD ]
Line_2 $$ public TextChunk[] createTextChunks(@NotNull UsageInfo2UsageAdapter usageInfo2UsageAdapter, @NotNull CharSequence chars, int start, int end, boolean selectUsageWithBold, @NotNull List<TextChunk> result) -->Line_19 $$ if (hiStart >= end)[ FD ]
Line_2 $$ public TextChunk[] createTextChunks(@NotNull UsageInfo2UsageAdapter usageInfo2UsageAdapter, @NotNull CharSequence chars, int start, int end, boolean selectUsageWithBold, @NotNull List<TextChunk> result) -->Line_6 $$ int i = StringUtil.indexOf(chars, '\n', start, end)[ CD ]
Line_2 $$ public TextChunk[] createTextChunks(@NotNull UsageInfo2UsageAdapter usageInfo2UsageAdapter, @NotNull CharSequence chars, int start, int end, boolean selectUsageWithBold, @NotNull List<TextChunk> result) -->Line_34 $$ processIntersectingRange(usageInfo2UsageAdapter, chars, hiStart, hiEnd, tokenHighlights, selectUsageWithBold, result)[ FD ]
Line_3 $$ final Lexer lexer = myHighlighter.getHighlightingLexer()-->Line_17 $$ int hiStart = lexer.getTokenStart()[ FD ]
Line_2 $$ public TextChunk[] createTextChunks(@NotNull UsageInfo2UsageAdapter usageInfo2UsageAdapter, @NotNull CharSequence chars, int start, int end, boolean selectUsageWithBold, @NotNull List<TextChunk> result) -->Line_21 $$ hiStart = Math.max(hiStart, start)[ FD ]
Line_8 $$ end = i-->Line_22 $$ hiEnd = Math.min(hiEnd, end)[ FD ]
Line_2 $$ public TextChunk[] createTextChunks(@NotNull UsageInfo2UsageAdapter usageInfo2UsageAdapter, @NotNull CharSequence chars, int start, int end, boolean selectUsageWithBold, @NotNull List<TextChunk> result) -->Line_36 $$ return result.toArray(new TextChunk[result.size()])[ FD ]
Line_21 $$ hiStart = Math.max(hiStart, start)-->Line_19 $$ if (hiStart >= end)[ FD ]
Line_16 $$ for (; lexer.getTokenType() != null; lexer.advance()) -->Line_21 $$ hiStart = Math.max(hiStart, start)[ CD ]
Line_6 $$ int i = StringUtil.indexOf(chars, '\n', start, end)-->Line_8 $$ end = i[ FD ]
Line_26 $$ if (isBeginning) -->Line_28 $$ if (text.trim().isEmpty())[ CD ]
Line_17 $$ int hiStart = lexer.getTokenStart()-->Line_27 $$ String text = chars.subSequence(hiStart, hiEnd).toString()[ FD ]
Line_6 $$ int i = StringUtil.indexOf(chars, '\n', start, end)-->Line_7 $$ if (i != -1)[ FD ]
