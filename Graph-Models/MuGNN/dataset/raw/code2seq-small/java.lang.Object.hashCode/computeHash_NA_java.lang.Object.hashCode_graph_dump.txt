Line_12 $$ for (SingleChildDescriptor childDescriptor : descriptor.getSingleChildDescriptors()) -->Line_18 $$ final Couple<Integer> childHashResult = computeHash(childDescriptor, fragment, hasher)[ FD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_11 $$ int cost = hasher.getNodeCost(element)[ FD ]
Line_3 $$ final NodeSpecificHasherBase ssrHasher = (NodeSpecificHasherBase) hasher-->Line_4 $$ final PsiElement element2 = DuplocatorUtil.skipNodeIfNeccessary(element, descriptor, ssrHasher.getNodeFilter())[ FD ]
Line_12 $$ for (SingleChildDescriptor childDescriptor : descriptor.getSingleChildDescriptors()) -->Line_13 $$ final Couple<Integer> childHashResult = computeHash(childDescriptor, fragment, hasher)[ FD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_28 $$ final TreeHashResult childHashResult = hashCodeBlock(filteredBlock, fragment, hasher)[ FD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_32 $$ if (myCallback != null) [ CD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_12 $$ for (SingleChildDescriptor childDescriptor : descriptor.getSingleChildDescriptors()) [ FD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_6 $$ final PsiFragment fragment = buildFragment(hasher, element, 0)[ FD ]
Line_14 $$ hash = hash * 31 + childHashResult.first-->Line_29 $$ hash = hash * 31 + childHashResult.getHash()[ FD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_3 $$ final NodeSpecificHasherBase ssrHasher = (NodeSpecificHasherBase) hasher[ CD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_4 $$ final PsiElement element2 = DuplocatorUtil.skipNodeIfNeccessary(element, descriptor, ssrHasher.getNodeFilter())[ FD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_4 $$ final PsiElement element2 = DuplocatorUtil.skipNodeIfNeccessary(element, descriptor, ssrHasher.getNodeFilter())[ CD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_7 $$ if (parent != null) [ FD ]
Line_6 $$ final PsiFragment fragment = buildFragment(hasher, element, 0)-->Line_28 $$ final TreeHashResult childHashResult = hashCodeBlock(filteredBlock, fragment, hasher)[ FD ]
Line_13 $$ final Couple<Integer> childHashResult = computeHash(childDescriptor, fragment, hasher)-->Line_29 $$ hash = hash * 31 + childHashResult.getHash()[ FD ]
Line_15 $$ cost += childHashResult.second-->Line_30 $$ cost += childHashResult.getCost()[ FD ]
Line_24 $$ hash = hash * 31 + constantHash-->Line_33 $$ myCallback.add(hash, cost, fragment)[ FD ]
Line_29 $$ hash = hash * 31 + childHashResult.getHash()-->Line_33 $$ myCallback.add(hash, cost, fragment)[ FD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_11 $$ int cost = hasher.getNodeCost(element)[ CD ]
Line_10 $$ int hash = canSkip ? 0 : hasher.getNodeHash(element)-->Line_33 $$ myCallback.add(hash, cost, fragment)[ FD ]
Line_32 $$ if (myCallback != null) -->Line_33 $$ myCallback.add(hash, cost, fragment)[ CD ]
Line_11 $$ int cost = hasher.getNodeCost(element)-->Line_33 $$ myCallback.add(hash, cost, fragment)[ FD ]
Line_15 $$ cost += childHashResult.second-->Line_20 $$ cost += childHashResult.second[ FD ]
Line_14 $$ hash = hash * 31 + childHashResult.first-->Line_33 $$ myCallback.add(hash, cost, fragment)[ FD ]
Line_10 $$ int hash = canSkip ? 0 : hasher.getNodeHash(element)-->Line_24 $$ hash = hash * 31 + constantHash[ FD ]
Line_19 $$ hash = hash * 31 + childHashResult.first-->Line_29 $$ hash = hash * 31 + childHashResult.getHash()[ FD ]
Line_19 $$ hash = hash * 31 + childHashResult.first-->Line_33 $$ myCallback.add(hash, cost, fragment)[ FD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_8 $$ fragment.setParent(parent)[ FD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_5 $$ final boolean canSkip = element2 != element[ CD ]
Line_15 $$ cost += childHashResult.second-->Line_33 $$ myCallback.add(hash, cost, fragment)[ FD ]
Line_20 $$ cost += childHashResult.second-->Line_33 $$ myCallback.add(hash, cost, fragment)[ FD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_17 $$ for (MultiChildDescriptor childDescriptor : descriptor.getMultiChildDescriptors()) [ FD ]
Line_10 $$ int hash = canSkip ? 0 : hasher.getNodeHash(element)-->Line_29 $$ hash = hash * 31 + childHashResult.getHash()[ FD ]
Line_6 $$ final PsiFragment fragment = buildFragment(hasher, element, 0)-->Line_8 $$ fragment.setParent(parent)[ FD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_26 $$ for (PsiElement[] codeBlock : descriptor.getCodeBlocks()) [ FD ]
Line_22 $$ for (Object constant : descriptor.getConstants()) -->Line_23 $$ final int constantHash = constant != null ? constant.hashCode() : 0[ FD ]
Line_20 $$ cost += childHashResult.second-->Line_30 $$ cost += childHashResult.getCost()[ FD ]
Line_24 $$ hash = hash * 31 + constantHash-->Line_29 $$ hash = hash * 31 + childHashResult.getHash()[ FD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_6 $$ final PsiFragment fragment = buildFragment(hasher, element, 0)[ CD ]
Line_14 $$ hash = hash * 31 + childHashResult.first-->Line_24 $$ hash = hash * 31 + constantHash[ FD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_13 $$ final Couple<Integer> childHashResult = computeHash(childDescriptor, fragment, hasher)[ FD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_10 $$ int hash = canSkip ? 0 : hasher.getNodeHash(element)[ FD ]
Line_11 $$ int cost = hasher.getNodeCost(element)-->Line_15 $$ cost += childHashResult.second[ FD ]
Line_13 $$ final Couple<Integer> childHashResult = computeHash(childDescriptor, fragment, hasher)-->Line_30 $$ cost += childHashResult.getCost()[ FD ]
Line_27 $$ final List<PsiElement> filteredBlock = filter(codeBlock, ssrHasher)-->Line_28 $$ final TreeHashResult childHashResult = hashCodeBlock(filteredBlock, fragment, hasher)[ FD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_22 $$ for (Object constant : descriptor.getConstants()) [ FD ]
Line_11 $$ int cost = hasher.getNodeCost(element)-->Line_30 $$ cost += childHashResult.getCost()[ FD ]
Line_19 $$ hash = hash * 31 + childHashResult.first-->Line_24 $$ hash = hash * 31 + constantHash[ FD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_10 $$ int hash = canSkip ? 0 : hasher.getNodeHash(element)[ CD ]
Line_6 $$ final PsiFragment fragment = buildFragment(hasher, element, 0)-->Line_18 $$ final Couple<Integer> childHashResult = computeHash(childDescriptor, fragment, hasher)[ FD ]
Line_26 $$ for (PsiElement[] codeBlock : descriptor.getCodeBlocks()) -->Line_27 $$ final List<PsiElement> filteredBlock = filter(codeBlock, ssrHasher)[ FD ]
Line_14 $$ hash = hash * 31 + childHashResult.first-->Line_19 $$ hash = hash * 31 + childHashResult.first[ FD ]
Line_3 $$ final NodeSpecificHasherBase ssrHasher = (NodeSpecificHasherBase) hasher-->Line_27 $$ final List<PsiElement> filteredBlock = filter(codeBlock, ssrHasher)[ FD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_35 $$ return new TreeHashResult(hash, cost, fragment)[ CD ]
Line_7 $$ if (parent != null) -->Line_8 $$ fragment.setParent(parent)[ CD ]
Line_6 $$ final PsiFragment fragment = buildFragment(hasher, element, 0)-->Line_13 $$ final Couple<Integer> childHashResult = computeHash(childDescriptor, fragment, hasher)[ FD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_7 $$ if (parent != null) [ CD ]
Line_30 $$ cost += childHashResult.getCost()-->Line_33 $$ myCallback.add(hash, cost, fragment)[ FD ]
Line_2 $$ private TreeHashResult computeHash(PsiElement element, PsiFragment parent, EquivalenceDescriptor descriptor, NodeSpecificHasher hasher) -->Line_18 $$ final Couple<Integer> childHashResult = computeHash(childDescriptor, fragment, hasher)[ FD ]
Line_6 $$ final PsiFragment fragment = buildFragment(hasher, element, 0)-->Line_33 $$ myCallback.add(hash, cost, fragment)[ FD ]
Line_10 $$ int hash = canSkip ? 0 : hasher.getNodeHash(element)-->Line_14 $$ hash = hash * 31 + childHashResult.first[ FD ]
Line_10 $$ int hash = canSkip ? 0 : hasher.getNodeHash(element)-->Line_19 $$ hash = hash * 31 + childHashResult.first[ FD ]
Line_11 $$ int cost = hasher.getNodeCost(element)-->Line_20 $$ cost += childHashResult.second[ FD ]
Line_23 $$ final int constantHash = constant != null ? constant.hashCode() : 0-->Line_24 $$ hash = hash * 31 + constantHash[ FD ]
