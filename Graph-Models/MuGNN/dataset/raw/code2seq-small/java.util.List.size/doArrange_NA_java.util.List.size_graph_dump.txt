Line_33 $$ final ArrangementEntryWrapper<E> parentWrapper = initialWrapper.getParent()-->Line_45 $$ context.changer.insertSection(context, arranged.get(i), newSectionsInfo, arrangedWrapper, initialWrapper, parentWrapper)[ FD ]
Line_2 $$ private <E extends ArrangementEntry> void doArrange(@NotNull List<ArrangementEntryWrapper<E>> wrappers, @NotNull Context<E> context) -->Line_7 $$ Map<E, ArrangementEntryWrapper<E>> map = ContainerUtilRt.newHashMap()[ CD ]
Line_30 $$ ArrangementEntryWrapper<E> initialWrapper = wrappers.get(i)-->Line_45 $$ context.changer.insertSection(context, arranged.get(i), newSectionsInfo, arrangedWrapper, initialWrapper, parentWrapper)[ FD ]
Line_13 $$ if (!entry.canBeMatched()) -->Line_17 $$ arranged.add(entry)[ CD ]
Line_30 $$ ArrangementEntryWrapper<E> initialWrapper = wrappers.get(i)-->Line_44 $$ context.changer.replace(arrangedWrapper, initialWrapper, previous, next, context)[ FD ]
Line_30 $$ ArrangementEntryWrapper<E> initialWrapper = wrappers.get(i)-->Line_34 $$ if (arrangedWrapper.equals(initialWrapper)) [ FD ]
Line_28 $$ for (int i = arranged.size() - 1; i >= 0; i--) -->Line_45 $$ context.changer.insertSection(context, arranged.get(i), newSectionsInfo, arrangedWrapper, initialWrapper, parentWrapper)[ CD ]
Line_8 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_43 $$ ArrangementEntryWrapper<E> next = i < arranged.size() - 1 ? map.get(arranged.get(i + 1)) : null[ FD ]
Line_2 $$ private <E extends ArrangementEntry> void doArrange(@NotNull List<ArrangementEntryWrapper<E>> wrappers, @NotNull Context<E> context) -->Line_27 $$ context.changer.prepare(wrappers, context)[ CD ]
Line_8 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_24 $$ arranged.addAll(arrange(toArrange, context.sectionRules, context.rulesByPriority, entryToSection))[ FD ]
Line_8 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_17 $$ arranged.add(entry)[ FD ]
Line_2 $$ private <E extends ArrangementEntry> void doArrange(@NotNull List<ArrangementEntryWrapper<E>> wrappers, @NotNull Context<E> context) -->Line_9 $$ List<E> toArrange = ContainerUtilRt.newArrayList()[ CD ]
Line_8 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_15 $$ arranged.addAll(arrange(toArrange, context.sectionRules, context.rulesByPriority, entryToSection))[ FD ]
Line_8 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_26 $$ final NewSectionInfo<E> newSectionsInfo = NewSectionInfo.create(arranged, entryToSection)[ FD ]
Line_9 $$ List<E> toArrange = ContainerUtilRt.newArrayList()-->Line_18 $$ toArrange.clear()[ FD ]
Line_28 $$ for (int i = arranged.size() - 1; i >= 0; i--) -->Line_33 $$ final ArrangementEntryWrapper<E> parentWrapper = initialWrapper.getParent()[ CD ]
Line_11 $$ E entry = wrapper.getEntry()-->Line_13 $$ if (!entry.canBeMatched()) [ FD ]
Line_28 $$ for (int i = arranged.size() - 1; i >= 0; i--) -->Line_29 $$ ArrangementEntryWrapper<E> arrangedWrapper = map.get(arranged.get(i))[ CD ]
Line_7 $$ Map<E, ArrangementEntryWrapper<E>> map = ContainerUtilRt.newHashMap()-->Line_12 $$ map.put(wrapper.getEntry(), wrapper)[ FD ]
Line_2 $$ private <E extends ArrangementEntry> void doArrange(@NotNull List<ArrangementEntryWrapper<E>> wrappers, @NotNull Context<E> context) -->Line_6 $$ Map<E, ArrangementSectionRule> entryToSection = ContainerUtilRt.newHashMap()[ CD ]
Line_33 $$ final ArrangementEntryWrapper<E> parentWrapper = initialWrapper.getParent()-->Line_38 $$ boolean isInserted = context.changer.insertSection(context, arranged.get(i), newSectionsInfo, parentWrapper, beforeOffset, afterOffset)[ FD ]
Line_9 $$ List<E> toArrange = ContainerUtilRt.newArrayList()-->Line_15 $$ arranged.addAll(arrange(toArrange, context.sectionRules, context.rulesByPriority, entryToSection))[ FD ]
Line_11 $$ E entry = wrapper.getEntry()-->Line_20 $$ toArrange.add(entry)[ FD ]
Line_28 $$ for (int i = arranged.size() - 1; i >= 0; i--) -->Line_31 $$ ArrangementEntryWrapper<E> previous = i > 0 ? map.get(arranged.get(i - 1)) : null[ CD ]
Line_13 $$ if (!entry.canBeMatched()) -->Line_18 $$ toArrange.clear()[ CD ]
Line_13 $$ if (!entry.canBeMatched()) -->Line_20 $$ toArrange.add(entry)[ CD ]
Line_8 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_45 $$ context.changer.insertSection(context, arranged.get(i), newSectionsInfo, arrangedWrapper, initialWrapper, parentWrapper)[ FD ]
Line_2 $$ private <E extends ArrangementEntry> void doArrange(@NotNull List<ArrangementEntryWrapper<E>> wrappers, @NotNull Context<E> context) -->Line_30 $$ ArrangementEntryWrapper<E> initialWrapper = wrappers.get(i)[ FD ]
Line_29 $$ ArrangementEntryWrapper<E> arrangedWrapper = map.get(arranged.get(i))-->Line_37 $$ final int afterOffset = arrangedWrapper.getEndOffset()[ FD ]
Line_2 $$ private <E extends ArrangementEntry> void doArrange(@NotNull List<ArrangementEntryWrapper<E>> wrappers, @NotNull Context<E> context) -->Line_28 $$ for (int i = arranged.size() - 1; i >= 0; i--) [ CD ]
Line_28 $$ for (int i = arranged.size() - 1; i >= 0; i--) -->Line_32 $$ ArrangementEntryWrapper<E> previousInitial = i > 0 ? wrappers.get(i - 1) : null[ CD ]
Line_6 $$ Map<E, ArrangementSectionRule> entryToSection = ContainerUtilRt.newHashMap()-->Line_15 $$ arranged.addAll(arrange(toArrange, context.sectionRules, context.rulesByPriority, entryToSection))[ FD ]
Line_2 $$ private <E extends ArrangementEntry> void doArrange(@NotNull List<ArrangementEntryWrapper<E>> wrappers, @NotNull Context<E> context) -->Line_3 $$ if (wrappers.isEmpty()) [ CD ]
Line_29 $$ ArrangementEntryWrapper<E> arrangedWrapper = map.get(arranged.get(i))-->Line_44 $$ context.changer.replace(arrangedWrapper, initialWrapper, previous, next, context)[ FD ]
Line_34 $$ if (arrangedWrapper.equals(initialWrapper)) -->Line_35 $$ if (previous != null && previous.equals(previousInitial) || previous == null && previousInitial == null) [ CD ]
Line_9 $$ List<E> toArrange = ContainerUtilRt.newArrayList()-->Line_14 $$ if (toArrange.isEmpty()) [ FD ]
Line_28 $$ for (int i = arranged.size() - 1; i >= 0; i--) -->Line_34 $$ if (arrangedWrapper.equals(initialWrapper)) [ CD ]
Line_35 $$ if (previous != null && previous.equals(previousInitial) || previous == null && previousInitial == null) -->Line_38 $$ boolean isInserted = context.changer.insertSection(context, arranged.get(i), newSectionsInfo, parentWrapper, beforeOffset, afterOffset)[ CD ]
Line_2 $$ private <E extends ArrangementEntry> void doArrange(@NotNull List<ArrangementEntryWrapper<E>> wrappers, @NotNull Context<E> context) -->Line_38 $$ boolean isInserted = context.changer.insertSection(context, arranged.get(i), newSectionsInfo, parentWrapper, beforeOffset, afterOffset)[ FD ]
Line_7 $$ Map<E, ArrangementEntryWrapper<E>> map = ContainerUtilRt.newHashMap()-->Line_43 $$ ArrangementEntryWrapper<E> next = i < arranged.size() - 1 ? map.get(arranged.get(i + 1)) : null[ FD ]
Line_28 $$ for (int i = arranged.size() - 1; i >= 0; i--) -->Line_43 $$ ArrangementEntryWrapper<E> next = i < arranged.size() - 1 ? map.get(arranged.get(i + 1)) : null[ CD ]
Line_3 $$ if (wrappers.isEmpty()) -->Line_4 $$ return[ CD ]
Line_11 $$ E entry = wrapper.getEntry()-->Line_17 $$ arranged.add(entry)[ FD ]
Line_8 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_31 $$ ArrangementEntryWrapper<E> previous = i > 0 ? map.get(arranged.get(i - 1)) : null[ FD ]
Line_37 $$ final int afterOffset = arrangedWrapper.getEndOffset()-->Line_38 $$ boolean isInserted = context.changer.insertSection(context, arranged.get(i), newSectionsInfo, parentWrapper, beforeOffset, afterOffset)[ FD ]
Line_30 $$ ArrangementEntryWrapper<E> initialWrapper = wrappers.get(i)-->Line_33 $$ final ArrangementEntryWrapper<E> parentWrapper = initialWrapper.getParent()[ FD ]
Line_2 $$ private <E extends ArrangementEntry> void doArrange(@NotNull List<ArrangementEntryWrapper<E>> wrappers, @NotNull Context<E> context) -->Line_45 $$ context.changer.insertSection(context, arranged.get(i), newSectionsInfo, arrangedWrapper, initialWrapper, parentWrapper)[ FD ]
Line_28 $$ for (int i = arranged.size() - 1; i >= 0; i--) -->Line_30 $$ ArrangementEntryWrapper<E> initialWrapper = wrappers.get(i)[ CD ]
Line_8 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_28 $$ for (int i = arranged.size() - 1; i >= 0; i--) [ FD ]
Line_2 $$ private <E extends ArrangementEntry> void doArrange(@NotNull List<ArrangementEntryWrapper<E>> wrappers, @NotNull Context<E> context) -->Line_8 $$ List<E> arranged = ContainerUtilRt.newArrayList()[ CD ]
Line_26 $$ final NewSectionInfo<E> newSectionsInfo = NewSectionInfo.create(arranged, entryToSection)-->Line_38 $$ boolean isInserted = context.changer.insertSection(context, arranged.get(i), newSectionsInfo, parentWrapper, beforeOffset, afterOffset)[ FD ]
Line_2 $$ private <E extends ArrangementEntry> void doArrange(@NotNull List<ArrangementEntryWrapper<E>> wrappers, @NotNull Context<E> context) -->Line_32 $$ ArrangementEntryWrapper<E> previousInitial = i > 0 ? wrappers.get(i - 1) : null[ FD ]
Line_2 $$ private <E extends ArrangementEntry> void doArrange(@NotNull List<ArrangementEntryWrapper<E>> wrappers, @NotNull Context<E> context) -->Line_26 $$ final NewSectionInfo<E> newSectionsInfo = NewSectionInfo.create(arranged, entryToSection)[ CD ]
Line_10 $$ for (ArrangementEntryWrapper<E> wrapper : wrappers) -->Line_12 $$ map.put(wrapper.getEntry(), wrapper)[ FD ]
Line_14 $$ if (toArrange.isEmpty()) -->Line_15 $$ arranged.addAll(arrange(toArrange, context.sectionRules, context.rulesByPriority, entryToSection))[ CD ]
Line_28 $$ for (int i = arranged.size() - 1; i >= 0; i--) -->Line_29 $$ ArrangementEntryWrapper<E> arrangedWrapper = map.get(arranged.get(i))[ FD ]
Line_29 $$ ArrangementEntryWrapper<E> arrangedWrapper = map.get(arranged.get(i))-->Line_45 $$ context.changer.insertSection(context, arranged.get(i), newSectionsInfo, arrangedWrapper, initialWrapper, parentWrapper)[ FD ]
Line_31 $$ ArrangementEntryWrapper<E> previous = i > 0 ? map.get(arranged.get(i - 1)) : null-->Line_44 $$ context.changer.replace(arrangedWrapper, initialWrapper, previous, next, context)[ FD ]
Line_23 $$ if (!toArrange.isEmpty()) -->Line_24 $$ arranged.addAll(arrange(toArrange, context.sectionRules, context.rulesByPriority, entryToSection))[ CD ]
Line_28 $$ for (int i = arranged.size() - 1; i >= 0; i--) -->Line_45 $$ context.changer.insertSection(context, arranged.get(i), newSectionsInfo, arrangedWrapper, initialWrapper, parentWrapper)[ FD ]
Line_26 $$ final NewSectionInfo<E> newSectionsInfo = NewSectionInfo.create(arranged, entryToSection)-->Line_45 $$ context.changer.insertSection(context, arranged.get(i), newSectionsInfo, arrangedWrapper, initialWrapper, parentWrapper)[ FD ]
Line_6 $$ Map<E, ArrangementSectionRule> entryToSection = ContainerUtilRt.newHashMap()-->Line_26 $$ final NewSectionInfo<E> newSectionsInfo = NewSectionInfo.create(arranged, entryToSection)[ FD ]
Line_8 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_29 $$ ArrangementEntryWrapper<E> arrangedWrapper = map.get(arranged.get(i))[ FD ]
Line_9 $$ List<E> toArrange = ContainerUtilRt.newArrayList()-->Line_24 $$ arranged.addAll(arrange(toArrange, context.sectionRules, context.rulesByPriority, entryToSection))[ FD ]
Line_35 $$ if (previous != null && previous.equals(previousInitial) || previous == null && previousInitial == null) -->Line_37 $$ final int afterOffset = arrangedWrapper.getEndOffset()[ CD ]
Line_10 $$ for (ArrangementEntryWrapper<E> wrapper : wrappers) -->Line_11 $$ E entry = wrapper.getEntry()[ FD ]
Line_36 $$ final int beforeOffset = arrangedWrapper.getStartOffset()-->Line_38 $$ boolean isInserted = context.changer.insertSection(context, arranged.get(i), newSectionsInfo, parentWrapper, beforeOffset, afterOffset)[ FD ]
Line_43 $$ ArrangementEntryWrapper<E> next = i < arranged.size() - 1 ? map.get(arranged.get(i + 1)) : null-->Line_44 $$ context.changer.replace(arrangedWrapper, initialWrapper, previous, next, context)[ FD ]
Line_13 $$ if (!entry.canBeMatched()) -->Line_14 $$ if (toArrange.isEmpty()) [ CD ]
Line_28 $$ for (int i = arranged.size() - 1; i >= 0; i--) -->Line_30 $$ ArrangementEntryWrapper<E> initialWrapper = wrappers.get(i)[ FD ]
Line_28 $$ for (int i = arranged.size() - 1; i >= 0; i--) -->Line_44 $$ context.changer.replace(arrangedWrapper, initialWrapper, previous, next, context)[ CD ]
Line_7 $$ Map<E, ArrangementEntryWrapper<E>> map = ContainerUtilRt.newHashMap()-->Line_31 $$ ArrangementEntryWrapper<E> previous = i > 0 ? map.get(arranged.get(i - 1)) : null[ FD ]
Line_6 $$ Map<E, ArrangementSectionRule> entryToSection = ContainerUtilRt.newHashMap()-->Line_24 $$ arranged.addAll(arrange(toArrange, context.sectionRules, context.rulesByPriority, entryToSection))[ FD ]
Line_2 $$ private <E extends ArrangementEntry> void doArrange(@NotNull List<ArrangementEntryWrapper<E>> wrappers, @NotNull Context<E> context) -->Line_23 $$ if (!toArrange.isEmpty()) [ CD ]
Line_28 $$ for (int i = arranged.size() - 1; i >= 0; i--) -->Line_38 $$ boolean isInserted = context.changer.insertSection(context, arranged.get(i), newSectionsInfo, parentWrapper, beforeOffset, afterOffset)[ FD ]
Line_9 $$ List<E> toArrange = ContainerUtilRt.newArrayList()-->Line_20 $$ toArrange.add(entry)[ FD ]
Line_2 $$ private <E extends ArrangementEntry> void doArrange(@NotNull List<ArrangementEntryWrapper<E>> wrappers, @NotNull Context<E> context) -->Line_44 $$ context.changer.replace(arrangedWrapper, initialWrapper, previous, next, context)[ FD ]
Line_32 $$ ArrangementEntryWrapper<E> previousInitial = i > 0 ? wrappers.get(i - 1) : null-->Line_35 $$ if (previous != null && previous.equals(previousInitial) || previous == null && previousInitial == null) [ FD ]
Line_7 $$ Map<E, ArrangementEntryWrapper<E>> map = ContainerUtilRt.newHashMap()-->Line_29 $$ ArrangementEntryWrapper<E> arrangedWrapper = map.get(arranged.get(i))[ FD ]
Line_2 $$ private <E extends ArrangementEntry> void doArrange(@NotNull List<ArrangementEntryWrapper<E>> wrappers, @NotNull Context<E> context) -->Line_27 $$ context.changer.prepare(wrappers, context)[ FD ]
Line_29 $$ ArrangementEntryWrapper<E> arrangedWrapper = map.get(arranged.get(i))-->Line_34 $$ if (arrangedWrapper.equals(initialWrapper)) [ FD ]
Line_29 $$ ArrangementEntryWrapper<E> arrangedWrapper = map.get(arranged.get(i))-->Line_36 $$ final int beforeOffset = arrangedWrapper.getStartOffset()[ FD ]
Line_35 $$ if (previous != null && previous.equals(previousInitial) || previous == null && previousInitial == null) -->Line_36 $$ final int beforeOffset = arrangedWrapper.getStartOffset()[ CD ]
Line_9 $$ List<E> toArrange = ContainerUtilRt.newArrayList()-->Line_23 $$ if (!toArrange.isEmpty()) [ FD ]
Line_2 $$ private <E extends ArrangementEntry> void doArrange(@NotNull List<ArrangementEntryWrapper<E>> wrappers, @NotNull Context<E> context) -->Line_3 $$ if (wrappers.isEmpty()) [ FD ]
Line_8 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_38 $$ boolean isInserted = context.changer.insertSection(context, arranged.get(i), newSectionsInfo, parentWrapper, beforeOffset, afterOffset)[ FD ]
Line_31 $$ ArrangementEntryWrapper<E> previous = i > 0 ? map.get(arranged.get(i - 1)) : null-->Line_35 $$ if (previous != null && previous.equals(previousInitial) || previous == null && previousInitial == null) [ FD ]
