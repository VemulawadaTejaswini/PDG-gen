Line_13 $$ int requiredParticipants = participants / 2 + 1-->Line_15 $$ if (liveEndpoints.size() < requiredParticipants)[ FD ]
Line_14 $$ List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive))-->Line_16 $$ throw new UnavailableException(consistencyForPaxos, requiredParticipants, liveEndpoints.size())[ FD ]
Line_10 $$ pendingEndpoints = ImmutableList.copyOf(Iterables.filter(pendingEndpoints, isLocalDc))-->Line_14 $$ List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive))[ FD ]
Line_7 $$ String localDc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getBroadcastAddress())-->Line_8 $$ Predicate<InetAddress> isLocalDc = sameDCPredicateFor(localDc)[ FD ]
Line_9 $$ naturalEndpoints = ImmutableList.copyOf(Iterables.filter(naturalEndpoints, isLocalDc))-->Line_14 $$ List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive))[ FD ]
Line_4 $$ List<InetAddress> naturalEndpoints = StorageService.instance.getNaturalEndpoints(cfm.ksName, tk)-->Line_12 $$ int participants = pendingEndpoints.size() + naturalEndpoints.size()[ FD ]
Line_6 $$ if (consistencyForPaxos == ConsistencyLevel.LOCAL_SERIAL) -->Line_7 $$ String localDc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getBroadcastAddress())[ CD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_17 $$ if (pendingEndpoints.size() > 1)[ CD ]
Line_4 $$ List<InetAddress> naturalEndpoints = StorageService.instance.getNaturalEndpoints(cfm.ksName, tk)-->Line_14 $$ List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive))[ FD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_6 $$ if (consistencyForPaxos == ConsistencyLevel.LOCAL_SERIAL) [ CD ]
Line_6 $$ if (consistencyForPaxos == ConsistencyLevel.LOCAL_SERIAL) -->Line_9 $$ naturalEndpoints = ImmutableList.copyOf(Iterables.filter(naturalEndpoints, isLocalDc))[ CD ]
Line_14 $$ List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive))-->Line_15 $$ if (liveEndpoints.size() < requiredParticipants)[ FD ]
Line_6 $$ if (consistencyForPaxos == ConsistencyLevel.LOCAL_SERIAL) -->Line_10 $$ pendingEndpoints = ImmutableList.copyOf(Iterables.filter(pendingEndpoints, isLocalDc))[ CD ]
Line_3 $$ Token tk = key.getToken()-->Line_4 $$ List<InetAddress> naturalEndpoints = StorageService.instance.getNaturalEndpoints(cfm.ksName, tk)[ FD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_3 $$ Token tk = key.getToken()[ FD ]
Line_10 $$ pendingEndpoints = ImmutableList.copyOf(Iterables.filter(pendingEndpoints, isLocalDc))-->Line_12 $$ int participants = pendingEndpoints.size() + naturalEndpoints.size()[ FD ]
Line_6 $$ if (consistencyForPaxos == ConsistencyLevel.LOCAL_SERIAL) -->Line_8 $$ Predicate<InetAddress> isLocalDc = sameDCPredicateFor(localDc)[ CD ]
Line_5 $$ Collection<InetAddress> pendingEndpoints = StorageService.instance.getTokenMetadata().pendingEndpointsFor(tk, cfm.ksName)-->Line_10 $$ pendingEndpoints = ImmutableList.copyOf(Iterables.filter(pendingEndpoints, isLocalDc))[ FD ]
Line_3 $$ Token tk = key.getToken()-->Line_5 $$ Collection<InetAddress> pendingEndpoints = StorageService.instance.getTokenMetadata().pendingEndpointsFor(tk, cfm.ksName)[ FD ]
Line_10 $$ pendingEndpoints = ImmutableList.copyOf(Iterables.filter(pendingEndpoints, isLocalDc))-->Line_18 $$ throw new UnavailableException(String.format("Cannot perform LWT operation as there is more than one (%d) pending range movement", pendingEndpoints.size()), consistencyForPaxos, participants + 1, liveEndpoints.size())[ FD ]
Line_5 $$ Collection<InetAddress> pendingEndpoints = StorageService.instance.getTokenMetadata().pendingEndpointsFor(tk, cfm.ksName)-->Line_14 $$ List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive))[ FD ]
Line_14 $$ List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive))-->Line_19 $$ return Pair.create(liveEndpoints, requiredParticipants)[ FD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_4 $$ List<InetAddress> naturalEndpoints = StorageService.instance.getNaturalEndpoints(cfm.ksName, tk)[ CD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_19 $$ return Pair.create(liveEndpoints, requiredParticipants)[ CD ]
Line_14 $$ List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive))-->Line_18 $$ throw new UnavailableException(String.format("Cannot perform LWT operation as there is more than one (%d) pending range movement", pendingEndpoints.size()), consistencyForPaxos, participants + 1, liveEndpoints.size())[ FD ]
Line_5 $$ Collection<InetAddress> pendingEndpoints = StorageService.instance.getTokenMetadata().pendingEndpointsFor(tk, cfm.ksName)-->Line_18 $$ throw new UnavailableException(String.format("Cannot perform LWT operation as there is more than one (%d) pending range movement", pendingEndpoints.size()), consistencyForPaxos, participants + 1, liveEndpoints.size())[ FD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_12 $$ int participants = pendingEndpoints.size() + naturalEndpoints.size()[ CD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_6 $$ if (consistencyForPaxos == ConsistencyLevel.LOCAL_SERIAL) [ FD ]
Line_8 $$ Predicate<InetAddress> isLocalDc = sameDCPredicateFor(localDc)-->Line_9 $$ naturalEndpoints = ImmutableList.copyOf(Iterables.filter(naturalEndpoints, isLocalDc))[ FD ]
Line_8 $$ Predicate<InetAddress> isLocalDc = sameDCPredicateFor(localDc)-->Line_10 $$ pendingEndpoints = ImmutableList.copyOf(Iterables.filter(pendingEndpoints, isLocalDc))[ FD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_15 $$ if (liveEndpoints.size() < requiredParticipants)[ CD ]
Line_5 $$ Collection<InetAddress> pendingEndpoints = StorageService.instance.getTokenMetadata().pendingEndpointsFor(tk, cfm.ksName)-->Line_17 $$ if (pendingEndpoints.size() > 1)[ FD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_14 $$ List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive))[ CD ]
Line_10 $$ pendingEndpoints = ImmutableList.copyOf(Iterables.filter(pendingEndpoints, isLocalDc))-->Line_17 $$ if (pendingEndpoints.size() > 1)[ FD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_5 $$ Collection<InetAddress> pendingEndpoints = StorageService.instance.getTokenMetadata().pendingEndpointsFor(tk, cfm.ksName)[ CD ]
Line_13 $$ int requiredParticipants = participants / 2 + 1-->Line_19 $$ return Pair.create(liveEndpoints, requiredParticipants)[ FD ]
Line_9 $$ naturalEndpoints = ImmutableList.copyOf(Iterables.filter(naturalEndpoints, isLocalDc))-->Line_12 $$ int participants = pendingEndpoints.size() + naturalEndpoints.size()[ FD ]
Line_5 $$ Collection<InetAddress> pendingEndpoints = StorageService.instance.getTokenMetadata().pendingEndpointsFor(tk, cfm.ksName)-->Line_12 $$ int participants = pendingEndpoints.size() + naturalEndpoints.size()[ FD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_13 $$ int requiredParticipants = participants / 2 + 1[ CD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_3 $$ Token tk = key.getToken()[ CD ]
Line_4 $$ List<InetAddress> naturalEndpoints = StorageService.instance.getNaturalEndpoints(cfm.ksName, tk)-->Line_9 $$ naturalEndpoints = ImmutableList.copyOf(Iterables.filter(naturalEndpoints, isLocalDc))[ FD ]
