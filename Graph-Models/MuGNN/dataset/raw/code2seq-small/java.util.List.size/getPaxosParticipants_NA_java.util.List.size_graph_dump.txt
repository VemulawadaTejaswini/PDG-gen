Line_6 $$ if (consistencyForPaxos == ConsistencyLevel.LOCAL_SERIAL) -->Line_10 $$ naturalEndpoints = ImmutableList.copyOf(Iterables.filter(naturalEndpoints, isLocalDc))[ CD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_5 $$ Collection<InetAddress> pendingEndpoints = StorageService.instance.getTokenMetadata().pendingEndpointsFor(tk, cfm.ksName)[ CD ]
Line_3 $$ Token tk = key.getToken()-->Line_5 $$ Collection<InetAddress> pendingEndpoints = StorageService.instance.getTokenMetadata().pendingEndpointsFor(tk, cfm.ksName)[ FD ]
Line_16 $$ List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive))-->Line_17 $$ if (liveEndpoints.size() < requiredParticipants)[ FD ]
Line_9 $$ Predicate<InetAddress> isLocalDc = sameDCPredicateFor(localDc)-->Line_11 $$ pendingEndpoints = ImmutableList.copyOf(Iterables.filter(pendingEndpoints, isLocalDc))[ FD ]
Line_4 $$ List<InetAddress> naturalEndpoints = StorageService.instance.getNaturalEndpoints(cfm.ksName, tk)-->Line_16 $$ List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive))[ FD ]
Line_6 $$ if (consistencyForPaxos == ConsistencyLevel.LOCAL_SERIAL) -->Line_11 $$ pendingEndpoints = ImmutableList.copyOf(Iterables.filter(pendingEndpoints, isLocalDc))[ CD ]
Line_6 $$ if (consistencyForPaxos == ConsistencyLevel.LOCAL_SERIAL) -->Line_9 $$ Predicate<InetAddress> isLocalDc = sameDCPredicateFor(localDc)[ CD ]
Line_11 $$ pendingEndpoints = ImmutableList.copyOf(Iterables.filter(pendingEndpoints, isLocalDc))-->Line_13 $$ int participants = pendingEndpoints.size() + naturalEndpoints.size()[ FD ]
Line_5 $$ Collection<InetAddress> pendingEndpoints = StorageService.instance.getTokenMetadata().pendingEndpointsFor(tk, cfm.ksName)-->Line_16 $$ List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive))[ FD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_4 $$ List<InetAddress> naturalEndpoints = StorageService.instance.getNaturalEndpoints(cfm.ksName, tk)[ CD ]
Line_11 $$ pendingEndpoints = ImmutableList.copyOf(Iterables.filter(pendingEndpoints, isLocalDc))-->Line_23 $$ throw new UnavailableException(String.format("Cannot perform LWT operation as there is more than one (%d) pending range movement", pendingEndpoints.size()), consistencyForPaxos, participants + 1, liveEndpoints.size())[ FD ]
Line_5 $$ Collection<InetAddress> pendingEndpoints = StorageService.instance.getTokenMetadata().pendingEndpointsFor(tk, cfm.ksName)-->Line_11 $$ pendingEndpoints = ImmutableList.copyOf(Iterables.filter(pendingEndpoints, isLocalDc))[ FD ]
Line_4 $$ List<InetAddress> naturalEndpoints = StorageService.instance.getNaturalEndpoints(cfm.ksName, tk)-->Line_10 $$ naturalEndpoints = ImmutableList.copyOf(Iterables.filter(naturalEndpoints, isLocalDc))[ FD ]
Line_11 $$ pendingEndpoints = ImmutableList.copyOf(Iterables.filter(pendingEndpoints, isLocalDc))-->Line_16 $$ List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive))[ FD ]
Line_16 $$ List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive))-->Line_18 $$ throw new UnavailableException(consistencyForPaxos, requiredParticipants, liveEndpoints.size())[ FD ]
Line_5 $$ Collection<InetAddress> pendingEndpoints = StorageService.instance.getTokenMetadata().pendingEndpointsFor(tk, cfm.ksName)-->Line_13 $$ int participants = pendingEndpoints.size() + naturalEndpoints.size()[ FD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_16 $$ List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive))[ CD ]
Line_10 $$ naturalEndpoints = ImmutableList.copyOf(Iterables.filter(naturalEndpoints, isLocalDc))-->Line_16 $$ List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive))[ FD ]
Line_10 $$ naturalEndpoints = ImmutableList.copyOf(Iterables.filter(naturalEndpoints, isLocalDc))-->Line_13 $$ int participants = pendingEndpoints.size() + naturalEndpoints.size()[ FD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_13 $$ int participants = pendingEndpoints.size() + naturalEndpoints.size()[ CD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_17 $$ if (liveEndpoints.size() < requiredParticipants)[ CD ]
Line_3 $$ Token tk = key.getToken()-->Line_4 $$ List<InetAddress> naturalEndpoints = StorageService.instance.getNaturalEndpoints(cfm.ksName, tk)[ FD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_6 $$ if (consistencyForPaxos == ConsistencyLevel.LOCAL_SERIAL) [ FD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_3 $$ Token tk = key.getToken()[ FD ]
Line_4 $$ List<InetAddress> naturalEndpoints = StorageService.instance.getNaturalEndpoints(cfm.ksName, tk)-->Line_13 $$ int participants = pendingEndpoints.size() + naturalEndpoints.size()[ FD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_6 $$ if (consistencyForPaxos == ConsistencyLevel.LOCAL_SERIAL) [ CD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_24 $$ return Pair.create(liveEndpoints, requiredParticipants)[ CD ]
Line_5 $$ Collection<InetAddress> pendingEndpoints = StorageService.instance.getTokenMetadata().pendingEndpointsFor(tk, cfm.ksName)-->Line_23 $$ throw new UnavailableException(String.format("Cannot perform LWT operation as there is more than one (%d) pending range movement", pendingEndpoints.size()), consistencyForPaxos, participants + 1, liveEndpoints.size())[ FD ]
Line_2 $$ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(CFMetaData cfm, DecoratedKey key, ConsistencyLevel consistencyForPaxos) throws UnavailableException -->Line_3 $$ Token tk = key.getToken()[ CD ]
Line_16 $$ List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive))-->Line_24 $$ return Pair.create(liveEndpoints, requiredParticipants)[ FD ]
Line_9 $$ Predicate<InetAddress> isLocalDc = sameDCPredicateFor(localDc)-->Line_10 $$ naturalEndpoints = ImmutableList.copyOf(Iterables.filter(naturalEndpoints, isLocalDc))[ FD ]
Line_16 $$ List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive))-->Line_23 $$ throw new UnavailableException(String.format("Cannot perform LWT operation as there is more than one (%d) pending range movement", pendingEndpoints.size()), consistencyForPaxos, participants + 1, liveEndpoints.size())[ FD ]
