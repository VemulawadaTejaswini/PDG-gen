Line_12 $$ for (int i = 0; i < sharedRecycle.length; i++) -->Line_13 $$ sharedRecycle[i] = new SPSCQueue()[ CD ]
Line_71 $$ for (int t = 0; t < threadCount; t++) -->Line_73 $$ final int targetSize = t == 0 ? BufferPool.CHUNK_SIZE : targetSizeQuanta * t[ CD ]
Line_130 $$ totalSize -= size-->Line_98 $$ while (totalSize > currentTargetSize - freeingSize) [ FD ]
Line_118 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_175 $$ ByteBuffer buffer = BufferPool.get(size)[ FD ]
Line_98 $$ while (totalSize > currentTargetSize - freeingSize) -->Line_116 $$ checks.remove(check.listnode)[ CD ]
Line_228 $$ while (null != (check = queue.poll())) -->Line_230 $$ BufferPool.put(check.buffer)[ CD ]
Line_201 $$ index += moveBy-->Line_196 $$ int baseSampleIndex = sum1toN(index)[ FD ]
Line_196 $$ int baseSampleIndex = sum1toN(index)-->Line_198 $$ if (sampleIndex >= baseSampleIndex) [ FD ]
Line_198 $$ if (sampleIndex >= baseSampleIndex) -->Line_201 $$ index += moveBy[ CD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_194 $$ int index = size / 2[ CD ]
Line_120 $$ size = 0-->Line_178 $$ assertEquals(size, buffer.capacity())[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_29 $$ executorService.submit(new TestUntil(until) [ CD ]
Line_158 $$ BufferCheck check = checks.get(0)-->Line_181 $$ check.listnode = checks.append(check)[ FD ]
Line_119 $$ if (size > BufferPool.CHUNK_SIZE)-->Line_120 $$ size = 0[ CD ]
Line_106 $$ if (!recycleFromNeighbour()) -->Line_107 $$ if (++spinCount > 1000 && System.nanoTime() > until)[ CD ]
Line_41 $$ ByteBuffer buffer = BufferPool.tryGet(BufferPool.CHUNK_SIZE)-->Line_63 $$ BufferPool.put(buffer)[ FD ]
Line_204 $$ moveBy = Math.max(moveBy / 2, 1)-->Line_201 $$ index += moveBy[ FD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_177 $$ BufferCheck check = new BufferCheck(buffer, rand.nextLong())[ CD ]
Line_91 $$ if (!makingProgress[threadIdx].get())-->Line_92 $$ makingProgress[threadIdx].set(true)[ CD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_96 $$ long currentTargetSize = rand.nextInt(poolSize / 1024) == 0 ? 0 : targetSize[ CD ]
Line_130 $$ totalSize -= size-->Line_146 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_29 $$ executorService.submit(new TestUntil(until) -->Line_52 $$ doneAdd.countDown()[ CD ]
Line_177 $$ BufferCheck check = new BufferCheck(buffer, rand.nextLong())-->Line_180 $$ check.init()[ FD ]
Line_55 $$ executorService.submit(new TestUntil(until) -->Line_59 $$ if (buffer == null) [ CD ]
Line_120 $$ size = 0-->Line_124 $$ freeingSize += size[ FD ]
Line_166 $$ BufferCheck check = shareFrom.poll()-->Line_181 $$ check.listnode = checks.append(check)[ FD ]
Line_29 $$ executorService.submit(new TestUntil(until) -->Line_48 $$ count++[ CD ]
Line_120 $$ size = 0-->Line_137 $$ allocate(size)[ FD ]
Line_194 $$ int index = size / 2-->Line_203 $$ index -= moveBy[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_11 $$ final AtomicBoolean[] makingProgress = new AtomicBoolean[threadCount][ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_7 $$ System.out.println(String.format("%s - testing %d threads for %dm", dateFormat.format(new Date()), threadCount, TimeUnit.NANOSECONDS.toMinutes(duration)))[ FD ]
Line_218 $$ if (!first)-->Line_219 $$ BufferPool.assertAllRecycled()[ CD ]
Line_191 $$ int sampleIndex = rand.nextInt(sampleRange)-->Line_199 $$ if (sampleIndex < endOfSampleIndex)[ FD ]
Line_118 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_136 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_144 $$ if (size <= BufferPool.CHUNK_SIZE) -->Line_145 $$ allocate(size)[ CD ]
Line_17 $$ List<Future<Boolean>> ret = new ArrayList(threadCount)-->Line_74 $$ ret.add(executorService.submit(new TestUntil(until) [ FD ]
Line_16 $$ ExecutorService executorService = Executors.newFixedThreadPool(threadCount + 2)-->Line_74 $$ ret.add(executorService.submit(new TestUntil(until) [ FD ]
Line_203 $$ index -= moveBy-->Line_208 $$ return checks.get(index)[ FD ]
Line_158 $$ BufferCheck check = checks.get(0)-->Line_167 $$ if (check == null)[ FD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_178 $$ assertEquals(size, buffer.capacity())[ CD ]
Line_201 $$ index += moveBy-->Line_203 $$ index -= moveBy[ FD ]
Line_105 $$ freeingSize = 0-->Line_124 $$ freeingSize += size[ FD ]
Line_118 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_135 $$ if (size <= BufferPool.CHUNK_SIZE) [ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_236 $$ System.out.println(String.format("%s - finished.", dateFormat.format(new Date())))[ CD ]
Line_166 $$ BufferCheck check = shareFrom.poll()-->Line_169 $$ check.validate()[ FD ]
Line_97 $$ int spinCount = 0-->Line_107 $$ if (++spinCount > 1000 && System.nanoTime() > until)[ FD ]
Line_158 $$ BufferCheck check = checks.get(0)-->Line_180 $$ check.init()[ FD ]
Line_198 $$ if (sampleIndex >= baseSampleIndex) -->Line_203 $$ index -= moveBy[ CD ]
Line_118 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_146 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_97 $$ int spinCount = 0[ CD ]
Line_120 $$ size = 0-->Line_130 $$ totalSize -= size[ FD ]
Line_120 $$ size = 0-->Line_135 $$ if (size <= BufferPool.CHUNK_SIZE) [ FD ]
Line_217 $$ while (!latch.await(10L, TimeUnit.SECONDS)) -->Line_218 $$ if (!first)[ CD ]
Line_135 $$ if (size <= BufferPool.CHUNK_SIZE) -->Line_137 $$ allocate(size)[ CD ]
Line_29 $$ executorService.submit(new TestUntil(until) -->Line_46 $$ BufferPool.put(buffer)[ CD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_208 $$ return checks.get(index)[ CD ]
Line_42 $$ if (buffer == null) -->Line_43 $$ Thread.yield()[ CD ]
Line_28 $$ final CountDownLatch doneAdd = new CountDownLatch(1)-->Line_67 $$ Uninterruptibles.awaitUninterruptibly(doneAdd)[ FD ]
Line_29 $$ executorService.submit(new TestUntil(until) -->Line_34 $$ if (count * BufferPool.CHUNK_SIZE >= poolSize / 10) [ CD ]
Line_201 $$ index += moveBy-->Line_208 $$ return checks.get(index)[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_12 $$ for (int i = 0; i < sharedRecycle.length; i++) [ CD ]
Line_9 $$ final CountDownLatch latch = new CountDownLatch(threadCount)-->Line_217 $$ while (!latch.await(10L, TimeUnit.SECONDS)) [ FD ]
Line_221 $$ for (AtomicBoolean progress : makingProgress) -->Line_223 $$ progress.set(false)[ FD ]
Line_55 $$ executorService.submit(new TestUntil(until) -->Line_63 $$ BufferPool.put(buffer)[ CD ]
Line_118 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_130 $$ totalSize -= size[ FD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_175 $$ ByteBuffer buffer = BufferPool.get(size)[ CD ]
Line_130 $$ totalSize -= size-->Line_136 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_181 $$ check.listnode = checks.append(check)[ CD ]
Line_42 $$ if (buffer == null) -->Line_44 $$ return[ CD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_178 $$ assertEquals(size, buffer.capacity())[ FD ]
Line_16 $$ ExecutorService executorService = Executors.newFixedThreadPool(threadCount + 2)-->Line_29 $$ executorService.submit(new TestUntil(until) [ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_233 $$ assertEquals(0, executorService.shutdownNow().size())[ CD ]
Line_195 $$ while (true) -->Line_197 $$ int endOfSampleIndex = sum1toN(index + 1)[ CD ]
Line_195 $$ while (true) -->Line_204 $$ moveBy = Math.max(moveBy / 2, 1)[ CD ]
Line_118 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_144 $$ if (size <= BufferPool.CHUNK_SIZE) [ FD ]
Line_158 $$ BufferCheck check = checks.get(0)-->Line_169 $$ check.validate()[ FD ]
Line_55 $$ executorService.submit(new TestUntil(until) -->Line_67 $$ Uninterruptibles.awaitUninterruptibly(doneAdd)[ CD ]
Line_175 $$ ByteBuffer buffer = BufferPool.get(size)-->Line_179 $$ assertEquals(0, buffer.position())[ FD ]
Line_120 $$ size = 0-->Line_139 $$ allocate(size)[ FD ]
Line_138 $$ if (rand.nextBoolean()) -->Line_139 $$ allocate(size)[ CD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_182 $$ return check[ CD ]
Line_104 $$ totalSize -= freeingSize-->Line_146 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_41 $$ ByteBuffer buffer = BufferPool.tryGet(BufferPool.CHUNK_SIZE)-->Line_179 $$ assertEquals(0, buffer.position())[ FD ]
Line_166 $$ BufferCheck check = shareFrom.poll()-->Line_229 $$ check.validate()[ FD ]
Line_34 $$ if (count * BufferPool.CHUNK_SIZE >= poolSize / 10) -->Line_39 $$ return[ CD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_170 $$ BufferPool.put(check.buffer)[ CD ]
Line_194 $$ int index = size / 2-->Line_196 $$ int baseSampleIndex = sum1toN(index)[ FD ]
Line_29 $$ executorService.submit(new TestUntil(until) -->Line_47 $$ burn.add(buffer)[ CD ]
Line_104 $$ totalSize -= freeingSize-->Line_98 $$ while (totalSize > currentTargetSize - freeingSize) [ FD ]
Line_118 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_124 $$ freeingSize += size[ FD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_171 $$ return true[ CD ]
Line_71 $$ for (int t = 0; t < threadCount; t++) -->Line_72 $$ final int threadIdx = t[ CD ]
Line_195 $$ while (true) -->Line_196 $$ int baseSampleIndex = sum1toN(index)[ CD ]
Line_120 $$ size = 0-->Line_146 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_58 $$ ByteBuffer buffer = burn.poll()-->Line_179 $$ assertEquals(0, buffer.position())[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_8 $$ final long until = System.nanoTime() + duration[ CD ]
Line_135 $$ if (size <= BufferPool.CHUNK_SIZE) -->Line_136 $$ totalSize += BufferPool.roundUpNormal(size)[ CD ]
Line_157 $$ while (checks.size() > 0) -->Line_160 $$ checks.remove(check.listnode)[ CD ]
Line_29 $$ executorService.submit(new TestUntil(until) -->Line_42 $$ if (buffer == null) [ CD ]
Line_143 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_144 $$ if (size <= BufferPool.CHUNK_SIZE) [ FD ]
Line_58 $$ ByteBuffer buffer = burn.poll()-->Line_178 $$ assertEquals(size, buffer.capacity())[ FD ]
Line_118 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_178 $$ assertEquals(size, buffer.capacity())[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_71 $$ for (int t = 0; t < threadCount; t++) [ CD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_191 $$ int sampleIndex = rand.nextInt(sampleRange)[ CD ]
Line_177 $$ BufferCheck check = new BufferCheck(buffer, rand.nextLong())-->Line_229 $$ check.validate()[ FD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_169 $$ check.validate()[ CD ]
Line_58 $$ ByteBuffer buffer = burn.poll()-->Line_176 $$ assertNotNull(buffer)[ FD ]
Line_120 $$ size = 0-->Line_136 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_19 $$ BufferPool.MEMORY_USAGE_THRESHOLD = poolSize[ CD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_195 $$ while (true) [ CD ]
Line_157 $$ while (checks.size() > 0) -->Line_159 $$ BufferPool.put(check.buffer)[ CD ]
Line_118 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_119 $$ if (size > BufferPool.CHUNK_SIZE)[ FD ]
Line_228 $$ while (null != (check = queue.poll())) -->Line_229 $$ check.validate()[ CD ]
Line_6 $$ final DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss")-->Line_236 $$ System.out.println(String.format("%s - finished.", dateFormat.format(new Date())))[ FD ]
Line_104 $$ totalSize -= freeingSize-->Line_130 $$ totalSize -= size[ FD ]
Line_9 $$ final CountDownLatch latch = new CountDownLatch(threadCount)-->Line_162 $$ latch.countDown()[ FD ]
Line_157 $$ while (checks.size() > 0) -->Line_158 $$ BufferCheck check = checks.get(0)[ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_18 $$ long prevPoolSize = BufferPool.MEMORY_USAGE_THRESHOLD[ CD ]
Line_34 $$ if (count * BufferPool.CHUNK_SIZE >= poolSize / 10) -->Line_35 $$ if (burn.exhausted)[ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_55 $$ executorService.submit(new TestUntil(until) [ CD ]
Line_55 $$ executorService.submit(new TestUntil(until) -->Line_58 $$ ByteBuffer buffer = burn.poll()[ CD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_212 $$ return (n * (n + 1)) / 2[ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_16 $$ ExecutorService executorService = Executors.newFixedThreadPool(threadCount + 2)[ CD ]
Line_41 $$ ByteBuffer buffer = BufferPool.tryGet(BufferPool.CHUNK_SIZE)-->Line_59 $$ if (buffer == null) [ FD ]
Line_35 $$ if (burn.exhausted)-->Line_36 $$ count = 0[ CD ]
Line_191 $$ int sampleIndex = rand.nextInt(sampleRange)-->Line_198 $$ if (sampleIndex >= baseSampleIndex) [ FD ]
Line_41 $$ ByteBuffer buffer = BufferPool.tryGet(BufferPool.CHUNK_SIZE)-->Line_42 $$ if (buffer == null) [ FD ]
Line_118 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_120 $$ size = 0[ FD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_175 $$ ByteBuffer buffer = BufferPool.get(size)[ FD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_179 $$ assertEquals(0, buffer.position())[ CD ]
Line_98 $$ while (totalSize > currentTargetSize - freeingSize) -->Line_119 $$ if (size > BufferPool.CHUNK_SIZE)[ CD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_157 $$ while (checks.size() > 0) [ CD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_98 $$ while (totalSize > currentTargetSize - freeingSize) [ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_217 $$ while (!latch.await(10L, TimeUnit.SECONDS)) [ CD ]
Line_158 $$ BufferCheck check = checks.get(0)-->Line_229 $$ check.validate()[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_7 $$ System.out.println(String.format("%s - testing %d threads for %dm", dateFormat.format(new Date()), threadCount, TimeUnit.NANOSECONDS.toMinutes(duration)))[ CD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_180 $$ check.init()[ CD ]
Line_124 $$ freeingSize += size-->Line_104 $$ totalSize -= freeingSize[ FD ]
Line_136 $$ totalSize += BufferPool.roundUpNormal(size)-->Line_146 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_176 $$ assertNotNull(buffer)[ CD ]
Line_118 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_143 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))[ FD ]
Line_194 $$ int index = size / 2-->Line_201 $$ index += moveBy[ FD ]
Line_203 $$ index -= moveBy-->Line_196 $$ int baseSampleIndex = sum1toN(index)[ FD ]
Line_104 $$ totalSize -= freeingSize-->Line_136 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_35 $$ if (burn.exhausted)-->Line_38 $$ Thread.yield()[ CD ]
Line_143 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_178 $$ assertEquals(size, buffer.capacity())[ FD ]
Line_58 $$ ByteBuffer buffer = burn.poll()-->Line_59 $$ if (buffer == null) [ FD ]
Line_107 $$ if (++spinCount > 1000 && System.nanoTime() > until)-->Line_108 $$ return[ CD ]
Line_118 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_137 $$ allocate(size)[ FD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_91 $$ if (!makingProgress[threadIdx].get())[ CD ]
Line_120 $$ size = 0-->Line_144 $$ if (size <= BufferPool.CHUNK_SIZE) [ FD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_162 $$ latch.countDown()[ CD ]
Line_16 $$ ExecutorService executorService = Executors.newFixedThreadPool(threadCount + 2)-->Line_55 $$ executorService.submit(new TestUntil(until) [ FD ]
Line_12 $$ for (int i = 0; i < sharedRecycle.length; i++) -->Line_14 $$ makingProgress[i] = new AtomicBoolean(true)[ CD ]
Line_143 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_175 $$ ByteBuffer buffer = BufferPool.get(size)[ FD ]
Line_135 $$ if (size <= BufferPool.CHUNK_SIZE) -->Line_138 $$ if (rand.nextBoolean()) [ CD ]
Line_105 $$ freeingSize = 0-->Line_104 $$ totalSize -= freeingSize[ FD ]
Line_221 $$ for (AtomicBoolean progress : makingProgress) -->Line_222 $$ assert progress.get()[ FD ]
Line_71 $$ for (int t = 0; t < threadCount; t++) -->Line_74 $$ ret.add(executorService.submit(new TestUntil(until) [ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_6 $$ final DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss")[ CD ]
Line_59 $$ if (buffer == null) -->Line_61 $$ return[ CD ]
Line_197 $$ int endOfSampleIndex = sum1toN(index + 1)-->Line_199 $$ if (sampleIndex < endOfSampleIndex)[ FD ]
Line_143 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_146 $$ totalSize += BufferPool.roundUpNormal(size)[ FD ]
Line_41 $$ ByteBuffer buffer = BufferPool.tryGet(BufferPool.CHUNK_SIZE)-->Line_176 $$ assertNotNull(buffer)[ FD ]
Line_16 $$ ExecutorService executorService = Executors.newFixedThreadPool(threadCount + 2)-->Line_233 $$ assertEquals(0, executorService.shutdownNow().size())[ FD ]
Line_175 $$ ByteBuffer buffer = BufferPool.get(size)-->Line_176 $$ assertNotNull(buffer)[ FD ]
Line_29 $$ executorService.submit(new TestUntil(until) -->Line_41 $$ ByteBuffer buffer = BufferPool.tryGet(BufferPool.CHUNK_SIZE)[ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_9 $$ final CountDownLatch latch = new CountDownLatch(threadCount)[ CD ]
Line_143 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))-->Line_145 $$ allocate(size)[ FD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_166 $$ BufferCheck check = shareFrom.poll()[ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_28 $$ final CountDownLatch doneAdd = new CountDownLatch(1)[ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_17 $$ List<Future<Boolean>> ret = new ArrayList(threadCount)[ CD ]
Line_59 $$ if (buffer == null) -->Line_60 $$ Thread.yield()[ CD ]
Line_118 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_145 $$ allocate(size)[ FD ]
Line_175 $$ ByteBuffer buffer = BufferPool.get(size)-->Line_178 $$ assertEquals(size, buffer.capacity())[ FD ]
Line_195 $$ while (true) -->Line_198 $$ if (sampleIndex >= baseSampleIndex) [ CD ]
Line_120 $$ size = 0-->Line_119 $$ if (size > BufferPool.CHUNK_SIZE)[ FD ]
Line_120 $$ size = 0-->Line_175 $$ ByteBuffer buffer = BufferPool.get(size)[ FD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_167 $$ if (check == null)[ CD ]
Line_144 $$ if (size <= BufferPool.CHUNK_SIZE) -->Line_146 $$ totalSize += BufferPool.roundUpNormal(size)[ CD ]
Line_6 $$ final DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss")-->Line_7 $$ System.out.println(String.format("%s - testing %d threads for %dm", dateFormat.format(new Date()), threadCount, TimeUnit.NANOSECONDS.toMinutes(duration)))[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_3 $$ final int avgBufferSize = 16 << 10[ CD ]
Line_118 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())-->Line_139 $$ allocate(size)[ FD ]
Line_198 $$ if (sampleIndex >= baseSampleIndex) -->Line_199 $$ if (sampleIndex < endOfSampleIndex)[ CD ]
Line_194 $$ int index = size / 2-->Line_208 $$ return checks.get(index)[ FD ]
Line_28 $$ final CountDownLatch doneAdd = new CountDownLatch(1)-->Line_52 $$ doneAdd.countDown()[ FD ]
Line_204 $$ moveBy = Math.max(moveBy / 2, 1)-->Line_203 $$ index -= moveBy[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_19 $$ BufferPool.MEMORY_USAGE_THRESHOLD = poolSize[ FD ]
Line_166 $$ BufferCheck check = shareFrom.poll()-->Line_167 $$ if (check == null)[ FD ]
Line_177 $$ BufferCheck check = new BufferCheck(buffer, rand.nextLong())-->Line_181 $$ check.listnode = checks.append(check)[ FD ]
Line_98 $$ while (totalSize > currentTargetSize - freeingSize) -->Line_117 $$ check.validate()[ CD ]
Line_166 $$ BufferCheck check = shareFrom.poll()-->Line_180 $$ check.init()[ FD ]
Line_41 $$ ByteBuffer buffer = BufferPool.tryGet(BufferPool.CHUNK_SIZE)-->Line_178 $$ assertEquals(size, buffer.capacity())[ FD ]
Line_58 $$ ByteBuffer buffer = burn.poll()-->Line_63 $$ BufferPool.put(buffer)[ FD ]
Line_167 $$ if (check == null)-->Line_168 $$ return false[ CD ]
Line_36 $$ count = 0-->Line_48 $$ count++[ FD ]
Line_41 $$ ByteBuffer buffer = BufferPool.tryGet(BufferPool.CHUNK_SIZE)-->Line_46 $$ BufferPool.put(buffer)[ FD ]
Line_120 $$ size = 0-->Line_145 $$ allocate(size)[ FD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_10 $$ final SPSCQueue<BufferCheck>[] sharedRecycle = new SPSCQueue[threadCount][ CD ]
Line_98 $$ while (totalSize > currentTargetSize - freeingSize) -->Line_118 $$ size = BufferPool.roundUpNormal(check.buffer.capacity())[ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_20 $$ BufferPool.DEBUG = true[ CD ]
Line_2 $$ public void testAllocate(int threadCount, long duration, int poolSize) throws InterruptedException, ExecutionException -->Line_71 $$ for (int t = 0; t < threadCount; t++) [ FD ]
Line_120 $$ size = 0-->Line_143 $$ size = (int) Math.max(1, avgBufferSize + (stdevBufferSize * rand.nextGaussian()))[ FD ]
Line_41 $$ ByteBuffer buffer = BufferPool.tryGet(BufferPool.CHUNK_SIZE)-->Line_47 $$ burn.add(buffer)[ FD ]
Line_74 $$ ret.add(executorService.submit(new TestUntil(until) -->Line_135 $$ if (size <= BufferPool.CHUNK_SIZE) [ CD ]
