Line_25 $$ if (!alreadyVisited) -->Line_46 $$ path.push(taskNode)[ CD ]
Line_25 $$ if (!alreadyVisited) -->Line_48 $$ nodeQueue.remove(0)[ CD ]
Line_17 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_20 $$ maybeRemoveProcessedShouldRunAfterEdge(walkedShouldRunAfterEdges, taskNode)[ FD ]
Line_2 $$ public void determineExecutionPlan() -->Line_61 $$ executionQueue.clear()[ CD ]
Line_31 $$ for (TaskInfo successor : successors) -->Line_32 $$ if (visitingNodes.containsEntry(successor, currentSegment)) [ FD ]
Line_18 $$ if (taskNode.isIncludeInGraph() || executionPlan.containsKey(taskNode.getTask())) -->Line_20 $$ maybeRemoveProcessedShouldRunAfterEdge(walkedShouldRunAfterEdges, taskNode)[ CD ]
Line_2 $$ public void determineExecutionPlan() -->Line_14 $$ while (!nodeQueue.isEmpty()) [ CD ]
Line_2 $$ public void determineExecutionPlan() -->Line_9 $$ int visitingSegmentCounter = nodeQueue.size()[ CD ]
Line_14 $$ while (!nodeQueue.isEmpty()) -->Line_23 $$ boolean alreadyVisited = visitingNodes.containsKey(taskNode)[ CD ]
Line_14 $$ while (!nodeQueue.isEmpty()) -->Line_16 $$ int currentSegment = taskInfoInVisitingSegment.visitingSegment[ CD ]
Line_34 $$ GraphEdge toBeRemoved = walkedShouldRunAfterEdges.pop()-->Line_38 $$ restoreExecutionPlan(planBeforeVisiting, toBeRemoved)[ FD ]
Line_25 $$ if (!alreadyVisited) -->Line_50 $$ path.pop()[ CD ]
Line_17 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_51 $$ executionPlan.put(taskNode.getTask(), taskNode)[ FD ]
Line_14 $$ while (!nodeQueue.isEmpty()) -->Line_15 $$ TaskInfoInVisitingSegment taskInfoInVisitingSegment = nodeQueue.get(0)[ CD ]
Line_25 $$ if (!alreadyVisited) -->Line_52 $$ ArrayList<TaskInfo> finalizerTasks = new ArrayList<TaskInfo>()[ CD ]
Line_17 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_30 $$ addAllSuccessorsInReverseOrder(taskNode, successors)[ FD ]
Line_2 $$ public void determineExecutionPlan() -->Line_3 $$ List<TaskInfoInVisitingSegment> nodeQueue = Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() [ CD ]
Line_3 $$ List<TaskInfoInVisitingSegment> nodeQueue = Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() -->Line_9 $$ int visitingSegmentCounter = nodeQueue.size()[ FD ]
Line_25 $$ if (!alreadyVisited) -->Line_53 $$ addAllReversed(finalizerTasks, taskNode.getFinalizers())[ CD ]
Line_54 $$ for (TaskInfo finalizer : finalizerTasks) -->Line_56 $$ nodeQueue.add(finalizerTaskPosition(finalizer, nodeQueue), new TaskInfoInVisitingSegment(finalizer, visitingSegmentCounter++))[ FD ]
Line_25 $$ if (!alreadyVisited) -->Line_27 $$ removeShouldRunAfterSuccessorsIfTheyImposeACycle(visitingNodes, taskInfoInVisitingSegment)[ CD ]
Line_29 $$ ArrayList<TaskInfo> successors = new ArrayList<TaskInfo>()-->Line_30 $$ addAllSuccessorsInReverseOrder(taskNode, successors)[ FD ]
Line_17 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_24 $$ visitingNodes.put(taskNode, currentSegment)[ FD ]
Line_3 $$ List<TaskInfoInVisitingSegment> nodeQueue = Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() -->Line_44 $$ nodeQueue.add(0, new TaskInfoInVisitingSegment(successor, currentSegment))[ FD ]
Line_14 $$ while (!nodeQueue.isEmpty()) -->Line_24 $$ visitingNodes.put(taskNode, currentSegment)[ CD ]
Line_3 $$ List<TaskInfoInVisitingSegment> nodeQueue = Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() -->Line_56 $$ nodeQueue.add(finalizerTaskPosition(finalizer, nodeQueue), new TaskInfoInVisitingSegment(finalizer, visitingSegmentCounter++))[ FD ]
Line_3 $$ List<TaskInfoInVisitingSegment> nodeQueue = Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() -->Line_15 $$ TaskInfoInVisitingSegment taskInfoInVisitingSegment = nodeQueue.get(0)[ FD ]
Line_34 $$ GraphEdge toBeRemoved = walkedShouldRunAfterEdges.pop()-->Line_37 $$ restoreQueue(nodeQueue, visitingNodes, toBeRemoved)[ FD ]
Line_33 $$ if (!walkedShouldRunAfterEdges.empty()) -->Line_38 $$ restoreExecutionPlan(planBeforeVisiting, toBeRemoved)[ CD ]
Line_32 $$ if (visitingNodes.containsEntry(successor, currentSegment)) -->Line_33 $$ if (!walkedShouldRunAfterEdges.empty()) [ CD ]
Line_3 $$ List<TaskInfoInVisitingSegment> nodeQueue = Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() -->Line_19 $$ nodeQueue.remove(0)[ FD ]
Line_23 $$ boolean alreadyVisited = visitingNodes.containsKey(taskNode)-->Line_25 $$ if (!alreadyVisited) [ FD ]
Line_17 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_49 $$ visitingNodes.remove(taskNode, currentSegment)[ FD ]
Line_52 $$ ArrayList<TaskInfo> finalizerTasks = new ArrayList<TaskInfo>()-->Line_53 $$ addAllReversed(finalizerTasks, taskNode.getFinalizers())[ FD ]
Line_17 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_23 $$ boolean alreadyVisited = visitingNodes.containsKey(taskNode)[ FD ]
Line_17 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_26 $$ recordEdgeIfArrivedViaShouldRunAfter(walkedShouldRunAfterEdges, path, taskNode)[ FD ]
Line_25 $$ if (!alreadyVisited) -->Line_29 $$ ArrayList<TaskInfo> successors = new ArrayList<TaskInfo>()[ CD ]
Line_16 $$ int currentSegment = taskInfoInVisitingSegment.visitingSegment-->Line_32 $$ if (visitingNodes.containsEntry(successor, currentSegment)) [ FD ]
Line_54 $$ for (TaskInfo finalizer : finalizerTasks) -->Line_55 $$ if (!visitingNodes.containsKey(finalizer)) [ FD ]
Line_55 $$ if (!visitingNodes.containsKey(finalizer)) -->Line_56 $$ nodeQueue.add(finalizerTaskPosition(finalizer, nodeQueue), new TaskInfoInVisitingSegment(finalizer, visitingSegmentCounter++))[ CD ]
Line_25 $$ if (!alreadyVisited) -->Line_51 $$ executionPlan.put(taskNode.getTask(), taskNode)[ CD ]
Line_17 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_28 $$ takePlanSnapshotIfCanBeRestoredToCurrentTask(planBeforeVisiting, taskNode)[ FD ]
Line_16 $$ int currentSegment = taskInfoInVisitingSegment.visitingSegment-->Line_24 $$ visitingNodes.put(taskNode, currentSegment)[ FD ]
Line_15 $$ TaskInfoInVisitingSegment taskInfoInVisitingSegment = nodeQueue.get(0)-->Line_27 $$ removeShouldRunAfterSuccessorsIfTheyImposeACycle(visitingNodes, taskInfoInVisitingSegment)[ FD ]
Line_33 $$ if (!walkedShouldRunAfterEdges.empty()) -->Line_41 $$ onOrderingCycle()[ CD ]
Line_14 $$ while (!nodeQueue.isEmpty()) -->Line_25 $$ if (!alreadyVisited) [ CD ]
Line_33 $$ if (!walkedShouldRunAfterEdges.empty()) -->Line_37 $$ restoreQueue(nodeQueue, visitingNodes, toBeRemoved)[ CD ]
Line_3 $$ List<TaskInfoInVisitingSegment> nodeQueue = Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() -->Line_37 $$ restoreQueue(nodeQueue, visitingNodes, toBeRemoved)[ FD ]
Line_3 $$ List<TaskInfoInVisitingSegment> nodeQueue = Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() -->Line_14 $$ while (!nodeQueue.isEmpty()) [ FD ]
Line_3 $$ List<TaskInfoInVisitingSegment> nodeQueue = Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() -->Line_6 $$ return new TaskInfoInVisitingSegment(taskInfo, index++)[ CD ]
Line_2 $$ public void determineExecutionPlan() -->Line_10 $$ HashMultimap<TaskInfo, Integer> visitingNodes = HashMultimap.create()[ CD ]
Line_14 $$ while (!nodeQueue.isEmpty()) -->Line_17 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo[ CD ]
Line_34 $$ GraphEdge toBeRemoved = walkedShouldRunAfterEdges.pop()-->Line_36 $$ restorePath(path, toBeRemoved)[ FD ]
Line_25 $$ if (!alreadyVisited) -->Line_49 $$ visitingNodes.remove(taskNode, currentSegment)[ CD ]
Line_18 $$ if (taskNode.isIncludeInGraph() || executionPlan.containsKey(taskNode.getTask())) -->Line_19 $$ nodeQueue.remove(0)[ CD ]
Line_17 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_18 $$ if (taskNode.isIncludeInGraph() || executionPlan.containsKey(taskNode.getTask())) [ FD ]
Line_33 $$ if (!walkedShouldRunAfterEdges.empty()) -->Line_34 $$ GraphEdge toBeRemoved = walkedShouldRunAfterEdges.pop()[ CD ]
Line_33 $$ if (!walkedShouldRunAfterEdges.empty()) -->Line_35 $$ toBeRemoved.from.removeShouldRunAfterSuccessor(toBeRemoved.to)[ CD ]
Line_3 $$ List<TaskInfoInVisitingSegment> nodeQueue = Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() -->Line_48 $$ nodeQueue.remove(0)[ FD ]
Line_17 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_46 $$ path.push(taskNode)[ FD ]
Line_17 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_53 $$ addAllReversed(finalizerTasks, taskNode.getFinalizers())[ FD ]
Line_2 $$ public void determineExecutionPlan() -->Line_62 $$ executionQueue.addAll(executionPlan.values())[ CD ]
Line_25 $$ if (!alreadyVisited) -->Line_28 $$ takePlanSnapshotIfCanBeRestoredToCurrentTask(planBeforeVisiting, taskNode)[ CD ]
Line_25 $$ if (!alreadyVisited) -->Line_26 $$ recordEdgeIfArrivedViaShouldRunAfter(walkedShouldRunAfterEdges, path, taskNode)[ CD ]
Line_16 $$ int currentSegment = taskInfoInVisitingSegment.visitingSegment-->Line_49 $$ visitingNodes.remove(taskNode, currentSegment)[ FD ]
Line_14 $$ while (!nodeQueue.isEmpty()) -->Line_18 $$ if (taskNode.isIncludeInGraph() || executionPlan.containsKey(taskNode.getTask())) [ CD ]
Line_25 $$ if (!alreadyVisited) -->Line_30 $$ addAllSuccessorsInReverseOrder(taskNode, successors)[ CD ]
Line_33 $$ if (!walkedShouldRunAfterEdges.empty()) -->Line_36 $$ restorePath(path, toBeRemoved)[ CD ]
