Line_18 $$ int currentSegment = taskInfoInVisitingSegment.visitingSegment-->Line_55 $$ visitingNodes.remove(taskNode, currentSegment)[ FD ]
Line_35 $$ for (TaskInfo successor : successors) -->Line_36 $$ if (visitingNodes.containsEntry(successor, currentSegment)) [ FD ]
Line_3 $$ List<TaskInfoInVisitingSegment> nodeQueue = Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() -->Line_17 $$ TaskInfoInVisitingSegment taskInfoInVisitingSegment = nodeQueue.get(0)[ FD ]
Line_37 $$ if (!walkedShouldRunAfterEdges.empty()) -->Line_41 $$ restorePath(path, toBeRemoved)[ CD ]
Line_16 $$ while (!nodeQueue.isEmpty()) -->Line_20 $$ if (taskNode.isIncludeInGraph() || executionPlan.containsKey(taskNode.getTask())) [ CD ]
Line_16 $$ while (!nodeQueue.isEmpty()) -->Line_27 $$ if (!alreadyVisited) [ CD ]
Line_2 $$ public void determineExecutionPlan() -->Line_12 $$ HashMultimap<TaskInfo, Integer> visitingNodes = HashMultimap.create()[ CD ]
Line_27 $$ if (!alreadyVisited) -->Line_34 $$ addAllSuccessorsInReverseOrder(taskNode, successors)[ CD ]
Line_2 $$ public void determineExecutionPlan() -->Line_11 $$ int visitingSegmentCounter = nodeQueue.size()[ CD ]
Line_2 $$ public void determineExecutionPlan() -->Line_16 $$ while (!nodeQueue.isEmpty()) [ CD ]
Line_16 $$ while (!nodeQueue.isEmpty()) -->Line_18 $$ int currentSegment = taskInfoInVisitingSegment.visitingSegment[ CD ]
Line_16 $$ while (!nodeQueue.isEmpty()) -->Line_19 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo[ CD ]
Line_19 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_34 $$ addAllSuccessorsInReverseOrder(taskNode, successors)[ FD ]
Line_3 $$ List<TaskInfoInVisitingSegment> nodeQueue = Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() -->Line_21 $$ nodeQueue.remove(0)[ FD ]
Line_61 $$ for (TaskInfo finalizer : finalizerTasks) -->Line_62 $$ if (!visitingNodes.containsKey(finalizer)) [ FD ]
Line_3 $$ List<TaskInfoInVisitingSegment> nodeQueue = Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() -->Line_16 $$ while (!nodeQueue.isEmpty()) [ FD ]
Line_19 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_32 $$ takePlanSnapshotIfCanBeRestoredToCurrentTask(planBeforeVisiting, taskNode)[ FD ]
Line_3 $$ List<TaskInfoInVisitingSegment> nodeQueue = Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() -->Line_11 $$ int visitingSegmentCounter = nodeQueue.size()[ FD ]
Line_37 $$ if (!walkedShouldRunAfterEdges.empty()) -->Line_42 $$ restoreQueue(nodeQueue, visitingNodes, toBeRemoved)[ CD ]
Line_18 $$ int currentSegment = taskInfoInVisitingSegment.visitingSegment-->Line_26 $$ visitingNodes.put(taskNode, currentSegment)[ FD ]
Line_16 $$ while (!nodeQueue.isEmpty()) -->Line_25 $$ boolean alreadyVisited = visitingNodes.containsKey(taskNode)[ CD ]
Line_19 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_60 $$ addAllReversed(finalizerTasks, taskNode.getFinalizers())[ FD ]
Line_27 $$ if (!alreadyVisited) -->Line_33 $$ ArrayList<TaskInfo> successors = new ArrayList<TaskInfo>()[ CD ]
Line_27 $$ if (!alreadyVisited) -->Line_55 $$ visitingNodes.remove(taskNode, currentSegment)[ CD ]
Line_37 $$ if (!walkedShouldRunAfterEdges.empty()) -->Line_46 $$ onOrderingCycle()[ CD ]
Line_2 $$ public void determineExecutionPlan() -->Line_3 $$ List<TaskInfoInVisitingSegment> nodeQueue = Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() [ CD ]
Line_19 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_51 $$ path.push(taskNode)[ FD ]
Line_2 $$ public void determineExecutionPlan() -->Line_69 $$ executionQueue.addAll(executionPlan.values())[ CD ]
Line_16 $$ while (!nodeQueue.isEmpty()) -->Line_26 $$ visitingNodes.put(taskNode, currentSegment)[ CD ]
Line_3 $$ List<TaskInfoInVisitingSegment> nodeQueue = Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() -->Line_49 $$ nodeQueue.add(0, new TaskInfoInVisitingSegment(successor, currentSegment))[ FD ]
Line_27 $$ if (!alreadyVisited) -->Line_51 $$ path.push(taskNode)[ CD ]
Line_36 $$ if (visitingNodes.containsEntry(successor, currentSegment)) -->Line_37 $$ if (!walkedShouldRunAfterEdges.empty()) [ CD ]
Line_25 $$ boolean alreadyVisited = visitingNodes.containsKey(taskNode)-->Line_27 $$ if (!alreadyVisited) [ FD ]
Line_3 $$ List<TaskInfoInVisitingSegment> nodeQueue = Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() -->Line_42 $$ restoreQueue(nodeQueue, visitingNodes, toBeRemoved)[ FD ]
Line_20 $$ if (taskNode.isIncludeInGraph() || executionPlan.containsKey(taskNode.getTask())) -->Line_22 $$ maybeRemoveProcessedShouldRunAfterEdge(walkedShouldRunAfterEdges, taskNode)[ CD ]
Line_19 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_25 $$ boolean alreadyVisited = visitingNodes.containsKey(taskNode)[ FD ]
Line_27 $$ if (!alreadyVisited) -->Line_31 $$ removeShouldRunAfterSuccessorsIfTheyImposeACycle(visitingNodes, taskInfoInVisitingSegment)[ CD ]
Line_17 $$ TaskInfoInVisitingSegment taskInfoInVisitingSegment = nodeQueue.get(0)-->Line_31 $$ removeShouldRunAfterSuccessorsIfTheyImposeACycle(visitingNodes, taskInfoInVisitingSegment)[ FD ]
Line_3 $$ List<TaskInfoInVisitingSegment> nodeQueue = Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() -->Line_63 $$ nodeQueue.add(finalizerTaskPosition(finalizer, nodeQueue), new TaskInfoInVisitingSegment(finalizer, visitingSegmentCounter++))[ FD ]
Line_3 $$ List<TaskInfoInVisitingSegment> nodeQueue = Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() -->Line_8 $$ return new TaskInfoInVisitingSegment(taskInfo, index++)[ CD ]
Line_27 $$ if (!alreadyVisited) -->Line_60 $$ addAllReversed(finalizerTasks, taskNode.getFinalizers())[ CD ]
Line_37 $$ if (!walkedShouldRunAfterEdges.empty()) -->Line_43 $$ restoreExecutionPlan(planBeforeVisiting, toBeRemoved)[ CD ]
Line_27 $$ if (!alreadyVisited) -->Line_56 $$ path.pop()[ CD ]
Line_2 $$ public void determineExecutionPlan() -->Line_68 $$ executionQueue.clear()[ CD ]
Line_18 $$ int currentSegment = taskInfoInVisitingSegment.visitingSegment-->Line_36 $$ if (visitingNodes.containsEntry(successor, currentSegment)) [ FD ]
Line_27 $$ if (!alreadyVisited) -->Line_32 $$ takePlanSnapshotIfCanBeRestoredToCurrentTask(planBeforeVisiting, taskNode)[ CD ]
Line_61 $$ for (TaskInfo finalizer : finalizerTasks) -->Line_63 $$ nodeQueue.add(finalizerTaskPosition(finalizer, nodeQueue), new TaskInfoInVisitingSegment(finalizer, visitingSegmentCounter++))[ FD ]
Line_37 $$ if (!walkedShouldRunAfterEdges.empty()) -->Line_40 $$ toBeRemoved.from.removeShouldRunAfterSuccessor(toBeRemoved.to)[ CD ]
Line_19 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_20 $$ if (taskNode.isIncludeInGraph() || executionPlan.containsKey(taskNode.getTask())) [ FD ]
Line_19 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_57 $$ executionPlan.put(taskNode.getTask(), taskNode)[ FD ]
Line_19 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_22 $$ maybeRemoveProcessedShouldRunAfterEdge(walkedShouldRunAfterEdges, taskNode)[ FD ]
Line_27 $$ if (!alreadyVisited) -->Line_57 $$ executionPlan.put(taskNode.getTask(), taskNode)[ CD ]
Line_33 $$ ArrayList<TaskInfo> successors = new ArrayList<TaskInfo>()-->Line_34 $$ addAllSuccessorsInReverseOrder(taskNode, successors)[ FD ]
Line_16 $$ while (!nodeQueue.isEmpty()) -->Line_17 $$ TaskInfoInVisitingSegment taskInfoInVisitingSegment = nodeQueue.get(0)[ CD ]
Line_19 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_55 $$ visitingNodes.remove(taskNode, currentSegment)[ FD ]
Line_62 $$ if (!visitingNodes.containsKey(finalizer)) -->Line_63 $$ nodeQueue.add(finalizerTaskPosition(finalizer, nodeQueue), new TaskInfoInVisitingSegment(finalizer, visitingSegmentCounter++))[ CD ]
Line_19 $$ TaskInfo taskNode = taskInfoInVisitingSegment.taskInfo-->Line_26 $$ visitingNodes.put(taskNode, currentSegment)[ FD ]
Line_20 $$ if (taskNode.isIncludeInGraph() || executionPlan.containsKey(taskNode.getTask())) -->Line_21 $$ nodeQueue.remove(0)[ CD ]
