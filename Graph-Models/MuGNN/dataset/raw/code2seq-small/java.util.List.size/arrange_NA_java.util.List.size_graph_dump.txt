Line_36 $$ if (entry.canBeMatched() && rule.getMatcher().isMatched(entry)) -->Line_37 $$ elementsByRule.putValue(rule, entry)[ CD ]
Line_17 $$ for (E entry : entries) -->Line_38 $$ matched.add(entry)[ FD ]
Line_33 $$ for (ArrangementMatchRule rule : rulesByPriority) -->Line_36 $$ if (entry.canBeMatched() && rule.getMatcher().isMatched(entry)) [ FD ]
Line_55 $$ E e = arranged.get(i)-->Line_67 $$ final ArrangementSectionRule rule = entryToSection.get(e)[ FD ]
Line_17 $$ for (E entry : entries) -->Line_27 $$ dependent.add(Pair.create(first, entry))[ FD ]
Line_31 $$ Set<E> matched = new HashSet<E>()-->Line_38 $$ matched.add(entry)[ FD ]
Line_19 $$ if (dependencies == null) -->Line_22 $$ if (dependencies.size() == 1 && dependencies.get(0) == entry.getParent()) [ CD ]
Line_33 $$ for (ArrangementMatchRule rule : rulesByPriority) -->Line_45 $$ final Collection<E> arrangedEntries = arrangeByRule(arranged, elementsByRule, rule)[ FD ]
Line_32 $$ MultiMap<ArrangementMatchRule, E> elementsByRule = new MultiMap<ArrangementMatchRule, E>()-->Line_37 $$ elementsByRule.putValue(rule, entry)[ FD ]
Line_22 $$ if (dependencies.size() == 1 && dependencies.get(0) == entry.getParent()) -->Line_26 $$ Set<ArrangementEntry> first = new HashSet<ArrangementEntry>(dependencies)[ CD ]
Line_32 $$ MultiMap<ArrangementMatchRule, E> elementsByRule = new MultiMap<ArrangementMatchRule, E>()-->Line_45 $$ final Collection<E> arrangedEntries = arrangeByRule(arranged, elementsByRule, rule)[ FD ]
Line_26 $$ Set<ArrangementEntry> first = new HashSet<ArrangementEntry>(dependencies)-->Line_27 $$ dependent.add(Pair.create(first, entry))[ FD ]
Line_15 $$ Set<E> unprocessed = ContainerUtilRt.newLinkedHashSet()-->Line_41 $$ unprocessed.removeAll(matched)[ FD ]
Line_17 $$ for (E entry : entries) -->Line_20 $$ unprocessed.add(entry)[ FD ]
Line_57 $$ for (Iterator<Pair<Set<ArrangementEntry>, E>> iterator = dependent.iterator(); iterator.hasNext(); ) -->Line_58 $$ Pair<Set<ArrangementEntry>, E> pair = iterator.next()[ FD ]
Line_14 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_54 $$ for (int i = 0; i < arranged.size() && !dependent.isEmpty(); i++) [ FD ]
Line_18 $$ List<? extends ArrangementEntry> dependencies = entry.getDependencies()-->Line_19 $$ if (dependencies == null) [ FD ]
Line_16 $$ List<Pair<Set<ArrangementEntry>, E>> dependent = ContainerUtilRt.newArrayList()-->Line_54 $$ for (int i = 0; i < arranged.size() && !dependent.isEmpty(); i++) [ FD ]
Line_54 $$ for (int i = 0; i < arranged.size() && !dependent.isEmpty(); i++) -->Line_57 $$ for (Iterator<Pair<Set<ArrangementEntry>, E>> iterator = dependent.iterator(); iterator.hasNext(); ) [ CD ]
Line_17 $$ for (E entry : entries) -->Line_36 $$ if (entry.canBeMatched() && rule.getMatcher().isMatched(entry)) [ FD ]
Line_54 $$ for (int i = 0; i < arranged.size() && !dependent.isEmpty(); i++) -->Line_72 $$ arranged.addAll(i + 1, shouldBeAddedAfterCurrentElement)[ CD ]
Line_54 $$ for (int i = 0; i < arranged.size() && !dependent.isEmpty(); i++) -->Line_55 $$ E e = arranged.get(i)[ CD ]
Line_18 $$ List<? extends ArrangementEntry> dependencies = entry.getDependencies()-->Line_22 $$ if (dependencies.size() == 1 && dependencies.get(0) == entry.getParent()) [ FD ]
Line_54 $$ for (int i = 0; i < arranged.size() && !dependent.isEmpty(); i++) -->Line_56 $$ List<E> shouldBeAddedAfterCurrentElement = ContainerUtil.newArrayList()[ CD ]
Line_60 $$ if (pair.first.isEmpty()) -->Line_62 $$ shouldBeAddedAfterCurrentElement.add(pair.second)[ CD ]
Line_15 $$ Set<E> unprocessed = ContainerUtilRt.newLinkedHashSet()-->Line_20 $$ unprocessed.add(entry)[ FD ]
Line_17 $$ for (E entry : entries) -->Line_48 $$ entryToSection.put(entry, sectionRule)[ FD ]
Line_57 $$ for (Iterator<Pair<Set<ArrangementEntry>, E>> iterator = dependent.iterator(); iterator.hasNext(); ) -->Line_60 $$ if (pair.first.isEmpty()) [ CD ]
Line_60 $$ if (pair.first.isEmpty()) -->Line_61 $$ iterator.remove()[ CD ]
Line_31 $$ Set<E> matched = new HashSet<E>()-->Line_34 $$ matched.clear()[ FD ]
Line_55 $$ E e = arranged.get(i)-->Line_59 $$ pair.first.remove(e)[ FD ]
Line_36 $$ if (entry.canBeMatched() && rule.getMatcher().isMatched(entry)) -->Line_38 $$ matched.add(entry)[ CD ]
Line_16 $$ List<Pair<Set<ArrangementEntry>, E>> dependent = ContainerUtilRt.newArrayList()-->Line_57 $$ for (Iterator<Pair<Set<ArrangementEntry>, E>> iterator = dependent.iterator(); iterator.hasNext(); ) [ FD ]
Line_14 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_72 $$ arranged.addAll(i + 1, shouldBeAddedAfterCurrentElement)[ FD ]
Line_16 $$ List<Pair<Set<ArrangementEntry>, E>> dependent = ContainerUtilRt.newArrayList()-->Line_27 $$ dependent.add(Pair.create(first, entry))[ FD ]
Line_17 $$ for (E entry : entries) -->Line_22 $$ if (dependencies.size() == 1 && dependencies.get(0) == entry.getParent()) [ FD ]
Line_31 $$ Set<E> matched = new HashSet<E>()-->Line_41 $$ unprocessed.removeAll(matched)[ FD ]
Line_17 $$ for (E entry : entries) -->Line_37 $$ elementsByRule.putValue(rule, entry)[ FD ]
Line_33 $$ for (ArrangementMatchRule rule : rulesByPriority) -->Line_37 $$ elementsByRule.putValue(rule, entry)[ FD ]
Line_14 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_53 $$ arranged.addAll(unprocessed)[ FD ]
Line_17 $$ for (E entry : entries) -->Line_18 $$ List<? extends ArrangementEntry> dependencies = entry.getDependencies()[ FD ]
Line_19 $$ if (dependencies == null) -->Line_20 $$ unprocessed.add(entry)[ CD ]
Line_43 $$ for (ArrangementSectionRule sectionRule : sectionRules) -->Line_44 $$ for (ArrangementMatchRule rule : sectionRule.getMatchRules()) [ FD ]
Line_14 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_45 $$ final Collection<E> arrangedEntries = arrangeByRule(arranged, elementsByRule, rule)[ FD ]
Line_57 $$ for (Iterator<Pair<Set<ArrangementEntry>, E>> iterator = dependent.iterator(); iterator.hasNext(); ) -->Line_61 $$ iterator.remove()[ FD ]
Line_57 $$ for (Iterator<Pair<Set<ArrangementEntry>, E>> iterator = dependent.iterator(); iterator.hasNext(); ) -->Line_59 $$ pair.first.remove(e)[ CD ]
Line_15 $$ Set<E> unprocessed = ContainerUtilRt.newLinkedHashSet()-->Line_53 $$ arranged.addAll(unprocessed)[ FD ]
Line_57 $$ for (Iterator<Pair<Set<ArrangementEntry>, E>> iterator = dependent.iterator(); iterator.hasNext(); ) -->Line_58 $$ Pair<Set<ArrangementEntry>, E> pair = iterator.next()[ CD ]
Line_56 $$ List<E> shouldBeAddedAfterCurrentElement = ContainerUtil.newArrayList()-->Line_62 $$ shouldBeAddedAfterCurrentElement.add(pair.second)[ FD ]
Line_43 $$ for (ArrangementSectionRule sectionRule : sectionRules) -->Line_48 $$ entryToSection.put(entry, sectionRule)[ FD ]
Line_14 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_55 $$ E e = arranged.get(i)[ FD ]
Line_22 $$ if (dependencies.size() == 1 && dependencies.get(0) == entry.getParent()) -->Line_27 $$ dependent.add(Pair.create(first, entry))[ CD ]
Line_56 $$ List<E> shouldBeAddedAfterCurrentElement = ContainerUtil.newArrayList()-->Line_72 $$ arranged.addAll(i + 1, shouldBeAddedAfterCurrentElement)[ FD ]
Line_33 $$ for (ArrangementMatchRule rule : rulesByPriority) -->Line_69 $$ entryToSection.put(e1, rule)[ FD ]
Line_54 $$ for (int i = 0; i < arranged.size() && !dependent.isEmpty(); i++) -->Line_55 $$ E e = arranged.get(i)[ FD ]
