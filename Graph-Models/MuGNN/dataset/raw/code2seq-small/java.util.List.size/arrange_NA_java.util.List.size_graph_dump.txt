Line_4 $$ Set<E> unprocessed = ContainerUtilRt.newLinkedHashSet()-->Line_9 $$ unprocessed.add(entry)[ FD ]
Line_6 $$ for (E entry : entries) -->Line_25 $$ elementsByRule.putValue(rule, entry)[ FD ]
Line_21 $$ for (ArrangementMatchRule rule : rulesByPriority) -->Line_33 $$ final Collection<E> arrangedEntries = arrangeByRule(arranged, elementsByRule, rule)[ FD ]
Line_43 $$ E e = arranged.get(i)-->Line_53 $$ if (entryToSection != null && entryToSection.containsKey(e)) [ FD ]
Line_3 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_43 $$ E e = arranged.get(i)[ FD ]
Line_3 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_33 $$ final Collection<E> arrangedEntries = arrangeByRule(arranged, elementsByRule, rule)[ FD ]
Line_42 $$ for (int i = 0; i < arranged.size() && !dependent.isEmpty(); i++) -->Line_59 $$ arranged.addAll(i + 1, shouldBeAddedAfterCurrentElement)[ CD ]
Line_3 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_42 $$ for (int i = 0; i < arranged.size() && !dependent.isEmpty(); i++) [ FD ]
Line_7 $$ List<? extends ArrangementEntry> dependencies = entry.getDependencies()-->Line_8 $$ if (dependencies == null) [ FD ]
Line_2 $$ public static <E extends ArrangementEntry> List<E> arrange(@NotNull Collection<E> entries, @NotNull List<ArrangementSectionRule> sectionRules, @NotNull List<? extends ArrangementMatchRule> rulesByPriority, @Nullable Map<E, ArrangementSectionRule> entryToSection) -->Line_54 $$ final ArrangementSectionRule rule = entryToSection.get(e)[ FD ]
Line_42 $$ for (int i = 0; i < arranged.size() && !dependent.isEmpty(); i++) -->Line_43 $$ E e = arranged.get(i)[ CD ]
Line_5 $$ List<Pair<Set<ArrangementEntry>, E>> dependent = ContainerUtilRt.newArrayList()-->Line_45 $$ for (Iterator<Pair<Set<ArrangementEntry>, E>> iterator = dependent.iterator(); iterator.hasNext(); ) [ FD ]
Line_45 $$ for (Iterator<Pair<Set<ArrangementEntry>, E>> iterator = dependent.iterator(); iterator.hasNext(); ) -->Line_47 $$ pair.first.remove(e)[ CD ]
Line_7 $$ List<? extends ArrangementEntry> dependencies = entry.getDependencies()-->Line_11 $$ if (dependencies.size() == 1 && dependencies.get(0) == entry.getParent()) [ FD ]
Line_45 $$ for (Iterator<Pair<Set<ArrangementEntry>, E>> iterator = dependent.iterator(); iterator.hasNext(); ) -->Line_46 $$ Pair<Set<ArrangementEntry>, E> pair = iterator.next()[ FD ]
Line_19 $$ Set<E> matched = new HashSet<E>()-->Line_29 $$ unprocessed.removeAll(matched)[ FD ]
Line_44 $$ List<E> shouldBeAddedAfterCurrentElement = ContainerUtil.newArrayList()-->Line_59 $$ arranged.addAll(i + 1, shouldBeAddedAfterCurrentElement)[ FD ]
Line_4 $$ Set<E> unprocessed = ContainerUtilRt.newLinkedHashSet()-->Line_29 $$ unprocessed.removeAll(matched)[ FD ]
Line_45 $$ for (Iterator<Pair<Set<ArrangementEntry>, E>> iterator = dependent.iterator(); iterator.hasNext(); ) -->Line_49 $$ iterator.remove()[ FD ]
Line_48 $$ if (pair.first.isEmpty()) -->Line_50 $$ shouldBeAddedAfterCurrentElement.add(pair.second)[ CD ]
Line_3 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_59 $$ arranged.addAll(i + 1, shouldBeAddedAfterCurrentElement)[ FD ]
Line_19 $$ Set<E> matched = new HashSet<E>()-->Line_22 $$ matched.clear()[ FD ]
Line_6 $$ for (E entry : entries) -->Line_36 $$ entryToSection.put(entry, sectionRule)[ FD ]
Line_3 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_12 $$ arranged.add(entry)[ FD ]
Line_14 $$ Set<ArrangementEntry> first = new HashSet<ArrangementEntry>(dependencies)-->Line_15 $$ dependent.add(Pair.create(first, entry))[ FD ]
Line_20 $$ MultiMap<ArrangementMatchRule, E> elementsByRule = new MultiMap<ArrangementMatchRule, E>()-->Line_33 $$ final Collection<E> arrangedEntries = arrangeByRule(arranged, elementsByRule, rule)[ FD ]
Line_45 $$ for (Iterator<Pair<Set<ArrangementEntry>, E>> iterator = dependent.iterator(); iterator.hasNext(); ) -->Line_46 $$ Pair<Set<ArrangementEntry>, E> pair = iterator.next()[ CD ]
Line_2 $$ public static <E extends ArrangementEntry> List<E> arrange(@NotNull Collection<E> entries, @NotNull List<ArrangementSectionRule> sectionRules, @NotNull List<? extends ArrangementMatchRule> rulesByPriority, @Nullable Map<E, ArrangementSectionRule> entryToSection) -->Line_42 $$ for (int i = 0; i < arranged.size() && !dependent.isEmpty(); i++) [ CD ]
Line_5 $$ List<Pair<Set<ArrangementEntry>, E>> dependent = ContainerUtilRt.newArrayList()-->Line_15 $$ dependent.add(Pair.create(first, entry))[ FD ]
Line_21 $$ for (ArrangementMatchRule rule : rulesByPriority) -->Line_25 $$ elementsByRule.putValue(rule, entry)[ FD ]
Line_11 $$ if (dependencies.size() == 1 && dependencies.get(0) == entry.getParent()) -->Line_12 $$ arranged.add(entry)[ CD ]
Line_2 $$ public static <E extends ArrangementEntry> List<E> arrange(@NotNull Collection<E> entries, @NotNull List<ArrangementSectionRule> sectionRules, @NotNull List<? extends ArrangementMatchRule> rulesByPriority, @Nullable Map<E, ArrangementSectionRule> entryToSection) -->Line_3 $$ List<E> arranged = ContainerUtilRt.newArrayList()[ CD ]
Line_31 $$ for (ArrangementSectionRule sectionRule : sectionRules) -->Line_36 $$ entryToSection.put(entry, sectionRule)[ FD ]
Line_2 $$ public static <E extends ArrangementEntry> List<E> arrange(@NotNull Collection<E> entries, @NotNull List<ArrangementSectionRule> sectionRules, @NotNull List<? extends ArrangementMatchRule> rulesByPriority, @Nullable Map<E, ArrangementSectionRule> entryToSection) -->Line_56 $$ entryToSection.put(e1, rule)[ FD ]
Line_20 $$ MultiMap<ArrangementMatchRule, E> elementsByRule = new MultiMap<ArrangementMatchRule, E>()-->Line_25 $$ elementsByRule.putValue(rule, entry)[ FD ]
Line_24 $$ if (entry.canBeMatched() && rule.getMatcher().isMatched(entry)) -->Line_25 $$ elementsByRule.putValue(rule, entry)[ CD ]
Line_42 $$ for (int i = 0; i < arranged.size() && !dependent.isEmpty(); i++) -->Line_53 $$ if (entryToSection != null && entryToSection.containsKey(e)) [ CD ]
Line_19 $$ Set<E> matched = new HashSet<E>()-->Line_26 $$ matched.add(entry)[ FD ]
Line_2 $$ public static <E extends ArrangementEntry> List<E> arrange(@NotNull Collection<E> entries, @NotNull List<ArrangementSectionRule> sectionRules, @NotNull List<? extends ArrangementMatchRule> rulesByPriority, @Nullable Map<E, ArrangementSectionRule> entryToSection) -->Line_36 $$ entryToSection.put(entry, sectionRule)[ FD ]
Line_2 $$ public static <E extends ArrangementEntry> List<E> arrange(@NotNull Collection<E> entries, @NotNull List<ArrangementSectionRule> sectionRules, @NotNull List<? extends ArrangementMatchRule> rulesByPriority, @Nullable Map<E, ArrangementSectionRule> entryToSection) -->Line_5 $$ List<Pair<Set<ArrangementEntry>, E>> dependent = ContainerUtilRt.newArrayList()[ CD ]
Line_2 $$ public static <E extends ArrangementEntry> List<E> arrange(@NotNull Collection<E> entries, @NotNull List<ArrangementSectionRule> sectionRules, @NotNull List<? extends ArrangementMatchRule> rulesByPriority, @Nullable Map<E, ArrangementSectionRule> entryToSection) -->Line_20 $$ MultiMap<ArrangementMatchRule, E> elementsByRule = new MultiMap<ArrangementMatchRule, E>()[ CD ]
Line_5 $$ List<Pair<Set<ArrangementEntry>, E>> dependent = ContainerUtilRt.newArrayList()-->Line_42 $$ for (int i = 0; i < arranged.size() && !dependent.isEmpty(); i++) [ FD ]
Line_42 $$ for (int i = 0; i < arranged.size() && !dependent.isEmpty(); i++) -->Line_43 $$ E e = arranged.get(i)[ FD ]
Line_44 $$ List<E> shouldBeAddedAfterCurrentElement = ContainerUtil.newArrayList()-->Line_50 $$ shouldBeAddedAfterCurrentElement.add(pair.second)[ FD ]
Line_21 $$ for (ArrangementMatchRule rule : rulesByPriority) -->Line_24 $$ if (entry.canBeMatched() && rule.getMatcher().isMatched(entry)) [ FD ]
Line_2 $$ public static <E extends ArrangementEntry> List<E> arrange(@NotNull Collection<E> entries, @NotNull List<ArrangementSectionRule> sectionRules, @NotNull List<? extends ArrangementMatchRule> rulesByPriority, @Nullable Map<E, ArrangementSectionRule> entryToSection) -->Line_4 $$ Set<E> unprocessed = ContainerUtilRt.newLinkedHashSet()[ CD ]
Line_6 $$ for (E entry : entries) -->Line_26 $$ matched.add(entry)[ FD ]
Line_6 $$ for (E entry : entries) -->Line_15 $$ dependent.add(Pair.create(first, entry))[ FD ]
Line_3 $$ List<E> arranged = ContainerUtilRt.newArrayList()-->Line_41 $$ arranged.addAll(unprocessed)[ FD ]
Line_6 $$ for (E entry : entries) -->Line_7 $$ List<? extends ArrangementEntry> dependencies = entry.getDependencies()[ FD ]
Line_31 $$ for (ArrangementSectionRule sectionRule : sectionRules) -->Line_32 $$ for (ArrangementMatchRule rule : sectionRule.getMatchRules()) [ FD ]
Line_42 $$ for (int i = 0; i < arranged.size() && !dependent.isEmpty(); i++) -->Line_44 $$ List<E> shouldBeAddedAfterCurrentElement = ContainerUtil.newArrayList()[ CD ]
Line_4 $$ Set<E> unprocessed = ContainerUtilRt.newLinkedHashSet()-->Line_41 $$ arranged.addAll(unprocessed)[ FD ]
Line_6 $$ for (E entry : entries) -->Line_24 $$ if (entry.canBeMatched() && rule.getMatcher().isMatched(entry)) [ FD ]
Line_53 $$ if (entryToSection != null && entryToSection.containsKey(e)) -->Line_54 $$ final ArrangementSectionRule rule = entryToSection.get(e)[ CD ]
Line_8 $$ if (dependencies == null) -->Line_9 $$ unprocessed.add(entry)[ CD ]
Line_2 $$ public static <E extends ArrangementEntry> List<E> arrange(@NotNull Collection<E> entries, @NotNull List<ArrangementSectionRule> sectionRules, @NotNull List<? extends ArrangementMatchRule> rulesByPriority, @Nullable Map<E, ArrangementSectionRule> entryToSection) -->Line_53 $$ if (entryToSection != null && entryToSection.containsKey(e)) [ FD ]
Line_2 $$ public static <E extends ArrangementEntry> List<E> arrange(@NotNull Collection<E> entries, @NotNull List<ArrangementSectionRule> sectionRules, @NotNull List<? extends ArrangementMatchRule> rulesByPriority, @Nullable Map<E, ArrangementSectionRule> entryToSection) -->Line_19 $$ Set<E> matched = new HashSet<E>()[ CD ]
Line_6 $$ for (E entry : entries) -->Line_11 $$ if (dependencies.size() == 1 && dependencies.get(0) == entry.getParent()) [ FD ]
Line_24 $$ if (entry.canBeMatched() && rule.getMatcher().isMatched(entry)) -->Line_26 $$ matched.add(entry)[ CD ]
Line_43 $$ E e = arranged.get(i)-->Line_54 $$ final ArrangementSectionRule rule = entryToSection.get(e)[ FD ]
Line_2 $$ public static <E extends ArrangementEntry> List<E> arrange(@NotNull Collection<E> entries, @NotNull List<ArrangementSectionRule> sectionRules, @NotNull List<? extends ArrangementMatchRule> rulesByPriority, @Nullable Map<E, ArrangementSectionRule> entryToSection) -->Line_41 $$ arranged.addAll(unprocessed)[ CD ]
Line_6 $$ for (E entry : entries) -->Line_9 $$ unprocessed.add(entry)[ FD ]
Line_11 $$ if (dependencies.size() == 1 && dependencies.get(0) == entry.getParent()) -->Line_15 $$ dependent.add(Pair.create(first, entry))[ CD ]
Line_43 $$ E e = arranged.get(i)-->Line_47 $$ pair.first.remove(e)[ FD ]
Line_6 $$ for (E entry : entries) -->Line_12 $$ arranged.add(entry)[ FD ]
Line_8 $$ if (dependencies == null) -->Line_11 $$ if (dependencies.size() == 1 && dependencies.get(0) == entry.getParent()) [ CD ]
Line_45 $$ for (Iterator<Pair<Set<ArrangementEntry>, E>> iterator = dependent.iterator(); iterator.hasNext(); ) -->Line_48 $$ if (pair.first.isEmpty()) [ CD ]
Line_42 $$ for (int i = 0; i < arranged.size() && !dependent.isEmpty(); i++) -->Line_45 $$ for (Iterator<Pair<Set<ArrangementEntry>, E>> iterator = dependent.iterator(); iterator.hasNext(); ) [ CD ]
Line_21 $$ for (ArrangementMatchRule rule : rulesByPriority) -->Line_56 $$ entryToSection.put(e1, rule)[ FD ]
Line_2 $$ public static <E extends ArrangementEntry> List<E> arrange(@NotNull Collection<E> entries, @NotNull List<ArrangementSectionRule> sectionRules, @NotNull List<? extends ArrangementMatchRule> rulesByPriority, @Nullable Map<E, ArrangementSectionRule> entryToSection) -->Line_61 $$ return arranged[ CD ]
Line_48 $$ if (pair.first.isEmpty()) -->Line_49 $$ iterator.remove()[ CD ]
Line_11 $$ if (dependencies.size() == 1 && dependencies.get(0) == entry.getParent()) -->Line_14 $$ Set<ArrangementEntry> first = new HashSet<ArrangementEntry>(dependencies)[ CD ]
