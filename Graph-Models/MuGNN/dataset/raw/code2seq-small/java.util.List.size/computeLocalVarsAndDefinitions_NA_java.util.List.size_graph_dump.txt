Line_30 $$ InvocationExprent constructor = ((NewExprent) expr).getConstructor()-->Line_41 $$ Exprent param = constructor.getLstParameters().get(i)[ FD ]
Line_39 $$ List<VarFieldPair> lstTemp = new ArrayList<VarFieldPair>()-->Line_51 $$ pairMask = lstTemp[ FD ]
Line_10 $$ clTypes |= nd.type-->Line_21 $$ if (clTypes != ClassNode.CLASS_MEMBER) [ FD ]
Line_20 $$ final Map<String, Map<String, List<VarFieldPair>>> mapVarFieldPairs = new HashMap<String, Map<String, List<VarFieldPair>>>()-->Line_37 $$ mapVarFieldPairs.put(refClassName, new HashMap<String, List<VarFieldPair>>())[ FD ]
Line_43 $$ if (param.type == Exprent.EXPRENT_VAR && mask.get(i) != null) -->Line_44 $$ VarVersionPair varPair = new VarVersionPair((VarExprent) param)[ CD ]
Line_11 $$ Map<String, List<VarFieldPair>> mask = getMaskLocalVars(nd.getWrapper())-->Line_12 $$ if (mask.isEmpty()) [ FD ]
Line_105 $$ if (pair != null && pair.fieldKey.length() > 0) -->Line_106 $$ nestedNode.mapFieldsToVars.put(pair.fieldKey, pair.varPair)[ CD ]
Line_50 $$ if (pairMask == null) -->Line_51 $$ pairMask = lstTemp[ CD ]
Line_29 $$ if (expr.type == Exprent.EXPRENT_NEW) -->Line_31 $$ if (constructor != null && mapVarMasks.containsKey(constructor.getClassname())) [ CD ]
Line_49 $$ List<VarFieldPair> pairMask = mapVarFieldPairs.get(refClassName).get(constructor.getStringDescriptor())-->Line_54 $$ if (!InterpreterUtil.equalObjects(pairMask.get(i), lstTemp.get(i))) [ FD ]
Line_13 $$ String message = "Nested class " + nd.classStruct.qualifiedName + " has no constructor!"-->Line_14 $$ DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.WARN)[ FD ]
Line_40 $$ for (int i = 0; i < mask.size(); i++) -->Line_45 $$ pair = new VarFieldPair(mask.get(i).fieldKey, varPair)[ FD ]
Line_49 $$ List<VarFieldPair> pairMask = mapVarFieldPairs.get(refClassName).get(constructor.getStringDescriptor())-->Line_50 $$ if (pairMask == null) [ FD ]
Line_20 $$ final Map<String, Map<String, List<VarFieldPair>>> mapVarFieldPairs = new HashMap<String, Map<String, List<VarFieldPair>>>()-->Line_36 $$ if (!mapVarFieldPairs.containsKey(refClassName)) [ FD ]
Line_36 $$ if (!mapVarFieldPairs.containsKey(refClassName)) -->Line_37 $$ mapVarFieldPairs.put(refClassName, new HashMap<String, List<VarFieldPair>>())[ CD ]
Line_34 $$ if (nestedClassNode.type != ClassNode.CLASS_MEMBER) -->Line_60 $$ nestedClassNode.enclosingMethod = InterpreterUtil.makeUniqueKey(method.methodStruct.getName(), method.methodStruct.getDescriptor())[ CD ]
Line_11 $$ Map<String, List<VarFieldPair>> mask = getMaskLocalVars(nd.getWrapper())-->Line_16 $$ mapVarMasks.put(nd.classStruct.qualifiedName, mask)[ FD ]
Line_24 $$ method.getOrBuildGraph().iterateExprents(new DirectGraph.ExprentIterator() -->Line_27 $$ lst.add(exprent)[ CD ]
Line_32 $$ String refClassName = constructor.getClassname()-->Line_33 $$ ClassNode nestedClassNode = node.getClassNode(refClassName)[ FD ]
Line_50 $$ if (pairMask == null) -->Line_53 $$ for (int i = 0; i < pairMask.size(); i++) [ CD ]
Line_11 $$ Map<String, List<VarFieldPair>> mask = getMaskLocalVars(nd.getWrapper())-->Line_45 $$ pair = new VarFieldPair(mask.get(i).fieldKey, varPair)[ FD ]
Line_24 $$ method.getOrBuildGraph().iterateExprents(new DirectGraph.ExprentIterator() -->Line_26 $$ List<Exprent> lst = exprent.getAllExprents(true)[ CD ]
Line_30 $$ InvocationExprent constructor = ((NewExprent) expr).getConstructor()-->Line_32 $$ String refClassName = constructor.getClassname()[ FD ]
Line_34 $$ if (nestedClassNode.type != ClassNode.CLASS_MEMBER) -->Line_50 $$ if (pairMask == null) [ CD ]
Line_51 $$ pairMask = lstTemp-->Line_59 $$ mapVarFieldPairs.get(refClassName).put(constructor.getStringDescriptor(), pairMask)[ FD ]
Line_42 $$ VarFieldPair pair = null-->Line_45 $$ pair = new VarFieldPair(mask.get(i).fieldKey, varPair)[ FD ]
Line_49 $$ List<VarFieldPair> pairMask = mapVarFieldPairs.get(refClassName).get(constructor.getStringDescriptor())-->Line_59 $$ mapVarFieldPairs.get(refClassName).put(constructor.getStringDescriptor(), pairMask)[ FD ]
Line_2 $$ private static void computeLocalVarsAndDefinitions(final ClassNode node) -->Line_22 $$ for (final MethodWrapper method : node.getWrapper().getMethods()) [ FD ]
Line_3 $$ final Map<String, Map<String, List<VarFieldPair>>> mapVarMasks = new HashMap<String, Map<String, List<VarFieldPair>>>()-->Line_31 $$ if (constructor != null && mapVarMasks.containsKey(constructor.getClassname())) [ FD ]
Line_35 $$ List<VarFieldPair> mask = mapVarMasks.get(refClassName).get(constructor.getStringDescriptor())-->Line_45 $$ pair = new VarFieldPair(mask.get(i).fieldKey, varPair)[ FD ]
Line_12 $$ if (mask.isEmpty()) -->Line_14 $$ DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.WARN)[ CD ]
Line_2 $$ private static void computeLocalVarsAndDefinitions(final ClassNode node) -->Line_21 $$ if (clTypes != ClassNode.CLASS_MEMBER) [ CD ]
Line_2 $$ private static void computeLocalVarsAndDefinitions(final ClassNode node) -->Line_4 $$ int clTypes = 0[ CD ]
Line_94 $$ for (int i = 0; i < interPairMask.size(); i++) -->Line_97 $$ interPairMask.set(i, null)[ FD ]
Line_40 $$ for (int i = 0; i < mask.size(); i++) -->Line_97 $$ interPairMask.set(i, null)[ FD ]
Line_49 $$ List<VarFieldPair> pairMask = mapVarFieldPairs.get(refClassName).get(constructor.getStringDescriptor())-->Line_53 $$ for (int i = 0; i < pairMask.size(); i++) [ FD ]
Line_53 $$ for (int i = 0; i < pairMask.size(); i++) -->Line_95 $$ if (interPairMask.get(i) != null) [ FD ]
Line_42 $$ VarFieldPair pair = null-->Line_47 $$ lstTemp.add(pair)[ FD ]
Line_40 $$ for (int i = 0; i < mask.size(); i++) -->Line_43 $$ if (param.type == Exprent.EXPRENT_VAR && mask.get(i) != null) [ CD ]
Line_95 $$ if (interPairMask.get(i) != null) -->Line_96 $$ if (found) [ CD ]
Line_51 $$ pairMask = lstTemp-->Line_53 $$ for (int i = 0; i < pairMask.size(); i++) [ FD ]
Line_53 $$ for (int i = 0; i < pairMask.size(); i++) -->Line_54 $$ if (!InterpreterUtil.equalObjects(pairMask.get(i), lstTemp.get(i))) [ FD ]
Line_20 $$ final Map<String, Map<String, List<VarFieldPair>>> mapVarFieldPairs = new HashMap<String, Map<String, List<VarFieldPair>>>()-->Line_75 $$ for (List<VarFieldPair> mask : mapVarFieldPairs.get(enclosing.getKey()).values()) [ FD ]
Line_53 $$ for (int i = 0; i < pairMask.size(); i++) -->Line_97 $$ interPairMask.set(i, null)[ FD ]
Line_32 $$ String refClassName = constructor.getClassname()-->Line_36 $$ if (!mapVarFieldPairs.containsKey(refClassName)) [ FD ]
Line_12 $$ if (mask.isEmpty()) -->Line_13 $$ String message = "Nested class " + nd.classStruct.qualifiedName + " has no constructor!"[ CD ]
Line_20 $$ final Map<String, Map<String, List<VarFieldPair>>> mapVarFieldPairs = new HashMap<String, Map<String, List<VarFieldPair>>>()-->Line_49 $$ List<VarFieldPair> pairMask = mapVarFieldPairs.get(refClassName).get(constructor.getStringDescriptor())[ FD ]
Line_40 $$ for (int i = 0; i < mask.size(); i++) -->Line_47 $$ lstTemp.add(pair)[ CD ]
Line_40 $$ for (int i = 0; i < mask.size(); i++) -->Line_41 $$ Exprent param = constructor.getLstParameters().get(i)[ CD ]
Line_40 $$ for (int i = 0; i < mask.size(); i++) -->Line_41 $$ Exprent param = constructor.getLstParameters().get(i)[ FD ]
Line_40 $$ for (int i = 0; i < mask.size(); i++) -->Line_43 $$ if (param.type == Exprent.EXPRENT_VAR && mask.get(i) != null) [ FD ]
Line_30 $$ InvocationExprent constructor = ((NewExprent) expr).getConstructor()-->Line_59 $$ mapVarFieldPairs.get(refClassName).put(constructor.getStringDescriptor(), pairMask)[ FD ]
Line_24 $$ method.getOrBuildGraph().iterateExprents(new DirectGraph.ExprentIterator() -->Line_65 $$ return 0[ CD ]
Line_45 $$ pair = new VarFieldPair(mask.get(i).fieldKey, varPair)-->Line_47 $$ lstTemp.add(pair)[ FD ]
Line_31 $$ if (constructor != null && mapVarMasks.containsKey(constructor.getClassname())) -->Line_34 $$ if (nestedClassNode.type != ClassNode.CLASS_MEMBER) [ CD ]
Line_94 $$ for (int i = 0; i < interPairMask.size(); i++) -->Line_95 $$ if (interPairMask.get(i) != null) [ FD ]
Line_96 $$ if (found) -->Line_97 $$ interPairMask.set(i, null)[ CD ]
Line_12 $$ if (mask.isEmpty()) -->Line_16 $$ mapVarMasks.put(nd.classStruct.qualifiedName, mask)[ CD ]
Line_40 $$ for (int i = 0; i < mask.size(); i++) -->Line_53 $$ for (int i = 0; i < pairMask.size(); i++) [ FD ]
Line_30 $$ InvocationExprent constructor = ((NewExprent) expr).getConstructor()-->Line_31 $$ if (constructor != null && mapVarMasks.containsKey(constructor.getClassname())) [ FD ]
Line_34 $$ if (nestedClassNode.type != ClassNode.CLASS_MEMBER) -->Line_39 $$ List<VarFieldPair> lstTemp = new ArrayList<VarFieldPair>()[ CD ]
Line_30 $$ InvocationExprent constructor = ((NewExprent) expr).getConstructor()-->Line_35 $$ List<VarFieldPair> mask = mapVarMasks.get(refClassName).get(constructor.getStringDescriptor())[ FD ]
Line_9 $$ if (nd.type != ClassNode.CLASS_LAMBDA && (nd.access & CodeConstants.ACC_STATIC) == 0 && (nd.access & CodeConstants.ACC_INTERFACE) == 0) -->Line_12 $$ if (mask.isEmpty()) [ CD ]
Line_32 $$ String refClassName = constructor.getClassname()-->Line_35 $$ List<VarFieldPair> mask = mapVarMasks.get(refClassName).get(constructor.getStringDescriptor())[ FD ]
Line_43 $$ if (param.type == Exprent.EXPRENT_VAR && mask.get(i) != null) -->Line_45 $$ pair = new VarFieldPair(mask.get(i).fieldKey, varPair)[ CD ]
Line_34 $$ if (nestedClassNode.type != ClassNode.CLASS_MEMBER) -->Line_49 $$ List<VarFieldPair> pairMask = mapVarFieldPairs.get(refClassName).get(constructor.getStringDescriptor())[ CD ]
Line_76 $$ if (interPairMask == null) -->Line_79 $$ mergeListSignatures(interPairMask, mask, false)[ CD ]
Line_11 $$ Map<String, List<VarFieldPair>> mask = getMaskLocalVars(nd.getWrapper())-->Line_40 $$ for (int i = 0; i < mask.size(); i++) [ FD ]
Line_40 $$ for (int i = 0; i < mask.size(); i++) -->Line_95 $$ if (interPairMask.get(i) != null) [ FD ]
Line_11 $$ Map<String, List<VarFieldPair>> mask = getMaskLocalVars(nd.getWrapper())-->Line_79 $$ mergeListSignatures(interPairMask, mask, false)[ FD ]
Line_32 $$ String refClassName = constructor.getClassname()-->Line_59 $$ mapVarFieldPairs.get(refClassName).put(constructor.getStringDescriptor(), pairMask)[ FD ]
Line_32 $$ String refClassName = constructor.getClassname()-->Line_49 $$ List<VarFieldPair> pairMask = mapVarFieldPairs.get(refClassName).get(constructor.getStringDescriptor())[ FD ]
Line_85 $$ if (interMask == null) -->Line_88 $$ mergeListSignatures(interMask, mask, false)[ CD ]
Line_9 $$ if (nd.type != ClassNode.CLASS_LAMBDA && (nd.access & CodeConstants.ACC_STATIC) == 0 && (nd.access & CodeConstants.ACC_INTERFACE) == 0) -->Line_11 $$ Map<String, List<VarFieldPair>> mask = getMaskLocalVars(nd.getWrapper())[ CD ]
Line_35 $$ List<VarFieldPair> mask = mapVarMasks.get(refClassName).get(constructor.getStringDescriptor())-->Line_40 $$ for (int i = 0; i < mask.size(); i++) [ FD ]
Line_34 $$ if (nestedClassNode.type != ClassNode.CLASS_MEMBER) -->Line_36 $$ if (!mapVarFieldPairs.containsKey(refClassName)) [ CD ]
Line_31 $$ if (constructor != null && mapVarMasks.containsKey(constructor.getClassname())) -->Line_33 $$ ClassNode nestedClassNode = node.getClassNode(refClassName)[ CD ]
Line_3 $$ final Map<String, Map<String, List<VarFieldPair>>> mapVarMasks = new HashMap<String, Map<String, List<VarFieldPair>>>()-->Line_71 $$ for (Entry<String, Map<String, List<VarFieldPair>>> enclosing : mapVarMasks.entrySet()) [ FD ]
Line_40 $$ for (int i = 0; i < mask.size(); i++) -->Line_54 $$ if (!InterpreterUtil.equalObjects(pairMask.get(i), lstTemp.get(i))) [ FD ]
Line_94 $$ for (int i = 0; i < interPairMask.size(); i++) -->Line_95 $$ if (interPairMask.get(i) != null) [ CD ]
Line_23 $$ if (method.root != null) -->Line_24 $$ method.getOrBuildGraph().iterateExprents(new DirectGraph.ExprentIterator() [ CD ]
Line_11 $$ Map<String, List<VarFieldPair>> mask = getMaskLocalVars(nd.getWrapper())-->Line_88 $$ mergeListSignatures(interMask, mask, false)[ FD ]
Line_3 $$ final Map<String, Map<String, List<VarFieldPair>>> mapVarMasks = new HashMap<String, Map<String, List<VarFieldPair>>>()-->Line_16 $$ mapVarMasks.put(nd.classStruct.qualifiedName, mask)[ FD ]
Line_49 $$ List<VarFieldPair> pairMask = mapVarFieldPairs.get(refClassName).get(constructor.getStringDescriptor())-->Line_55 $$ pairMask.set(i, null)[ FD ]
Line_54 $$ if (!InterpreterUtil.equalObjects(pairMask.get(i), lstTemp.get(i))) -->Line_55 $$ pairMask.set(i, null)[ CD ]
Line_20 $$ final Map<String, Map<String, List<VarFieldPair>>> mapVarFieldPairs = new HashMap<String, Map<String, List<VarFieldPair>>>()-->Line_59 $$ mapVarFieldPairs.get(refClassName).put(constructor.getStringDescriptor(), pairMask)[ FD ]
Line_40 $$ for (int i = 0; i < mask.size(); i++) -->Line_42 $$ VarFieldPair pair = null[ CD ]
Line_22 $$ for (final MethodWrapper method : node.getWrapper().getMethods()) -->Line_24 $$ method.getOrBuildGraph().iterateExprents(new DirectGraph.ExprentIterator() [ FD ]
Line_30 $$ InvocationExprent constructor = ((NewExprent) expr).getConstructor()-->Line_49 $$ List<VarFieldPair> pairMask = mapVarFieldPairs.get(refClassName).get(constructor.getStringDescriptor())[ FD ]
Line_34 $$ if (nestedClassNode.type != ClassNode.CLASS_MEMBER) -->Line_59 $$ mapVarFieldPairs.get(refClassName).put(constructor.getStringDescriptor(), pairMask)[ CD ]
Line_20 $$ final Map<String, Map<String, List<VarFieldPair>>> mapVarFieldPairs = new HashMap<String, Map<String, List<VarFieldPair>>>()-->Line_74 $$ if (mapVarFieldPairs.containsKey(enclosing.getKey())) [ FD ]
Line_40 $$ for (int i = 0; i < mask.size(); i++) -->Line_94 $$ for (int i = 0; i < interPairMask.size(); i++) [ FD ]
Line_24 $$ method.getOrBuildGraph().iterateExprents(new DirectGraph.ExprentIterator() -->Line_26 $$ List<Exprent> lst = exprent.getAllExprents(true)[ FD ]
Line_2 $$ private static void computeLocalVarsAndDefinitions(final ClassNode node) -->Line_3 $$ final Map<String, Map<String, List<VarFieldPair>>> mapVarMasks = new HashMap<String, Map<String, List<VarFieldPair>>>()[ CD ]
Line_53 $$ for (int i = 0; i < pairMask.size(); i++) -->Line_94 $$ for (int i = 0; i < interPairMask.size(); i++) [ FD ]
Line_9 $$ if (nd.type != ClassNode.CLASS_LAMBDA && (nd.access & CodeConstants.ACC_STATIC) == 0 && (nd.access & CodeConstants.ACC_INTERFACE) == 0) -->Line_10 $$ clTypes |= nd.type[ CD ]
Line_4 $$ int clTypes = 0-->Line_10 $$ clTypes |= nd.type[ FD ]
Line_5 $$ for (ClassNode nd : node.nested) -->Line_11 $$ Map<String, List<VarFieldPair>> mask = getMaskLocalVars(nd.getWrapper())[ FD ]
Line_29 $$ if (expr.type == Exprent.EXPRENT_NEW) -->Line_30 $$ InvocationExprent constructor = ((NewExprent) expr).getConstructor()[ CD ]
Line_3 $$ final Map<String, Map<String, List<VarFieldPair>>> mapVarMasks = new HashMap<String, Map<String, List<VarFieldPair>>>()-->Line_35 $$ List<VarFieldPair> mask = mapVarMasks.get(refClassName).get(constructor.getStringDescriptor())[ FD ]
Line_2 $$ private static void computeLocalVarsAndDefinitions(final ClassNode node) -->Line_33 $$ ClassNode nestedClassNode = node.getClassNode(refClassName)[ FD ]
Line_32 $$ String refClassName = constructor.getClassname()-->Line_37 $$ mapVarFieldPairs.put(refClassName, new HashMap<String, List<VarFieldPair>>())[ FD ]
Line_2 $$ private static void computeLocalVarsAndDefinitions(final ClassNode node) -->Line_20 $$ final Map<String, Map<String, List<VarFieldPair>>> mapVarFieldPairs = new HashMap<String, Map<String, List<VarFieldPair>>>()[ CD ]
Line_26 $$ List<Exprent> lst = exprent.getAllExprents(true)-->Line_27 $$ lst.add(exprent)[ FD ]
Line_34 $$ if (nestedClassNode.type != ClassNode.CLASS_MEMBER) -->Line_40 $$ for (int i = 0; i < mask.size(); i++) [ CD ]
Line_40 $$ for (int i = 0; i < mask.size(); i++) -->Line_55 $$ pairMask.set(i, null)[ FD ]
Line_53 $$ for (int i = 0; i < pairMask.size(); i++) -->Line_55 $$ pairMask.set(i, null)[ FD ]
Line_39 $$ List<VarFieldPair> lstTemp = new ArrayList<VarFieldPair>()-->Line_47 $$ lstTemp.add(pair)[ FD ]
Line_49 $$ List<VarFieldPair> pairMask = mapVarFieldPairs.get(refClassName).get(constructor.getStringDescriptor())-->Line_51 $$ pairMask = lstTemp[ FD ]
Line_51 $$ pairMask = lstTemp-->Line_55 $$ pairMask.set(i, null)[ FD ]
Line_24 $$ method.getOrBuildGraph().iterateExprents(new DirectGraph.ExprentIterator() -->Line_27 $$ lst.add(exprent)[ FD ]
Line_11 $$ Map<String, List<VarFieldPair>> mask = getMaskLocalVars(nd.getWrapper())-->Line_43 $$ if (param.type == Exprent.EXPRENT_VAR && mask.get(i) != null) [ FD ]
Line_31 $$ if (constructor != null && mapVarMasks.containsKey(constructor.getClassname())) -->Line_32 $$ String refClassName = constructor.getClassname()[ CD ]
Line_51 $$ pairMask = lstTemp-->Line_54 $$ if (!InterpreterUtil.equalObjects(pairMask.get(i), lstTemp.get(i))) [ FD ]
Line_4 $$ int clTypes = 0-->Line_21 $$ if (clTypes != ClassNode.CLASS_MEMBER) [ FD ]
Line_35 $$ List<VarFieldPair> mask = mapVarMasks.get(refClassName).get(constructor.getStringDescriptor())-->Line_79 $$ mergeListSignatures(interPairMask, mask, false)[ FD ]
Line_91 $$ if (interPairMask == null) -->Line_94 $$ for (int i = 0; i < interPairMask.size(); i++) [ CD ]
Line_39 $$ List<VarFieldPair> lstTemp = new ArrayList<VarFieldPair>()-->Line_54 $$ if (!InterpreterUtil.equalObjects(pairMask.get(i), lstTemp.get(i))) [ FD ]
Line_2 $$ private static void computeLocalVarsAndDefinitions(final ClassNode node) -->Line_72 $$ ClassNode nestedNode = node.getClassNode(enclosing.getKey())[ FD ]
Line_34 $$ if (nestedClassNode.type != ClassNode.CLASS_MEMBER) -->Line_35 $$ List<VarFieldPair> mask = mapVarMasks.get(refClassName).get(constructor.getStringDescriptor())[ CD ]
Line_35 $$ List<VarFieldPair> mask = mapVarMasks.get(refClassName).get(constructor.getStringDescriptor())-->Line_88 $$ mergeListSignatures(interMask, mask, false)[ FD ]
Line_53 $$ for (int i = 0; i < pairMask.size(); i++) -->Line_54 $$ if (!InterpreterUtil.equalObjects(pairMask.get(i), lstTemp.get(i))) [ CD ]
Line_35 $$ List<VarFieldPair> mask = mapVarMasks.get(refClassName).get(constructor.getStringDescriptor())-->Line_43 $$ if (param.type == Exprent.EXPRENT_VAR && mask.get(i) != null) [ FD ]
