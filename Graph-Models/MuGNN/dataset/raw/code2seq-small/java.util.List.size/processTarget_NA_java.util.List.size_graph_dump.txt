Line_17 $$ for (Item item : items) -->Line_112 $$ SourceState sourceState = sourceStates.get(item)[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_6 $$ final List<Item> items = instance.getItems(target)[ CD ]
Line_49 $$ if (LOG.isDebugEnabled()) -->Line_51 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) [ CD ]
Line_54 $$ for (int i = 0; i < getItemsCountToShowInLog(toRemove.size()); i++) -->Line_102 $$ LOG.debug("file: " + filesToRefresh.get(i))[ FD ]
Line_39 $$ cache.processSources(targetId, new Processor<Key>() -->Line_43 $$ if (!keySet.contains(key)) [ FD ]
Line_54 $$ for (int i = 0; i < getItemsCountToShowInLog(toRemove.size()); i++) -->Line_55 $$ LOG.debug("to delete:" + toRemove.get(i))[ CD ]
Line_8 $$ final List<GenericCompilerProcessingItem<Item, SourceState, OutputState>> toProcess = new ArrayList<GenericCompilerProcessingItem<Item, SourceState, OutputState>>()-->Line_58 $$ if (toProcess.isEmpty() && toRemove.isEmpty()) [ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_49 $$ if (LOG.isDebugEnabled()) [ CD ]
Line_39 $$ cache.processSources(targetId, new Processor<Key>() -->Line_43 $$ if (!keySet.contains(key)) [ CD ]
Line_111 $$ for (Item item : processedItems) -->Line_112 $$ SourceState sourceState = sourceStates.get(item)[ FD ]
Line_51 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) -->Line_52 $$ LOG.debug("to process:" + toProcess.get(i).getItem().getKey())[ FD ]
Line_90 $$ CompilerUtil.runInContext(myContext, CompilerBundle.message("progress.updating.caches"), new ThrowableRunnable<IOException>() -->Line_120 $$ Throwable throwable = runResult.getThrowable()[ CD ]
Line_39 $$ cache.processSources(targetId, new Processor<Key>() -->Line_46 $$ return true[ CD ]
Line_72 $$ instance.processItems(target, toProcess, obsoleteItems, new GenericCompilerInstance.OutputConsumer<Item>() -->Line_76 $$ filesToRefresh.add(file)[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_7 $$ checkForErrorsOrCanceled()[ CD ]
Line_23 $$ SourceState sourceState = data != null ? data.mySourceState : null-->Line_116 $$ cache.putState(targetId, item.getKey(), sourceState, item.computeOutputState())[ FD ]
Line_51 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) -->Line_54 $$ for (int i = 0; i < getItemsCountToShowInLog(toRemove.size()); i++) [ FD ]
Line_51 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) -->Line_105 $$ LOG.debug("dir: " + dirsToRefresh.get(i))[ FD ]
Line_18 $$ final Key key = item.getKey()-->Line_19 $$ keySet.add(key)[ FD ]
Line_99 $$ if (LOG.isDebugEnabled()) -->Line_100 $$ LOG.debug("refreshed " + filesToRefresh.size() + " files and " + dirsToRefresh.size() + " dirs")[ CD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_72 $$ instance.processItems(target, toProcess, obsoleteItems, new GenericCompilerInstance.OutputConsumer<Item>() [ FD ]
Line_51 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) -->Line_102 $$ LOG.debug("file: " + filesToRefresh.get(i))[ FD ]
Line_90 $$ CompilerUtil.runInContext(myContext, CompilerBundle.message("progress.updating.caches"), new ThrowableRunnable<IOException>() -->Line_121 $$ if (throwable instanceof IOException)[ CD ]
Line_18 $$ final Key key = item.getKey()-->Line_44 $$ toRemove.add(key)[ FD ]
Line_72 $$ instance.processItems(target, toProcess, obsoleteItems, new GenericCompilerInstance.OutputConsumer<Item>() -->Line_76 $$ filesToRefresh.add(file)[ CD ]
Line_10 $$ final Ref<IOException> exception = Ref.create(null)-->Line_31 $$ exception.set(e)[ FD ]
Line_17 $$ for (Item item : items) -->Line_26 $$ sourceStates.put(item, item.computeSourceState())[ FD ]
Line_111 $$ for (Item item : processedItems) -->Line_114 $$ sourceState = item.computeSourceState()[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_58 $$ if (toProcess.isEmpty() && toRemove.isEmpty()) [ CD ]
Line_99 $$ if (LOG.isDebugEnabled()) -->Line_104 $$ for (int i = 0; i < getItemsCountToShowInLog(dirsToRefresh.size()); i++) [ CD ]
Line_113 $$ if (sourceState == null) -->Line_114 $$ sourceState = item.computeSourceState()[ CD ]
Line_112 $$ SourceState sourceState = sourceStates.get(item)-->Line_116 $$ cache.putState(targetId, item.getKey(), sourceState, item.computeOutputState())[ FD ]
Line_104 $$ for (int i = 0; i < getItemsCountToShowInLog(dirsToRefresh.size()); i++) -->Line_105 $$ LOG.debug("dir: " + dirsToRefresh.get(i))[ FD ]
Line_51 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) -->Line_101 $$ for (int i = 0; i < getItemsCountToShowInLog(filesToRefresh.size()); i++) [ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_6 $$ final List<Item> items = instance.getItems(target)[ FD ]
Line_11 $$ final Map<Item, SourceState> sourceStates = new HashMap<Item, SourceState>()-->Line_112 $$ SourceState sourceState = sourceStates.get(item)[ FD ]
Line_54 $$ for (int i = 0; i < getItemsCountToShowInLog(toRemove.size()); i++) -->Line_104 $$ for (int i = 0; i < getItemsCountToShowInLog(dirsToRefresh.size()); i++) [ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_8 $$ final List<GenericCompilerProcessingItem<Item, SourceState, OutputState>> toProcess = new ArrayList<GenericCompilerProcessingItem<Item, SourceState, OutputState>>()[ CD ]
Line_101 $$ for (int i = 0; i < getItemsCountToShowInLog(filesToRefresh.size()); i++) -->Line_102 $$ LOG.debug("file: " + filesToRefresh.get(i))[ CD ]
Line_3 $$ if (LOG.isDebugEnabled()) -->Line_4 $$ LOG.debug("Processing target '" + target + "' (id=" + targetId + ") by " + compiler)[ CD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_9 $$ final THashSet<Key> keySet = new THashSet<Key>(new SourceItemHashingStrategy<Key>(compiler))[ CD ]
Line_17 $$ for (Item item : items) -->Line_116 $$ cache.putState(targetId, item.getKey(), sourceState, item.computeOutputState())[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_11 $$ final Map<Item, SourceState> sourceStates = new HashMap<Item, SourceState>()[ CD ]
Line_43 $$ if (!keySet.contains(key)) -->Line_44 $$ toRemove.add(key)[ CD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_10 $$ final Ref<IOException> exception = Ref.create(null)[ CD ]
Line_99 $$ if (LOG.isDebugEnabled()) -->Line_101 $$ for (int i = 0; i < getItemsCountToShowInLog(filesToRefresh.size()); i++) [ CD ]
Line_101 $$ for (int i = 0; i < getItemsCountToShowInLog(filesToRefresh.size()); i++) -->Line_102 $$ LOG.debug("file: " + filesToRefresh.get(i))[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_22 $$ final GenericCompilerCache.PersistentStateData<SourceState, OutputState> data = cache.getState(targetId, key)[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_3 $$ if (LOG.isDebugEnabled()) [ CD ]
Line_49 $$ if (LOG.isDebugEnabled()) -->Line_50 $$ LOG.debug(toProcess.size() + " items will be processed, " + toRemove.size() + " items will be removed")[ CD ]
Line_23 $$ SourceState sourceState = data != null ? data.mySourceState : null-->Line_114 $$ sourceState = item.computeSourceState()[ FD ]
Line_8 $$ final List<GenericCompilerProcessingItem<Item, SourceState, OutputState>> toProcess = new ArrayList<GenericCompilerProcessingItem<Item, SourceState, OutputState>>()-->Line_52 $$ LOG.debug("to process:" + toProcess.get(i).getItem().getKey())[ FD ]
Line_9 $$ final THashSet<Key> keySet = new THashSet<Key>(new SourceItemHashingStrategy<Key>(compiler))-->Line_43 $$ if (!keySet.contains(key)) [ FD ]
Line_17 $$ for (Item item : items) -->Line_20 $$ if (item.isExcluded())[ FD ]
Line_39 $$ cache.processSources(targetId, new Processor<Key>() -->Line_95 $$ cache.remove(targetId, key)[ FD ]
Line_72 $$ instance.processItems(target, toProcess, obsoleteItems, new GenericCompilerInstance.OutputConsumer<Item>() -->Line_81 $$ dirsToRefresh.add(dir)[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_39 $$ cache.processSources(targetId, new Processor<Key>() [ CD ]
Line_111 $$ for (Item item : processedItems) -->Line_116 $$ cache.putState(targetId, item.getKey(), sourceState, item.computeOutputState())[ FD ]
Line_51 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) -->Line_52 $$ LOG.debug("to process:" + toProcess.get(i).getItem().getKey())[ CD ]
Line_54 $$ for (int i = 0; i < getItemsCountToShowInLog(toRemove.size()); i++) -->Line_55 $$ LOG.debug("to delete:" + toRemove.get(i))[ FD ]
Line_49 $$ if (LOG.isDebugEnabled()) -->Line_54 $$ for (int i = 0; i < getItemsCountToShowInLog(toRemove.size()); i++) [ CD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_90 $$ CompilerUtil.runInContext(myContext, CompilerBundle.message("progress.updating.caches"), new ThrowableRunnable<IOException>() [ CD ]
Line_8 $$ final List<GenericCompilerProcessingItem<Item, SourceState, OutputState>> toProcess = new ArrayList<GenericCompilerProcessingItem<Item, SourceState, OutputState>>()-->Line_51 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) [ FD ]
Line_11 $$ final Map<Item, SourceState> sourceStates = new HashMap<Item, SourceState>()-->Line_26 $$ sourceStates.put(item, item.computeSourceState())[ FD ]
Line_90 $$ CompilerUtil.runInContext(myContext, CompilerBundle.message("progress.updating.caches"), new ThrowableRunnable<IOException>() -->Line_98 $$ CompilerUtil.refreshIODirectories(dirsToRefresh)[ CD ]
Line_112 $$ SourceState sourceState = sourceStates.get(item)-->Line_113 $$ if (sourceState == null) [ FD ]
Line_18 $$ final Key key = item.getKey()-->Line_95 $$ cache.remove(targetId, key)[ FD ]
Line_58 $$ if (toProcess.isEmpty() && toRemove.isEmpty()) -->Line_59 $$ return false[ CD ]
Line_25 $$ if (myForceCompile || sourceState == null || !item.isSourceUpToDate(sourceState) || outputState == null || !item.isOutputUpToDate(outputState)) -->Line_27 $$ toProcess.add(new GenericCompilerProcessingItem<Item, SourceState, OutputState>(item, sourceState, outputState))[ CD ]
Line_18 $$ final Key key = item.getKey()-->Line_43 $$ if (!keySet.contains(key)) [ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_95 $$ cache.remove(targetId, key)[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_66 $$ final GenericCompilerCache.PersistentStateData<SourceState, OutputState> data = cache.getState(targetId, key)[ FD ]
Line_90 $$ CompilerUtil.runInContext(myContext, CompilerBundle.message("progress.updating.caches"), new ThrowableRunnable<IOException>() -->Line_99 $$ if (LOG.isDebugEnabled()) [ CD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_116 $$ cache.putState(targetId, item.getKey(), sourceState, item.computeOutputState())[ FD ]
Line_25 $$ if (myForceCompile || sourceState == null || !item.isSourceUpToDate(sourceState) || outputState == null || !item.isOutputUpToDate(outputState)) -->Line_26 $$ sourceStates.put(item, item.computeSourceState())[ CD ]
Line_17 $$ for (Item item : items) -->Line_114 $$ sourceState = item.computeSourceState()[ FD ]
Line_23 $$ SourceState sourceState = data != null ? data.mySourceState : null-->Line_113 $$ if (sourceState == null) [ FD ]
Line_72 $$ instance.processItems(target, toProcess, obsoleteItems, new GenericCompilerInstance.OutputConsumer<Item>() -->Line_86 $$ processedItems.add(sourceItem)[ FD ]
Line_104 $$ for (int i = 0; i < getItemsCountToShowInLog(dirsToRefresh.size()); i++) -->Line_105 $$ LOG.debug("dir: " + dirsToRefresh.get(i))[ CD ]
Line_121 $$ if (throwable instanceof IOException)-->Line_123 $$ if (throwable != null)[ CD ]
Line_101 $$ for (int i = 0; i < getItemsCountToShowInLog(filesToRefresh.size()); i++) -->Line_104 $$ for (int i = 0; i < getItemsCountToShowInLog(dirsToRefresh.size()); i++) [ FD ]
Line_101 $$ for (int i = 0; i < getItemsCountToShowInLog(filesToRefresh.size()); i++) -->Line_105 $$ LOG.debug("dir: " + dirsToRefresh.get(i))[ FD ]
Line_8 $$ final List<GenericCompilerProcessingItem<Item, SourceState, OutputState>> toProcess = new ArrayList<GenericCompilerProcessingItem<Item, SourceState, OutputState>>()-->Line_50 $$ LOG.debug(toProcess.size() + " items will be processed, " + toRemove.size() + " items will be removed")[ FD ]
Line_72 $$ instance.processItems(target, toProcess, obsoleteItems, new GenericCompilerInstance.OutputConsumer<Item>() -->Line_86 $$ processedItems.add(sourceItem)[ CD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_61 $$ if (myOnlyCheckStatus) [ CD ]
Line_108 $$ final RunResult runResult = new ReadAction() -->Line_120 $$ Throwable throwable = runResult.getThrowable()[ FD ]
Line_39 $$ cache.processSources(targetId, new Processor<Key>() -->Line_66 $$ final GenericCompilerCache.PersistentStateData<SourceState, OutputState> data = cache.getState(targetId, key)[ FD ]
Line_24 $$ final OutputState outputState = data != null ? data.myOutputState : null-->Line_25 $$ if (myForceCompile || sourceState == null || !item.isSourceUpToDate(sourceState) || outputState == null || !item.isOutputUpToDate(outputState)) [ FD ]
Line_90 $$ CompilerUtil.runInContext(myContext, CompilerBundle.message("progress.updating.caches"), new ThrowableRunnable<IOException>() -->Line_108 $$ final RunResult runResult = new ReadAction() [ CD ]
Line_90 $$ CompilerUtil.runInContext(myContext, CompilerBundle.message("progress.updating.caches"), new ThrowableRunnable<IOException>() -->Line_97 $$ CompilerUtil.refreshIOFiles(filesToRefresh)[ CD ]
Line_54 $$ for (int i = 0; i < getItemsCountToShowInLog(toRemove.size()); i++) -->Line_105 $$ LOG.debug("dir: " + dirsToRefresh.get(i))[ FD ]
Line_114 $$ sourceState = item.computeSourceState()-->Line_116 $$ cache.putState(targetId, item.getKey(), sourceState, item.computeOutputState())[ FD ]
Line_17 $$ for (Item item : items) -->Line_25 $$ if (myForceCompile || sourceState == null || !item.isSourceUpToDate(sourceState) || outputState == null || !item.isOutputUpToDate(outputState)) [ FD ]
Line_39 $$ cache.processSources(targetId, new Processor<Key>() -->Line_44 $$ toRemove.add(key)[ FD ]
Line_8 $$ final List<GenericCompilerProcessingItem<Item, SourceState, OutputState>> toProcess = new ArrayList<GenericCompilerProcessingItem<Item, SourceState, OutputState>>()-->Line_72 $$ instance.processItems(target, toProcess, obsoleteItems, new GenericCompilerInstance.OutputConsumer<Item>() [ FD ]
Line_54 $$ for (int i = 0; i < getItemsCountToShowInLog(toRemove.size()); i++) -->Line_101 $$ for (int i = 0; i < getItemsCountToShowInLog(filesToRefresh.size()); i++) [ FD ]
Line_94 $$ for (Key key : toRemove) -->Line_95 $$ cache.remove(targetId, key)[ FD ]
Line_23 $$ SourceState sourceState = data != null ? data.mySourceState : null-->Line_25 $$ if (myForceCompile || sourceState == null || !item.isSourceUpToDate(sourceState) || outputState == null || !item.isOutputUpToDate(outputState)) [ FD ]
Line_51 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) -->Line_55 $$ LOG.debug("to delete:" + toRemove.get(i))[ FD ]
Line_17 $$ for (Item item : items) -->Line_18 $$ final Key key = item.getKey()[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_12 $$ DumbService.getInstance(myProject).runReadActionInSmartMode(new Runnable() [ CD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_35 $$ if (!exception.isNull()) [ CD ]
Line_10 $$ final Ref<IOException> exception = Ref.create(null)-->Line_35 $$ if (!exception.isNull()) [ FD ]
Line_18 $$ final Key key = item.getKey()-->Line_66 $$ final GenericCompilerCache.PersistentStateData<SourceState, OutputState> data = cache.getState(targetId, key)[ FD ]
Line_18 $$ final Key key = item.getKey()-->Line_22 $$ final GenericCompilerCache.PersistentStateData<SourceState, OutputState> data = cache.getState(targetId, key)[ FD ]
Line_8 $$ final List<GenericCompilerProcessingItem<Item, SourceState, OutputState>> toProcess = new ArrayList<GenericCompilerProcessingItem<Item, SourceState, OutputState>>()-->Line_27 $$ toProcess.add(new GenericCompilerProcessingItem<Item, SourceState, OutputState>(item, sourceState, outputState))[ FD ]
Line_9 $$ final THashSet<Key> keySet = new THashSet<Key>(new SourceItemHashingStrategy<Key>(compiler))-->Line_19 $$ keySet.add(key)[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_39 $$ cache.processSources(targetId, new Processor<Key>() [ FD ]
Line_112 $$ SourceState sourceState = sourceStates.get(item)-->Line_114 $$ sourceState = item.computeSourceState()[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_127 $$ return true[ CD ]
Line_10 $$ final Ref<IOException> exception = Ref.create(null)-->Line_36 $$ throw exception.get()[ FD ]
Line_72 $$ instance.processItems(target, toProcess, obsoleteItems, new GenericCompilerInstance.OutputConsumer<Item>() -->Line_81 $$ dirsToRefresh.add(dir)[ CD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_72 $$ instance.processItems(target, toProcess, obsoleteItems, new GenericCompilerInstance.OutputConsumer<Item>() [ CD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_89 $$ checkForErrorsOrCanceled()[ CD ]
Line_51 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) -->Line_104 $$ for (int i = 0; i < getItemsCountToShowInLog(dirsToRefresh.size()); i++) [ FD ]
