Line_15 $$ for (Item item : items) -->Line_18 $$ if (item.isExcluded())[ FD ]
Line_87 $$ if (LOG.isDebugEnabled()) -->Line_92 $$ for (int i = 0; i < getItemsCountToShowInLog(dirsToRefresh.size()); i++) [ CD ]
Line_98 $$ for (Item item : processedItems) -->Line_101 $$ sourceState = item.computeSourceState()[ FD ]
Line_101 $$ sourceState = item.computeSourceState()-->Line_103 $$ cache.putState(targetId, item.getKey(), sourceState, item.computeOutputState())[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_8 $$ final List<GenericCompilerProcessingItem<Item, SourceState, OutputState>> toProcess = new ArrayList<GenericCompilerProcessingItem<Item, SourceState, OutputState>>()[ CD ]
Line_98 $$ for (Item item : processedItems) -->Line_103 $$ cache.putState(targetId, item.getKey(), sourceState, item.computeOutputState())[ FD ]
Line_50 $$ for (int i = 0; i < getItemsCountToShowInLog(toRemove.size()); i++) -->Line_92 $$ for (int i = 0; i < getItemsCountToShowInLog(dirsToRefresh.size()); i++) [ FD ]
Line_45 $$ if (LOG.isDebugEnabled()) -->Line_46 $$ LOG.debug(toProcess.size() + " items will be processed, " + toRemove.size() + " items will be removed")[ CD ]
Line_37 $$ cache.processSources(targetId, new Processor<Key>() -->Line_40 $$ toRemove.add(key)[ FD ]
Line_47 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) -->Line_90 $$ LOG.debug("file: " + filesToRefresh.get(i))[ FD ]
Line_80 $$ CompilerUtil.runInContext(myContext, CompilerBundle.message("progress.updating.caches"), new ThrowableRunnable<IOException>() -->Line_108 $$ if (throwable instanceof IOException)[ CD ]
Line_47 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) -->Line_51 $$ LOG.debug("to delete:" + toRemove.get(i))[ FD ]
Line_47 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) -->Line_89 $$ for (int i = 0; i < getItemsCountToShowInLog(filesToRefresh.size()); i++) [ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_57 $$ if (myOnlyCheckStatus) [ CD ]
Line_68 $$ instance.processItems(target, toProcess, obsoleteItems, new GenericCompilerInstance.OutputConsumer<Item>() -->Line_70 $$ filesToRefresh.add(file)[ CD ]
Line_80 $$ CompilerUtil.runInContext(myContext, CompilerBundle.message("progress.updating.caches"), new ThrowableRunnable<IOException>() -->Line_87 $$ if (LOG.isDebugEnabled()) [ CD ]
Line_16 $$ final Key key = item.getKey()-->Line_40 $$ toRemove.add(key)[ FD ]
Line_82 $$ for (Key key : toRemove) -->Line_83 $$ cache.remove(targetId, key)[ FD ]
Line_92 $$ for (int i = 0; i < getItemsCountToShowInLog(dirsToRefresh.size()); i++) -->Line_93 $$ LOG.debug("dir: " + dirsToRefresh.get(i))[ FD ]
Line_89 $$ for (int i = 0; i < getItemsCountToShowInLog(filesToRefresh.size()); i++) -->Line_90 $$ LOG.debug("file: " + filesToRefresh.get(i))[ FD ]
Line_45 $$ if (LOG.isDebugEnabled()) -->Line_50 $$ for (int i = 0; i < getItemsCountToShowInLog(toRemove.size()); i++) [ CD ]
Line_21 $$ SourceState sourceState = data != null ? data.mySourceState : null-->Line_103 $$ cache.putState(targetId, item.getKey(), sourceState, item.computeOutputState())[ FD ]
Line_89 $$ for (int i = 0; i < getItemsCountToShowInLog(filesToRefresh.size()); i++) -->Line_92 $$ for (int i = 0; i < getItemsCountToShowInLog(dirsToRefresh.size()); i++) [ FD ]
Line_15 $$ for (Item item : items) -->Line_16 $$ final Key key = item.getKey()[ FD ]
Line_37 $$ cache.processSources(targetId, new Processor<Key>() -->Line_42 $$ return true[ CD ]
Line_47 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) -->Line_92 $$ for (int i = 0; i < getItemsCountToShowInLog(dirsToRefresh.size()); i++) [ FD ]
Line_9 $$ final THashSet<Key> keySet = new THashSet<Key>(new SourceItemHashingStrategy<Key>(compiler))-->Line_39 $$ if (!keySet.contains(key)) [ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_3 $$ if (LOG.isDebugEnabled()) [ CD ]
Line_80 $$ CompilerUtil.runInContext(myContext, CompilerBundle.message("progress.updating.caches"), new ThrowableRunnable<IOException>() -->Line_85 $$ CompilerUtil.refreshIOFiles(filesToRefresh)[ CD ]
Line_10 $$ final Ref<IOException> exception = Ref.create(null)-->Line_29 $$ exception.set(e)[ FD ]
Line_8 $$ final List<GenericCompilerProcessingItem<Item, SourceState, OutputState>> toProcess = new ArrayList<GenericCompilerProcessingItem<Item, SourceState, OutputState>>()-->Line_48 $$ LOG.debug("to process:" + toProcess.get(i).getItem().getKey())[ FD ]
Line_68 $$ instance.processItems(target, toProcess, obsoleteItems, new GenericCompilerInstance.OutputConsumer<Item>() -->Line_76 $$ processedItems.add(sourceItem)[ FD ]
Line_47 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) -->Line_93 $$ LOG.debug("dir: " + dirsToRefresh.get(i))[ FD ]
Line_15 $$ for (Item item : items) -->Line_99 $$ SourceState sourceState = sourceStates.get(item)[ FD ]
Line_99 $$ SourceState sourceState = sourceStates.get(item)-->Line_103 $$ cache.putState(targetId, item.getKey(), sourceState, item.computeOutputState())[ FD ]
Line_21 $$ SourceState sourceState = data != null ? data.mySourceState : null-->Line_101 $$ sourceState = item.computeSourceState()[ FD ]
Line_11 $$ final Map<Item, SourceState> sourceStates = new HashMap<Item, SourceState>()-->Line_99 $$ SourceState sourceState = sourceStates.get(item)[ FD ]
Line_16 $$ final Key key = item.getKey()-->Line_83 $$ cache.remove(targetId, key)[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_114 $$ return true[ CD ]
Line_50 $$ for (int i = 0; i < getItemsCountToShowInLog(toRemove.size()); i++) -->Line_90 $$ LOG.debug("file: " + filesToRefresh.get(i))[ FD ]
Line_8 $$ final List<GenericCompilerProcessingItem<Item, SourceState, OutputState>> toProcess = new ArrayList<GenericCompilerProcessingItem<Item, SourceState, OutputState>>()-->Line_25 $$ toProcess.add(new GenericCompilerProcessingItem<Item, SourceState, OutputState>(item, sourceState, outputState))[ FD ]
Line_37 $$ cache.processSources(targetId, new Processor<Key>() -->Line_39 $$ if (!keySet.contains(key)) [ CD ]
Line_21 $$ SourceState sourceState = data != null ? data.mySourceState : null-->Line_100 $$ if (sourceState == null) [ FD ]
Line_15 $$ for (Item item : items) -->Line_24 $$ sourceStates.put(item, item.computeSourceState())[ FD ]
Line_45 $$ if (LOG.isDebugEnabled()) -->Line_47 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) [ CD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_68 $$ instance.processItems(target, toProcess, obsoleteItems, new GenericCompilerInstance.OutputConsumer<Item>() [ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_80 $$ CompilerUtil.runInContext(myContext, CompilerBundle.message("progress.updating.caches"), new ThrowableRunnable<IOException>() [ CD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_33 $$ if (!exception.isNull()) [ CD ]
Line_54 $$ if (toProcess.isEmpty() && toRemove.isEmpty()) -->Line_55 $$ return false[ CD ]
Line_108 $$ if (throwable instanceof IOException)-->Line_110 $$ if (throwable != null)[ CD ]
Line_8 $$ final List<GenericCompilerProcessingItem<Item, SourceState, OutputState>> toProcess = new ArrayList<GenericCompilerProcessingItem<Item, SourceState, OutputState>>()-->Line_54 $$ if (toProcess.isEmpty() && toRemove.isEmpty()) [ FD ]
Line_68 $$ instance.processItems(target, toProcess, obsoleteItems, new GenericCompilerInstance.OutputConsumer<Item>() -->Line_73 $$ dirsToRefresh.add(dir)[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_12 $$ DumbService.getInstance(myProject).runReadActionInSmartMode(new Runnable() [ CD ]
Line_39 $$ if (!keySet.contains(key)) -->Line_40 $$ toRemove.add(key)[ CD ]
Line_92 $$ for (int i = 0; i < getItemsCountToShowInLog(dirsToRefresh.size()); i++) -->Line_93 $$ LOG.debug("dir: " + dirsToRefresh.get(i))[ CD ]
Line_16 $$ final Key key = item.getKey()-->Line_39 $$ if (!keySet.contains(key)) [ FD ]
Line_8 $$ final List<GenericCompilerProcessingItem<Item, SourceState, OutputState>> toProcess = new ArrayList<GenericCompilerProcessingItem<Item, SourceState, OutputState>>()-->Line_46 $$ LOG.debug(toProcess.size() + " items will be processed, " + toRemove.size() + " items will be removed")[ FD ]
Line_8 $$ final List<GenericCompilerProcessingItem<Item, SourceState, OutputState>> toProcess = new ArrayList<GenericCompilerProcessingItem<Item, SourceState, OutputState>>()-->Line_47 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) [ FD ]
Line_15 $$ for (Item item : items) -->Line_101 $$ sourceState = item.computeSourceState()[ FD ]
Line_50 $$ for (int i = 0; i < getItemsCountToShowInLog(toRemove.size()); i++) -->Line_93 $$ LOG.debug("dir: " + dirsToRefresh.get(i))[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_9 $$ final THashSet<Key> keySet = new THashSet<Key>(new SourceItemHashingStrategy<Key>(compiler))[ CD ]
Line_50 $$ for (int i = 0; i < getItemsCountToShowInLog(toRemove.size()); i++) -->Line_89 $$ for (int i = 0; i < getItemsCountToShowInLog(filesToRefresh.size()); i++) [ FD ]
Line_47 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) -->Line_48 $$ LOG.debug("to process:" + toProcess.get(i).getItem().getKey())[ FD ]
Line_50 $$ for (int i = 0; i < getItemsCountToShowInLog(toRemove.size()); i++) -->Line_51 $$ LOG.debug("to delete:" + toRemove.get(i))[ FD ]
Line_68 $$ instance.processItems(target, toProcess, obsoleteItems, new GenericCompilerInstance.OutputConsumer<Item>() -->Line_70 $$ filesToRefresh.add(file)[ FD ]
Line_80 $$ CompilerUtil.runInContext(myContext, CompilerBundle.message("progress.updating.caches"), new ThrowableRunnable<IOException>() -->Line_96 $$ final RunResult runResult = new ReadAction() [ CD ]
Line_8 $$ final List<GenericCompilerProcessingItem<Item, SourceState, OutputState>> toProcess = new ArrayList<GenericCompilerProcessingItem<Item, SourceState, OutputState>>()-->Line_68 $$ instance.processItems(target, toProcess, obsoleteItems, new GenericCompilerInstance.OutputConsumer<Item>() [ FD ]
Line_68 $$ instance.processItems(target, toProcess, obsoleteItems, new GenericCompilerInstance.OutputConsumer<Item>() -->Line_73 $$ dirsToRefresh.add(dir)[ CD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_20 $$ final GenericCompilerCache.PersistentStateData<SourceState, OutputState> data = cache.getState(targetId, key)[ FD ]
Line_21 $$ SourceState sourceState = data != null ? data.mySourceState : null-->Line_23 $$ if (myForceCompile || sourceState == null || !item.isSourceUpToDate(sourceState) || outputState == null || !item.isOutputUpToDate(outputState)) [ FD ]
Line_15 $$ for (Item item : items) -->Line_103 $$ cache.putState(targetId, item.getKey(), sourceState, item.computeOutputState())[ FD ]
Line_9 $$ final THashSet<Key> keySet = new THashSet<Key>(new SourceItemHashingStrategy<Key>(compiler))-->Line_17 $$ keySet.add(key)[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_10 $$ final Ref<IOException> exception = Ref.create(null)[ CD ]
Line_37 $$ cache.processSources(targetId, new Processor<Key>() -->Line_62 $$ final GenericCompilerCache.PersistentStateData<SourceState, OutputState> data = cache.getState(targetId, key)[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_6 $$ final List<Item> items = instance.getItems(target)[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_45 $$ if (LOG.isDebugEnabled()) [ CD ]
Line_68 $$ instance.processItems(target, toProcess, obsoleteItems, new GenericCompilerInstance.OutputConsumer<Item>() -->Line_76 $$ processedItems.add(sourceItem)[ CD ]
Line_11 $$ final Map<Item, SourceState> sourceStates = new HashMap<Item, SourceState>()-->Line_24 $$ sourceStates.put(item, item.computeSourceState())[ FD ]
Line_47 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) -->Line_48 $$ LOG.debug("to process:" + toProcess.get(i).getItem().getKey())[ CD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_54 $$ if (toProcess.isEmpty() && toRemove.isEmpty()) [ CD ]
Line_96 $$ final RunResult runResult = new ReadAction() -->Line_107 $$ Throwable throwable = runResult.getThrowable()[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_6 $$ final List<Item> items = instance.getItems(target)[ CD ]
Line_89 $$ for (int i = 0; i < getItemsCountToShowInLog(filesToRefresh.size()); i++) -->Line_90 $$ LOG.debug("file: " + filesToRefresh.get(i))[ CD ]
Line_98 $$ for (Item item : processedItems) -->Line_99 $$ SourceState sourceState = sourceStates.get(item)[ FD ]
Line_99 $$ SourceState sourceState = sourceStates.get(item)-->Line_100 $$ if (sourceState == null) [ FD ]
Line_3 $$ if (LOG.isDebugEnabled()) -->Line_4 $$ LOG.debug("Processing target '" + target + "' (id=" + targetId + ") by " + compiler)[ CD ]
Line_16 $$ final Key key = item.getKey()-->Line_62 $$ final GenericCompilerCache.PersistentStateData<SourceState, OutputState> data = cache.getState(targetId, key)[ FD ]
Line_10 $$ final Ref<IOException> exception = Ref.create(null)-->Line_33 $$ if (!exception.isNull()) [ FD ]
Line_16 $$ final Key key = item.getKey()-->Line_20 $$ final GenericCompilerCache.PersistentStateData<SourceState, OutputState> data = cache.getState(targetId, key)[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_7 $$ checkForErrorsOrCanceled()[ CD ]
Line_23 $$ if (myForceCompile || sourceState == null || !item.isSourceUpToDate(sourceState) || outputState == null || !item.isOutputUpToDate(outputState)) -->Line_25 $$ toProcess.add(new GenericCompilerProcessingItem<Item, SourceState, OutputState>(item, sourceState, outputState))[ CD ]
Line_89 $$ for (int i = 0; i < getItemsCountToShowInLog(filesToRefresh.size()); i++) -->Line_93 $$ LOG.debug("dir: " + dirsToRefresh.get(i))[ FD ]
Line_37 $$ cache.processSources(targetId, new Processor<Key>() -->Line_83 $$ cache.remove(targetId, key)[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_79 $$ checkForErrorsOrCanceled()[ CD ]
Line_100 $$ if (sourceState == null) -->Line_101 $$ sourceState = item.computeSourceState()[ CD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_68 $$ instance.processItems(target, toProcess, obsoleteItems, new GenericCompilerInstance.OutputConsumer<Item>() [ CD ]
Line_23 $$ if (myForceCompile || sourceState == null || !item.isSourceUpToDate(sourceState) || outputState == null || !item.isOutputUpToDate(outputState)) -->Line_24 $$ sourceStates.put(item, item.computeSourceState())[ CD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_37 $$ cache.processSources(targetId, new Processor<Key>() [ FD ]
Line_87 $$ if (LOG.isDebugEnabled()) -->Line_89 $$ for (int i = 0; i < getItemsCountToShowInLog(filesToRefresh.size()); i++) [ CD ]
Line_80 $$ CompilerUtil.runInContext(myContext, CompilerBundle.message("progress.updating.caches"), new ThrowableRunnable<IOException>() -->Line_107 $$ Throwable throwable = runResult.getThrowable()[ CD ]
Line_99 $$ SourceState sourceState = sourceStates.get(item)-->Line_101 $$ sourceState = item.computeSourceState()[ FD ]
Line_10 $$ final Ref<IOException> exception = Ref.create(null)-->Line_34 $$ throw exception.get()[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_37 $$ cache.processSources(targetId, new Processor<Key>() [ CD ]
Line_22 $$ final OutputState outputState = data != null ? data.myOutputState : null-->Line_23 $$ if (myForceCompile || sourceState == null || !item.isSourceUpToDate(sourceState) || outputState == null || !item.isOutputUpToDate(outputState)) [ FD ]
Line_16 $$ final Key key = item.getKey()-->Line_17 $$ keySet.add(key)[ FD ]
Line_15 $$ for (Item item : items) -->Line_23 $$ if (myForceCompile || sourceState == null || !item.isSourceUpToDate(sourceState) || outputState == null || !item.isOutputUpToDate(outputState)) [ FD ]
Line_47 $$ for (int i = 0; i < getItemsCountToShowInLog(toProcess.size()); i++) -->Line_50 $$ for (int i = 0; i < getItemsCountToShowInLog(toRemove.size()); i++) [ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_83 $$ cache.remove(targetId, key)[ FD ]
Line_37 $$ cache.processSources(targetId, new Processor<Key>() -->Line_39 $$ if (!keySet.contains(key)) [ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_103 $$ cache.putState(targetId, item.getKey(), sourceState, item.computeOutputState())[ FD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_11 $$ final Map<Item, SourceState> sourceStates = new HashMap<Item, SourceState>()[ CD ]
Line_80 $$ CompilerUtil.runInContext(myContext, CompilerBundle.message("progress.updating.caches"), new ThrowableRunnable<IOException>() -->Line_86 $$ CompilerUtil.refreshIODirectories(dirsToRefresh)[ CD ]
Line_2 $$ private <T extends BuildTarget, Item extends CompileItem<Key, SourceState, OutputState>, Key, SourceState, OutputState> boolean processTarget(T target, final int targetId, final GenericCompiler<Key, SourceState, OutputState> compiler, final GenericCompilerInstance<T, Item, Key, SourceState, OutputState> instance, final GenericCompilerCache<Key, SourceState, OutputState> cache) throws IOException, ExitException -->Line_62 $$ final GenericCompilerCache.PersistentStateData<SourceState, OutputState> data = cache.getState(targetId, key)[ FD ]
Line_87 $$ if (LOG.isDebugEnabled()) -->Line_88 $$ LOG.debug("refreshed " + filesToRefresh.size() + " files and " + dirsToRefresh.size() + " dirs")[ CD ]
Line_50 $$ for (int i = 0; i < getItemsCountToShowInLog(toRemove.size()); i++) -->Line_51 $$ LOG.debug("to delete:" + toRemove.get(i))[ CD ]
