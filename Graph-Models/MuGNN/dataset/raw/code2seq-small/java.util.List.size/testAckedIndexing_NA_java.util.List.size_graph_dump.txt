Line_29 $$ final Semaphore semaphore = new Semaphore(0)-->Line_87 $$ assertThat(semaphore.availablePermits(), equalTo(0))[ FD ]
Line_24 $$ final AtomicReference<CountDownLatch> countDownLatchRef = new AtomicReference()-->Line_78 $$ assertTrue(countDownLatchRef.get().await(1, TimeUnit.MINUTES))[ FD ]
Line_46 $$ id = Integer.toString(idGenerator.incrementAndGet())-->Line_52 $$ logger.trace("[[ FD ]
Line_79 $$ for (int iter = 1 + randomInt(2); iter > 0; iter--) -->Line_90 $$ assertTrue(countDownLatchRef.get().await(60000 + disruptionScheme.expectedTimeToHeal().millis() * (docsPerIndexer * indexers.size()), TimeUnit.MILLISECONDS))[ CD ]
Line_39 $$ String id = null-->Line_49 $$ IndexResponse response = client.prepareIndex("test", "type", id).setSource("[ FD ]
Line_79 $$ for (int iter = 1 + randomInt(2); iter > 0; iter--) -->Line_93 $$ ensureStableCluster(3, TimeValue.timeValueMillis(disruptionScheme.expectedTimeToHeal().millis() + DISRUPTION_HEALING_OVERHEAD.millis()))[ CD ]
Line_46 $$ id = Integer.toString(idGenerator.incrementAndGet())-->Line_100 $$ assertTrue("doc [" + id + "] indexed via node [" + ackedDocs.get(id) + "] not found", client(node).prepareGet("test", "type", id).setPreference("_local").get().isExists())[ FD ]
Line_16 $$ ServiceDisruptionScheme disruptionScheme = addRandomDisruptionScheme()-->Line_17 $$ logger.info("disruption scheme [[ FD ]
Line_28 $$ for (final String node : nodes) -->Line_100 $$ assertTrue("doc [" + id + "] indexed via node [" + ackedDocs.get(id) + "] not found", client(node).prepareGet("test", "type", id).setPreference("_local").get().isExists())[ FD ]
Line_39 $$ String id = null-->Line_100 $$ assertTrue("doc [" + id + "] indexed via node [" + ackedDocs.get(id) + "] not found", client(node).prepareGet("test", "type", id).setPreference("_local").get().isExists())[ FD ]
Line_16 $$ ServiceDisruptionScheme disruptionScheme = addRandomDisruptionScheme()-->Line_93 $$ ensureStableCluster(3, TimeValue.timeValueMillis(disruptionScheme.expectedTimeToHeal().millis() + DISRUPTION_HEALING_OVERHEAD.millis()))[ FD ]
Line_39 $$ String id = null-->Line_48 $$ logger.trace("[[ FD ]
Line_29 $$ final Semaphore semaphore = new Semaphore(0)-->Line_41 $$ if (!semaphore.tryAcquire(10, TimeUnit.SECONDS)) [ FD ]
Line_86 $$ for (Semaphore semaphore : semaphores) -->Line_88 $$ semaphore.release(docsPerIndexer)[ FD ]
Line_46 $$ id = Integer.toString(idGenerator.incrementAndGet())-->Line_48 $$ logger.trace("[[ FD ]
Line_24 $$ final AtomicReference<CountDownLatch> countDownLatchRef = new AtomicReference()-->Line_74 $$ countDownLatchRef.set(new CountDownLatch(docsPerIndexer * indexers.size()))[ FD ]
Line_28 $$ for (final String node : nodes) -->Line_51 $$ ackedDocs.put(id, node)[ FD ]
Line_28 $$ for (final String node : nodes) -->Line_55 $$ logger.trace("[[ FD ]
Line_39 $$ String id = null-->Line_47 $$ int shard = Murmur3HashFunction.hash(id) % numPrimaries[ FD ]
Line_79 $$ for (int iter = 1 + randomInt(2); iter > 0; iter--) -->Line_95 $$ logger.info("validating successful docs")[ CD ]
Line_39 $$ String id = null-->Line_46 $$ id = Integer.toString(idGenerator.incrementAndGet())[ FD ]
Line_28 $$ for (final String node : nodes) -->Line_52 $$ logger.trace("[[ FD ]
Line_29 $$ final Semaphore semaphore = new Semaphore(0)-->Line_88 $$ semaphore.release(docsPerIndexer)[ FD ]
Line_79 $$ for (int iter = 1 + randomInt(2); iter > 0; iter--) -->Line_91 $$ logger.info("stopping disruption")[ CD ]
Line_22 $$ List<Semaphore> semaphores = new ArrayList(nodes.size())-->Line_30 $$ semaphores.add(semaphore)[ FD ]
Line_46 $$ id = Integer.toString(idGenerator.incrementAndGet())-->Line_51 $$ ackedDocs.put(id, node)[ FD ]
Line_29 $$ final Semaphore semaphore = new Semaphore(0)-->Line_30 $$ semaphores.add(semaphore)[ FD ]
Line_46 $$ id = Integer.toString(idGenerator.incrementAndGet())-->Line_47 $$ int shard = Murmur3HashFunction.hash(id) % numPrimaries[ FD ]
Line_21 $$ List<Thread> indexers = new ArrayList(nodes.size())-->Line_32 $$ final String name = "indexer_" + indexers.size()[ FD ]
Line_28 $$ for (final String node : nodes) -->Line_98 $$ logger.debug("validating through node [[ FD ]
Line_86 $$ for (Semaphore semaphore : semaphores) -->Line_87 $$ assertThat(semaphore.availablePermits(), equalTo(0))[ FD ]
Line_24 $$ final AtomicReference<CountDownLatch> countDownLatchRef = new AtomicReference()-->Line_90 $$ assertTrue(countDownLatchRef.get().await(60000 + disruptionScheme.expectedTimeToHeal().millis() * (docsPerIndexer * indexers.size()), TimeUnit.MILLISECONDS))[ FD ]
Line_28 $$ for (final String node : nodes) -->Line_48 $$ logger.trace("[[ FD ]
Line_34 $$ Thread thread = new Thread(new Runnable() -->Line_69 $$ thread.start()[ FD ]
Line_49 $$ IndexResponse response = client.prepareIndex("test", "type", id).setSource("-->Line_50 $$ assertThat(response.getVersion(), equalTo(1l))[ FD ]
Line_46 $$ id = Integer.toString(idGenerator.incrementAndGet())-->Line_55 $$ logger.trace("[[ FD ]
Line_20 $$ final AtomicBoolean stop = new AtomicBoolean(false)-->Line_117 $$ stop.set(true)[ FD ]
Line_34 $$ Thread thread = new Thread(new Runnable() -->Line_38 $$ while (!stop.get()) [ CD ]
Line_47 $$ int shard = Murmur3HashFunction.hash(id) % numPrimaries-->Line_48 $$ logger.trace("[[ FD ]
Line_21 $$ List<Thread> indexers = new ArrayList(nodes.size())-->Line_90 $$ assertTrue(countDownLatchRef.get().await(60000 + disruptionScheme.expectedTimeToHeal().millis() * (docsPerIndexer * indexers.size()), TimeUnit.MILLISECONDS))[ FD ]
Line_99 $$ for (String id : ackedDocs.keySet()) -->Line_100 $$ assertTrue("doc [" + id + "] indexed via node [" + ackedDocs.get(id) + "] not found", client(node).prepareGet("test", "type", id).setPreference("_local").get().isExists())[ FD ]
Line_29 $$ final Semaphore semaphore = new Semaphore(0)-->Line_44 $$ logger.info("[[ FD ]
Line_79 $$ for (int iter = 1 + randomInt(2); iter > 0; iter--) -->Line_106 $$ logger.info("done validating (iteration [[ CD ]
Line_21 $$ List<Thread> indexers = new ArrayList(nodes.size())-->Line_70 $$ indexers.add(thread)[ FD ]
Line_24 $$ final AtomicReference<CountDownLatch> countDownLatchRef = new AtomicReference()-->Line_57 $$ countDownLatchRef.get().countDown()[ FD ]
Line_25 $$ final List<Exception> exceptedExceptions = Collections.synchronizedList(new ArrayList<Exception>())-->Line_109 $$ if (exceptedExceptions.size() > 0) [ FD ]
Line_16 $$ ServiceDisruptionScheme disruptionScheme = addRandomDisruptionScheme()-->Line_81 $$ disruptionScheme.startDisrupting()[ FD ]
Line_32 $$ final String name = "indexer_" + indexers.size()-->Line_48 $$ logger.trace("[[ FD ]
Line_24 $$ final AtomicReference<CountDownLatch> countDownLatchRef = new AtomicReference()-->Line_84 $$ countDownLatchRef.set(new CountDownLatch(docsPerIndexer * indexers.size()))[ FD ]
Line_39 $$ String id = null-->Line_51 $$ ackedDocs.put(id, node)[ FD ]
Line_46 $$ id = Integer.toString(idGenerator.incrementAndGet())-->Line_49 $$ IndexResponse response = client.prepareIndex("test", "type", id).setSource("[ FD ]
Line_31 $$ final Client client = client(node)-->Line_49 $$ IndexResponse response = client.prepareIndex("test", "type", id).setSource("[ FD ]
Line_79 $$ for (int iter = 1 + randomInt(2); iter > 0; iter--) -->Line_83 $$ logger.info("indexing " + docsPerIndexer + " docs per indexer during partition")[ CD ]
Line_23 $$ final AtomicInteger idGenerator = new AtomicInteger(0)-->Line_46 $$ id = Integer.toString(idGenerator.incrementAndGet())[ FD ]
Line_29 $$ final Semaphore semaphore = new Semaphore(0)-->Line_76 $$ semaphore.release(docsPerIndexer)[ FD ]
Line_109 $$ if (exceptedExceptions.size() > 0) -->Line_114 $$ logger.debug(sb.toString())[ CD ]
Line_96 $$ for (String node : nodes) -->Line_100 $$ assertTrue("doc [" + id + "] indexed via node [" + ackedDocs.get(id) + "] not found", client(node).prepareGet("test", "type", id).setPreference("_local").get().isExists())[ FD ]
Line_79 $$ for (int iter = 1 + randomInt(2); iter > 0; iter--) -->Line_85 $$ Collections.shuffle(semaphores, random())[ CD ]
Line_79 $$ for (int iter = 1 + randomInt(2); iter > 0; iter--) -->Line_80 $$ logger.info("starting disruptions & indexing (iteration [[ FD ]
Line_28 $$ for (final String node : nodes) -->Line_63 $$ logger.info("unexpected exception in background thread of [[ FD ]
Line_39 $$ String id = null-->Line_55 $$ logger.trace("[[ FD ]
Line_32 $$ final String name = "indexer_" + indexers.size()-->Line_44 $$ logger.info("[[ FD ]
Line_79 $$ for (int iter = 1 + randomInt(2); iter > 0; iter--) -->Line_81 $$ disruptionScheme.startDisrupting()[ CD ]
Line_79 $$ for (int iter = 1 + randomInt(2); iter > 0; iter--) -->Line_94 $$ ensureGreen("test")[ CD ]
Line_79 $$ for (int iter = 1 + randomInt(2); iter > 0; iter--) -->Line_84 $$ countDownLatchRef.set(new CountDownLatch(docsPerIndexer * indexers.size()))[ CD ]
Line_38 $$ while (!stop.get()) -->Line_39 $$ String id = null[ CD ]
Line_34 $$ Thread thread = new Thread(new Runnable() -->Line_70 $$ indexers.add(thread)[ FD ]
Line_32 $$ final String name = "indexer_" + indexers.size()-->Line_52 $$ logger.trace("[[ FD ]
Line_25 $$ final List<Exception> exceptedExceptions = Collections.synchronizedList(new ArrayList<Exception>())-->Line_54 $$ exceptedExceptions.add(e)[ FD ]
Line_34 $$ Thread thread = new Thread(new Runnable() -->Line_68 $$ thread.setName(name)[ FD ]
Line_22 $$ List<Semaphore> semaphores = new ArrayList(nodes.size())-->Line_85 $$ Collections.shuffle(semaphores, random())[ FD ]
Line_32 $$ final String name = "indexer_" + indexers.size()-->Line_55 $$ logger.trace("[[ FD ]
Line_32 $$ final String name = "indexer_" + indexers.size()-->Line_68 $$ thread.setName(name)[ FD ]
Line_24 $$ final AtomicReference<CountDownLatch> countDownLatchRef = new AtomicReference()-->Line_58 $$ logger.trace("[[ FD ]
Line_79 $$ for (int iter = 1 + randomInt(2); iter > 0; iter--) -->Line_80 $$ logger.info("starting disruptions & indexing (iteration [[ CD ]
Line_21 $$ List<Thread> indexers = new ArrayList(nodes.size())-->Line_84 $$ countDownLatchRef.set(new CountDownLatch(docsPerIndexer * indexers.size()))[ FD ]
Line_16 $$ ServiceDisruptionScheme disruptionScheme = addRandomDisruptionScheme()-->Line_90 $$ assertTrue(countDownLatchRef.get().await(60000 + disruptionScheme.expectedTimeToHeal().millis() * (docsPerIndexer * indexers.size()), TimeUnit.MILLISECONDS))[ FD ]
Line_16 $$ ServiceDisruptionScheme disruptionScheme = addRandomDisruptionScheme()-->Line_92 $$ disruptionScheme.stopDisrupting()[ FD ]
Line_21 $$ List<Thread> indexers = new ArrayList(nodes.size())-->Line_74 $$ countDownLatchRef.set(new CountDownLatch(docsPerIndexer * indexers.size()))[ FD ]
Line_20 $$ final AtomicBoolean stop = new AtomicBoolean(false)-->Line_38 $$ while (!stop.get()) [ FD ]
Line_32 $$ final String name = "indexer_" + indexers.size()-->Line_58 $$ logger.trace("[[ FD ]
Line_28 $$ for (final String node : nodes) -->Line_31 $$ final Client client = client(node)[ FD ]
Line_79 $$ for (int iter = 1 + randomInt(2); iter > 0; iter--) -->Line_92 $$ disruptionScheme.stopDisrupting()[ CD ]
Line_39 $$ String id = null-->Line_52 $$ logger.trace("[[ FD ]
Line_96 $$ for (String node : nodes) -->Line_98 $$ logger.debug("validating through node [[ FD ]
Line_79 $$ for (int iter = 1 + randomInt(2); iter > 0; iter--) -->Line_106 $$ logger.info("done validating (iteration [[ FD ]
