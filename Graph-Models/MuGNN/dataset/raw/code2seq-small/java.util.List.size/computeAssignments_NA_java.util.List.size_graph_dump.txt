Line_17 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)-->Line_64 $$ assignmentStats.addAssignedSplit(chosenNode)[ FD ]
Line_4 $$ NodeMap nodeMap = this.nodeMap.get().get()-->Line_52 $$ Set<Node> nodes = nodeMap.getWorkersByNetworkPath().get(location)[ FD ]
Line_17 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)-->Line_20 $$ assignmentStats.addAssignedSplit(chosenNode)[ FD ]
Line_10 $$ for (Split split : splits) -->Line_63 $$ assignment.put(chosenNode, split)[ FD ]
Line_25 $$ int depth = networkLocationSegmentNames.size()-->Line_43 $$ depth = 0[ FD ]
Line_48 $$ location = location.subLocation(0, i)-->Line_52 $$ Set<Node> nodes = nodeMap.getWorkersByNetworkPath().get(location)[ FD ]
Line_12 $$ List<Node> candidateNodes = selectExactNodes(nodeMap, split.getAddresses(), includeCoordinator)-->Line_13 $$ if (candidateNodes.isEmpty()) [ FD ]
Line_55 $$ if (chosenNode != null) -->Line_56 $$ chosenDepth = i[ CD ]
Line_7 $$ NodeAssignmentStats assignmentStats = new NodeAssignmentStats(nodeTaskMap, nodeMap, existingTasks)-->Line_20 $$ assignmentStats.addAssignedSplit(chosenNode)[ FD ]
Line_6 $$ Multimap<Node, Split> assignment = HashMultimap.create()-->Line_19 $$ assignment.put(chosenNode, split)[ FD ]
Line_7 $$ NodeAssignmentStats assignmentStats = new NodeAssignmentStats(nodeTaskMap, nodeMap, existingTasks)-->Line_54 $$ chosenNode = bestNodeSplitCount(new ResettableRandomizedIterator(nodes), minCandidates, (int) Math.ceil(queueFraction * maxSplitsPerNodePerTaskWhenFull), assignmentStats)[ FD ]
Line_9 $$ Set<NetworkLocation> filledLocations = new HashSet()-->Line_59 $$ filledLocations.add(location)[ FD ]
Line_17 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)-->Line_63 $$ assignment.put(chosenNode, split)[ FD ]
Line_10 $$ for (Split split : splits) -->Line_14 $$ log.debug("No nodes available to schedule %s. Available nodes %s", split, nodeMap.getNodesByHost().keys())[ FD ]
Line_4 $$ NodeMap nodeMap = this.nodeMap.get().get()-->Line_12 $$ List<Node> candidateNodes = selectExactNodes(nodeMap, split.getAddresses(), includeCoordinator)[ FD ]
Line_10 $$ for (Split split : splits) -->Line_11 $$ if (!split.isRemotelyAccessible()) [ FD ]
Line_10 $$ for (Split split : splits) -->Line_28 $$ for (HostAddress host : split.getAddresses()) [ FD ]
Line_4 $$ NodeMap nodeMap = this.nodeMap.get().get()-->Line_5 $$ Collection<Node> allNodes = nodeMap.getNodesByHostAndPort().values()[ FD ]
Line_9 $$ Set<NetworkLocation> filledLocations = new HashSet()-->Line_49 $$ if (filledLocations.contains(location)) [ FD ]
Line_26 $$ int chosenDepth = 0-->Line_56 $$ chosenDepth = i[ FD ]
Line_11 $$ if (!split.isRemotelyAccessible()) -->Line_12 $$ List<Node> candidateNodes = selectExactNodes(nodeMap, split.getAddresses(), includeCoordinator)[ CD ]
Line_18 $$ if (chosenNode != null) -->Line_19 $$ assignment.put(chosenNode, split)[ CD ]
Line_47 $$ for (NetworkLocation location : locations) -->Line_48 $$ location = location.subLocation(0, i)[ FD ]
Line_17 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)-->Line_62 $$ if (chosenNode != null) [ FD ]
Line_11 $$ if (!split.isRemotelyAccessible()) -->Line_17 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)[ CD ]
Line_28 $$ for (HostAddress host : split.getAddresses()) -->Line_30 $$ if (negativeNetworkLocationCache.getIfPresent(host) != null) [ FD ]
Line_54 $$ chosenNode = bestNodeSplitCount(new ResettableRandomizedIterator(nodes), minCandidates, (int) Math.ceil(queueFraction * maxSplitsPerNodePerTaskWhenFull), assignmentStats)-->Line_63 $$ assignment.put(chosenNode, split)[ FD ]
Line_13 $$ if (candidateNodes.isEmpty()) -->Line_14 $$ log.debug("No nodes available to schedule %s. Available nodes %s", split, nodeMap.getNodesByHost().keys())[ CD ]
Line_17 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)-->Line_18 $$ if (chosenNode != null) [ FD ]
Line_69 $$ if (topologicCounters[i] > 0) -->Line_70 $$ topologicalSplitCounters.get(i).update(topologicCounters[i])[ CD ]
Line_11 $$ if (!split.isRemotelyAccessible()) -->Line_18 $$ if (chosenNode != null) [ CD ]
Line_48 $$ location = location.subLocation(0, i)-->Line_49 $$ if (filledLocations.contains(location)) [ FD ]
Line_28 $$ for (HostAddress host : split.getAddresses()) -->Line_36 $$ negativeNetworkLocationCache.put(host, true)[ FD ]
Line_54 $$ chosenNode = bestNodeSplitCount(new ResettableRandomizedIterator(nodes), minCandidates, (int) Math.ceil(queueFraction * maxSplitsPerNodePerTaskWhenFull), assignmentStats)-->Line_62 $$ if (chosenNode != null) [ FD ]
Line_11 $$ if (!split.isRemotelyAccessible()) -->Line_13 $$ if (candidateNodes.isEmpty()) [ CD ]
Line_12 $$ List<Node> candidateNodes = selectExactNodes(nodeMap, split.getAddresses(), includeCoordinator)-->Line_17 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)[ FD ]
Line_7 $$ NodeAssignmentStats assignmentStats = new NodeAssignmentStats(nodeTaskMap, nodeMap, existingTasks)-->Line_17 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)[ FD ]
Line_27 $$ List<NetworkLocation> locations = new ArrayList()-->Line_33 $$ locations.add(networkLocationCache.get(host))[ FD ]
Line_62 $$ if (chosenNode != null) -->Line_63 $$ assignment.put(chosenNode, split)[ CD ]
Line_28 $$ for (HostAddress host : split.getAddresses()) -->Line_37 $$ log.warn(e, "Unable to determine location of %s. Will attempt again in %s", host, NEGATIVE_CACHE_DURATION)[ FD ]
Line_7 $$ NodeAssignmentStats assignmentStats = new NodeAssignmentStats(nodeTaskMap, nodeMap, existingTasks)-->Line_64 $$ assignmentStats.addAssignedSplit(chosenNode)[ FD ]
Line_62 $$ if (chosenNode != null) -->Line_65 $$ topologicCounters[chosenDepth]++[ CD ]
Line_17 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)-->Line_54 $$ chosenNode = bestNodeSplitCount(new ResettableRandomizedIterator(nodes), minCandidates, (int) Math.ceil(queueFraction * maxSplitsPerNodePerTaskWhenFull), assignmentStats)[ FD ]
Line_10 $$ for (Split split : splits) -->Line_12 $$ List<Node> candidateNodes = selectExactNodes(nodeMap, split.getAddresses(), includeCoordinator)[ FD ]
Line_18 $$ if (chosenNode != null) -->Line_20 $$ assignmentStats.addAssignedSplit(chosenNode)[ CD ]
Line_10 $$ for (Split split : splits) -->Line_19 $$ assignment.put(chosenNode, split)[ FD ]
Line_54 $$ chosenNode = bestNodeSplitCount(new ResettableRandomizedIterator(nodes), minCandidates, (int) Math.ceil(queueFraction * maxSplitsPerNodePerTaskWhenFull), assignmentStats)-->Line_64 $$ assignmentStats.addAssignedSplit(chosenNode)[ FD ]
Line_6 $$ Multimap<Node, Split> assignment = HashMultimap.create()-->Line_63 $$ assignment.put(chosenNode, split)[ FD ]
Line_68 $$ for (int i = 0; i < topologicCounters.length; i++) -->Line_70 $$ topologicalSplitCounters.get(i).update(topologicCounters[i])[ FD ]
Line_54 $$ chosenNode = bestNodeSplitCount(new ResettableRandomizedIterator(nodes), minCandidates, (int) Math.ceil(queueFraction * maxSplitsPerNodePerTaskWhenFull), assignmentStats)-->Line_55 $$ if (chosenNode != null) [ FD ]
Line_47 $$ for (NetworkLocation location : locations) -->Line_49 $$ if (filledLocations.contains(location)) [ FD ]
Line_62 $$ if (chosenNode != null) -->Line_64 $$ assignmentStats.addAssignedSplit(chosenNode)[ CD ]
Line_47 $$ for (NetworkLocation location : locations) -->Line_59 $$ filledLocations.add(location)[ FD ]
Line_48 $$ location = location.subLocation(0, i)-->Line_59 $$ filledLocations.add(location)[ FD ]
Line_47 $$ for (NetworkLocation location : locations) -->Line_52 $$ Set<Node> nodes = nodeMap.getWorkersByNetworkPath().get(location)[ FD ]
Line_17 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)-->Line_19 $$ assignment.put(chosenNode, split)[ FD ]
Line_4 $$ NodeMap nodeMap = this.nodeMap.get().get()-->Line_14 $$ log.debug("No nodes available to schedule %s. Available nodes %s", split, nodeMap.getNodesByHost().keys())[ FD ]
Line_68 $$ for (int i = 0; i < topologicCounters.length; i++) -->Line_69 $$ if (topologicCounters[i] > 0) [ CD ]
Line_17 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)-->Line_55 $$ if (chosenNode != null) [ FD ]
Line_28 $$ for (HostAddress host : split.getAddresses()) -->Line_33 $$ locations.add(networkLocationCache.get(host))[ FD ]
Line_27 $$ List<NetworkLocation> locations = new ArrayList()-->Line_40 $$ if (locations.isEmpty()) [ FD ]
Line_40 $$ if (locations.isEmpty()) -->Line_43 $$ depth = 0[ CD ]
