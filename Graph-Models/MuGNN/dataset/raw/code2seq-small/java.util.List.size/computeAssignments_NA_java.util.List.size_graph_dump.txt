Line_3 $$ NodeMap nodeMap = this.nodeMap.get().get()-->Line_11 $$ List<Node> candidateNodes = selectExactNodes(nodeMap, split.getAddresses(), includeCoordinator)[ FD ]
Line_9 $$ for (Split split : splits) -->Line_13 $$ log.debug("No nodes available to schedule %s. Available nodes %s", split, nodeMap.getNodesByHost().keys())[ FD ]
Line_3 $$ NodeMap nodeMap = this.nodeMap.get().get()-->Line_13 $$ log.debug("No nodes available to schedule %s. Available nodes %s", split, nodeMap.getNodesByHost().keys())[ FD ]
Line_42 $$ for (int i = depth; i >= 0 && chosenNode == null; i--) -->Line_64 $$ for (int i = 0; i < topologicCounters.length; i++) [ FD ]
Line_6 $$ NodeAssignmentStats assignmentStats = new NodeAssignmentStats(nodeTaskMap, nodeMap, existingTasks)-->Line_50 $$ chosenNode = bestNodeSplitCount(new ResettableRandomizedIterator(nodes), minCandidates, (int) Math.ceil(queueFraction * maxSplitsPerNodePerTaskWhenFull), assignmentStats)[ FD ]
Line_38 $$ if (locations.isEmpty()) -->Line_40 $$ depth = 0[ CD ]
Line_42 $$ for (int i = depth; i >= 0 && chosenNode == null; i--) -->Line_44 $$ location = location.subLocation(0, i)[ FD ]
Line_12 $$ if (candidateNodes.isEmpty()) -->Line_13 $$ log.debug("No nodes available to schedule %s. Available nodes %s", split, nodeMap.getNodesByHost().keys())[ CD ]
Line_44 $$ location = location.subLocation(0, i)-->Line_48 $$ Set<Node> nodes = nodeMap.getWorkersByNetworkPath().get(location)[ FD ]
Line_5 $$ Multimap<Node, Split> assignment = HashMultimap.create()-->Line_18 $$ assignment.put(chosenNode, split)[ FD ]
Line_6 $$ NodeAssignmentStats assignmentStats = new NodeAssignmentStats(nodeTaskMap, nodeMap, existingTasks)-->Line_16 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)[ FD ]
Line_8 $$ Set<NetworkLocation> filledLocations = new HashSet()-->Line_45 $$ if (filledLocations.contains(location)) [ FD ]
Line_42 $$ for (int i = depth; i >= 0 && chosenNode == null; i--) -->Line_52 $$ chosenDepth = i[ FD ]
Line_64 $$ for (int i = 0; i < topologicCounters.length; i++) -->Line_66 $$ topologicalSplitCounters.get(i).update(topologicCounters[i])[ FD ]
Line_43 $$ for (NetworkLocation location : locations) -->Line_45 $$ if (filledLocations.contains(location)) [ FD ]
Line_11 $$ List<Node> candidateNodes = selectExactNodes(nodeMap, split.getAddresses(), includeCoordinator)-->Line_16 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)[ FD ]
Line_26 $$ List<NetworkLocation> locations = new ArrayList()-->Line_39 $$ locations.add(new NetworkLocation())[ FD ]
Line_2 $$ public Multimap<Node, Split> computeAssignments(Set<Split> splits, List<RemoteTask> existingTasks) -->Line_6 $$ NodeAssignmentStats assignmentStats = new NodeAssignmentStats(nodeTaskMap, nodeMap, existingTasks)[ CD ]
Line_8 $$ Set<NetworkLocation> filledLocations = new HashSet()-->Line_55 $$ filledLocations.add(location)[ FD ]
Line_27 $$ for (HostAddress host : split.getAddresses()) -->Line_32 $$ locations.add(networkLocationCache.get(host))[ FD ]
Line_50 $$ chosenNode = bestNodeSplitCount(new ResettableRandomizedIterator(nodes), minCandidates, (int) Math.ceil(queueFraction * maxSplitsPerNodePerTaskWhenFull), assignmentStats)-->Line_60 $$ assignmentStats.addAssignedSplit(chosenNode)[ FD ]
Line_16 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)-->Line_59 $$ assignment.put(chosenNode, split)[ FD ]
Line_43 $$ for (NetworkLocation location : locations) -->Line_48 $$ Set<Node> nodes = nodeMap.getWorkersByNetworkPath().get(location)[ FD ]
Line_16 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)-->Line_19 $$ assignmentStats.addAssignedSplit(chosenNode)[ FD ]
Line_38 $$ if (locations.isEmpty()) -->Line_39 $$ locations.add(new NetworkLocation())[ CD ]
Line_50 $$ chosenNode = bestNodeSplitCount(new ResettableRandomizedIterator(nodes), minCandidates, (int) Math.ceil(queueFraction * maxSplitsPerNodePerTaskWhenFull), assignmentStats)-->Line_51 $$ if (chosenNode != null) [ FD ]
Line_3 $$ NodeMap nodeMap = this.nodeMap.get().get()-->Line_48 $$ Set<Node> nodes = nodeMap.getWorkersByNetworkPath().get(location)[ FD ]
Line_9 $$ for (Split split : splits) -->Line_11 $$ List<Node> candidateNodes = selectExactNodes(nodeMap, split.getAddresses(), includeCoordinator)[ FD ]
Line_26 $$ List<NetworkLocation> locations = new ArrayList()-->Line_38 $$ if (locations.isEmpty()) [ FD ]
Line_58 $$ if (chosenNode != null) -->Line_59 $$ assignment.put(chosenNode, split)[ CD ]
Line_2 $$ public Multimap<Node, Split> computeAssignments(Set<Split> splits, List<RemoteTask> existingTasks) -->Line_64 $$ for (int i = 0; i < topologicCounters.length; i++) [ CD ]
Line_6 $$ NodeAssignmentStats assignmentStats = new NodeAssignmentStats(nodeTaskMap, nodeMap, existingTasks)-->Line_60 $$ assignmentStats.addAssignedSplit(chosenNode)[ FD ]
Line_43 $$ for (NetworkLocation location : locations) -->Line_44 $$ location = location.subLocation(0, i)[ FD ]
Line_2 $$ public Multimap<Node, Split> computeAssignments(Set<Split> splits, List<RemoteTask> existingTasks) -->Line_7 $$ int[] topologicCounters = new int[topologicalSplitCounters.size()][ CD ]
Line_16 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)-->Line_17 $$ if (chosenNode != null) [ FD ]
Line_65 $$ if (topologicCounters[i] > 0) -->Line_66 $$ topologicalSplitCounters.get(i).update(topologicCounters[i])[ CD ]
Line_50 $$ chosenNode = bestNodeSplitCount(new ResettableRandomizedIterator(nodes), minCandidates, (int) Math.ceil(queueFraction * maxSplitsPerNodePerTaskWhenFull), assignmentStats)-->Line_58 $$ if (chosenNode != null) [ FD ]
Line_10 $$ if (!split.isRemotelyAccessible()) -->Line_11 $$ List<Node> candidateNodes = selectExactNodes(nodeMap, split.getAddresses(), includeCoordinator)[ CD ]
Line_64 $$ for (int i = 0; i < topologicCounters.length; i++) -->Line_65 $$ if (topologicCounters[i] > 0) [ CD ]
Line_16 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)-->Line_50 $$ chosenNode = bestNodeSplitCount(new ResettableRandomizedIterator(nodes), minCandidates, (int) Math.ceil(queueFraction * maxSplitsPerNodePerTaskWhenFull), assignmentStats)[ FD ]
Line_27 $$ for (HostAddress host : split.getAddresses()) -->Line_34 $$ negativeNetworkLocationCache.put(host, true)[ FD ]
Line_27 $$ for (HostAddress host : split.getAddresses()) -->Line_35 $$ log.warn(e, "Unable to determine location of %s. Will attempt again in %s", host, NEGATIVE_CACHE_DURATION)[ FD ]
Line_51 $$ if (chosenNode != null) -->Line_52 $$ chosenDepth = i[ CD ]
Line_10 $$ if (!split.isRemotelyAccessible()) -->Line_17 $$ if (chosenNode != null) [ CD ]
Line_2 $$ public Multimap<Node, Split> computeAssignments(Set<Split> splits, List<RemoteTask> existingTasks) -->Line_69 $$ return assignment[ CD ]
Line_2 $$ public Multimap<Node, Split> computeAssignments(Set<Split> splits, List<RemoteTask> existingTasks) -->Line_8 $$ Set<NetworkLocation> filledLocations = new HashSet()[ CD ]
Line_16 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)-->Line_60 $$ assignmentStats.addAssignedSplit(chosenNode)[ FD ]
Line_42 $$ for (int i = depth; i >= 0 && chosenNode == null; i--) -->Line_66 $$ topologicalSplitCounters.get(i).update(topologicCounters[i])[ FD ]
Line_9 $$ for (Split split : splits) -->Line_27 $$ for (HostAddress host : split.getAddresses()) [ FD ]
Line_44 $$ location = location.subLocation(0, i)-->Line_55 $$ filledLocations.add(location)[ FD ]
Line_6 $$ NodeAssignmentStats assignmentStats = new NodeAssignmentStats(nodeTaskMap, nodeMap, existingTasks)-->Line_19 $$ assignmentStats.addAssignedSplit(chosenNode)[ FD ]
Line_16 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)-->Line_18 $$ assignment.put(chosenNode, split)[ FD ]
Line_44 $$ location = location.subLocation(0, i)-->Line_45 $$ if (filledLocations.contains(location)) [ FD ]
Line_10 $$ if (!split.isRemotelyAccessible()) -->Line_12 $$ if (candidateNodes.isEmpty()) [ CD ]
Line_5 $$ Multimap<Node, Split> assignment = HashMultimap.create()-->Line_59 $$ assignment.put(chosenNode, split)[ FD ]
Line_17 $$ if (chosenNode != null) -->Line_19 $$ assignmentStats.addAssignedSplit(chosenNode)[ CD ]
Line_2 $$ public Multimap<Node, Split> computeAssignments(Set<Split> splits, List<RemoteTask> existingTasks) -->Line_4 $$ Collection<Node> allNodes = nodeMap.getNodesByHostAndPort().values()[ CD ]
Line_11 $$ List<Node> candidateNodes = selectExactNodes(nodeMap, split.getAddresses(), includeCoordinator)-->Line_12 $$ if (candidateNodes.isEmpty()) [ FD ]
Line_58 $$ if (chosenNode != null) -->Line_61 $$ topologicCounters[chosenDepth]++[ CD ]
Line_24 $$ int depth = networkLocationSegmentNames.size()-->Line_40 $$ depth = 0[ FD ]
Line_25 $$ int chosenDepth = 0-->Line_52 $$ chosenDepth = i[ FD ]
Line_9 $$ for (Split split : splits) -->Line_59 $$ assignment.put(chosenNode, split)[ FD ]
Line_43 $$ for (NetworkLocation location : locations) -->Line_55 $$ filledLocations.add(location)[ FD ]
Line_9 $$ for (Split split : splits) -->Line_18 $$ assignment.put(chosenNode, split)[ FD ]
Line_10 $$ if (!split.isRemotelyAccessible()) -->Line_16 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)[ CD ]
Line_2 $$ public Multimap<Node, Split> computeAssignments(Set<Split> splits, List<RemoteTask> existingTasks) -->Line_5 $$ Multimap<Node, Split> assignment = HashMultimap.create()[ CD ]
Line_16 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)-->Line_51 $$ if (chosenNode != null) [ FD ]
Line_16 $$ Node chosenNode = bestNodeSplitCount(candidateNodes.iterator(), minCandidates, maxSplitsPerNodePerTaskWhenFull, assignmentStats)-->Line_58 $$ if (chosenNode != null) [ FD ]
Line_50 $$ chosenNode = bestNodeSplitCount(new ResettableRandomizedIterator(nodes), minCandidates, (int) Math.ceil(queueFraction * maxSplitsPerNodePerTaskWhenFull), assignmentStats)-->Line_59 $$ assignment.put(chosenNode, split)[ FD ]
Line_58 $$ if (chosenNode != null) -->Line_60 $$ assignmentStats.addAssignedSplit(chosenNode)[ CD ]
Line_9 $$ for (Split split : splits) -->Line_10 $$ if (!split.isRemotelyAccessible()) [ FD ]
Line_3 $$ NodeMap nodeMap = this.nodeMap.get().get()-->Line_4 $$ Collection<Node> allNodes = nodeMap.getNodesByHostAndPort().values()[ FD ]
Line_27 $$ for (HostAddress host : split.getAddresses()) -->Line_29 $$ if (negativeNetworkLocationCache.getIfPresent(host) != null) [ FD ]
Line_2 $$ public Multimap<Node, Split> computeAssignments(Set<Split> splits, List<RemoteTask> existingTasks) -->Line_3 $$ NodeMap nodeMap = this.nodeMap.get().get()[ CD ]
Line_26 $$ List<NetworkLocation> locations = new ArrayList()-->Line_32 $$ locations.add(networkLocationCache.get(host))[ FD ]
Line_17 $$ if (chosenNode != null) -->Line_18 $$ assignment.put(chosenNode, split)[ CD ]
