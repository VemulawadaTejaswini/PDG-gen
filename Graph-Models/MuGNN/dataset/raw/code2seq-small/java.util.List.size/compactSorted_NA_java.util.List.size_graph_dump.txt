Line_10 $$ StoragePageSink outputPageSink = storageManager.createStoragePageSink(transactionId, columnIds, columnTypes)-->Line_26 $$ outputPageSink.flush()[ FD ]
Line_17 $$ while (!rowSources.isEmpty()) -->Line_25 $$ if (outputPageSink.isFull()) [ CD ]
Line_2 $$ public List<ShardInfo> compactSorted(long transactionId, Set<UUID> uuids, List<ColumnInfo> columns, List<Long> sortColumnIds, List<SortOrder> sortOrders) throws IOException -->Line_4 $$ long start = System.nanoTime()[ CD ]
Line_2 $$ public List<ShardInfo> compactSorted(long transactionId, Set<UUID> uuids, List<ColumnInfo> columns, List<Long> sortColumnIds, List<SortOrder> sortOrders) throws IOException -->Line_3 $$ checkArgument(sortColumnIds.size() == sortOrders.size(), "sortColumnIds and sortOrders must be of the same size")[ CD ]
Line_12 $$ for (UUID uuid : uuids) -->Line_13 $$ ConnectorPageSource pageSource = storageManager.getPageSource(uuid, columnIds, columnTypes, TupleDomain.all(), readerAttributes)[ FD ]
Line_31 $$ List<ShardInfo> shardInfos = outputPageSink.commit()-->Line_33 $$ outputShardsPerCompaction.add(shardInfos.size())[ FD ]
Line_14 $$ SortedRowSource rowSource = new SortedRowSource(pageSource, columnTypes, sortIndexes, sortOrders)-->Line_24 $$ outputPageSink.appendRow(rowSource.next())[ FD ]
Line_2 $$ public List<ShardInfo> compactSorted(long transactionId, Set<UUID> uuids, List<ColumnInfo> columns, List<Long> sortColumnIds, List<SortOrder> sortOrders) throws IOException -->Line_5 $$ List<Long> columnIds = columns.stream().map(ColumnInfo::<>getColumnId).collect(toList())[ FD ]
Line_2 $$ public List<ShardInfo> compactSorted(long transactionId, Set<UUID> uuids, List<ColumnInfo> columns, List<Long> sortColumnIds, List<SortOrder> sortOrders) throws IOException -->Line_8 $$ List<Integer> sortIndexes = sortColumnIds.stream().map(columnIds::<>indexOf).collect(toList())[ CD ]
Line_10 $$ StoragePageSink outputPageSink = storageManager.createStoragePageSink(transactionId, columnIds, columnTypes)-->Line_37 $$ outputPageSink.rollback()[ FD ]
Line_18 $$ SortedRowSource rowSource = rowSources.poll()-->Line_24 $$ outputPageSink.appendRow(rowSource.next())[ FD ]
Line_2 $$ public List<ShardInfo> compactSorted(long transactionId, Set<UUID> uuids, List<ColumnInfo> columns, List<Long> sortColumnIds, List<SortOrder> sortOrders) throws IOException -->Line_7 $$ checkArgument(columnIds.containsAll(sortColumnIds), "sortColumnIds must be a subset of columnIds")[ FD ]
Line_14 $$ SortedRowSource rowSource = new SortedRowSource(pageSource, columnTypes, sortIndexes, sortOrders)-->Line_19 $$ if (!rowSource.hasNext()) [ FD ]
Line_25 $$ if (outputPageSink.isFull()) -->Line_26 $$ outputPageSink.flush()[ CD ]
Line_10 $$ StoragePageSink outputPageSink = storageManager.createStoragePageSink(transactionId, columnIds, columnTypes)-->Line_31 $$ List<ShardInfo> shardInfos = outputPageSink.commit()[ FD ]
Line_2 $$ public List<ShardInfo> compactSorted(long transactionId, Set<UUID> uuids, List<ColumnInfo> columns, List<Long> sortColumnIds, List<SortOrder> sortOrders) throws IOException -->Line_9 $$ Queue<SortedRowSource> rowSources = new PriorityQueue()[ CD ]
Line_2 $$ public List<ShardInfo> compactSorted(long transactionId, Set<UUID> uuids, List<ColumnInfo> columns, List<Long> sortColumnIds, List<SortOrder> sortOrders) throws IOException -->Line_7 $$ checkArgument(columnIds.containsAll(sortColumnIds), "sortColumnIds must be a subset of columnIds")[ CD ]
Line_18 $$ SortedRowSource rowSource = rowSources.poll()-->Line_28 $$ rowSources.add(rowSource)[ FD ]
Line_14 $$ SortedRowSource rowSource = new SortedRowSource(pageSource, columnTypes, sortIndexes, sortOrders)-->Line_28 $$ rowSources.add(rowSource)[ FD ]
Line_10 $$ StoragePageSink outputPageSink = storageManager.createStoragePageSink(transactionId, columnIds, columnTypes)-->Line_24 $$ outputPageSink.appendRow(rowSource.next())[ FD ]
Line_17 $$ while (!rowSources.isEmpty()) -->Line_18 $$ SortedRowSource rowSource = rowSources.poll()[ CD ]
Line_9 $$ Queue<SortedRowSource> rowSources = new PriorityQueue()-->Line_28 $$ rowSources.add(rowSource)[ FD ]
Line_4 $$ long start = System.nanoTime()-->Line_34 $$ sortedCompactionLatencyMillis.add(Duration.nanosSince(start).toMillis())[ FD ]
Line_2 $$ public List<ShardInfo> compactSorted(long transactionId, Set<UUID> uuids, List<ColumnInfo> columns, List<Long> sortColumnIds, List<SortOrder> sortOrders) throws IOException -->Line_6 $$ List<Type> columnTypes = columns.stream().map(ColumnInfo::<>getType).collect(toList())[ CD ]
Line_17 $$ while (!rowSources.isEmpty()) -->Line_28 $$ rowSources.add(rowSource)[ CD ]
Line_6 $$ List<Type> columnTypes = columns.stream().map(ColumnInfo::<>getType).collect(toList())-->Line_10 $$ StoragePageSink outputPageSink = storageManager.createStoragePageSink(transactionId, columnIds, columnTypes)[ FD ]
Line_5 $$ List<Long> columnIds = columns.stream().map(ColumnInfo::<>getColumnId).collect(toList())-->Line_7 $$ checkArgument(columnIds.containsAll(sortColumnIds), "sortColumnIds must be a subset of columnIds")[ FD ]
Line_2 $$ public List<ShardInfo> compactSorted(long transactionId, Set<UUID> uuids, List<ColumnInfo> columns, List<Long> sortColumnIds, List<SortOrder> sortOrders) throws IOException -->Line_3 $$ checkArgument(sortColumnIds.size() == sortOrders.size(), "sortColumnIds and sortOrders must be of the same size")[ FD ]
Line_6 $$ List<Type> columnTypes = columns.stream().map(ColumnInfo::<>getType).collect(toList())-->Line_13 $$ ConnectorPageSource pageSource = storageManager.getPageSource(uuid, columnIds, columnTypes, TupleDomain.all(), readerAttributes)[ FD ]
Line_9 $$ Queue<SortedRowSource> rowSources = new PriorityQueue()-->Line_40 $$ rowSources.stream().forEach(SortedRowSource::<>closeQuietly)[ FD ]
Line_2 $$ public List<ShardInfo> compactSorted(long transactionId, Set<UUID> uuids, List<ColumnInfo> columns, List<Long> sortColumnIds, List<SortOrder> sortOrders) throws IOException -->Line_10 $$ StoragePageSink outputPageSink = storageManager.createStoragePageSink(transactionId, columnIds, columnTypes)[ FD ]
Line_9 $$ Queue<SortedRowSource> rowSources = new PriorityQueue()-->Line_18 $$ SortedRowSource rowSource = rowSources.poll()[ FD ]
Line_2 $$ public List<ShardInfo> compactSorted(long transactionId, Set<UUID> uuids, List<ColumnInfo> columns, List<Long> sortColumnIds, List<SortOrder> sortOrders) throws IOException -->Line_5 $$ List<Long> columnIds = columns.stream().map(ColumnInfo::<>getColumnId).collect(toList())[ CD ]
Line_9 $$ Queue<SortedRowSource> rowSources = new PriorityQueue()-->Line_15 $$ rowSources.add(rowSource)[ FD ]
Line_18 $$ SortedRowSource rowSource = rowSources.poll()-->Line_19 $$ if (!rowSource.hasNext()) [ FD ]
Line_5 $$ List<Long> columnIds = columns.stream().map(ColumnInfo::<>getColumnId).collect(toList())-->Line_10 $$ StoragePageSink outputPageSink = storageManager.createStoragePageSink(transactionId, columnIds, columnTypes)[ FD ]
Line_2 $$ public List<ShardInfo> compactSorted(long transactionId, Set<UUID> uuids, List<ColumnInfo> columns, List<Long> sortColumnIds, List<SortOrder> sortOrders) throws IOException -->Line_32 $$ inputShardsPerCompaction.add(uuids.size())[ FD ]
Line_14 $$ SortedRowSource rowSource = new SortedRowSource(pageSource, columnTypes, sortIndexes, sortOrders)-->Line_15 $$ rowSources.add(rowSource)[ FD ]
Line_17 $$ while (!rowSources.isEmpty()) -->Line_24 $$ outputPageSink.appendRow(rowSource.next())[ CD ]
Line_5 $$ List<Long> columnIds = columns.stream().map(ColumnInfo::<>getColumnId).collect(toList())-->Line_13 $$ ConnectorPageSource pageSource = storageManager.getPageSource(uuid, columnIds, columnTypes, TupleDomain.all(), readerAttributes)[ FD ]
Line_2 $$ public List<ShardInfo> compactSorted(long transactionId, Set<UUID> uuids, List<ColumnInfo> columns, List<Long> sortColumnIds, List<SortOrder> sortOrders) throws IOException -->Line_8 $$ List<Integer> sortIndexes = sortColumnIds.stream().map(columnIds::<>indexOf).collect(toList())[ FD ]
Line_10 $$ StoragePageSink outputPageSink = storageManager.createStoragePageSink(transactionId, columnIds, columnTypes)-->Line_30 $$ outputPageSink.flush()[ FD ]
Line_2 $$ public List<ShardInfo> compactSorted(long transactionId, Set<UUID> uuids, List<ColumnInfo> columns, List<Long> sortColumnIds, List<SortOrder> sortOrders) throws IOException -->Line_10 $$ StoragePageSink outputPageSink = storageManager.createStoragePageSink(transactionId, columnIds, columnTypes)[ CD ]
Line_10 $$ StoragePageSink outputPageSink = storageManager.createStoragePageSink(transactionId, columnIds, columnTypes)-->Line_25 $$ if (outputPageSink.isFull()) [ FD ]
Line_9 $$ Queue<SortedRowSource> rowSources = new PriorityQueue()-->Line_17 $$ while (!rowSources.isEmpty()) [ FD ]
Line_17 $$ while (!rowSources.isEmpty()) -->Line_19 $$ if (!rowSource.hasNext()) [ CD ]
Line_2 $$ public List<ShardInfo> compactSorted(long transactionId, Set<UUID> uuids, List<ColumnInfo> columns, List<Long> sortColumnIds, List<SortOrder> sortOrders) throws IOException -->Line_6 $$ List<Type> columnTypes = columns.stream().map(ColumnInfo::<>getType).collect(toList())[ FD ]
