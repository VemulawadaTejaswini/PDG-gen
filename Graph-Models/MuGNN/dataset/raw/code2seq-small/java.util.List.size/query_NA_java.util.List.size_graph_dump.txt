Line_13 $$ for (InetAddress endpoint : toQuery.filteredEndpoints) -->Line_14 $$ MessageOut<ReadCommand> message = rangeCommand.createMessage(MessagingService.instance().getVersion(endpoint))[ FD ]
Line_2 $$ private SingleRangeResponse query(RangeForQuery toQuery) -->Line_5 $$ int blockFor = consistency.blockFor(keyspace)[ CD ]
Line_2 $$ private SingleRangeResponse query(RangeForQuery toQuery) -->Line_4 $$ DataResolver resolver = new DataResolver(keyspace, rangeCommand, consistency, toQuery.filteredEndpoints.size())[ CD ]
Line_8 $$ ReadCallback handler = new ReadCallback(resolver, consistency, rangeCommand, minimalEndpoints)-->Line_9 $$ handler.assureSufficientLiveNodes()[ FD ]
Line_8 $$ ReadCallback handler = new ReadCallback(resolver, consistency, rangeCommand, minimalEndpoints)-->Line_16 $$ MessagingService.instance().sendRRWithFailure(message, endpoint, handler)[ FD ]
Line_2 $$ private SingleRangeResponse query(RangeForQuery toQuery) -->Line_6 $$ int minResponses = Math.min(toQuery.filteredEndpoints.size(), blockFor)[ CD ]
Line_2 $$ private SingleRangeResponse query(RangeForQuery toQuery) -->Line_19 $$ return new SingleRangeResponse(handler)[ CD ]
Line_2 $$ private SingleRangeResponse query(RangeForQuery toQuery) -->Line_9 $$ handler.assureSufficientLiveNodes()[ CD ]
Line_10 $$ if (toQuery.filteredEndpoints.size() == 1 && canDoLocalRequest(toQuery.filteredEndpoints.get(0))) -->Line_11 $$ StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(rangeCommand, handler), Tracing.instance.get())[ CD ]
Line_2 $$ private SingleRangeResponse query(RangeForQuery toQuery) -->Line_3 $$ PartitionRangeReadCommand rangeCommand = command.forSubRange(toQuery.range)[ CD ]
Line_13 $$ for (InetAddress endpoint : toQuery.filteredEndpoints) -->Line_15 $$ Tracing.trace("Enqueuing request to [ FD ]
Line_2 $$ private SingleRangeResponse query(RangeForQuery toQuery) -->Line_7 $$ List<InetAddress> minimalEndpoints = toQuery.filteredEndpoints.subList(0, minResponses)[ CD ]
Line_6 $$ int minResponses = Math.min(toQuery.filteredEndpoints.size(), blockFor)-->Line_7 $$ List<InetAddress> minimalEndpoints = toQuery.filteredEndpoints.subList(0, minResponses)[ FD ]
Line_13 $$ for (InetAddress endpoint : toQuery.filteredEndpoints) -->Line_16 $$ MessagingService.instance().sendRRWithFailure(message, endpoint, handler)[ FD ]
Line_2 $$ private SingleRangeResponse query(RangeForQuery toQuery) -->Line_8 $$ ReadCallback handler = new ReadCallback(resolver, consistency, rangeCommand, minimalEndpoints)[ CD ]
Line_14 $$ MessageOut<ReadCommand> message = rangeCommand.createMessage(MessagingService.instance().getVersion(endpoint))-->Line_16 $$ MessagingService.instance().sendRRWithFailure(message, endpoint, handler)[ FD ]
Line_5 $$ int blockFor = consistency.blockFor(keyspace)-->Line_6 $$ int minResponses = Math.min(toQuery.filteredEndpoints.size(), blockFor)[ FD ]
Line_2 $$ private SingleRangeResponse query(RangeForQuery toQuery) -->Line_10 $$ if (toQuery.filteredEndpoints.size() == 1 && canDoLocalRequest(toQuery.filteredEndpoints.get(0))) [ CD ]
Line_3 $$ PartitionRangeReadCommand rangeCommand = command.forSubRange(toQuery.range)-->Line_14 $$ MessageOut<ReadCommand> message = rangeCommand.createMessage(MessagingService.instance().getVersion(endpoint))[ FD ]
