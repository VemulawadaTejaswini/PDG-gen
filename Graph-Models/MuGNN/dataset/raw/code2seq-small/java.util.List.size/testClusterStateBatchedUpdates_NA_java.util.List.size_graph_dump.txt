Line_73 $$ Thread thread = new Thread(() -> -->Line_81 $$ thread.start()[ FD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_19 $$ int numberOfExecutors = Math.max(1, numberOfThreads / 4)[ CD ]
Line_6 $$ AtomicInteger counter = new AtomicInteger()-->Line_13 $$ counter.incrementAndGet()[ FD ]
Line_5 $$ ClusterService clusterService = internalCluster().getInstance(ClusterService.class)-->Line_77 $$ clusterService.submitStateUpdateTask(Thread.currentThread().getName(), new Task(), ClusterStateTaskConfig.build(randomFrom(Priority.values())), executor, listener)[ FD ]
Line_6 $$ AtomicInteger counter = new AtomicInteger()-->Line_89 $$ assertEquals(numberOfThreads * tasksSubmittedPerThread, counter.get())[ FD ]
Line_30 $$ maybeUpdatedClusterState = ClusterState.builder(currentState).build()-->Line_34 $$ return BatchResult.<Task>builder().successes(tasks).build(maybeUpdatedClusterState)[ FD ]
Line_21 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_41 $$ semaphore.release()[ CD ]
Line_21 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_26 $$ tasks.forEach( task -> task.execute())[ CD ]
Line_75 $$ for (int j = 0; j < tasksSubmittedPerThread; j++) -->Line_76 $$ ClusterStateTaskExecutor<Task> executor = assignments.get(index * tasksSubmittedPerThread + j)[ CD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_88 $$ semaphore.acquire(numberOfExecutors)[ CD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_71 $$ for (int i = 0; i < numberOfThreads; i++) [ CD ]
Line_61 $$ for (int j = 0; j < tasksSubmittedPerThread; j++) -->Line_75 $$ for (int j = 0; j < tasksSubmittedPerThread; j++) [ FD ]
Line_71 $$ for (int i = 0; i < numberOfThreads; i++) -->Line_80 $$ threads.add(thread)[ CD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_4 $$ internalCluster().startNode(settings)[ CD ]
Line_10 $$ if (!state.compareAndSet(false, true)) -->Line_13 $$ counter.incrementAndGet()[ CD ]
Line_29 $$ if (randomBoolean()) -->Line_32 $$ semaphore.acquire()[ CD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_56 $$ for (int i = 0; i < numberOfExecutors; i++) [ CD ]
Line_61 $$ for (int j = 0; j < tasksSubmittedPerThread; j++) -->Line_62 $$ assignments.add(randomFrom(executors))[ CD ]
Line_21 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_27 $$ counter.addAndGet(tasks.size())[ CD ]
Line_21 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_37 $$ return false[ CD ]
Line_56 $$ for (int i = 0; i < numberOfExecutors; i++) -->Line_60 $$ for (int i = 0; i < numberOfThreads; i++) [ FD ]
Line_21 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_30 $$ maybeUpdatedClusterState = ClusterState.builder(currentState).build()[ FD ]
Line_21 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_27 $$ counter.addAndGet(tasks.size())[ FD ]
Line_60 $$ for (int i = 0; i < numberOfThreads; i++) -->Line_71 $$ for (int i = 0; i < numberOfThreads; i++) [ FD ]
Line_73 $$ Thread thread = new Thread(() -> -->Line_85 $$ thread.join()[ FD ]
Line_29 $$ if (randomBoolean()) -->Line_31 $$ batches.incrementAndGet()[ CD ]
Line_21 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_34 $$ return BatchResult.<Task>builder().successes(tasks).build(maybeUpdatedClusterState)[ FD ]
Line_75 $$ for (int j = 0; j < tasksSubmittedPerThread; j++) -->Line_77 $$ clusterService.submitStateUpdateTask(Thread.currentThread().getName(), new Task(), ClusterStateTaskConfig.build(randomFrom(Priority.values())), executor, listener)[ CD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_5 $$ ClusterService clusterService = internalCluster().getInstance(ClusterService.class)[ CD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_18 $$ int tasksSubmittedPerThread = randomIntBetween(1, 1024)[ CD ]
Line_76 $$ ClusterStateTaskExecutor<Task> executor = assignments.get(index * tasksSubmittedPerThread + j)-->Line_77 $$ clusterService.submitStateUpdateTask(Thread.currentThread().getName(), new Task(), ClusterStateTaskConfig.build(randomFrom(Priority.values())), executor, listener)[ FD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_89 $$ assertEquals(numberOfThreads * tasksSubmittedPerThread, counter.get())[ CD ]
Line_71 $$ for (int i = 0; i < numberOfThreads; i++) -->Line_72 $$ final int index = i[ CD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_17 $$ int numberOfThreads = randomIntBetween(2, 8)[ CD ]
Line_46 $$ ClusterStateTaskListener listener = new ClusterStateTaskListener() -->Line_52 $$ updateLatch.countDown()[ CD ]
Line_71 $$ for (int i = 0; i < numberOfThreads; i++) -->Line_73 $$ Thread thread = new Thread(() -> [ CD ]
Line_60 $$ for (int i = 0; i < numberOfThreads; i++) -->Line_61 $$ for (int j = 0; j < tasksSubmittedPerThread; j++) [ CD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_60 $$ for (int i = 0; i < numberOfThreads; i++) [ CD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_83 $$ startingGun.countDown()[ CD ]
Line_6 $$ AtomicInteger counter = new AtomicInteger()-->Line_27 $$ counter.addAndGet(tasks.size())[ FD ]
Line_7 $$ class Task -->Line_10 $$ if (!state.compareAndSet(false, true)) [ CD ]
Line_56 $$ for (int i = 0; i < numberOfExecutors; i++) -->Line_57 $$ executors.add(new TaskExecutor())[ CD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_87 $$ updateLatch.await()[ CD ]
Line_71 $$ for (int i = 0; i < numberOfThreads; i++) -->Line_81 $$ thread.start()[ CD ]
Line_91 $$ if (counts.containsKey(executor)) -->Line_93 $$ assertEquals(executor.batches.get(), executor.published.get())[ CD ]
Line_76 $$ ClusterStateTaskExecutor<Task> executor = assignments.get(index * tasksSubmittedPerThread + j)-->Line_92 $$ assertEquals((int) counts.get(executor), executor.counter.get())[ FD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_3 $$ Settings settings = settingsBuilder().put("discovery.type", "local").build()[ CD ]
Line_21 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_26 $$ tasks.forEach( task -> task.execute())[ FD ]
Line_29 $$ if (randomBoolean()) -->Line_30 $$ maybeUpdatedClusterState = ClusterState.builder(currentState).build()[ CD ]
Line_21 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_34 $$ return BatchResult.<Task>builder().successes(tasks).build(maybeUpdatedClusterState)[ CD ]
Line_46 $$ ClusterStateTaskListener listener = new ClusterStateTaskListener() -->Line_51 $$ counters.computeIfAbsent(source,  key -> new AtomicInteger()).incrementAndGet()[ FD ]
Line_56 $$ for (int i = 0; i < numberOfExecutors; i++) -->Line_71 $$ for (int i = 0; i < numberOfThreads; i++) [ FD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_6 $$ AtomicInteger counter = new AtomicInteger()[ CD ]
Line_3 $$ Settings settings = settingsBuilder().put("discovery.type", "local").build()-->Line_4 $$ internalCluster().startNode(settings)[ FD ]
Line_21 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_28 $$ ClusterState maybeUpdatedClusterState = currentState[ CD ]
Line_21 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_40 $$ published.incrementAndGet()[ CD ]
Line_91 $$ if (counts.containsKey(executor)) -->Line_92 $$ assertEquals((int) counts.get(executor), executor.counter.get())[ CD ]
Line_28 $$ ClusterState maybeUpdatedClusterState = currentState-->Line_34 $$ return BatchResult.<Task>builder().successes(tasks).build(maybeUpdatedClusterState)[ FD ]
Line_28 $$ ClusterState maybeUpdatedClusterState = currentState-->Line_30 $$ maybeUpdatedClusterState = ClusterState.builder(currentState).build()[ FD ]
Line_21 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_29 $$ if (randomBoolean()) [ CD ]
Line_73 $$ Thread thread = new Thread(() -> -->Line_80 $$ threads.add(thread)[ FD ]
Line_76 $$ ClusterStateTaskExecutor<Task> executor = assignments.get(index * tasksSubmittedPerThread + j)-->Line_91 $$ if (counts.containsKey(executor)) [ FD ]
Line_46 $$ ClusterStateTaskListener listener = new ClusterStateTaskListener() -->Line_51 $$ counters.computeIfAbsent(source,  key -> new AtomicInteger()).incrementAndGet()[ CD ]
