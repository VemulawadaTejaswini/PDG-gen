Line_89 $$ Thread thread = new Thread(() -> -->Line_101 $$ thread.join()[ FD ]
Line_36 $$ if (randomBoolean()) -->Line_37 $$ maybeUpdatedClusterState = ClusterState.builder(currentState).build()[ CD ]
Line_6 $$ AtomicInteger counter = new AtomicInteger()-->Line_15 $$ counter.incrementAndGet()[ FD ]
Line_23 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_33 $$ tasks.forEach( task -> task.execute())[ FD ]
Line_23 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_41 $$ return BatchResult.<Task>builder().successes(tasks).build(maybeUpdatedClusterState)[ FD ]
Line_12 $$ if (!state.compareAndSet(false, true)) -->Line_15 $$ counter.incrementAndGet()[ CD ]
Line_37 $$ maybeUpdatedClusterState = ClusterState.builder(currentState).build()-->Line_41 $$ return BatchResult.<Task>builder().successes(tasks).build(maybeUpdatedClusterState)[ FD ]
Line_111 $$ if (counts.containsKey(executor)) -->Line_112 $$ assertEquals((int) counts.get(executor), executor.counter.get())[ CD ]
Line_23 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_41 $$ return BatchResult.<Task>builder().successes(tasks).build(maybeUpdatedClusterState)[ CD ]
Line_23 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_37 $$ maybeUpdatedClusterState = ClusterState.builder(currentState).build()[ FD ]
Line_35 $$ ClusterState maybeUpdatedClusterState = currentState-->Line_41 $$ return BatchResult.<Task>builder().successes(tasks).build(maybeUpdatedClusterState)[ FD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_3 $$ Settings settings = settingsBuilder().put("discovery.type", "local").build()[ CD ]
Line_3 $$ Settings settings = settingsBuilder().put("discovery.type", "local").build()-->Line_4 $$ internalCluster().startNode(settings)[ FD ]
Line_23 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_46 $$ return false[ CD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_99 $$ startingGun.countDown()[ CD ]
Line_57 $$ ClusterStateTaskListener listener = new ClusterStateTaskListener() -->Line_66 $$ counters.computeIfAbsent(source,  key -> new AtomicInteger()).incrementAndGet()[ CD ]
Line_87 $$ for (int i = 0; i < numberOfThreads; i++) -->Line_88 $$ final int index = i[ CD ]
Line_89 $$ Thread thread = new Thread(() -> -->Line_97 $$ thread.start()[ FD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_20 $$ int tasksSubmittedPerThread = randomIntBetween(1, 1024)[ CD ]
Line_76 $$ for (int i = 0; i < numberOfThreads; i++) -->Line_77 $$ for (int j = 0; j < tasksSubmittedPerThread; j++) [ CD ]
Line_92 $$ ClusterStateTaskExecutor<Task> executor = assignments.get(index * tasksSubmittedPerThread + j)-->Line_111 $$ if (counts.containsKey(executor)) [ FD ]
Line_91 $$ for (int j = 0; j < tasksSubmittedPerThread; j++) -->Line_92 $$ ClusterStateTaskExecutor<Task> executor = assignments.get(index * tasksSubmittedPerThread + j)[ CD ]
Line_57 $$ ClusterStateTaskListener listener = new ClusterStateTaskListener() -->Line_67 $$ updateLatch.countDown()[ CD ]
Line_77 $$ for (int j = 0; j < tasksSubmittedPerThread; j++) -->Line_78 $$ assignments.add(randomFrom(executors))[ CD ]
Line_7 $$ class Task -->Line_12 $$ if (!state.compareAndSet(false, true)) [ CD ]
Line_23 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_36 $$ if (randomBoolean()) [ CD ]
Line_36 $$ if (randomBoolean()) -->Line_39 $$ semaphore.acquire()[ CD ]
Line_87 $$ for (int i = 0; i < numberOfThreads; i++) -->Line_89 $$ Thread thread = new Thread(() -> [ CD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_71 $$ for (int i = 0; i < numberOfExecutors; i++) [ CD ]
Line_35 $$ ClusterState maybeUpdatedClusterState = currentState-->Line_37 $$ maybeUpdatedClusterState = ClusterState.builder(currentState).build()[ FD ]
Line_71 $$ for (int i = 0; i < numberOfExecutors; i++) -->Line_72 $$ executors.add(new TaskExecutor())[ CD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_5 $$ ClusterService clusterService = internalCluster().getInstance(ClusterService.class)[ CD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_87 $$ for (int i = 0; i < numberOfThreads; i++) [ CD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_21 $$ int numberOfExecutors = Math.max(1, numberOfThreads / 4)[ CD ]
Line_76 $$ for (int i = 0; i < numberOfThreads; i++) -->Line_87 $$ for (int i = 0; i < numberOfThreads; i++) [ FD ]
Line_71 $$ for (int i = 0; i < numberOfExecutors; i++) -->Line_87 $$ for (int i = 0; i < numberOfThreads; i++) [ FD ]
Line_5 $$ ClusterService clusterService = internalCluster().getInstance(ClusterService.class)-->Line_93 $$ clusterService.submitStateUpdateTask(Thread.currentThread().getName(), new Task(), ClusterStateTaskConfig.build(randomFrom(Priority.values())), executor, listener)[ FD ]
Line_87 $$ for (int i = 0; i < numberOfThreads; i++) -->Line_97 $$ thread.start()[ CD ]
Line_92 $$ ClusterStateTaskExecutor<Task> executor = assignments.get(index * tasksSubmittedPerThread + j)-->Line_112 $$ assertEquals((int) counts.get(executor), executor.counter.get())[ FD ]
Line_23 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_51 $$ published.incrementAndGet()[ CD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_19 $$ int numberOfThreads = randomIntBetween(2, 8)[ CD ]
Line_36 $$ if (randomBoolean()) -->Line_38 $$ batches.incrementAndGet()[ CD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_6 $$ AtomicInteger counter = new AtomicInteger()[ CD ]
Line_23 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_33 $$ tasks.forEach( task -> task.execute())[ CD ]
Line_87 $$ for (int i = 0; i < numberOfThreads; i++) -->Line_96 $$ threads.add(thread)[ CD ]
Line_91 $$ for (int j = 0; j < tasksSubmittedPerThread; j++) -->Line_93 $$ clusterService.submitStateUpdateTask(Thread.currentThread().getName(), new Task(), ClusterStateTaskConfig.build(randomFrom(Priority.values())), executor, listener)[ CD ]
Line_23 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_34 $$ counter.addAndGet(tasks.size())[ FD ]
Line_23 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_35 $$ ClusterState maybeUpdatedClusterState = currentState[ CD ]
Line_23 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_52 $$ semaphore.release()[ CD ]
Line_6 $$ AtomicInteger counter = new AtomicInteger()-->Line_34 $$ counter.addAndGet(tasks.size())[ FD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_76 $$ for (int i = 0; i < numberOfThreads; i++) [ CD ]
Line_71 $$ for (int i = 0; i < numberOfExecutors; i++) -->Line_76 $$ for (int i = 0; i < numberOfThreads; i++) [ FD ]
Line_111 $$ if (counts.containsKey(executor)) -->Line_113 $$ assertEquals(executor.batches.get(), executor.published.get())[ CD ]
Line_2 $$ public void testClusterStateBatchedUpdates() throws InterruptedException -->Line_4 $$ internalCluster().startNode(settings)[ CD ]
Line_92 $$ ClusterStateTaskExecutor<Task> executor = assignments.get(index * tasksSubmittedPerThread + j)-->Line_93 $$ clusterService.submitStateUpdateTask(Thread.currentThread().getName(), new Task(), ClusterStateTaskConfig.build(randomFrom(Priority.values())), executor, listener)[ FD ]
Line_89 $$ Thread thread = new Thread(() -> -->Line_96 $$ threads.add(thread)[ FD ]
Line_57 $$ ClusterStateTaskListener listener = new ClusterStateTaskListener() -->Line_66 $$ counters.computeIfAbsent(source,  key -> new AtomicInteger()).incrementAndGet()[ FD ]
Line_23 $$ class TaskExecutor implements ClusterStateTaskExecutor<Task> -->Line_34 $$ counter.addAndGet(tasks.size())[ CD ]
Line_77 $$ for (int j = 0; j < tasksSubmittedPerThread; j++) -->Line_91 $$ for (int j = 0; j < tasksSubmittedPerThread; j++) [ FD ]
