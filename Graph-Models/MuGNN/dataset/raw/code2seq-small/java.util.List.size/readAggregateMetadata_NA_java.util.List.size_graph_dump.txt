Line_2 $$ private static UDAggregate readAggregateMetadata(Functions functions, String keyspaceName, String functionName, List<String> signature) -->Line_15 $$ FunctionName finalFunc = row.has("final_func") ? new FunctionName(keyspaceName, row.getString("final_func")) : null[ CD ]
Line_4 $$ UntypedResultSet.Row row = query(query, keyspaceName, functionName, signature).one()-->Line_14 $$ AbstractType<?> stateType = parseType(row.getString("state_type"))[ FD ]
Line_4 $$ UntypedResultSet.Row row = query(query, keyspaceName, functionName, signature).one()-->Line_16 $$ ByteBuffer initcond = row.has("initcond") ? row.getBytes("initcond") : null[ FD ]
Line_12 $$ AbstractType<?> returnType = parseType(row.getString("return_type"))-->Line_20 $$ return UDAggregate.createBroken(name, argTypes, returnType, initcond, reason)[ FD ]
Line_7 $$ List<AbstractType<?>> argTypes = new ArrayList()-->Line_9 $$ argTypes = new ArrayList(types.size())[ FD ]
Line_7 $$ List<AbstractType<?>> argTypes = new ArrayList()-->Line_10 $$ argTypes.add(parseType(type))[ FD ]
Line_2 $$ private static UDAggregate readAggregateMetadata(Functions functions, String keyspaceName, String functionName, List<String> signature) -->Line_4 $$ UntypedResultSet.Row row = query(query, keyspaceName, functionName, signature).one()[ CD ]
Line_12 $$ AbstractType<?> returnType = parseType(row.getString("return_type"))-->Line_18 $$ return UDAggregate.create(functions, name, argTypes, returnType, stateFunc, finalFunc, stateType, initcond)[ FD ]
Line_2 $$ private static UDAggregate readAggregateMetadata(Functions functions, String keyspaceName, String functionName, List<String> signature) -->Line_12 $$ AbstractType<?> returnType = parseType(row.getString("return_type"))[ CD ]
Line_2 $$ private static UDAggregate readAggregateMetadata(Functions functions, String keyspaceName, String functionName, List<String> signature) -->Line_3 $$ String query = format("SELECT * FROM %s.%s WHERE keyspace_name = ? AND aggregate_name = ? AND signature = ?", SystemKeyspace.NAME, SystemKeyspace.LEGACY_AGGREGATES)[ CD ]
Line_16 $$ ByteBuffer initcond = row.has("initcond") ? row.getBytes("initcond") : null-->Line_18 $$ return UDAggregate.create(functions, name, argTypes, returnType, stateFunc, finalFunc, stateType, initcond)[ FD ]
Line_5 $$ FunctionName name = new FunctionName(keyspaceName, functionName)-->Line_18 $$ return UDAggregate.create(functions, name, argTypes, returnType, stateFunc, finalFunc, stateType, initcond)[ FD ]
Line_3 $$ String query = format("SELECT * FROM %s.%s WHERE keyspace_name = ? AND aggregate_name = ? AND signature = ?", SystemKeyspace.NAME, SystemKeyspace.LEGACY_AGGREGATES)-->Line_4 $$ UntypedResultSet.Row row = query(query, keyspaceName, functionName, signature).one()[ FD ]
Line_9 $$ argTypes = new ArrayList(types.size())-->Line_10 $$ argTypes.add(parseType(type))[ FD ]
Line_2 $$ private static UDAggregate readAggregateMetadata(Functions functions, String keyspaceName, String functionName, List<String> signature) -->Line_13 $$ FunctionName stateFunc = new FunctionName(keyspaceName, row.getString("state_func"))[ CD ]
Line_2 $$ private static UDAggregate readAggregateMetadata(Functions functions, String keyspaceName, String functionName, List<String> signature) -->Line_8 $$ if (types != null) [ CD ]
Line_16 $$ ByteBuffer initcond = row.has("initcond") ? row.getBytes("initcond") : null-->Line_20 $$ return UDAggregate.createBroken(name, argTypes, returnType, initcond, reason)[ FD ]
Line_2 $$ private static UDAggregate readAggregateMetadata(Functions functions, String keyspaceName, String functionName, List<String> signature) -->Line_18 $$ return UDAggregate.create(functions, name, argTypes, returnType, stateFunc, finalFunc, stateType, initcond)[ FD ]
Line_6 $$ List<String> types = row.getList("argument_types", UTF8Type.instance)-->Line_9 $$ argTypes = new ArrayList(types.size())[ FD ]
Line_9 $$ argTypes = new ArrayList(types.size())-->Line_18 $$ return UDAggregate.create(functions, name, argTypes, returnType, stateFunc, finalFunc, stateType, initcond)[ FD ]
Line_2 $$ private static UDAggregate readAggregateMetadata(Functions functions, String keyspaceName, String functionName, List<String> signature) -->Line_14 $$ AbstractType<?> stateType = parseType(row.getString("state_type"))[ CD ]
Line_2 $$ private static UDAggregate readAggregateMetadata(Functions functions, String keyspaceName, String functionName, List<String> signature) -->Line_6 $$ List<String> types = row.getList("argument_types", UTF8Type.instance)[ CD ]
Line_8 $$ if (types != null) -->Line_9 $$ argTypes = new ArrayList(types.size())[ CD ]
Line_2 $$ private static UDAggregate readAggregateMetadata(Functions functions, String keyspaceName, String functionName, List<String> signature) -->Line_5 $$ FunctionName name = new FunctionName(keyspaceName, functionName)[ CD ]
Line_4 $$ UntypedResultSet.Row row = query(query, keyspaceName, functionName, signature).one()-->Line_12 $$ AbstractType<?> returnType = parseType(row.getString("return_type"))[ FD ]
Line_7 $$ List<AbstractType<?>> argTypes = new ArrayList()-->Line_18 $$ return UDAggregate.create(functions, name, argTypes, returnType, stateFunc, finalFunc, stateType, initcond)[ FD ]
Line_13 $$ FunctionName stateFunc = new FunctionName(keyspaceName, row.getString("state_func"))-->Line_18 $$ return UDAggregate.create(functions, name, argTypes, returnType, stateFunc, finalFunc, stateType, initcond)[ FD ]
Line_15 $$ FunctionName finalFunc = row.has("final_func") ? new FunctionName(keyspaceName, row.getString("final_func")) : null-->Line_18 $$ return UDAggregate.create(functions, name, argTypes, returnType, stateFunc, finalFunc, stateType, initcond)[ FD ]
Line_4 $$ UntypedResultSet.Row row = query(query, keyspaceName, functionName, signature).one()-->Line_15 $$ FunctionName finalFunc = row.has("final_func") ? new FunctionName(keyspaceName, row.getString("final_func")) : null[ FD ]
Line_6 $$ List<String> types = row.getList("argument_types", UTF8Type.instance)-->Line_8 $$ if (types != null) [ FD ]
Line_5 $$ FunctionName name = new FunctionName(keyspaceName, functionName)-->Line_20 $$ return UDAggregate.createBroken(name, argTypes, returnType, initcond, reason)[ FD ]
Line_4 $$ UntypedResultSet.Row row = query(query, keyspaceName, functionName, signature).one()-->Line_6 $$ List<String> types = row.getList("argument_types", UTF8Type.instance)[ FD ]
Line_14 $$ AbstractType<?> stateType = parseType(row.getString("state_type"))-->Line_18 $$ return UDAggregate.create(functions, name, argTypes, returnType, stateFunc, finalFunc, stateType, initcond)[ FD ]
Line_7 $$ List<AbstractType<?>> argTypes = new ArrayList()-->Line_20 $$ return UDAggregate.createBroken(name, argTypes, returnType, initcond, reason)[ FD ]
Line_2 $$ private static UDAggregate readAggregateMetadata(Functions functions, String keyspaceName, String functionName, List<String> signature) -->Line_4 $$ UntypedResultSet.Row row = query(query, keyspaceName, functionName, signature).one()[ FD ]
Line_9 $$ argTypes = new ArrayList(types.size())-->Line_20 $$ return UDAggregate.createBroken(name, argTypes, returnType, initcond, reason)[ FD ]
Line_2 $$ private static UDAggregate readAggregateMetadata(Functions functions, String keyspaceName, String functionName, List<String> signature) -->Line_7 $$ List<AbstractType<?>> argTypes = new ArrayList()[ CD ]
Line_2 $$ private static UDAggregate readAggregateMetadata(Functions functions, String keyspaceName, String functionName, List<String> signature) -->Line_16 $$ ByteBuffer initcond = row.has("initcond") ? row.getBytes("initcond") : null[ CD ]
Line_4 $$ UntypedResultSet.Row row = query(query, keyspaceName, functionName, signature).one()-->Line_13 $$ FunctionName stateFunc = new FunctionName(keyspaceName, row.getString("state_func"))[ FD ]
