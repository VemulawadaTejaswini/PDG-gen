Line_46 $$ if (docMapper.parentFieldMapper().active()) -->Line_47 $$ neededFields.add(ParentFieldMapper.NAME)[ CD ]
Line_66 $$ value = source.routing-->Line_74 $$ value = docMapper.TTLFieldMapper().valueForSearch(source.timestamp + source.ttl)[ FD ]
Line_97 $$ if (value != null) -->Line_98 $$ if (fields == null) [ CD ]
Line_110 $$ SourceFieldMapper sourceFieldMapper = docMapper.sourceMapper()-->Line_111 $$ if (fetchSourceContext.fetchSource() && sourceFieldMapper.enabled()) [ FD ]
Line_23 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(type, id))).version(version).versionType(versionType))-->Line_136 $$ return new GetResult(shardId.index().name(), type, id, get.version(), get.exists(), sourceToBeReturned, fields)[ FD ]
Line_24 $$ if (!get.exists()) -->Line_25 $$ get.release()[ CD ]
Line_4 $$ Engine.GetResult get = null-->Line_8 $$ if (get.exists()) [ FD ]
Line_70 $$ value = source.timestamp-->Line_74 $$ value = docMapper.TTLFieldMapper().valueForSearch(source.timestamp + source.ttl)[ FD ]
Line_23 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(type, id))).version(version).versionType(versionType))-->Line_25 $$ get.release()[ FD ]
Line_64 $$ Object value = null-->Line_104 $$ fields.put(field, new GetField(field, Collections.singletonList(value)))[ FD ]
Line_23 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(type, id))).version(version).versionType(versionType))-->Line_24 $$ if (!get.exists()) [ FD ]
Line_118 $$ if (sourceFieldFiltering || sourceFetchFiltering) -->Line_121 $$ XContentType sourceContentType = typeMapTuple.v1()[ CD ]
Line_123 $$ if (sourceFieldFiltering) -->Line_124 $$ sourceAsMap = XContentMapValues.filter(sourceAsMap, sourceFieldMapper.includes(), sourceFieldMapper.excludes())[ CD ]
Line_69 $$ if (field.equals(TimestampFieldMapper.NAME) && docMapper.timestampFieldMapper().enabled()) -->Line_71 $$ if (field.equals(TTLFieldMapper.NAME) && docMapper.TTLFieldMapper().enabled()) [ CD ]
Line_7 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(typeX, id))).version(version).versionType(versionType))-->Line_8 $$ if (get.exists()) [ FD ]
Line_8 $$ if (get.exists()) -->Line_12 $$ get.release()[ CD ]
Line_59 $$ for (String field : neededFields) -->Line_69 $$ if (field.equals(TimestampFieldMapper.NAME) && docMapper.timestampFieldMapper().enabled()) [ FD ]
Line_74 $$ value = docMapper.TTLFieldMapper().valueForSearch(source.timestamp + source.ttl)-->Line_101 $$ if (value instanceof List) [ FD ]
Line_4 $$ Engine.GetResult get = null-->Line_12 $$ get.release()[ FD ]
Line_89 $$ if (!values.isEmpty()) -->Line_93 $$ value = values[ CD ]
Line_41 $$ SearchLookup searchLookup = null-->Line_77 $$ if (searchLookup == null) [ FD ]
Line_2 $$ private GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields) -->Line_111 $$ if (fetchSourceContext.fetchSource() && sourceFieldMapper.enabled()) [ FD ]
Line_5 $$ if (type == null || type.equals("_all")) -->Line_24 $$ if (!get.exists()) [ CD ]
Line_7 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(typeX, id))).version(version).versionType(versionType))-->Line_23 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(type, id))).version(version).versionType(versionType))[ FD ]
Line_65 $$ if (field.equals(RoutingFieldMapper.NAME)) -->Line_66 $$ value = source.routing[ CD ]
Line_29 $$ DocumentMapper docMapper = mapperService.documentMapper(type)-->Line_37 $$ return innerGetLoadFromStoredFields(type, id, gFields, fetchSourceContext, get, docMapper, ignoreErrorsOnGeneratedFields)[ FD ]
Line_64 $$ Object value = null-->Line_70 $$ value = source.timestamp[ FD ]
Line_9 $$ type = typeX-->Line_37 $$ return innerGetLoadFromStoredFields(type, id, gFields, fetchSourceContext, get, docMapper, ignoreErrorsOnGeneratedFields)[ FD ]
Line_7 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(typeX, id))).version(version).versionType(versionType))-->Line_18 $$ if (!get.exists()) [ FD ]
Line_71 $$ if (field.equals(TTLFieldMapper.NAME) && docMapper.TTLFieldMapper().enabled()) -->Line_77 $$ if (searchLookup == null) [ CD ]
Line_2 $$ private GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields) -->Line_7 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(typeX, id))).version(version).versionType(versionType))[ FD ]
Line_66 $$ value = source.routing-->Line_104 $$ fields.put(field, new GetField(field, Collections.singletonList(value)))[ FD ]
Line_90 $$ for (int i = 0; i < values.size(); i++) -->Line_91 $$ values.set(i, fieldMapper.fieldType().valueForSearch(values.get(i)))[ CD ]
Line_65 $$ if (field.equals(RoutingFieldMapper.NAME)) -->Line_67 $$ if (field.equals(ParentFieldMapper.NAME) && docMapper.parentFieldMapper().active()) [ CD ]
Line_64 $$ Object value = null-->Line_66 $$ value = source.routing[ FD ]
Line_7 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(typeX, id))).version(version).versionType(versionType))-->Line_37 $$ return innerGetLoadFromStoredFields(type, id, gFields, fetchSourceContext, get, docMapper, ignoreErrorsOnGeneratedFields)[ FD ]
Line_4 $$ Engine.GetResult get = null-->Line_15 $$ if (get == null) [ FD ]
Line_59 $$ for (String field : neededFields) -->Line_65 $$ if (field.equals(RoutingFieldMapper.NAME)) [ FD ]
Line_77 $$ if (searchLookup == null) -->Line_79 $$ searchLookup.source().setSource(source.source)[ CD ]
Line_81 $$ FieldMapper fieldMapper = docMapper.mappers().smartNameFieldMapper(field)-->Line_87 $$ if (shouldGetFromSource(ignoreErrorsOnGeneratedFields, docMapper, fieldMapper)) [ FD ]
Line_4 $$ Engine.GetResult get = null-->Line_136 $$ return new GetResult(shardId.index().name(), type, id, get.version(), get.exists(), sourceToBeReturned, fields)[ FD ]
Line_112 $$ sourceToBeReturned = source.source-->Line_130 $$ sourceToBeReturned = XContentFactory.contentBuilder(sourceContentType).map(sourceAsMap).bytes()[ FD ]
Line_68 $$ value = source.parent-->Line_101 $$ if (value instanceof List) [ FD ]
Line_122 $$ Map<String, Object> sourceAsMap = typeMapTuple.v2()-->Line_127 $$ sourceAsMap = XContentMapValues.filter(sourceAsMap, fetchSourceContext.includes(), fetchSourceContext.excludes())[ FD ]
Line_4 $$ Engine.GetResult get = null-->Line_23 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(type, id))).version(version).versionType(versionType))[ FD ]
Line_87 $$ if (shouldGetFromSource(ignoreErrorsOnGeneratedFields, docMapper, fieldMapper)) -->Line_88 $$ List<Object> values = searchLookup.source().extractRawValues(field)[ CD ]
Line_67 $$ if (field.equals(ParentFieldMapper.NAME) && docMapper.parentFieldMapper().active()) -->Line_68 $$ value = source.parent[ CD ]
Line_4 $$ Engine.GetResult get = null-->Line_18 $$ if (!get.exists()) [ FD ]
Line_71 $$ if (field.equals(TTLFieldMapper.NAME) && docMapper.TTLFieldMapper().enabled()) -->Line_81 $$ FieldMapper fieldMapper = docMapper.mappers().smartNameFieldMapper(field)[ CD ]
Line_40 $$ Map<String, GetField> fields = null-->Line_104 $$ fields.put(field, new GetField(field, Collections.singletonList(value)))[ FD ]
Line_70 $$ value = source.timestamp-->Line_97 $$ if (value != null) [ FD ]
Line_3 $$ fetchSourceContext = normalizeFetchSourceContent(fetchSourceContext, gFields)-->Line_37 $$ return innerGetLoadFromStoredFields(type, id, gFields, fetchSourceContext, get, docMapper, ignoreErrorsOnGeneratedFields)[ FD ]
Line_99 $$ fields = new HashMap(2)-->Line_104 $$ fields.put(field, new GetField(field, Collections.singletonList(value)))[ FD ]
Line_59 $$ for (String field : neededFields) -->Line_102 $$ fields.put(field, new GetField(field, (List) value))[ FD ]
Line_121 $$ XContentType sourceContentType = typeMapTuple.v1()-->Line_130 $$ sourceToBeReturned = XContentFactory.contentBuilder(sourceContentType).map(sourceAsMap).bytes()[ FD ]
Line_23 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(type, id))).version(version).versionType(versionType))-->Line_39 $$ Translog.Source source = get.source()[ FD ]
Line_49 $$ if (docMapper.timestampFieldMapper().enabled()) -->Line_50 $$ neededFields.add(TimestampFieldMapper.NAME)[ CD ]
Line_70 $$ value = source.timestamp-->Line_101 $$ if (value instanceof List) [ FD ]
Line_64 $$ Object value = null-->Line_101 $$ if (value instanceof List) [ FD ]
Line_29 $$ DocumentMapper docMapper = mapperService.documentMapper(type)-->Line_110 $$ SourceFieldMapper sourceFieldMapper = docMapper.sourceMapper()[ FD ]
Line_4 $$ Engine.GetResult get = null-->Line_25 $$ get.release()[ FD ]
Line_30 $$ if (docMapper == null) -->Line_31 $$ get.release()[ CD ]
Line_68 $$ value = source.parent-->Line_74 $$ value = docMapper.TTLFieldMapper().valueForSearch(source.timestamp + source.ttl)[ FD ]
Line_4 $$ Engine.GetResult get = null-->Line_7 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(typeX, id))).version(version).versionType(versionType))[ FD ]
Line_68 $$ value = source.parent-->Line_70 $$ value = source.timestamp[ FD ]
Line_93 $$ value = values-->Line_104 $$ fields.put(field, new GetField(field, Collections.singletonList(value)))[ FD ]
Line_97 $$ if (value != null) -->Line_101 $$ if (value instanceof List) [ CD ]
Line_9 $$ type = typeX-->Line_29 $$ DocumentMapper docMapper = mapperService.documentMapper(type)[ FD ]
Line_29 $$ DocumentMapper docMapper = mapperService.documentMapper(type)-->Line_87 $$ if (shouldGetFromSource(ignoreErrorsOnGeneratedFields, docMapper, fieldMapper)) [ FD ]
Line_90 $$ for (int i = 0; i < values.size(); i++) -->Line_91 $$ values.set(i, fieldMapper.fieldType().valueForSearch(values.get(i)))[ FD ]
Line_40 $$ Map<String, GetField> fields = null-->Line_102 $$ fields.put(field, new GetField(field, (List) value))[ FD ]
Line_2 $$ private GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields) -->Line_30 $$ if (docMapper == null) [ CD ]
Line_7 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(typeX, id))).version(version).versionType(versionType))-->Line_15 $$ if (get == null) [ FD ]
Line_88 $$ List<Object> values = searchLookup.source().extractRawValues(field)-->Line_91 $$ values.set(i, fieldMapper.fieldType().valueForSearch(values.get(i)))[ FD ]
Line_2 $$ private GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields) -->Line_29 $$ DocumentMapper docMapper = mapperService.documentMapper(type)[ CD ]
Line_70 $$ value = source.timestamp-->Line_93 $$ value = values[ FD ]
Line_124 $$ sourceAsMap = XContentMapValues.filter(sourceAsMap, sourceFieldMapper.includes(), sourceFieldMapper.excludes())-->Line_130 $$ sourceToBeReturned = XContentFactory.contentBuilder(sourceContentType).map(sourceAsMap).bytes()[ FD ]
Line_67 $$ if (field.equals(ParentFieldMapper.NAME) && docMapper.parentFieldMapper().active()) -->Line_69 $$ if (field.equals(TimestampFieldMapper.NAME) && docMapper.timestampFieldMapper().enabled()) [ CD ]
Line_122 $$ Map<String, Object> sourceAsMap = typeMapTuple.v2()-->Line_124 $$ sourceAsMap = XContentMapValues.filter(sourceAsMap, sourceFieldMapper.includes(), sourceFieldMapper.excludes())[ FD ]
Line_89 $$ if (!values.isEmpty()) -->Line_90 $$ for (int i = 0; i < values.size(); i++) [ CD ]
Line_2 $$ private GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields) -->Line_29 $$ DocumentMapper docMapper = mapperService.documentMapper(type)[ FD ]
Line_88 $$ List<Object> values = searchLookup.source().extractRawValues(field)-->Line_89 $$ if (!values.isEmpty()) [ FD ]
Line_111 $$ if (fetchSourceContext.fetchSource() && sourceFieldMapper.enabled()) -->Line_112 $$ sourceToBeReturned = source.source[ CD ]
Line_4 $$ Engine.GetResult get = null-->Line_139 $$ get.release()[ FD ]
Line_64 $$ Object value = null-->Line_68 $$ value = source.parent[ FD ]
Line_66 $$ value = source.routing-->Line_93 $$ value = values[ FD ]
Line_5 $$ if (type == null || type.equals("_all")) -->Line_15 $$ if (get == null) [ CD ]
Line_126 $$ if (sourceFetchFiltering) -->Line_127 $$ sourceAsMap = XContentMapValues.filter(sourceAsMap, fetchSourceContext.includes(), fetchSourceContext.excludes())[ CD ]
Line_64 $$ Object value = null-->Line_74 $$ value = docMapper.TTLFieldMapper().valueForSearch(source.timestamp + source.ttl)[ FD ]
Line_2 $$ private GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields) -->Line_127 $$ sourceAsMap = XContentMapValues.filter(sourceAsMap, fetchSourceContext.includes(), fetchSourceContext.excludes())[ FD ]
Line_101 $$ if (value instanceof List) -->Line_104 $$ fields.put(field, new GetField(field, Collections.singletonList(value)))[ CD ]
Line_81 $$ FieldMapper fieldMapper = docMapper.mappers().smartNameFieldMapper(field)-->Line_82 $$ if (fieldMapper == null) [ FD ]
Line_4 $$ Engine.GetResult get = null-->Line_24 $$ if (!get.exists()) [ FD ]
Line_24 $$ if (!get.exists()) -->Line_26 $$ return new GetResult(shardId.index().name(), type, id, -1, false, null, null)[ CD ]
Line_78 $$ searchLookup = new SearchLookup(mapperService, null, new String[] -->Line_88 $$ List<Object> values = searchLookup.source().extractRawValues(field)[ FD ]
Line_59 $$ for (String field : neededFields) -->Line_60 $$ if (SourceFieldMapper.NAME.equals(field)) [ FD ]
Line_29 $$ DocumentMapper docMapper = mapperService.documentMapper(type)-->Line_49 $$ if (docMapper.timestampFieldMapper().enabled()) [ FD ]
Line_69 $$ if (field.equals(TimestampFieldMapper.NAME) && docMapper.timestampFieldMapper().enabled()) -->Line_70 $$ value = source.timestamp[ CD ]
Line_41 $$ SearchLookup searchLookup = null-->Line_88 $$ List<Object> values = searchLookup.source().extractRawValues(field)[ FD ]
Line_29 $$ DocumentMapper docMapper = mapperService.documentMapper(type)-->Line_46 $$ if (docMapper.parentFieldMapper().active()) [ FD ]
Line_101 $$ if (value instanceof List) -->Line_102 $$ fields.put(field, new GetField(field, (List) value))[ CD ]
Line_6 $$ for (String typeX : mapperService.types()) -->Line_9 $$ type = typeX[ FD ]
Line_7 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(typeX, id))).version(version).versionType(versionType))-->Line_24 $$ if (!get.exists()) [ FD ]
Line_2 $$ private GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields) -->Line_117 $$ boolean sourceFetchFiltering = fetchSourceContext.includes().length > 0 || fetchSourceContext.excludes().length > 0[ FD ]
Line_41 $$ SearchLookup searchLookup = null-->Line_79 $$ searchLookup.source().setSource(source.source)[ FD ]
Line_15 $$ if (get == null) -->Line_16 $$ return new GetResult(shardId.index().name(), type, id, -1, false, null, null)[ CD ]
Line_68 $$ value = source.parent-->Line_104 $$ fields.put(field, new GetField(field, Collections.singletonList(value)))[ FD ]
Line_29 $$ DocumentMapper docMapper = mapperService.documentMapper(type)-->Line_74 $$ value = docMapper.TTLFieldMapper().valueForSearch(source.timestamp + source.ttl)[ FD ]
Line_64 $$ Object value = null-->Line_97 $$ if (value != null) [ FD ]
Line_6 $$ for (String typeX : mapperService.types()) -->Line_7 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(typeX, id))).version(version).versionType(versionType))[ FD ]
Line_2 $$ private GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields) -->Line_4 $$ Engine.GetResult get = null[ CD ]
Line_59 $$ for (String field : neededFields) -->Line_81 $$ FieldMapper fieldMapper = docMapper.mappers().smartNameFieldMapper(field)[ FD ]
Line_59 $$ for (String field : neededFields) -->Line_71 $$ if (field.equals(TTLFieldMapper.NAME) && docMapper.TTLFieldMapper().enabled()) [ FD ]
Line_68 $$ value = source.parent-->Line_93 $$ value = values[ FD ]
Line_59 $$ for (String field : neededFields) -->Line_88 $$ List<Object> values = searchLookup.source().extractRawValues(field)[ FD ]
Line_2 $$ private GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields) -->Line_3 $$ fetchSourceContext = normalizeFetchSourceContent(fetchSourceContext, gFields)[ CD ]
Line_66 $$ value = source.routing-->Line_97 $$ if (value != null) [ FD ]
Line_7 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(typeX, id))).version(version).versionType(versionType))-->Line_39 $$ Translog.Source source = get.source()[ FD ]
Line_7 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(typeX, id))).version(version).versionType(versionType))-->Line_12 $$ get.release()[ FD ]
Line_71 $$ if (field.equals(TTLFieldMapper.NAME) && docMapper.TTLFieldMapper().enabled()) -->Line_82 $$ if (fieldMapper == null) [ CD ]
Line_111 $$ if (fetchSourceContext.fetchSource() && sourceFieldMapper.enabled()) -->Line_118 $$ if (sourceFieldFiltering || sourceFetchFiltering) [ CD ]
Line_127 $$ sourceAsMap = XContentMapValues.filter(sourceAsMap, fetchSourceContext.includes(), fetchSourceContext.excludes())-->Line_130 $$ sourceToBeReturned = XContentFactory.contentBuilder(sourceContentType).map(sourceAsMap).bytes()[ FD ]
Line_7 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(typeX, id))).version(version).versionType(versionType))-->Line_31 $$ get.release()[ FD ]
Line_93 $$ value = values-->Line_97 $$ if (value != null) [ FD ]
Line_7 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(typeX, id))).version(version).versionType(versionType))-->Line_25 $$ get.release()[ FD ]
Line_29 $$ DocumentMapper docMapper = mapperService.documentMapper(type)-->Line_52 $$ if (docMapper.TTLFieldMapper().enabled()) [ FD ]
Line_9 $$ type = typeX-->Line_23 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(type, id))).version(version).versionType(versionType))[ FD ]
Line_8 $$ if (get.exists()) -->Line_9 $$ type = typeX[ CD ]
Line_29 $$ DocumentMapper docMapper = mapperService.documentMapper(type)-->Line_83 $$ if (docMapper.objectMappers().get(field) != null) [ FD ]
Line_124 $$ sourceAsMap = XContentMapValues.filter(sourceAsMap, sourceFieldMapper.includes(), sourceFieldMapper.excludes())-->Line_127 $$ sourceAsMap = XContentMapValues.filter(sourceAsMap, fetchSourceContext.includes(), fetchSourceContext.excludes())[ FD ]
Line_52 $$ if (docMapper.TTLFieldMapper().enabled()) -->Line_53 $$ neededFields.add(TTLFieldMapper.NAME)[ CD ]
Line_81 $$ FieldMapper fieldMapper = docMapper.mappers().smartNameFieldMapper(field)-->Line_91 $$ values.set(i, fieldMapper.fieldType().valueForSearch(values.get(i)))[ FD ]
Line_2 $$ private GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields) -->Line_87 $$ if (shouldGetFromSource(ignoreErrorsOnGeneratedFields, docMapper, fieldMapper)) [ FD ]
Line_117 $$ boolean sourceFetchFiltering = fetchSourceContext.includes().length > 0 || fetchSourceContext.excludes().length > 0-->Line_118 $$ if (sourceFieldFiltering || sourceFetchFiltering) [ FD ]
Line_78 $$ searchLookup = new SearchLookup(mapperService, null, new String[] -->Line_79 $$ searchLookup.source().setSource(source.source)[ FD ]
Line_118 $$ if (sourceFieldFiltering || sourceFetchFiltering) -->Line_126 $$ if (sourceFetchFiltering) [ CD ]
Line_3 $$ fetchSourceContext = normalizeFetchSourceContent(fetchSourceContext, gFields)-->Line_111 $$ if (fetchSourceContext.fetchSource() && sourceFieldMapper.enabled()) [ FD ]
Line_23 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(type, id))).version(version).versionType(versionType))-->Line_31 $$ get.release()[ FD ]
Line_2 $$ private GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields) -->Line_9 $$ type = typeX[ FD ]
Line_3 $$ fetchSourceContext = normalizeFetchSourceContent(fetchSourceContext, gFields)-->Line_127 $$ sourceAsMap = XContentMapValues.filter(sourceAsMap, fetchSourceContext.includes(), fetchSourceContext.excludes())[ FD ]
Line_98 $$ if (fields == null) -->Line_99 $$ fields = new HashMap(2)[ CD ]
Line_68 $$ value = source.parent-->Line_97 $$ if (value != null) [ FD ]
Line_29 $$ DocumentMapper docMapper = mapperService.documentMapper(type)-->Line_69 $$ if (field.equals(TimestampFieldMapper.NAME) && docMapper.timestampFieldMapper().enabled()) [ FD ]
Line_59 $$ for (String field : neededFields) -->Line_67 $$ if (field.equals(ParentFieldMapper.NAME) && docMapper.parentFieldMapper().active()) [ FD ]
Line_77 $$ if (searchLookup == null) -->Line_78 $$ searchLookup = new SearchLookup(mapperService, null, new String[] [ CD ]
Line_2 $$ private GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields) -->Line_57 $$ neededFields.addAll(Arrays.asList(gFields))[ FD ]
Line_66 $$ value = source.routing-->Line_70 $$ value = source.timestamp[ FD ]
Line_64 $$ Object value = null-->Line_93 $$ value = values[ FD ]
Line_23 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(type, id))).version(version).versionType(versionType))-->Line_139 $$ get.release()[ FD ]
Line_87 $$ if (shouldGetFromSource(ignoreErrorsOnGeneratedFields, docMapper, fieldMapper)) -->Line_89 $$ if (!values.isEmpty()) [ CD ]
Line_59 $$ for (String field : neededFields) -->Line_104 $$ fields.put(field, new GetField(field, Collections.singletonList(value)))[ FD ]
Line_2 $$ private GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields) -->Line_5 $$ if (type == null || type.equals("_all")) [ CD ]
Line_29 $$ DocumentMapper docMapper = mapperService.documentMapper(type)-->Line_71 $$ if (field.equals(TTLFieldMapper.NAME) && docMapper.TTLFieldMapper().enabled()) [ FD ]
Line_99 $$ fields = new HashMap(2)-->Line_102 $$ fields.put(field, new GetField(field, (List) value))[ FD ]
Line_74 $$ value = docMapper.TTLFieldMapper().valueForSearch(source.timestamp + source.ttl)-->Line_97 $$ if (value != null) [ FD ]
Line_88 $$ List<Object> values = searchLookup.source().extractRawValues(field)-->Line_93 $$ value = values[ FD ]
Line_2 $$ private GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields) -->Line_3 $$ fetchSourceContext = normalizeFetchSourceContent(fetchSourceContext, gFields)[ FD ]
Line_40 $$ Map<String, GetField> fields = null-->Line_99 $$ fields = new HashMap(2)[ FD ]
Line_30 $$ if (docMapper == null) -->Line_32 $$ return new GetResult(shardId.index().name(), type, id, -1, false, null, null)[ CD ]
Line_3 $$ fetchSourceContext = normalizeFetchSourceContent(fetchSourceContext, gFields)-->Line_117 $$ boolean sourceFetchFiltering = fetchSourceContext.includes().length > 0 || fetchSourceContext.excludes().length > 0[ FD ]
Line_4 $$ Engine.GetResult get = null-->Line_31 $$ get.release()[ FD ]
Line_82 $$ if (fieldMapper == null) -->Line_87 $$ if (shouldGetFromSource(ignoreErrorsOnGeneratedFields, docMapper, fieldMapper)) [ CD ]
Line_41 $$ SearchLookup searchLookup = null-->Line_78 $$ searchLookup = new SearchLookup(mapperService, null, new String[] [ FD ]
Line_29 $$ DocumentMapper docMapper = mapperService.documentMapper(type)-->Line_81 $$ FieldMapper fieldMapper = docMapper.mappers().smartNameFieldMapper(field)[ FD ]
Line_23 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(type, id))).version(version).versionType(versionType))-->Line_37 $$ return innerGetLoadFromStoredFields(type, id, gFields, fetchSourceContext, get, docMapper, ignoreErrorsOnGeneratedFields)[ FD ]
Line_122 $$ Map<String, Object> sourceAsMap = typeMapTuple.v2()-->Line_130 $$ sourceToBeReturned = XContentFactory.contentBuilder(sourceContentType).map(sourceAsMap).bytes()[ FD ]
Line_29 $$ DocumentMapper docMapper = mapperService.documentMapper(type)-->Line_67 $$ if (field.equals(ParentFieldMapper.NAME) && docMapper.parentFieldMapper().active()) [ FD ]
Line_70 $$ value = source.timestamp-->Line_104 $$ fields.put(field, new GetField(field, Collections.singletonList(value)))[ FD ]
Line_88 $$ List<Object> values = searchLookup.source().extractRawValues(field)-->Line_90 $$ for (int i = 0; i < values.size(); i++) [ FD ]
Line_5 $$ if (type == null || type.equals("_all")) -->Line_23 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(type, id))).version(version).versionType(versionType))[ CD ]
Line_2 $$ private GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields) -->Line_5 $$ if (type == null || type.equals("_all")) [ FD ]
Line_110 $$ SourceFieldMapper sourceFieldMapper = docMapper.sourceMapper()-->Line_124 $$ sourceAsMap = XContentMapValues.filter(sourceAsMap, sourceFieldMapper.includes(), sourceFieldMapper.excludes())[ FD ]
Line_59 $$ for (String field : neededFields) -->Line_83 $$ if (docMapper.objectMappers().get(field) != null) [ FD ]
Line_2 $$ private GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields) -->Line_23 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(type, id))).version(version).versionType(versionType))[ FD ]
Line_118 $$ if (sourceFieldFiltering || sourceFetchFiltering) -->Line_123 $$ if (sourceFieldFiltering) [ CD ]
Line_29 $$ DocumentMapper docMapper = mapperService.documentMapper(type)-->Line_30 $$ if (docMapper == null) [ FD ]
Line_118 $$ if (sourceFieldFiltering || sourceFetchFiltering) -->Line_122 $$ Map<String, Object> sourceAsMap = typeMapTuple.v2()[ CD ]
Line_7 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(typeX, id))).version(version).versionType(versionType))-->Line_139 $$ get.release()[ FD ]
Line_111 $$ if (fetchSourceContext.fetchSource() && sourceFieldMapper.enabled()) -->Line_117 $$ boolean sourceFetchFiltering = fetchSourceContext.includes().length > 0 || fetchSourceContext.excludes().length > 0[ CD ]
Line_4 $$ Engine.GetResult get = null-->Line_39 $$ Translog.Source source = get.source()[ FD ]
Line_4 $$ Engine.GetResult get = null-->Line_37 $$ return innerGetLoadFromStoredFields(type, id, gFields, fetchSourceContext, get, docMapper, ignoreErrorsOnGeneratedFields)[ FD ]
Line_66 $$ value = source.routing-->Line_68 $$ value = source.parent[ FD ]
Line_74 $$ value = docMapper.TTLFieldMapper().valueForSearch(source.timestamp + source.ttl)-->Line_93 $$ value = values[ FD ]
Line_74 $$ value = docMapper.TTLFieldMapper().valueForSearch(source.timestamp + source.ttl)-->Line_104 $$ fields.put(field, new GetField(field, Collections.singletonList(value)))[ FD ]
Line_66 $$ value = source.routing-->Line_101 $$ if (value instanceof List) [ FD ]
Line_40 $$ Map<String, GetField> fields = null-->Line_98 $$ if (fields == null) [ FD ]
Line_2 $$ private GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields) -->Line_37 $$ return innerGetLoadFromStoredFields(type, id, gFields, fetchSourceContext, get, docMapper, ignoreErrorsOnGeneratedFields)[ FD ]
Line_5 $$ if (type == null || type.equals("_all")) -->Line_18 $$ if (!get.exists()) [ CD ]
Line_82 $$ if (fieldMapper == null) -->Line_83 $$ if (docMapper.objectMappers().get(field) != null) [ CD ]
Line_7 $$ get = indexShard.get(new Engine.Get(realtime, new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(typeX, id))).version(version).versionType(versionType))-->Line_136 $$ return new GetResult(shardId.index().name(), type, id, get.version(), get.exists(), sourceToBeReturned, fields)[ FD ]
Line_93 $$ value = values-->Line_101 $$ if (value instanceof List) [ FD ]
