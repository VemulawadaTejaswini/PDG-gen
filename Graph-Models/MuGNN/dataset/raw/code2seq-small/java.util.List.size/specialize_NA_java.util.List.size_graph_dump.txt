Line_6 $$ MethodHandle compareMethod = functionRegistry.getScalarFunctionImplementation(internalOperator(operatorType, BOOLEAN, ImmutableList.of(type, type))).getMethodHandle()-->Line_8 $$ Class<?> clazz = generate(javaTypes, type, compareMethod)[ FD ]
Line_4 $$ Type type = types.get("E")-->Line_5 $$ checkArgument(type.isOrderable(), "Type must be orderable")[ FD ]
Line_7 $$ List<Class<?>> javaTypes = IntStream.range(0, arity).mapToObj( i -> type.getJavaType()).collect(toImmutableList())-->Line_9 $$ MethodHandle methodHandle = methodHandle(clazz, getSignature().getName(), javaTypes.toArray(new Class<?>[javaTypes.size()]))[ FD ]
Line_4 $$ Type type = types.get("E")-->Line_8 $$ Class<?> clazz = generate(javaTypes, type, compareMethod)[ FD ]
Line_4 $$ Type type = types.get("E")-->Line_6 $$ MethodHandle compareMethod = functionRegistry.getScalarFunctionImplementation(internalOperator(operatorType, BOOLEAN, ImmutableList.of(type, type))).getMethodHandle()[ FD ]
Line_8 $$ Class<?> clazz = generate(javaTypes, type, compareMethod)-->Line_9 $$ MethodHandle methodHandle = methodHandle(clazz, getSignature().getName(), javaTypes.toArray(new Class<?>[javaTypes.size()]))[ FD ]
Line_7 $$ List<Class<?>> javaTypes = IntStream.range(0, arity).mapToObj( i -> type.getJavaType()).collect(toImmutableList())-->Line_10 $$ List<Boolean> nullableParameters = ImmutableList.copyOf(Collections.nCopies(javaTypes.size(), false))[ FD ]
Line_7 $$ List<Class<?>> javaTypes = IntStream.range(0, arity).mapToObj( i -> type.getJavaType()).collect(toImmutableList())-->Line_8 $$ Class<?> clazz = generate(javaTypes, type, compareMethod)[ FD ]
Line_4 $$ Type type = types.get("E")-->Line_7 $$ type.getJavaType()[ FD ]
