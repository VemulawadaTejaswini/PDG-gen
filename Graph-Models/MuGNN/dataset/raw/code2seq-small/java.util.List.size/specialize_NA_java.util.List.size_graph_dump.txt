Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_5 $$ MethodHandle compareMethod = functionRegistry.getScalarFunctionImplementation(internalOperator(operatorType, BOOLEAN, ImmutableList.of(type, type))).getMethodHandle()[ CD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_3 $$ Type type = types.get("E")[ CD ]
Line_3 $$ Type type = types.get("E")-->Line_7 $$ Class<?> clazz = generate(javaTypes, type, compareMethod)[ FD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_9 $$ List<Boolean> nullableParameters = ImmutableList.copyOf(Collections.nCopies(javaTypes.size(), false))[ CD ]
Line_6 $$ List<Class<?>> javaTypes = IntStream.range(0, arity).mapToObj( i -> type.getJavaType()).collect(toImmutableList())-->Line_9 $$ List<Boolean> nullableParameters = ImmutableList.copyOf(Collections.nCopies(javaTypes.size(), false))[ FD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_5 $$ MethodHandle compareMethod = functionRegistry.getScalarFunctionImplementation(internalOperator(operatorType, BOOLEAN, ImmutableList.of(type, type))).getMethodHandle()[ FD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_8 $$ MethodHandle methodHandle = methodHandle(clazz, getSignature().getName(), javaTypes.toArray(new Class<?>[javaTypes.size()]))[ CD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_7 $$ Class<?> clazz = generate(javaTypes, type, compareMethod)[ CD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_6 $$ List<Class<?>> javaTypes = IntStream.range(0, arity).mapToObj( i -> type.getJavaType()).collect(toImmutableList())[ CD ]
Line_5 $$ MethodHandle compareMethod = functionRegistry.getScalarFunctionImplementation(internalOperator(operatorType, BOOLEAN, ImmutableList.of(type, type))).getMethodHandle()-->Line_7 $$ Class<?> clazz = generate(javaTypes, type, compareMethod)[ FD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_6 $$ List<Class<?>> javaTypes = IntStream.range(0, arity).mapToObj( i -> type.getJavaType()).collect(toImmutableList())[ FD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_10 $$ return new ScalarFunctionImplementation(false, nullableParameters, methodHandle, isDeterministic())[ CD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_3 $$ Type type = types.get("E")[ FD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_4 $$ checkArgument(type.isOrderable(), "Type must be orderable")[ CD ]
Line_7 $$ Class<?> clazz = generate(javaTypes, type, compareMethod)-->Line_8 $$ MethodHandle methodHandle = methodHandle(clazz, getSignature().getName(), javaTypes.toArray(new Class<?>[javaTypes.size()]))[ FD ]
Line_6 $$ List<Class<?>> javaTypes = IntStream.range(0, arity).mapToObj( i -> type.getJavaType()).collect(toImmutableList())-->Line_8 $$ MethodHandle methodHandle = methodHandle(clazz, getSignature().getName(), javaTypes.toArray(new Class<?>[javaTypes.size()]))[ FD ]
Line_6 $$ List<Class<?>> javaTypes = IntStream.range(0, arity).mapToObj( i -> type.getJavaType()).collect(toImmutableList())-->Line_7 $$ Class<?> clazz = generate(javaTypes, type, compareMethod)[ FD ]
Line_3 $$ Type type = types.get("E")-->Line_6 $$ type.getJavaType()[ FD ]
Line_3 $$ Type type = types.get("E")-->Line_4 $$ checkArgument(type.isOrderable(), "Type must be orderable")[ FD ]
Line_3 $$ Type type = types.get("E")-->Line_5 $$ MethodHandle compareMethod = functionRegistry.getScalarFunctionImplementation(internalOperator(operatorType, BOOLEAN, ImmutableList.of(type, type))).getMethodHandle()[ FD ]
