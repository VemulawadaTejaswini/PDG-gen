Line_11 $$ Callback callback = null-->Line_69 $$ callback = new ListenerCallback(jpaListenerFactory.buildListener(listener), method)[ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_89 $$ return callbacks.toArray(new Callback[callbacks.size()])[ CD ]
Line_7 $$ XClass currentClazz = beanClass-->Line_40 $$ stopDefaultListeners = currentClazz.isAnnotationPresent(ExcludeDefaultListeners.class)[ FD ]
Line_15 $$ Method method = reflectionManager.toMethod(xMethod)-->Line_76 $$ method.setAccessible(true)[ FD ]
Line_58 $$ if (listener != null) -->Line_59 $$ XClass xListener = reflectionManager.toXClass(listener)[ CD ]
Line_64 $$ final Method method = reflectionManager.toMethod(xMethod)-->Line_76 $$ method.setAccessible(true)[ FD ]
Line_59 $$ XClass xListener = reflectionManager.toXClass(listener)-->Line_61 $$ List<XMethod> methods = xListener.getDeclaredMethods()[ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_73 $$ throw new PersistenceException("Callback methods annotated in a listener bean class must return void and take one argument: " + annotation.getName() + " - " + method)[ FD ]
Line_48 $$ List<Class> defaultListeners = (List<Class>) reflectionManager.getDefaults().get(EntityListeners.class)-->Line_52 $$ orderedListeners.add(defaultListeners.get(i))[ FD ]
Line_48 $$ List<Class> defaultListeners = (List<Class>) reflectionManager.getDefaults().get(EntityListeners.class)-->Line_50 $$ int defaultListenerSize = defaultListeners.size()[ FD ]
Line_9 $$ boolean stopDefaultListeners = false-->Line_40 $$ stopDefaultListeners = currentClazz.isAnnotationPresent(ExcludeDefaultListeners.class)[ FD ]
Line_51 $$ for (int i = defaultListenerSize - 1; i >= 0; i--) -->Line_52 $$ orderedListeners.add(defaultListeners.get(i))[ FD ]
Line_10 $$ do -->Line_12 $$ List<XMethod> methods = currentClazz.getDeclaredMethods()[ CD ]
Line_10 $$ do -->Line_37 $$ if (!stopListeners) [ CD ]
Line_13 $$ for (final XMethod xMethod : methods) -->Line_63 $$ if (xMethod.isAnnotationPresent(annotation)) [ FD ]
Line_49 $$ if (defaultListeners != null) -->Line_51 $$ for (int i = defaultListenerSize - 1; i >= 0; i--) [ CD ]
Line_56 $$ for (Class listener : orderedListeners) -->Line_58 $$ if (listener != null) [ FD ]
Line_58 $$ if (listener != null) -->Line_61 $$ List<XMethod> methods = xListener.getDeclaredMethods()[ CD ]
Line_7 $$ XClass currentClazz = beanClass-->Line_39 $$ stopListeners = currentClazz.isAnnotationPresent(ExcludeSuperclassListeners.class)[ FD ]
Line_39 $$ stopListeners = currentClazz.isAnnotationPresent(ExcludeSuperclassListeners.class)-->Line_37 $$ if (!stopListeners) [ FD ]
Line_10 $$ do -->Line_42 $$ do [ CD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_8 $$ boolean stopListeners = false[ CD ]
Line_43 $$ currentClazz = currentClazz.getSuperclass()-->Line_42 $$ do [ FD ]
Line_58 $$ if (listener != null) -->Line_60 $$ callbacksMethodNames = new ArrayList<String>()[ CD ]
Line_11 $$ Callback callback = null-->Line_20 $$ callback = new EntityCallback(method)[ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_32 $$ throw new PersistenceException("You can only annotate one callback method with " + annotation.getName() + " in bean class: " + beanClass.getName())[ FD ]
Line_14 $$ if (xMethod.isAnnotationPresent(annotation)) -->Line_17 $$ if (!callbacksMethodNames.contains(methodName)) [ CD ]
Line_42 $$ do -->Line_43 $$ currentClazz = currentClazz.getSuperclass()[ CD ]
Line_75 $$ if (!method.isAccessible()) -->Line_76 $$ method.setAccessible(true)[ CD ]
Line_7 $$ XClass currentClazz = beanClass-->Line_12 $$ List<XMethod> methods = currentClazz.getDeclaredMethods()[ FD ]
Line_56 $$ for (Class listener : orderedListeners) -->Line_69 $$ callback = new ListenerCallback(jpaListenerFactory.buildListener(listener), method)[ FD ]
Line_15 $$ Method method = reflectionManager.toMethod(xMethod)-->Line_65 $$ final String methodName = method.getName()[ FD ]
Line_7 $$ XClass currentClazz = beanClass-->Line_38 $$ getListeners(currentClazz, orderedListeners)[ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_64 $$ final Method method = reflectionManager.toMethod(xMethod)[ FD ]
Line_65 $$ final String methodName = method.getName()-->Line_66 $$ if (!callbacksMethodNames.contains(methodName)) [ FD ]
Line_6 $$ List<Class> orderedListeners = new ArrayList<Class>()-->Line_38 $$ getListeners(currentClazz, orderedListeners)[ FD ]
Line_7 $$ XClass currentClazz = beanClass-->Line_42 $$ do [ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_82 $$ throw new PersistenceException("You can only annotate one callback method with " + annotation.getName() + " in bean class: " + beanClass.getName() + " and callback listener: " + listener.getName())[ FD ]
Line_16 $$ final String methodName = method.getName()-->Line_78 $$ log.debugf("Adding %s as %s callback for entity %s", methodName, annotation.getSimpleName(), beanClass.getName())[ FD ]
Line_7 $$ XClass currentClazz = beanClass-->Line_43 $$ currentClazz = currentClazz.getSuperclass()[ FD ]
Line_16 $$ final String methodName = method.getName()-->Line_30 $$ callbacksMethodNames.add(0, methodName)[ FD ]
Line_37 $$ if (!stopListeners) -->Line_39 $$ stopListeners = currentClazz.isAnnotationPresent(ExcludeSuperclassListeners.class)[ CD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_10 $$ do [ CD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_15 $$ Method method = reflectionManager.toMethod(xMethod)[ FD ]
Line_49 $$ if (defaultListeners != null) -->Line_50 $$ int defaultListenerSize = defaultListeners.size()[ CD ]
Line_15 $$ Method method = reflectionManager.toMethod(xMethod)-->Line_26 $$ method.setAccessible(true)[ FD ]
Line_15 $$ Method method = reflectionManager.toMethod(xMethod)-->Line_16 $$ final String methodName = method.getName()[ FD ]
Line_60 $$ callbacksMethodNames = new ArrayList<String>()-->Line_66 $$ if (!callbacksMethodNames.contains(methodName)) [ FD ]
Line_13 $$ for (final XMethod xMethod : methods) -->Line_64 $$ final Method method = reflectionManager.toMethod(xMethod)[ FD ]
Line_14 $$ if (xMethod.isAnnotationPresent(annotation)) -->Line_16 $$ final String methodName = method.getName()[ CD ]
Line_48 $$ List<Class> defaultListeners = (List<Class>) reflectionManager.getDefaults().get(EntityListeners.class)-->Line_49 $$ if (defaultListeners != null) [ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_6 $$ List<Class> orderedListeners = new ArrayList<Class>()[ CD ]
Line_15 $$ Method method = reflectionManager.toMethod(xMethod)-->Line_22 $$ Class[] args = method.getParameterTypes()[ FD ]
Line_51 $$ for (int i = defaultListenerSize - 1; i >= 0; i--) -->Line_52 $$ orderedListeners.add(defaultListeners.get(i))[ CD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_14 $$ if (xMethod.isAnnotationPresent(annotation)) [ FD ]
Line_64 $$ final Method method = reflectionManager.toMethod(xMethod)-->Line_70 $$ Class returnType = method.getReturnType()[ FD ]
Line_6 $$ List<Class> orderedListeners = new ArrayList<Class>()-->Line_52 $$ orderedListeners.add(defaultListeners.get(i))[ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_24 $$ throw new RuntimeException("Callback methods annotated on the bean class must return void and take no arguments: " + annotation.getName() + " - " + xMethod)[ FD ]
Line_64 $$ final Method method = reflectionManager.toMethod(xMethod)-->Line_75 $$ if (!method.isAccessible()) [ FD ]
Line_16 $$ final String methodName = method.getName()-->Line_66 $$ if (!callbacksMethodNames.contains(methodName)) [ FD ]
Line_20 $$ callback = new EntityCallback(method)-->Line_69 $$ callback = new ListenerCallback(jpaListenerFactory.buildListener(listener), method)[ FD ]
Line_62 $$ for (final XMethod xMethod : methods) -->Line_64 $$ final Method method = reflectionManager.toMethod(xMethod)[ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_7 $$ XClass currentClazz = beanClass[ CD ]
Line_8 $$ boolean stopListeners = false-->Line_37 $$ if (!stopListeners) [ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_59 $$ XClass xListener = reflectionManager.toXClass(listener)[ FD ]
Line_37 $$ if (!stopListeners) -->Line_38 $$ getListeners(currentClazz, orderedListeners)[ CD ]
Line_15 $$ Method method = reflectionManager.toMethod(xMethod)-->Line_75 $$ if (!method.isAccessible()) [ FD ]
Line_13 $$ for (final XMethod xMethod : methods) -->Line_15 $$ Method method = reflectionManager.toMethod(xMethod)[ FD ]
Line_62 $$ for (final XMethod xMethod : methods) -->Line_63 $$ if (xMethod.isAnnotationPresent(annotation)) [ FD ]
Line_56 $$ for (Class listener : orderedListeners) -->Line_59 $$ XClass xListener = reflectionManager.toXClass(listener)[ FD ]
Line_37 $$ if (!stopListeners) -->Line_40 $$ stopDefaultListeners = currentClazz.isAnnotationPresent(ExcludeDefaultListeners.class)[ CD ]
Line_14 $$ if (xMethod.isAnnotationPresent(annotation)) -->Line_15 $$ Method method = reflectionManager.toMethod(xMethod)[ CD ]
Line_57 $$ Callback callback = null-->Line_69 $$ callback = new ListenerCallback(jpaListenerFactory.buildListener(listener), method)[ FD ]
Line_65 $$ final String methodName = method.getName()-->Line_78 $$ log.debugf("Adding %s as %s callback for entity %s", methodName, annotation.getSimpleName(), beanClass.getName())[ FD ]
Line_15 $$ Method method = reflectionManager.toMethod(xMethod)-->Line_71 $$ Class[] args = method.getParameterTypes()[ FD ]
Line_15 $$ Method method = reflectionManager.toMethod(xMethod)-->Line_21 $$ Class returnType = method.getReturnType()[ FD ]
Line_8 $$ boolean stopListeners = false-->Line_39 $$ stopListeners = currentClazz.isAnnotationPresent(ExcludeSuperclassListeners.class)[ FD ]
Line_15 $$ Method method = reflectionManager.toMethod(xMethod)-->Line_70 $$ Class returnType = method.getReturnType()[ FD ]
Line_16 $$ final String methodName = method.getName()-->Line_17 $$ if (!callbacksMethodNames.contains(methodName)) [ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_27 $$ log.debugf("Adding %s as %s callback for entity %s", methodName, annotation.getSimpleName(), beanClass.getName())[ FD ]
Line_63 $$ if (xMethod.isAnnotationPresent(annotation)) -->Line_64 $$ final Method method = reflectionManager.toMethod(xMethod)[ CD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_9 $$ boolean stopDefaultListeners = false[ CD ]
Line_13 $$ for (final XMethod xMethod : methods) -->Line_14 $$ if (xMethod.isAnnotationPresent(annotation)) [ FD ]
Line_7 $$ XClass currentClazz = beanClass-->Line_10 $$ do [ FD ]
Line_10 $$ do -->Line_11 $$ Callback callback = null[ CD ]
Line_64 $$ final Method method = reflectionManager.toMethod(xMethod)-->Line_65 $$ final String methodName = method.getName()[ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_48 $$ List<Class> defaultListeners = (List<Class>) reflectionManager.getDefaults().get(EntityListeners.class)[ FD ]
Line_64 $$ final Method method = reflectionManager.toMethod(xMethod)-->Line_71 $$ Class[] args = method.getParameterTypes()[ FD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_78 $$ log.debugf("Adding %s as %s callback for entity %s", methodName, annotation.getSimpleName(), beanClass.getName())[ FD ]
Line_3 $$ List<Callback> callbacks = new ArrayList<Callback>()-->Line_89 $$ return callbacks.toArray(new Callback[callbacks.size()])[ FD ]
Line_56 $$ for (Class listener : orderedListeners) -->Line_82 $$ throw new PersistenceException("You can only annotate one callback method with " + annotation.getName() + " in bean class: " + beanClass.getName() + " and callback listener: " + listener.getName())[ FD ]
Line_16 $$ final String methodName = method.getName()-->Line_27 $$ log.debugf("Adding %s as %s callback for entity %s", methodName, annotation.getSimpleName(), beanClass.getName())[ FD ]
Line_63 $$ if (xMethod.isAnnotationPresent(annotation)) -->Line_65 $$ final String methodName = method.getName()[ CD ]
Line_63 $$ if (xMethod.isAnnotationPresent(annotation)) -->Line_66 $$ if (!callbacksMethodNames.contains(methodName)) [ CD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_3 $$ List<Callback> callbacks = new ArrayList<Callback>()[ CD ]
Line_2 $$ public Callback[] resolveCallbacks(XClass beanClass, Class annotation, ReflectionManager reflectionManager) -->Line_63 $$ if (xMethod.isAnnotationPresent(annotation)) [ FD ]
