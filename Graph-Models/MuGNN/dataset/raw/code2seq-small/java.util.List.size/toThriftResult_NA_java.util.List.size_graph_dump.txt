Line_7 $$ for (int i = 0; i < metadata.columnCount; i++) -->Line_9 $$ ByteBuffer colName = ByteBufferUtil.bytes(spec.name.toString())[ CD ]
Line_9 $$ ByteBuffer colName = ByteBufferUtil.bytes(spec.name.toString())-->Line_12 $$ schema.value_types.put(colName, normalizedType.toString())[ FD ]
Line_16 $$ List<Column> thriftCols = new ArrayList<Column>(metadata.columnCount)-->Line_20 $$ thriftCols.add(col)[ FD ]
Line_17 $$ for (int i = 0; i < metadata.columnCount; i++) -->Line_20 $$ thriftCols.add(col)[ CD ]
Line_7 $$ for (int i = 0; i < metadata.columnCount; i++) -->Line_18 $$ Column col = new Column(ByteBufferUtil.bytes(metadata.names.get(i).name.toString()))[ FD ]
Line_7 $$ for (int i = 0; i < metadata.columnCount; i++) -->Line_8 $$ ColumnSpecification spec = metadata.names.get(i)[ FD ]
Line_7 $$ for (int i = 0; i < metadata.columnCount; i++) -->Line_11 $$ AbstractType<?> normalizedType = spec.type instanceof ReversedType ? ((ReversedType) spec.type).baseType : spec.type[ CD ]
Line_25 $$ CqlResult res = new CqlResult(CqlResultType.ROWS)-->Line_26 $$ res.setRows(cqlRows).setSchema(schema)[ FD ]
Line_2 $$ public CqlResult toThriftResult() -->Line_25 $$ CqlResult res = new CqlResult(CqlResultType.ROWS)[ CD ]
Line_2 $$ public CqlResult toThriftResult() -->Line_7 $$ for (int i = 0; i < metadata.columnCount; i++) [ CD ]
Line_2 $$ public CqlResult toThriftResult() -->Line_26 $$ res.setRows(cqlRows).setSchema(schema)[ CD ]
Line_14 $$ List<CqlRow> cqlRows = new ArrayList<CqlRow>(rows.size())-->Line_26 $$ res.setRows(cqlRows).setSchema(schema)[ FD ]
Line_17 $$ for (int i = 0; i < metadata.columnCount; i++) -->Line_18 $$ Column col = new Column(ByteBufferUtil.bytes(metadata.names.get(i).name.toString()))[ CD ]
Line_17 $$ for (int i = 0; i < metadata.columnCount; i++) -->Line_18 $$ Column col = new Column(ByteBufferUtil.bytes(metadata.names.get(i).name.toString()))[ FD ]
Line_2 $$ public CqlResult toThriftResult() -->Line_5 $$ CqlMetadata schema = new // The 2 following ones shouldn't be needed in CQL3[ CD ]
Line_9 $$ ByteBuffer colName = ByteBufferUtil.bytes(spec.name.toString())-->Line_10 $$ schema.name_types.put(colName, UTF8)[ FD ]
Line_7 $$ for (int i = 0; i < metadata.columnCount; i++) -->Line_8 $$ ColumnSpecification spec = metadata.names.get(i)[ CD ]
Line_2 $$ public CqlResult toThriftResult() -->Line_14 $$ List<CqlRow> cqlRows = new ArrayList<CqlRow>(rows.size())[ CD ]
Line_11 $$ AbstractType<?> normalizedType = spec.type instanceof ReversedType ? ((ReversedType) spec.type).baseType : spec.type-->Line_12 $$ schema.value_types.put(colName, normalizedType.toString())[ FD ]
Line_7 $$ for (int i = 0; i < metadata.columnCount; i++) -->Line_17 $$ for (int i = 0; i < metadata.columnCount; i++) [ FD ]
Line_5 $$ CqlMetadata schema = new // The 2 following ones shouldn't be needed in CQL3-->Line_26 $$ res.setRows(cqlRows).setSchema(schema)[ FD ]
Line_2 $$ public CqlResult toThriftResult() -->Line_4 $$ String UTF8 = "UTF8Type"[ CD ]
Line_17 $$ for (int i = 0; i < metadata.columnCount; i++) -->Line_19 $$ col.setValue(row.get(i))[ FD ]
Line_18 $$ Column col = new Column(ByteBufferUtil.bytes(metadata.names.get(i).name.toString()))-->Line_20 $$ thriftCols.add(col)[ FD ]
Line_7 $$ for (int i = 0; i < metadata.columnCount; i++) -->Line_10 $$ schema.name_types.put(colName, UTF8)[ CD ]
Line_15 $$ for (List<ByteBuffer> row : rows) -->Line_19 $$ col.setValue(row.get(i))[ FD ]
Line_4 $$ String UTF8 = "UTF8Type"-->Line_10 $$ schema.name_types.put(colName, UTF8)[ FD ]
Line_7 $$ for (int i = 0; i < metadata.columnCount; i++) -->Line_19 $$ col.setValue(row.get(i))[ FD ]
Line_18 $$ Column col = new Column(ByteBufferUtil.bytes(metadata.names.get(i).name.toString()))-->Line_19 $$ col.setValue(row.get(i))[ FD ]
Line_17 $$ for (int i = 0; i < metadata.columnCount; i++) -->Line_19 $$ col.setValue(row.get(i))[ CD ]
Line_2 $$ public CqlResult toThriftResult() -->Line_27 $$ return res[ CD ]
Line_7 $$ for (int i = 0; i < metadata.columnCount; i++) -->Line_12 $$ schema.value_types.put(colName, normalizedType.toString())[ CD ]
