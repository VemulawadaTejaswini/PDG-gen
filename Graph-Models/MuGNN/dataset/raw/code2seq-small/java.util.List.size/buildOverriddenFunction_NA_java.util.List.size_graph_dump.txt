Line_46 $$ if (PyNames.FAKE_OLD_BASE.equals(baseClass.getName()) || raisesNotImplementedError(baseFunction) || implement) -->Line_49 $$ if (!PyNames.INIT.equals(baseFunction.getName()) && context.getReturnType(baseFunction) != PyNoneType.INSTANCE || overridingNew) [ CD ]
Line_62 $$ while (outerClass != null) -->Line_63 $$ nameResult.add(0, ((PyClass) outerClass).getName())[ CD ]
Line_56 $$ if (!langLevel.isPy3K()) -->Line_59 $$ PsiElement outerClass = PsiTreeUtil.getParentOfType(pyClass, PyClass.class, true, PyFunction.class)[ CD ]
Line_3 $$ final boolean overridingNew = PyNames.NEW.equals(baseFunction.getName())-->Line_49 $$ if (!PyNames.INIT.equals(baseFunction.getName()) && context.getReturnType(baseFunction) != PyNoneType.INSTANCE || overridingNew) [ FD ]
Line_31 $$ List<String> parameters = new ArrayList<String>()-->Line_77 $$ StringUtil.join(parameters, ", ", statementBody)[ FD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_55 $$ final LanguageLevel langLevel = ((PyFile) pyClass.getContainingFile()).getLanguageLevel()[ FD ]
Line_18 $$ PyAnnotation anno = baseFunction.getAnnotation()-->Line_19 $$ if (anno != null) [ FD ]
Line_29 $$ StringBuilder statementBody = new StringBuilder()-->Line_66 $$ StringUtil.join(nameResult, ".", statementBody)[ FD ]
Line_6 $$ final PyDecoratorList decorators = baseFunction.getDecoratorList()-->Line_8 $$ if (decorators != null) [ FD ]
Line_29 $$ StringBuilder statementBody = new StringBuilder()-->Line_50 $$ statementBody.append("return ")[ FD ]
Line_46 $$ if (PyNames.FAKE_OLD_BASE.equals(baseClass.getName()) || raisesNotImplementedError(baseFunction) || implement) -->Line_77 $$ StringUtil.join(parameters, ", ", statementBody)[ CD ]
Line_62 $$ while (outerClass != null) -->Line_64 $$ outerClass = PsiTreeUtil.getParentOfType(outerClass, PyClass.class, true, PyFunction.class)[ CD ]
Line_46 $$ if (PyNames.FAKE_OLD_BASE.equals(baseClass.getName()) || raisesNotImplementedError(baseFunction) || implement) -->Line_78 $$ statementBody.append(")")[ CD ]
Line_30 $$ boolean hadStar = false-->Line_38 $$ hadStar = true[ FD ]
Line_46 $$ if (PyNames.FAKE_OLD_BASE.equals(baseClass.getName()) || raisesNotImplementedError(baseFunction) || implement) -->Line_52 $$ if (baseClass.isNewStyleClass(context)) [ CD ]
Line_5 $$ PyFunctionBuilder pyFunctionBuilder = new PyFunctionBuilder(baseFunction.getName(), baseFunction)-->Line_25 $$ pyFunctionBuilder.parameter(parameter.getText())[ FD ]
Line_24 $$ for (PyParameter parameter : baseParams) -->Line_25 $$ pyFunctionBuilder.parameter(parameter.getText())[ FD ]
Line_34 $$ if (pyNamedParameter != null) -->Line_36 $$ parameters.add(hadStar && !pyNamedParameter.isKeywordContainer() ? pyNamedParameter.getName() + "=" + repr : repr)[ CD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_18 $$ PyAnnotation anno = baseFunction.getAnnotation()[ CD ]
Line_52 $$ if (baseClass.isNewStyleClass(context)) -->Line_53 $$ statementBody.append(PyNames.SUPER)[ CD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_3 $$ final boolean overridingNew = PyNames.NEW.equals(baseFunction.getName())[ CD ]
Line_27 $$ PyClass baseClass = baseFunction.getContainingClass()-->Line_52 $$ if (baseClass.isNewStyleClass(context)) [ FD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_3 $$ final boolean overridingNew = PyNames.NEW.equals(baseFunction.getName())[ FD ]
Line_24 $$ for (PyParameter parameter : baseParams) -->Line_40 $$ if (parameter instanceof PySingleStarParameter) [ FD ]
Line_56 $$ if (!langLevel.isPy3K()) -->Line_66 $$ StringUtil.join(nameResult, ".", statementBody)[ CD ]
Line_18 $$ PyAnnotation anno = baseFunction.getAnnotation()-->Line_20 $$ pyFunctionBuilder.annotation(anno.getText())[ FD ]
Line_23 $$ final List<PyParameter> baseParams = PyUtil.getParameters(baseFunction, context)-->Line_57 $$ final String baseFirstName = !baseParams.isEmpty() ? baseParams.get(0).getName() : null[ FD ]
Line_56 $$ if (!langLevel.isPy3K()) -->Line_61 $$ final List<String> nameResult = Lists.newArrayList(className)[ CD ]
Line_6 $$ final PyDecoratorList decorators = baseFunction.getDecoratorList()-->Line_11 $$ if (decorators.findDecorator(PyNames.STATICMETHOD) != null) [ FD ]
Line_40 $$ if (parameter instanceof PySingleStarParameter) -->Line_43 $$ parameters.add(parameter.getText())[ CD ]
Line_61 $$ final List<String> nameResult = Lists.newArrayList(className)-->Line_63 $$ nameResult.add(0, ((PyClass) outerClass).getName())[ FD ]
Line_52 $$ if (baseClass.isNewStyleClass(context)) -->Line_69 $$ statementBody.append(").").append(baseFunction.getName()).append("(")[ CD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_6 $$ final PyDecoratorList decorators = baseFunction.getDecoratorList()[ FD ]
Line_40 $$ if (parameter instanceof PySingleStarParameter) -->Line_41 $$ hadStar = true[ CD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_5 $$ PyFunctionBuilder pyFunctionBuilder = new PyFunctionBuilder(baseFunction.getName(), baseFunction)[ FD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_22 $$ final TypeEvalContext context = TypeEvalContext.userInitiated(baseFunction.getProject(), baseFunction.getContainingFile())[ FD ]
Line_5 $$ PyFunctionBuilder pyFunctionBuilder = new PyFunctionBuilder(baseFunction.getName(), baseFunction)-->Line_20 $$ pyFunctionBuilder.annotation(anno.getText())[ FD ]
Line_49 $$ if (!PyNames.INIT.equals(baseFunction.getName()) && context.getReturnType(baseFunction) != PyNoneType.INSTANCE || overridingNew) -->Line_50 $$ statementBody.append("return ")[ CD ]
Line_56 $$ if (!langLevel.isPy3K()) -->Line_58 $$ final String firstName = baseFirstName != null ? baseFirstName : PyNames.CANONICAL_SELF[ CD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_69 $$ statementBody.append(").").append(baseFunction.getName()).append("(")[ FD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_8 $$ if (decorators != null) [ CD ]
Line_11 $$ if (decorators.findDecorator(PyNames.STATICMETHOD) != null) -->Line_13 $$ pyFunctionBuilder.decorate(PyNames.STATICMETHOD)[ CD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_6 $$ final PyDecoratorList decorators = baseFunction.getDecoratorList()[ CD ]
Line_34 $$ if (pyNamedParameter != null) -->Line_35 $$ String repr = pyNamedParameter.getRepr(false)[ CD ]
Line_31 $$ List<String> parameters = new ArrayList<String>()-->Line_72 $$ parameters.remove(0)[ FD ]
Line_22 $$ final TypeEvalContext context = TypeEvalContext.userInitiated(baseFunction.getProject(), baseFunction.getContainingFile())-->Line_49 $$ if (!PyNames.INIT.equals(baseFunction.getName()) && context.getReturnType(baseFunction) != PyNoneType.INSTANCE || overridingNew) [ FD ]
Line_46 $$ if (PyNames.FAKE_OLD_BASE.equals(baseClass.getName()) || raisesNotImplementedError(baseFunction) || implement) -->Line_47 $$ statementBody.append(PyNames.PASS)[ CD ]
Line_33 $$ final PyNamedParameter pyNamedParameter = parameter.getAsNamed()-->Line_37 $$ if (pyNamedParameter.isPositionalContainer()) [ FD ]
Line_6 $$ final PyDecoratorList decorators = baseFunction.getDecoratorList()-->Line_9 $$ if (decorators.findDecorator(PyNames.CLASSMETHOD) != null) [ FD ]
Line_34 $$ if (pyNamedParameter != null) -->Line_37 $$ if (pyNamedParameter.isPositionalContainer()) [ CD ]
Line_5 $$ PyFunctionBuilder pyFunctionBuilder = new PyFunctionBuilder(baseFunction.getName(), baseFunction)-->Line_80 $$ pyFunctionBuilder.statement(statementBody.toString())[ FD ]
Line_56 $$ if (!langLevel.isPy3K()) -->Line_57 $$ final String baseFirstName = !baseParams.isEmpty() ? baseParams.get(0).getName() : null[ CD ]
Line_19 $$ if (anno != null) -->Line_20 $$ pyFunctionBuilder.annotation(anno.getText())[ CD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_75 $$ statementBody.append(getReferenceText(pyClass, baseClass)).append(".").append(baseFunction.getName()).append("(")[ FD ]
Line_29 $$ StringBuilder statementBody = new StringBuilder()-->Line_47 $$ statementBody.append(PyNames.PASS)[ FD ]
Line_29 $$ StringBuilder statementBody = new StringBuilder()-->Line_75 $$ statementBody.append(getReferenceText(pyClass, baseClass)).append(".").append(baseFunction.getName()).append("(")[ FD ]
Line_52 $$ if (baseClass.isNewStyleClass(context)) -->Line_55 $$ final LanguageLevel langLevel = ((PyFile) pyClass.getContainingFile()).getLanguageLevel()[ CD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_46 $$ if (PyNames.FAKE_OLD_BASE.equals(baseClass.getName()) || raisesNotImplementedError(baseFunction) || implement) [ FD ]
Line_11 $$ if (decorators.findDecorator(PyNames.STATICMETHOD) != null) -->Line_14 $$ if (decorators.findDecorator(PyNames.PROPERTY) != null || decorators.findDecorator(PyNames.ABSTRACTPROPERTY) != null) [ CD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_29 $$ StringBuilder statementBody = new StringBuilder()[ CD ]
Line_5 $$ PyFunctionBuilder pyFunctionBuilder = new PyFunctionBuilder(baseFunction.getName(), baseFunction)-->Line_10 $$ pyFunctionBuilder.decorate(PyNames.CLASSMETHOD)[ FD ]
Line_56 $$ if (!langLevel.isPy3K()) -->Line_62 $$ while (outerClass != null) [ CD ]
Line_60 $$ String className = pyClass.getName()-->Line_61 $$ final List<String> nameResult = Lists.newArrayList(className)[ FD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_27 $$ PyClass baseClass = baseFunction.getContainingClass()[ FD ]
Line_24 $$ for (PyParameter parameter : baseParams) -->Line_33 $$ final PyNamedParameter pyNamedParameter = parameter.getAsNamed()[ FD ]
Line_58 $$ final String firstName = baseFirstName != null ? baseFirstName : PyNames.CANONICAL_SELF-->Line_67 $$ statementBody.append(", ").append(firstName)[ FD ]
Line_29 $$ StringBuilder statementBody = new StringBuilder()-->Line_78 $$ statementBody.append(")")[ FD ]
Line_5 $$ PyFunctionBuilder pyFunctionBuilder = new PyFunctionBuilder(baseFunction.getName(), baseFunction)-->Line_15 $$ pyFunctionBuilder.decorate(PyNames.PROPERTY)[ FD ]
Line_7 $$ boolean baseMethodIsStatic = false-->Line_12 $$ baseMethodIsStatic = true[ FD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_49 $$ if (!PyNames.INIT.equals(baseFunction.getName()) && context.getReturnType(baseFunction) != PyNoneType.INSTANCE || overridingNew) [ FD ]
Line_5 $$ PyFunctionBuilder pyFunctionBuilder = new PyFunctionBuilder(baseFunction.getName(), baseFunction)-->Line_13 $$ pyFunctionBuilder.decorate(PyNames.STATICMETHOD)[ FD ]
Line_52 $$ if (baseClass.isNewStyleClass(context)) -->Line_75 $$ statementBody.append(getReferenceText(pyClass, baseClass)).append(".").append(baseFunction.getName()).append("(")[ CD ]
Line_30 $$ boolean hadStar = false-->Line_41 $$ hadStar = true[ FD ]
Line_31 $$ List<String> parameters = new ArrayList<String>()-->Line_43 $$ parameters.add(parameter.getText())[ FD ]
Line_29 $$ StringBuilder statementBody = new StringBuilder()-->Line_67 $$ statementBody.append(", ").append(firstName)[ FD ]
Line_11 $$ if (decorators.findDecorator(PyNames.STATICMETHOD) != null) -->Line_12 $$ baseMethodIsStatic = true[ CD ]
Line_29 $$ StringBuilder statementBody = new StringBuilder()-->Line_77 $$ StringUtil.join(parameters, ", ", statementBody)[ FD ]
Line_56 $$ if (!langLevel.isPy3K()) -->Line_67 $$ statementBody.append(", ").append(firstName)[ CD ]
Line_31 $$ List<String> parameters = new ArrayList<String>()-->Line_36 $$ parameters.add(hadStar && !pyNamedParameter.isKeywordContainer() ? pyNamedParameter.getName() + "=" + repr : repr)[ FD ]
Line_52 $$ if (baseClass.isNewStyleClass(context)) -->Line_56 $$ if (!langLevel.isPy3K()) [ CD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_18 $$ PyAnnotation anno = baseFunction.getAnnotation()[ FD ]
Line_34 $$ if (pyNamedParameter != null) -->Line_40 $$ if (parameter instanceof PySingleStarParameter) [ CD ]
Line_33 $$ final PyNamedParameter pyNamedParameter = parameter.getAsNamed()-->Line_35 $$ String repr = pyNamedParameter.getRepr(false)[ FD ]
Line_55 $$ final LanguageLevel langLevel = ((PyFile) pyClass.getContainingFile()).getLanguageLevel()-->Line_56 $$ if (!langLevel.isPy3K()) [ FD ]
Line_29 $$ StringBuilder statementBody = new StringBuilder()-->Line_53 $$ statementBody.append(PyNames.SUPER)[ FD ]
Line_29 $$ StringBuilder statementBody = new StringBuilder()-->Line_54 $$ statementBody.append("(")[ FD ]
Line_52 $$ if (baseClass.isNewStyleClass(context)) -->Line_54 $$ statementBody.append("(")[ CD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_30 $$ boolean hadStar = false[ CD ]
Line_24 $$ for (PyParameter parameter : baseParams) -->Line_43 $$ parameters.add(parameter.getText())[ FD ]
Line_59 $$ PsiElement outerClass = PsiTreeUtil.getParentOfType(pyClass, PyClass.class, true, PyFunction.class)-->Line_64 $$ outerClass = PsiTreeUtil.getParentOfType(outerClass, PyClass.class, true, PyFunction.class)[ FD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_22 $$ final TypeEvalContext context = TypeEvalContext.userInitiated(baseFunction.getProject(), baseFunction.getContainingFile())[ CD ]
Line_29 $$ StringBuilder statementBody = new StringBuilder()-->Line_80 $$ pyFunctionBuilder.statement(statementBody.toString())[ FD ]
Line_29 $$ StringBuilder statementBody = new StringBuilder()-->Line_69 $$ statementBody.append(").").append(baseFunction.getName()).append("(")[ FD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_4 $$ assert baseFunction.getName() != null[ FD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_81 $$ return pyFunctionBuilder[ CD ]
Line_14 $$ if (decorators.findDecorator(PyNames.PROPERTY) != null || decorators.findDecorator(PyNames.ABSTRACTPROPERTY) != null) -->Line_15 $$ pyFunctionBuilder.decorate(PyNames.PROPERTY)[ CD ]
Line_61 $$ final List<String> nameResult = Lists.newArrayList(className)-->Line_66 $$ StringUtil.join(nameResult, ".", statementBody)[ FD ]
Line_38 $$ hadStar = true-->Line_41 $$ hadStar = true[ FD ]
Line_9 $$ if (decorators.findDecorator(PyNames.CLASSMETHOD) != null) -->Line_10 $$ pyFunctionBuilder.decorate(PyNames.CLASSMETHOD)[ CD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_5 $$ PyFunctionBuilder pyFunctionBuilder = new PyFunctionBuilder(baseFunction.getName(), baseFunction)[ CD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_23 $$ final List<PyParameter> baseParams = PyUtil.getParameters(baseFunction, context)[ CD ]
Line_37 $$ if (pyNamedParameter.isPositionalContainer()) -->Line_38 $$ hadStar = true[ CD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_27 $$ PyClass baseClass = baseFunction.getContainingClass()[ CD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_23 $$ final List<PyParameter> baseParams = PyUtil.getParameters(baseFunction, context)[ FD ]
Line_33 $$ final PyNamedParameter pyNamedParameter = parameter.getAsNamed()-->Line_34 $$ if (pyNamedParameter != null) [ FD ]
Line_27 $$ PyClass baseClass = baseFunction.getContainingClass()-->Line_75 $$ statementBody.append(getReferenceText(pyClass, baseClass)).append(".").append(baseFunction.getName()).append("(")[ FD ]
Line_8 $$ if (decorators != null) -->Line_9 $$ if (decorators.findDecorator(PyNames.CLASSMETHOD) != null) [ CD ]
Line_64 $$ outerClass = PsiTreeUtil.getParentOfType(outerClass, PyClass.class, true, PyFunction.class)-->Line_62 $$ while (outerClass != null) [ FD ]
Line_22 $$ final TypeEvalContext context = TypeEvalContext.userInitiated(baseFunction.getProject(), baseFunction.getContainingFile())-->Line_23 $$ final List<PyParameter> baseParams = PyUtil.getParameters(baseFunction, context)[ FD ]
Line_9 $$ if (decorators.findDecorator(PyNames.CLASSMETHOD) != null) -->Line_11 $$ if (decorators.findDecorator(PyNames.STATICMETHOD) != null) [ CD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_19 $$ if (anno != null) [ CD ]
Line_22 $$ final TypeEvalContext context = TypeEvalContext.userInitiated(baseFunction.getProject(), baseFunction.getContainingFile())-->Line_52 $$ if (baseClass.isNewStyleClass(context)) [ FD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_7 $$ boolean baseMethodIsStatic = false[ CD ]
Line_6 $$ final PyDecoratorList decorators = baseFunction.getDecoratorList()-->Line_14 $$ if (decorators.findDecorator(PyNames.PROPERTY) != null || decorators.findDecorator(PyNames.ABSTRACTPROPERTY) != null) [ FD ]
Line_59 $$ PsiElement outerClass = PsiTreeUtil.getParentOfType(pyClass, PyClass.class, true, PyFunction.class)-->Line_62 $$ while (outerClass != null) [ FD ]
Line_56 $$ if (!langLevel.isPy3K()) -->Line_60 $$ String className = pyClass.getName()[ CD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_31 $$ List<String> parameters = new ArrayList<String>()[ CD ]
Line_27 $$ PyClass baseClass = baseFunction.getContainingClass()-->Line_46 $$ if (PyNames.FAKE_OLD_BASE.equals(baseClass.getName()) || raisesNotImplementedError(baseFunction) || implement) [ FD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_59 $$ PsiElement outerClass = PsiTreeUtil.getParentOfType(pyClass, PyClass.class, true, PyFunction.class)[ FD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_60 $$ String className = pyClass.getName()[ FD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_80 $$ pyFunctionBuilder.statement(statementBody.toString())[ CD ]
Line_2 $$ private static PyFunctionBuilder buildOverriddenFunction(PyClass pyClass, PyFunction baseFunction, boolean implement) -->Line_46 $$ if (PyNames.FAKE_OLD_BASE.equals(baseClass.getName()) || raisesNotImplementedError(baseFunction) || implement) [ CD ]
Line_33 $$ final PyNamedParameter pyNamedParameter = parameter.getAsNamed()-->Line_36 $$ parameters.add(hadStar && !pyNamedParameter.isKeywordContainer() ? pyNamedParameter.getName() + "=" + repr : repr)[ FD ]
