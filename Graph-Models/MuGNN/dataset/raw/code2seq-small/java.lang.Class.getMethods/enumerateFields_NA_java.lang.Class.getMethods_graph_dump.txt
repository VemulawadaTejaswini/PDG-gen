Line_6 $$ for (Method method : clazz.getMethods()) -->Line_14 $$ builder.add(new StateField(name, type, getInitialValue(method)))[ FD ]
Line_23 $$ Ordering<StateField> ordering = new Ordering<StateField>() -->Line_31 $$ return left.getName().compareTo(right.getName())[ CD ]
Line_2 $$ private static List<StateField> enumerateFields(Class<?> clazz) -->Line_34 $$ List<StateField> fields = ordering.sortedCopy(builder.build())[ CD ]
Line_23 $$ Ordering<StateField> ordering = new Ordering<StateField>() -->Line_31 $$ return left.getName().compareTo(right.getName())[ FD ]
Line_16 $$ if (method.getName().startsWith("is")) -->Line_18 $$ checkArgument(type == boolean.class, "Only boolean is support for 'is' methods")[ CD ]
Line_23 $$ Ordering<StateField> ordering = new Ordering<StateField>() -->Line_34 $$ List<StateField> fields = ordering.sortedCopy(builder.build())[ FD ]
Line_10 $$ if (method.getName().startsWith("get")) -->Line_12 $$ checkArgument(supportedClasses.contains(type), type.getName() + " is not supported")[ CD ]
Line_23 $$ Ordering<StateField> ordering = new Ordering<StateField>() -->Line_25 $$ if (primitiveClasses.contains(left.getType()) && !primitiveClasses.contains(right.getType())) [ FD ]
Line_25 $$ if (primitiveClasses.contains(left.getType()) && !primitiveClasses.contains(right.getType())) -->Line_26 $$ return -1[ CD ]
Line_5 $$ Set<Class<?>> supportedClasses = ImmutableSet.<Class<?>>of(byte.class, boolean.class, long.class, double.class, Slice.class, Block.class)-->Line_12 $$ checkArgument(supportedClasses.contains(type), type.getName() + " is not supported")[ FD ]
Line_6 $$ for (Method method : clazz.getMethods()) -->Line_11 $$ Class<?> type = method.getReturnType()[ FD ]
Line_10 $$ if (method.getName().startsWith("get")) -->Line_14 $$ builder.add(new StateField(name, type, getInitialValue(method)))[ CD ]
Line_2 $$ private static List<StateField> enumerateFields(Class<?> clazz) -->Line_3 $$ ImmutableList.Builder<StateField> builder = ImmutableList.builder()[ CD ]
Line_23 $$ Ordering<StateField> ordering = new Ordering<StateField>() -->Line_28 $$ if (primitiveClasses.contains(right.getType()) && !primitiveClasses.contains(left.getType())) [ CD ]
Line_16 $$ if (method.getName().startsWith("is")) -->Line_19 $$ String name = method.getName().substring(2)[ CD ]
Line_6 $$ for (Method method : clazz.getMethods()) -->Line_19 $$ String name = method.getName().substring(2)[ FD ]
Line_16 $$ if (method.getName().startsWith("is")) -->Line_20 $$ builder.add(new StateField(name, type, getInitialValue(method), method.getName()))[ CD ]
Line_6 $$ for (Method method : clazz.getMethods()) -->Line_10 $$ if (method.getName().startsWith("get")) [ FD ]
Line_2 $$ private static List<StateField> enumerateFields(Class<?> clazz) -->Line_23 $$ Ordering<StateField> ordering = new Ordering<StateField>() [ CD ]
Line_3 $$ ImmutableList.Builder<StateField> builder = ImmutableList.builder()-->Line_34 $$ List<StateField> fields = ordering.sortedCopy(builder.build())[ FD ]
Line_23 $$ Ordering<StateField> ordering = new Ordering<StateField>() -->Line_28 $$ if (primitiveClasses.contains(right.getType()) && !primitiveClasses.contains(left.getType())) [ FD ]
Line_3 $$ ImmutableList.Builder<StateField> builder = ImmutableList.builder()-->Line_14 $$ builder.add(new StateField(name, type, getInitialValue(method)))[ FD ]
Line_2 $$ private static List<StateField> enumerateFields(Class<?> clazz) -->Line_36 $$ return fields[ CD ]
Line_6 $$ for (Method method : clazz.getMethods()) -->Line_17 $$ Class<?> type = method.getReturnType()[ FD ]
Line_10 $$ if (method.getName().startsWith("get")) -->Line_13 $$ String name = method.getName().substring(3)[ CD ]
Line_2 $$ private static List<StateField> enumerateFields(Class<?> clazz) -->Line_35 $$ checkInterface(clazz, fields)[ CD ]
Line_2 $$ private static List<StateField> enumerateFields(Class<?> clazz) -->Line_5 $$ Set<Class<?>> supportedClasses = ImmutableSet.<Class<?>>of(byte.class, boolean.class, long.class, double.class, Slice.class, Block.class)[ CD ]
Line_23 $$ Ordering<StateField> ordering = new Ordering<StateField>() -->Line_25 $$ if (primitiveClasses.contains(left.getType()) && !primitiveClasses.contains(right.getType())) [ CD ]
Line_4 $$ final Set<Class<?>> primitiveClasses = ImmutableSet.<Class<?>>of(byte.class, boolean.class, long.class, double.class)-->Line_25 $$ if (primitiveClasses.contains(left.getType()) && !primitiveClasses.contains(right.getType())) [ FD ]
Line_3 $$ ImmutableList.Builder<StateField> builder = ImmutableList.builder()-->Line_20 $$ builder.add(new StateField(name, type, getInitialValue(method), method.getName()))[ FD ]
Line_16 $$ if (method.getName().startsWith("is")) -->Line_17 $$ Class<?> type = method.getReturnType()[ CD ]
Line_11 $$ Class<?> type = method.getReturnType()-->Line_12 $$ checkArgument(supportedClasses.contains(type), type.getName() + " is not supported")[ FD ]
Line_6 $$ for (Method method : clazz.getMethods()) -->Line_13 $$ String name = method.getName().substring(3)[ FD ]
Line_6 $$ for (Method method : clazz.getMethods()) -->Line_7 $$ if (method.getName().equals("getEstimatedSize")) [ FD ]
Line_4 $$ final Set<Class<?>> primitiveClasses = ImmutableSet.<Class<?>>of(byte.class, boolean.class, long.class, double.class)-->Line_28 $$ if (primitiveClasses.contains(right.getType()) && !primitiveClasses.contains(left.getType())) [ FD ]
Line_28 $$ if (primitiveClasses.contains(right.getType()) && !primitiveClasses.contains(left.getType())) -->Line_29 $$ return 1[ CD ]
Line_2 $$ private static List<StateField> enumerateFields(Class<?> clazz) -->Line_35 $$ checkInterface(clazz, fields)[ FD ]
Line_6 $$ for (Method method : clazz.getMethods()) -->Line_16 $$ if (method.getName().startsWith("is")) [ FD ]
Line_2 $$ private static List<StateField> enumerateFields(Class<?> clazz) -->Line_6 $$ for (Method method : clazz.getMethods()) [ FD ]
Line_6 $$ for (Method method : clazz.getMethods()) -->Line_20 $$ builder.add(new StateField(name, type, getInitialValue(method), method.getName()))[ FD ]
Line_2 $$ private static List<StateField> enumerateFields(Class<?> clazz) -->Line_4 $$ final Set<Class<?>> primitiveClasses = ImmutableSet.<Class<?>>of(byte.class, boolean.class, long.class, double.class)[ CD ]
Line_10 $$ if (method.getName().startsWith("get")) -->Line_11 $$ Class<?> type = method.getReturnType()[ CD ]
