Line_16 $$ for (int i = 0; i < RECORDS; ++i) -->Line_18 $$ tval.set(Long.toString(r.nextLong(), 36))[ CD ]
Line_25 $$ InputFormat<BytesWritable, BytesWritable> bformat = new SequenceFileAsBinaryInputFormat()-->Line_34 $$ for (InputSplit split : bformat.getSplits(job)) [ FD ]
Line_35 $$ RecordReader<BytesWritable, BytesWritable> reader = bformat.createRecordReader(split, context)-->Line_40 $$ bkey = reader.getCurrentKey()[ FD ]
Line_39 $$ while (reader.nextKeyValue()) -->Line_44 $$ buf.reset(bkey.getBytes(), bkey.getLength())[ CD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_10 $$ fs.delete(dir, true)[ CD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_6 $$ Path file = new Path(dir, "testbinary.seq")[ CD ]
Line_24 $$ TaskAttemptContext context = MapReduceTestUtil.createDummyMapTaskAttemptContext(job.getConfiguration())-->Line_36 $$ MapContext<BytesWritable, BytesWritable, BytesWritable, BytesWritable> mcontext = new MapContextImpl<BytesWritable, BytesWritable, BytesWritable, BytesWritable>(job.getConfiguration(), context.getTaskAttemptID(), reader, null, null, MapReduceTestUtil.createDummyReporter(), split)[ FD ]
Line_24 $$ TaskAttemptContext context = MapReduceTestUtil.createDummyMapTaskAttemptContext(job.getConfiguration())-->Line_35 $$ RecordReader<BytesWritable, BytesWritable> reader = bformat.createRecordReader(split, context)[ FD ]
Line_12 $$ Text tkey = new Text()-->Line_19 $$ writer.append(tkey, tval)[ FD ]
Line_31 $$ Text cmpval = new Text()-->Line_47 $$ cmpval.readFields(buf)[ FD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_33 $$ FileInputFormat.setInputPaths(job, file)[ CD ]
Line_12 $$ Text tkey = new Text()-->Line_42 $$ tkey.set(Integer.toString(r.nextInt(), 36))[ FD ]
Line_7 $$ Random r = new Random()-->Line_43 $$ tval.set(Long.toString(r.nextLong(), 36))[ FD ]
Line_26 $$ int count = 0-->Line_50 $$ ++count[ FD ]
Line_5 $$ Path dir = new Path(System.getProperty("test.build.data", ".") + "/mapred")-->Line_11 $$ FileInputFormat.setInputPaths(job, dir)[ FD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_13 $$ Text tval = new Text()[ CD ]
Line_8 $$ long seed = r.nextLong()-->Line_9 $$ r.setSeed(seed)[ FD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_4 $$ FileSystem fs = FileSystem.getLocal(job.getConfiguration())[ CD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_56 $$ assertEquals("Some records not found", RECORDS, count)[ CD ]
Line_3 $$ Job job = Job.getInstance()-->Line_11 $$ FileInputFormat.setInputPaths(job, dir)[ FD ]
Line_14 $$ SequenceFile.Writer writer = new SequenceFile.Writer(fs, job.getConfiguration(), file, Text.class, Text.class)-->Line_22 $$ writer.close()[ FD ]
Line_39 $$ while (reader.nextKeyValue()) -->Line_49 $$ assertTrue("Vals don't match: " + "*" + cmpval.toString() + ":" + tval.toString() + "*", cmpval.toString().equals(tval.toString()))[ CD ]
Line_32 $$ DataInputBuffer buf = new DataInputBuffer()-->Line_46 $$ buf.reset(bval.getBytes(), bval.getLength())[ FD ]
Line_3 $$ Job job = Job.getInstance()-->Line_4 $$ FileSystem fs = FileSystem.getLocal(job.getConfiguration())[ FD ]
Line_13 $$ Text tval = new Text()-->Line_49 $$ assertTrue("Vals don't match: " + "*" + cmpval.toString() + ":" + tval.toString() + "*", cmpval.toString().equals(tval.toString()))[ FD ]
Line_25 $$ InputFormat<BytesWritable, BytesWritable> bformat = new SequenceFileAsBinaryInputFormat()-->Line_35 $$ RecordReader<BytesWritable, BytesWritable> reader = bformat.createRecordReader(split, context)[ FD ]
Line_29 $$ BytesWritable bval = new BytesWritable()-->Line_41 $$ bval = reader.getCurrentValue()[ FD ]
Line_16 $$ for (int i = 0; i < RECORDS; ++i) -->Line_17 $$ tkey.set(Integer.toString(r.nextInt(), 36))[ CD ]
Line_4 $$ FileSystem fs = FileSystem.getLocal(job.getConfiguration())-->Line_10 $$ fs.delete(dir, true)[ FD ]
Line_32 $$ DataInputBuffer buf = new DataInputBuffer()-->Line_45 $$ cmpkey.readFields(buf)[ FD ]
Line_30 $$ Text cmpkey = new Text()-->Line_45 $$ cmpkey.readFields(buf)[ FD ]
Line_3 $$ Job job = Job.getInstance()-->Line_34 $$ for (InputSplit split : bformat.getSplits(job)) [ FD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_12 $$ Text tkey = new Text()[ CD ]
Line_35 $$ RecordReader<BytesWritable, BytesWritable> reader = bformat.createRecordReader(split, context)-->Line_53 $$ reader.close()[ FD ]
Line_36 $$ MapContext<BytesWritable, BytesWritable, BytesWritable, BytesWritable> mcontext = new MapContextImpl<BytesWritable, BytesWritable, BytesWritable, BytesWritable>(job.getConfiguration(), context.getTaskAttemptID(), reader, null, null, MapReduceTestUtil.createDummyReporter(), split)-->Line_37 $$ reader.initialize(split, mcontext)[ FD ]
Line_26 $$ int count = 0-->Line_56 $$ assertEquals("Some records not found", RECORDS, count)[ FD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_27 $$ r.setSeed(seed)[ CD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_30 $$ Text cmpkey = new Text()[ CD ]
Line_32 $$ DataInputBuffer buf = new DataInputBuffer()-->Line_44 $$ buf.reset(bkey.getBytes(), bkey.getLength())[ FD ]
Line_35 $$ RecordReader<BytesWritable, BytesWritable> reader = bformat.createRecordReader(split, context)-->Line_41 $$ bval = reader.getCurrentValue()[ FD ]
Line_7 $$ Random r = new Random()-->Line_18 $$ tval.set(Long.toString(r.nextLong(), 36))[ FD ]
Line_39 $$ while (reader.nextKeyValue()) -->Line_41 $$ bval = reader.getCurrentValue()[ CD ]
Line_35 $$ RecordReader<BytesWritable, BytesWritable> reader = bformat.createRecordReader(split, context)-->Line_37 $$ reader.initialize(split, mcontext)[ FD ]
Line_8 $$ long seed = r.nextLong()-->Line_27 $$ r.setSeed(seed)[ FD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_5 $$ Path dir = new Path(System.getProperty("test.build.data", ".") + "/mapred")[ CD ]
Line_35 $$ RecordReader<BytesWritable, BytesWritable> reader = bformat.createRecordReader(split, context)-->Line_39 $$ while (reader.nextKeyValue()) [ FD ]
Line_39 $$ while (reader.nextKeyValue()) -->Line_43 $$ tval.set(Long.toString(r.nextLong(), 36))[ CD ]
Line_12 $$ Text tkey = new Text()-->Line_17 $$ tkey.set(Integer.toString(r.nextInt(), 36))[ FD ]
Line_39 $$ while (reader.nextKeyValue()) -->Line_45 $$ cmpkey.readFields(buf)[ CD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_31 $$ Text cmpval = new Text()[ CD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_11 $$ FileInputFormat.setInputPaths(job, dir)[ CD ]
Line_40 $$ bkey = reader.getCurrentKey()-->Line_44 $$ buf.reset(bkey.getBytes(), bkey.getLength())[ FD ]
Line_7 $$ Random r = new Random()-->Line_8 $$ long seed = r.nextLong()[ FD ]
Line_28 $$ BytesWritable bkey = new BytesWritable()-->Line_44 $$ buf.reset(bkey.getBytes(), bkey.getLength())[ FD ]
Line_34 $$ for (InputSplit split : bformat.getSplits(job)) -->Line_37 $$ reader.initialize(split, mcontext)[ FD ]
Line_39 $$ while (reader.nextKeyValue()) -->Line_50 $$ ++count[ CD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_7 $$ Random r = new Random()[ CD ]
Line_13 $$ Text tval = new Text()-->Line_19 $$ writer.append(tkey, tval)[ FD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_3 $$ Job job = Job.getInstance()[ CD ]
Line_6 $$ Path file = new Path(dir, "testbinary.seq")-->Line_33 $$ FileInputFormat.setInputPaths(job, file)[ FD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_9 $$ r.setSeed(seed)[ CD ]
Line_30 $$ Text cmpkey = new Text()-->Line_48 $$ assertTrue("Keys don't match: " + "*" + cmpkey.toString() + ":" + tkey.toString() + "*", cmpkey.toString().equals(tkey.toString()))[ FD ]
Line_7 $$ Random r = new Random()-->Line_9 $$ r.setSeed(seed)[ FD ]
Line_31 $$ Text cmpval = new Text()-->Line_49 $$ assertTrue("Vals don't match: " + "*" + cmpval.toString() + ":" + tval.toString() + "*", cmpval.toString().equals(tval.toString()))[ FD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_25 $$ InputFormat<BytesWritable, BytesWritable> bformat = new SequenceFileAsBinaryInputFormat()[ CD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_8 $$ long seed = r.nextLong()[ CD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_29 $$ BytesWritable bval = new BytesWritable()[ CD ]
Line_41 $$ bval = reader.getCurrentValue()-->Line_46 $$ buf.reset(bval.getBytes(), bval.getLength())[ FD ]
Line_5 $$ Path dir = new Path(System.getProperty("test.build.data", ".") + "/mapred")-->Line_10 $$ fs.delete(dir, true)[ FD ]
Line_29 $$ BytesWritable bval = new BytesWritable()-->Line_46 $$ buf.reset(bval.getBytes(), bval.getLength())[ FD ]
Line_3 $$ Job job = Job.getInstance()-->Line_14 $$ SequenceFile.Writer writer = new SequenceFile.Writer(fs, job.getConfiguration(), file, Text.class, Text.class)[ FD ]
Line_7 $$ Random r = new Random()-->Line_42 $$ tkey.set(Integer.toString(r.nextInt(), 36))[ FD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_32 $$ DataInputBuffer buf = new DataInputBuffer()[ CD ]
Line_32 $$ DataInputBuffer buf = new DataInputBuffer()-->Line_47 $$ cmpval.readFields(buf)[ FD ]
Line_3 $$ Job job = Job.getInstance()-->Line_33 $$ FileInputFormat.setInputPaths(job, file)[ FD ]
Line_39 $$ while (reader.nextKeyValue()) -->Line_47 $$ cmpval.readFields(buf)[ CD ]
Line_7 $$ Random r = new Random()-->Line_27 $$ r.setSeed(seed)[ FD ]
Line_7 $$ Random r = new Random()-->Line_17 $$ tkey.set(Integer.toString(r.nextInt(), 36))[ FD ]
Line_39 $$ while (reader.nextKeyValue()) -->Line_40 $$ bkey = reader.getCurrentKey()[ CD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_28 $$ BytesWritable bkey = new BytesWritable()[ CD ]
Line_3 $$ Job job = Job.getInstance()-->Line_36 $$ MapContext<BytesWritable, BytesWritable, BytesWritable, BytesWritable> mcontext = new MapContextImpl<BytesWritable, BytesWritable, BytesWritable, BytesWritable>(job.getConfiguration(), context.getTaskAttemptID(), reader, null, null, MapReduceTestUtil.createDummyReporter(), split)[ FD ]
Line_14 $$ SequenceFile.Writer writer = new SequenceFile.Writer(fs, job.getConfiguration(), file, Text.class, Text.class)-->Line_19 $$ writer.append(tkey, tval)[ FD ]
Line_13 $$ Text tval = new Text()-->Line_43 $$ tval.set(Long.toString(r.nextLong(), 36))[ FD ]
Line_28 $$ BytesWritable bkey = new BytesWritable()-->Line_40 $$ bkey = reader.getCurrentKey()[ FD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_24 $$ TaskAttemptContext context = MapReduceTestUtil.createDummyMapTaskAttemptContext(job.getConfiguration())[ CD ]
Line_39 $$ while (reader.nextKeyValue()) -->Line_48 $$ assertTrue("Keys don't match: " + "*" + cmpkey.toString() + ":" + tkey.toString() + "*", cmpkey.toString().equals(tkey.toString()))[ CD ]
Line_16 $$ for (int i = 0; i < RECORDS; ++i) -->Line_19 $$ writer.append(tkey, tval)[ CD ]
Line_39 $$ while (reader.nextKeyValue()) -->Line_42 $$ tkey.set(Integer.toString(r.nextInt(), 36))[ CD ]
Line_12 $$ Text tkey = new Text()-->Line_48 $$ assertTrue("Keys don't match: " + "*" + cmpkey.toString() + ":" + tkey.toString() + "*", cmpkey.toString().equals(tkey.toString()))[ FD ]
Line_39 $$ while (reader.nextKeyValue()) -->Line_46 $$ buf.reset(bval.getBytes(), bval.getLength())[ CD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_26 $$ int count = 0[ CD ]
Line_13 $$ Text tval = new Text()-->Line_18 $$ tval.set(Long.toString(r.nextLong(), 36))[ FD ]
Line_2 $$ public void testBinary() throws IOException, InterruptedException -->Line_14 $$ SequenceFile.Writer writer = new SequenceFile.Writer(fs, job.getConfiguration(), file, Text.class, Text.class)[ CD ]
Line_3 $$ Job job = Job.getInstance()-->Line_24 $$ TaskAttemptContext context = MapReduceTestUtil.createDummyMapTaskAttemptContext(job.getConfiguration())[ FD ]
Line_34 $$ for (InputSplit split : bformat.getSplits(job)) -->Line_35 $$ RecordReader<BytesWritable, BytesWritable> reader = bformat.createRecordReader(split, context)[ FD ]
