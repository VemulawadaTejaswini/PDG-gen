Line_6 $$ MethodHandle compareMethodHandle = functionRegistry.getScalarFunctionImplementation(internalOperator(operatorType, BOOLEAN, ImmutableList.of(elementType, elementType))).getMethodHandle()-->Line_12 $$ methodHandle = methodHandle.bindTo(compareMethodHandle).bindTo(elementType)[ FD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_6 $$ MethodHandle compareMethodHandle = functionRegistry.getScalarFunctionImplementation(internalOperator(operatorType, BOOLEAN, ImmutableList.of(elementType, elementType))).getMethodHandle()[ FD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_13 $$ return new ScalarFunctionImplementation(true, ImmutableList.of(false), methodHandle, isDeterministic())[ CD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_7 $$ MethodHandle methodHandle = METHOD_HANDLES.get(elementType.getJavaType())[ CD ]
Line_4 $$ Type elementType = types.get("E")-->Line_6 $$ MethodHandle compareMethodHandle = functionRegistry.getScalarFunctionImplementation(internalOperator(operatorType, BOOLEAN, ImmutableList.of(elementType, elementType))).getMethodHandle()[ FD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_3 $$ checkArgument(types.size() == 1, "Expected one type, got %s", types)[ FD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_4 $$ Type elementType = types.get("E")[ FD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_4 $$ Type elementType = types.get("E")[ CD ]
Line_4 $$ Type elementType = types.get("E")-->Line_7 $$ MethodHandle methodHandle = METHOD_HANDLES.get(elementType.getJavaType())[ FD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_6 $$ MethodHandle compareMethodHandle = functionRegistry.getScalarFunctionImplementation(internalOperator(operatorType, BOOLEAN, ImmutableList.of(elementType, elementType))).getMethodHandle()[ CD ]
Line_8 $$ if (methodHandle == null) -->Line_10 $$ compareMethodHandle = compareMethodHandle.asType(compareMethodHandle.type().changeParameterType(0, Object.class).changeParameterType(1, Object.class))[ CD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_3 $$ checkArgument(types.size() == 1, "Expected one type, got %s", types)[ CD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_12 $$ methodHandle = methodHandle.bindTo(compareMethodHandle).bindTo(elementType)[ CD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_8 $$ if (methodHandle == null) [ CD ]
Line_4 $$ Type elementType = types.get("E")-->Line_12 $$ methodHandle = methodHandle.bindTo(compareMethodHandle).bindTo(elementType)[ FD ]
Line_6 $$ MethodHandle compareMethodHandle = functionRegistry.getScalarFunctionImplementation(internalOperator(operatorType, BOOLEAN, ImmutableList.of(elementType, elementType))).getMethodHandle()-->Line_10 $$ compareMethodHandle = compareMethodHandle.asType(compareMethodHandle.type().changeParameterType(0, Object.class).changeParameterType(1, Object.class))[ FD ]
Line_7 $$ MethodHandle methodHandle = METHOD_HANDLES.get(elementType.getJavaType())-->Line_9 $$ methodHandle = METHOD_HANDLE_OBJECT[ FD ]
Line_2 $$ public ScalarFunctionImplementation specialize(Map<String, Type> types, int arity, TypeManager typeManager, FunctionRegistry functionRegistry) -->Line_5 $$ checkArgument(elementType.isOrderable(), "Type must be orderable")[ CD ]
Line_9 $$ methodHandle = METHOD_HANDLE_OBJECT-->Line_12 $$ methodHandle = methodHandle.bindTo(compareMethodHandle).bindTo(elementType)[ FD ]
Line_10 $$ compareMethodHandle = compareMethodHandle.asType(compareMethodHandle.type().changeParameterType(0, Object.class).changeParameterType(1, Object.class))-->Line_12 $$ methodHandle = methodHandle.bindTo(compareMethodHandle).bindTo(elementType)[ FD ]
Line_7 $$ MethodHandle methodHandle = METHOD_HANDLES.get(elementType.getJavaType())-->Line_8 $$ if (methodHandle == null) [ FD ]
Line_7 $$ MethodHandle methodHandle = METHOD_HANDLES.get(elementType.getJavaType())-->Line_12 $$ methodHandle = methodHandle.bindTo(compareMethodHandle).bindTo(elementType)[ FD ]
Line_4 $$ Type elementType = types.get("E")-->Line_5 $$ checkArgument(elementType.isOrderable(), "Type must be orderable")[ FD ]
Line_8 $$ if (methodHandle == null) -->Line_9 $$ methodHandle = METHOD_HANDLE_OBJECT[ CD ]
