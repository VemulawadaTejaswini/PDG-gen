Line_8 $$ Future<Throwable> future = exec.submit(new Callable<Throwable>() -->Line_12 $$ futureThread.set(Thread.currentThread())[ CD ]
Line_4 $$ final UnreliableInterface unreliable = (UnreliableInterface) RetryProxy.create(UnreliableInterface.class, unreliableImpl, retryUpToMaximumTimeWithFixedSleep(10, 10, TimeUnit.SECONDS))-->Line_15 $$ unreliable.alwaysFailsWithFatalException()[ FD ]
Line_6 $$ final AtomicReference<Thread> futureThread = new AtomicReference<Thread>()-->Line_26 $$ futureThread.get().interrupt()[ FD ]
Line_5 $$ final CountDownLatch latch = new CountDownLatch(1)-->Line_22 $$ latch.await()[ FD ]
Line_5 $$ final CountDownLatch latch = new CountDownLatch(1)-->Line_13 $$ latch.countDown()[ FD ]
Line_8 $$ Future<Throwable> future = exec.submit(new Callable<Throwable>() -->Line_13 $$ latch.countDown()[ CD ]
Line_8 $$ Future<Throwable> future = exec.submit(new Callable<Throwable>() -->Line_19 $$ return null[ CD ]
Line_6 $$ final AtomicReference<Thread> futureThread = new AtomicReference<Thread>()-->Line_25 $$ assertTrue(futureThread.get().isAlive())[ FD ]
Line_6 $$ final AtomicReference<Thread> futureThread = new AtomicReference<Thread>()-->Line_12 $$ futureThread.set(Thread.currentThread())[ FD ]
Line_7 $$ ExecutorService exec = Executors.newSingleThreadExecutor()-->Line_8 $$ Future<Throwable> future = exec.submit(new Callable<Throwable>() [ FD ]
