Line_2 $$ public static <T, O extends Watchable> T create(@NotNull final O target, final ProcessHandler process) -->Line_29 $$ process.addProcessListener(new ProcessAdapter() [ CD ]
Line_7 $$ while (!Thread.currentThread().isInterrupted()) -->Line_8 $$ final Call call = queue.first.take()[ CD ]
Line_2 $$ public static <T, O extends Watchable> T create(@NotNull final O target, final ProcessHandler process) -->Line_70 $$ final ClassLoader classLoader = target.getClass().getClassLoader()[ FD ]
Line_2 $$ public static <T, O extends Watchable> T create(@NotNull final O target, final ProcessHandler process) -->Line_3 $$ final Pair<LinkedBlockingQueue<Call>, LinkedBlockingQueue<Call.Result>> queue = Pair.create(new LinkedBlockingQueue<Call>(10), new LinkedBlockingQueue<Call.Result>())[ CD ]
Line_9 $$ if (call != null) -->Line_10 $$ queue.second.offer(call.invoke())[ CD ]
Line_4 $$ final Thread thread = new Thread("Async Invocation Thread for " + process) -->Line_17 $$ thread.start()[ FD ]
Line_2 $$ public static <T, O extends Watchable> T create(@NotNull final O target, final ProcessHandler process) -->Line_68 $$ alarm.addRequest(ping, 500)[ CD ]
Line_2 $$ public static <T, O extends Watchable> T create(@NotNull final O target, final ProcessHandler process) -->Line_29 $$ process.addProcessListener(new ProcessAdapter() [ FD ]
Line_2 $$ public static <T, O extends Watchable> T create(@NotNull final O target, final ProcessHandler process) -->Line_70 $$ final ClassLoader classLoader = target.getClass().getClassLoader()[ CD ]
Line_2 $$ public static <T, O extends Watchable> T create(@NotNull final O target, final ProcessHandler process) -->Line_17 $$ thread.start()[ CD ]
Line_2 $$ public static <T, O extends Watchable> T create(@NotNull final O target, final ProcessHandler process) -->Line_71 $$ final Class<?>[] interfaces = target.getClass().getInterfaces()[ FD ]
Line_8 $$ final Call call = queue.first.take()-->Line_10 $$ queue.second.offer(call.invoke())[ FD ]
Line_19 $$ final Disposable d = new Disposable() -->Line_22 $$ if (!disposed) [ CD ]
Line_7 $$ while (!Thread.currentThread().isInterrupted()) -->Line_9 $$ if (call != null) [ CD ]
Line_45 $$ final Runnable watchdog = new Runnable() -->Line_47 $$ ref.set(true)[ CD ]
Line_22 $$ if (!disposed) -->Line_23 $$ disposed = true[ CD ]
Line_8 $$ final Call call = queue.first.take()-->Line_9 $$ if (call != null) [ FD ]
Line_2 $$ public static <T, O extends Watchable> T create(@NotNull final O target, final ProcessHandler process) -->Line_71 $$ final Class<?>[] interfaces = target.getClass().getInterfaces()[ CD ]
Line_53 $$ if (alarm.isDisposed()) -->Line_54 $$ return[ CD ]
Line_2 $$ public static <T, O extends Watchable> T create(@NotNull final O target, final ProcessHandler process) -->Line_72 $$ return (T) Proxy.newProxyInstance(classLoader, interfaces, guard)[ CD ]
Line_2 $$ public static <T, O extends Watchable> T create(@NotNull final O target, final ProcessHandler process) -->Line_4 $$ final Thread thread = new Thread("Async Invocation Thread for " + process) [ CD ]
Line_29 $$ process.addProcessListener(new ProcessAdapter() -->Line_36 $$ if (!willBeDestroyed) [ FD ]
Line_22 $$ if (!disposed) -->Line_24 $$ ref.set(true)[ CD ]
Line_2 $$ public static <T, O extends Watchable> T create(@NotNull final O target, final ProcessHandler process) -->Line_58 $$ ref.set(!target.ping())[ FD ]
Line_29 $$ process.addProcessListener(new ProcessAdapter() -->Line_36 $$ if (!willBeDestroyed) [ CD ]
Line_4 $$ final Thread thread = new Thread("Async Invocation Thread for " + process) -->Line_25 $$ thread.interrupt()[ FD ]
Line_22 $$ if (!disposed) -->Line_25 $$ thread.interrupt()[ CD ]
