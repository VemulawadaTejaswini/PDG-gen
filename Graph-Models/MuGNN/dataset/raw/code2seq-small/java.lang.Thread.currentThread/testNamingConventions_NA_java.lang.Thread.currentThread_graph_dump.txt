Line_37 $$ if (isTestCase(clazz) == false) -->Line_38 $$ notImplementing.add(clazz)[ CD ]
Line_6 $$ final Set<Class> missingSuffix = new HashSet()-->Line_87 $$ assertTrue(missingSuffix.remove(WrongNameTheSecond.class))[ FD ]
Line_8 $$ final Set<Class> notRunnable = new HashSet()-->Line_36 $$ notRunnable.add(clazz)[ FD ]
Line_4 $$ final Set<Class> notImplementing = new HashSet()-->Line_44 $$ notImplementing.add(clazz)[ FD ]
Line_27 $$ String filename = file.getFileName().toString()-->Line_28 $$ if (filename.endsWith(".class")) [ FD ]
Line_29 $$ Class<?> clazz = loadClass(filename)-->Line_48 $$ if (isTestCase(clazz)) [ FD ]
Line_29 $$ Class<?> clazz = loadClass(filename)-->Line_30 $$ if (clazz.getName().endsWith("Tests")) [ FD ]
Line_9 $$ final Set<Class> innerClasses = new HashSet()-->Line_40 $$ innerClasses.add(clazz)[ FD ]
Line_47 $$ if (Modifier.isAbstract(clazz.getModifiers()) == false && Modifier.isInterface(clazz.getModifiers()) == false) -->Line_48 $$ if (isTestCase(clazz)) [ CD ]
Line_14 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_20 $$ pkgPrefix = pkgPrefix.resolve(dir.getFileName())[ FD ]
Line_67 $$ for (Path p : pkgPrefix) -->Line_68 $$ pkg.append(p.getFileName().toString()).append(".")[ FD ]
Line_14 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_70 $$ pkg.append(filename.substring(0, filename.length() - 6))[ CD ]
Line_14 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_66 $$ StringBuilder pkg = new StringBuilder()[ CD ]
Line_39 $$ if (Modifier.isStatic(clazz.getModifiers())) -->Line_40 $$ innerClasses.add(clazz)[ CD ]
Line_37 $$ if (isTestCase(clazz) == false) -->Line_39 $$ if (Modifier.isStatic(clazz.getModifiers())) [ CD ]
Line_5 $$ final Set<Class> pureUnitTest = new HashSet()-->Line_92 $$ assertTrue(pureUnitTest.remove(PlainUnit.class))[ FD ]
Line_6 $$ final Set<Class> missingSuffix = new HashSet()-->Line_94 $$ assertNoViolations("Not all subclasses of " + ESTestCase.class.getSimpleName() + " match the naming convention. Concrete classes must end with [Tests]:\n", missingSuffix)[ FD ]
Line_14 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_21 $$ return FileVisitResult.CONTINUE[ CD ]
Line_43 $$ if (isTestCase(clazz) == false) -->Line_44 $$ notImplementing.add(clazz)[ CD ]
Line_29 $$ Class<?> clazz = loadClass(filename)-->Line_35 $$ if (Modifier.isAbstract(clazz.getModifiers()) || Modifier.isInterface(clazz.getModifiers())) [ FD ]
Line_66 $$ StringBuilder pkg = new StringBuilder()-->Line_68 $$ pkg.append(p.getFileName().toString()).append(".")[ FD ]
Line_42 $$ if (clazz.getName().endsWith("IT")) -->Line_43 $$ if (isTestCase(clazz) == false) [ CD ]
Line_4 $$ final Set<Class> notImplementing = new HashSet()-->Line_91 $$ assertTrue(notImplementing.remove(NotImplementingTests.class))[ FD ]
Line_28 $$ if (filename.endsWith(".class")) -->Line_30 $$ if (clazz.getName().endsWith("Tests")) [ CD ]
Line_8 $$ final Set<Class> notRunnable = new HashSet()-->Line_89 $$ assertTrue(notRunnable.remove(DummyInterfaceTests.class))[ FD ]
Line_6 $$ final Set<Class> missingSuffix = new HashSet()-->Line_86 $$ assertTrue(missingSuffix.remove(WrongName.class))[ FD ]
Line_66 $$ StringBuilder pkg = new StringBuilder()-->Line_71 $$ return Thread.currentThread().getContextClassLoader().loadClass(pkg.toString())[ FD ]
Line_29 $$ Class<?> clazz = loadClass(filename)-->Line_36 $$ notRunnable.add(clazz)[ FD ]
Line_6 $$ final Set<Class> missingSuffix = new HashSet()-->Line_49 $$ missingSuffix.add(clazz)[ FD ]
Line_28 $$ if (filename.endsWith(".class")) -->Line_29 $$ Class<?> clazz = loadClass(filename)[ CD ]
Line_35 $$ if (Modifier.isAbstract(clazz.getModifiers()) || Modifier.isInterface(clazz.getModifiers())) -->Line_36 $$ notRunnable.add(clazz)[ CD ]
Line_12 $$ final String path = "/" + packageName.replace('.', '/')-->Line_13 $$ final Path startPath = getDataPath(path)[ FD ]
Line_29 $$ Class<?> clazz = loadClass(filename)-->Line_50 $$ if (junit.framework.Test.class.isAssignableFrom(clazz)) [ FD ]
Line_11 $$ for (final String packageName : packages) -->Line_12 $$ final String path = "/" + packageName.replace('.', '/')[ FD ]
Line_5 $$ final Set<Class> pureUnitTest = new HashSet()-->Line_97 $$ assertNoViolations("Pure Unit-Test found must subclass one of [" + classesToSubclass + "]:\n", pureUnitTest)[ FD ]
Line_29 $$ Class<?> clazz = loadClass(filename)-->Line_44 $$ notImplementing.add(clazz)[ FD ]
Line_14 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_70 $$ pkg.append(filename.substring(0, filename.length() - 6))[ FD ]
Line_4 $$ final Set<Class> notImplementing = new HashSet()-->Line_38 $$ notImplementing.add(clazz)[ FD ]
Line_29 $$ Class<?> clazz = loadClass(filename)-->Line_43 $$ if (isTestCase(clazz) == false) [ FD ]
Line_14 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_20 $$ pkgPrefix = pkgPrefix.resolve(dir.getFileName())[ CD ]
Line_48 $$ if (isTestCase(clazz)) -->Line_49 $$ missingSuffix.add(clazz)[ CD ]
Line_35 $$ if (Modifier.isAbstract(clazz.getModifiers()) || Modifier.isInterface(clazz.getModifiers())) -->Line_37 $$ if (isTestCase(clazz) == false) [ CD ]
Line_29 $$ Class<?> clazz = loadClass(filename)-->Line_47 $$ if (Modifier.isAbstract(clazz.getModifiers()) == false && Modifier.isInterface(clazz.getModifiers()) == false) [ FD ]
Line_66 $$ StringBuilder pkg = new StringBuilder()-->Line_70 $$ pkg.append(filename.substring(0, filename.length() - 6))[ FD ]
Line_14 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_62 $$ return LuceneTestCase.class.isAssignableFrom(clazz)[ CD ]
Line_9 $$ final Set<Class> innerClasses = new HashSet()-->Line_90 $$ assertTrue(innerClasses.remove(InnerTests.class))[ FD ]
Line_29 $$ Class<?> clazz = loadClass(filename)-->Line_38 $$ notImplementing.add(clazz)[ FD ]
Line_13 $$ final Path startPath = getDataPath(path)-->Line_14 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() [ FD ]
Line_14 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_62 $$ return LuceneTestCase.class.isAssignableFrom(clazz)[ FD ]
Line_14 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_81 $$ pkgPrefix = pkgPrefix.getParent()[ CD ]
Line_4 $$ final Set<Class> notImplementing = new HashSet()-->Line_98 $$ assertNoViolations("Classes ending with [Tests] must subclass [" + classesToSubclass + "]:\n", notImplementing)[ FD ]
Line_29 $$ Class<?> clazz = loadClass(filename)-->Line_37 $$ if (isTestCase(clazz) == false) [ FD ]
Line_7 $$ final Set<Class> integTestsInDisguise = new HashSet()-->Line_33 $$ integTestsInDisguise.add(clazz)[ FD ]
Line_29 $$ Class<?> clazz = loadClass(filename)-->Line_39 $$ if (Modifier.isStatic(clazz.getModifiers())) [ FD ]
Line_42 $$ if (clazz.getName().endsWith("IT")) -->Line_47 $$ if (Modifier.isAbstract(clazz.getModifiers()) == false && Modifier.isInterface(clazz.getModifiers()) == false) [ CD ]
Line_14 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_71 $$ return Thread.currentThread().getContextClassLoader().loadClass(pkg.toString())[ CD ]
Line_27 $$ String filename = file.getFileName().toString()-->Line_29 $$ Class<?> clazz = loadClass(filename)[ FD ]
Line_48 $$ if (isTestCase(clazz)) -->Line_50 $$ if (junit.framework.Test.class.isAssignableFrom(clazz)) [ CD ]
Line_29 $$ Class<?> clazz = loadClass(filename)-->Line_62 $$ return LuceneTestCase.class.isAssignableFrom(clazz)[ FD ]
Line_14 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_82 $$ return FileVisitResult.CONTINUE[ CD ]
Line_12 $$ final String path = "/" + packageName.replace('.', '/')-->Line_14 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() [ FD ]
Line_29 $$ Class<?> clazz = loadClass(filename)-->Line_42 $$ if (clazz.getName().endsWith("IT")) [ FD ]
Line_27 $$ String filename = file.getFileName().toString()-->Line_70 $$ pkg.append(filename.substring(0, filename.length() - 6))[ FD ]
Line_29 $$ Class<?> clazz = loadClass(filename)-->Line_33 $$ integTestsInDisguise.add(clazz)[ FD ]
Line_8 $$ final Set<Class> notRunnable = new HashSet()-->Line_95 $$ assertNoViolations("Classes ending with [Tests] are abstract or interfaces:\n", notRunnable)[ FD ]
Line_7 $$ final Set<Class> integTestsInDisguise = new HashSet()-->Line_99 $$ assertNoViolations("Subclasses of ESIntegTestCase should end with IT as they are integration tests:\n", integTestsInDisguise)[ FD ]
Line_8 $$ final Set<Class> notRunnable = new HashSet()-->Line_88 $$ assertTrue(notRunnable.remove(DummyAbstractTests.class))[ FD ]
Line_9 $$ final Set<Class> innerClasses = new HashSet()-->Line_96 $$ assertNoViolations("Found inner classes that are tests, which are excluded from the test runner:\n", innerClasses)[ FD ]
Line_29 $$ Class<?> clazz = loadClass(filename)-->Line_51 $$ pureUnitTest.add(clazz)[ FD ]
Line_50 $$ if (junit.framework.Test.class.isAssignableFrom(clazz)) -->Line_51 $$ pureUnitTest.add(clazz)[ CD ]
Line_5 $$ final Set<Class> pureUnitTest = new HashSet()-->Line_51 $$ pureUnitTest.add(clazz)[ FD ]
Line_29 $$ Class<?> clazz = loadClass(filename)-->Line_40 $$ innerClasses.add(clazz)[ FD ]
Line_30 $$ if (clazz.getName().endsWith("Tests")) -->Line_35 $$ if (Modifier.isAbstract(clazz.getModifiers()) || Modifier.isInterface(clazz.getModifiers())) [ CD ]
Line_30 $$ if (clazz.getName().endsWith("Tests")) -->Line_42 $$ if (clazz.getName().endsWith("IT")) [ CD ]
Line_29 $$ Class<?> clazz = loadClass(filename)-->Line_49 $$ missingSuffix.add(clazz)[ FD ]
Line_14 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_58 $$ return FileVisitResult.CONTINUE[ CD ]
Line_14 $$ Files.walkFileTree(startPath, new FileVisitor<Path>() -->Line_27 $$ String filename = file.getFileName().toString()[ FD ]
