Line_40 $$ if (type.equals(BOOLEAN)) -->Line_41 $$ return new BooleanLiteral(object.toString())[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_46 $$ object = output.slice()[ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_31 $$ if (type.equals(VARCHAR)) [ CD ]
Line_18 $$ Double value = (Double) object-->Line_23 $$ if (value.equals(Double.NEGATIVE_INFINITY)) [ FD ]
Line_23 $$ if (value.equals(Double.NEGATIVE_INFINITY)) -->Line_25 $$ if (value.equals(Double.POSITIVE_INFINITY)) [ CD ]
Line_54 $$ Signature signature = FunctionRegistry.getMagicLiteralFunctionSignature(type)-->Line_59 $$ return new FunctionCall(new QualifiedName(signature.getName()), ImmutableList.of(rawLiteral))[ FD ]
Line_31 $$ if (type.equals(VARCHAR)) -->Line_35 $$ if (object instanceof String) [ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_13 $$ checkArgument(Primitives.wrap(type.getJavaType()).isInstance(object), "object.getClass (%s) and type.getJavaType (%s) do not agree", object.getClass(), type.getJavaType())[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_14 $$ if (type.equals(BIGINT)) [ FD ]
Line_23 $$ if (value.equals(Double.NEGATIVE_INFINITY)) -->Line_24 $$ return ArithmeticUnaryExpression.negative(new FunctionCall(new QualifiedName("infinity"), ImmutableList.<Expression>of()))[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_49 $$ if (object instanceof Slice && !type.equals(VARCHAR)) [ FD ]
Line_7 $$ if (object == null) -->Line_11 $$ return new Cast(new NullLiteral(), type.getTypeSignature().toString())[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_8 $$ if (type.equals(UNKNOWN)) [ FD ]
Line_17 $$ if (type.equals(DOUBLE)) -->Line_18 $$ Double value = (Double) object[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_57 $$ Signature signature = FunctionRegistry.getMagicLiteralFunctionSignature(type)[ CD ]
Line_4 $$ if (object instanceof Expression) -->Line_5 $$ return (Expression) object[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_4 $$ if (object instanceof Expression) [ FD ]
Line_25 $$ if (value.equals(Double.POSITIVE_INFINITY)) -->Line_26 $$ return new FunctionCall(new QualifiedName("infinity"), ImmutableList.<Expression>of())[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_28 $$ return new DoubleLiteral(object.toString())[ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_3 $$ requireNonNull(type, "type is null")[ FD ]
Line_43 $$ if (object instanceof Block) -->Line_46 $$ object = output.slice()[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_11 $$ return new Cast(new NullLiteral(), type.getTypeSignature().toString())[ FD ]
Line_44 $$ SliceOutput output = new DynamicSliceOutput(((Block) object).getSizeInBytes())-->Line_46 $$ object = output.slice()[ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_40 $$ if (type.equals(BOOLEAN)) [ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_59 $$ return new FunctionCall(new QualifiedName(signature.getName()), ImmutableList.of(rawLiteral))[ CD ]
Line_7 $$ if (object == null) -->Line_8 $$ if (type.equals(UNKNOWN)) [ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_58 $$ Expression rawLiteral = toExpression(object, FunctionRegistry.typeForMagicLiteral(type))[ FD ]
Line_44 $$ SliceOutput output = new DynamicSliceOutput(((Block) object).getSizeInBytes())-->Line_45 $$ BlockSerdeUtil.writeBlock(output, (Block) object)[ FD ]
Line_58 $$ Expression rawLiteral = toExpression(object, FunctionRegistry.typeForMagicLiteral(type))-->Line_59 $$ return new FunctionCall(new QualifiedName(signature.getName()), ImmutableList.of(rawLiteral))[ FD ]
Line_31 $$ if (type.equals(VARCHAR)) -->Line_32 $$ if (object instanceof Slice) [ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_49 $$ if (object instanceof Slice && !type.equals(VARCHAR)) [ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_32 $$ if (object instanceof Slice) [ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_41 $$ return new BooleanLiteral(object.toString())[ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_54 $$ Signature signature = FunctionRegistry.getMagicLiteralFunctionSignature(type)[ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_17 $$ if (type.equals(DOUBLE)) [ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_40 $$ if (type.equals(BOOLEAN)) [ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_57 $$ Signature signature = FunctionRegistry.getMagicLiteralFunctionSignature(type)[ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_7 $$ if (object == null) [ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_35 $$ if (object instanceof String) [ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_43 $$ if (object instanceof Block) [ CD ]
Line_46 $$ object = output.slice()-->Line_58 $$ Expression rawLiteral = toExpression(object, FunctionRegistry.typeForMagicLiteral(type))[ FD ]
Line_49 $$ if (object instanceof Slice && !type.equals(VARCHAR)) -->Line_54 $$ Signature signature = FunctionRegistry.getMagicLiteralFunctionSignature(type)[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_3 $$ requireNonNull(type, "type is null")[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_4 $$ if (object instanceof Expression) [ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_7 $$ if (object == null) [ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_15 $$ return new LongLiteral(object.toString())[ FD ]
Line_18 $$ Double value = (Double) object-->Line_25 $$ if (value.equals(Double.POSITIVE_INFINITY)) [ FD ]
Line_32 $$ if (object instanceof Slice) -->Line_33 $$ return new StringLiteral(((Slice) object).toStringUtf8())[ CD ]
Line_25 $$ if (value.equals(Double.POSITIVE_INFINITY)) -->Line_28 $$ return new DoubleLiteral(object.toString())[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_43 $$ if (object instanceof Block) [ FD ]
Line_54 $$ Signature signature = FunctionRegistry.getMagicLiteralFunctionSignature(type)-->Line_55 $$ return new FunctionCall(new QualifiedName(signature.getName()), ImmutableList.of(fromBase64))[ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_17 $$ if (type.equals(DOUBLE)) [ CD ]
Line_43 $$ if (object instanceof Block) -->Line_45 $$ BlockSerdeUtil.writeBlock(output, (Block) object)[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_13 $$ checkArgument(Primitives.wrap(type.getJavaType()).isInstance(object), "object.getClass (%s) and type.getJavaType (%s) do not agree", object.getClass(), type.getJavaType())[ FD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_58 $$ Expression rawLiteral = toExpression(object, FunctionRegistry.typeForMagicLiteral(type))[ CD ]
Line_35 $$ if (object instanceof String) -->Line_36 $$ return new StringLiteral((String) object)[ CD ]
Line_8 $$ if (type.equals(UNKNOWN)) -->Line_9 $$ return new NullLiteral()[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_14 $$ if (type.equals(BIGINT)) [ CD ]
Line_14 $$ if (type.equals(BIGINT)) -->Line_15 $$ return new LongLiteral(object.toString())[ CD ]
Line_43 $$ if (object instanceof Block) -->Line_44 $$ SliceOutput output = new DynamicSliceOutput(((Block) object).getSizeInBytes())[ CD ]
Line_49 $$ if (object instanceof Slice && !type.equals(VARCHAR)) -->Line_55 $$ return new FunctionCall(new QualifiedName(signature.getName()), ImmutableList.of(fromBase64))[ CD ]
Line_2 $$ public static Expression toExpression(Object object, Type type) -->Line_31 $$ if (type.equals(VARCHAR)) [ FD ]
