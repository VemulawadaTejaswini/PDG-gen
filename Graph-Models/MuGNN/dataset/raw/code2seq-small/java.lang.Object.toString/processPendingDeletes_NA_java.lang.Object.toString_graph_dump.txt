Line_23 $$ Iterator<PendingDelete> iterator = remove.iterator()-->Line_47 $$ iterator.remove()[ FD ]
Line_38 $$ if (shardLock != null) -->Line_47 $$ iterator.remove()[ CD ]
Line_18 $$ long sleepTime = 10-->Line_55 $$ logger.debug("[ FD ]
Line_18 $$ long sleepTime = 10-->Line_54 $$ sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)[ FD ]
Line_54 $$ sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)-->Line_53 $$ Thread.sleep(sleepTime)[ FD ]
Line_13 $$ remove = pendingDeletes.remove(index)-->Line_15 $$ if (remove != null && remove.isEmpty() == false) [ FD ]
Line_19 $$ do -->Line_24 $$ while (iterator.hasNext()) [ CD ]
Line_8 $$ for (ShardLock lock : shardLocks) -->Line_9 $$ locks.put(lock.getShardId(), lock)[ FD ]
Line_24 $$ while (iterator.hasNext()) -->Line_26 $$ if (delete.deleteIndex) [ CD ]
Line_37 $$ ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))-->Line_43 $$ logger.debug("[ FD ]
Line_15 $$ if (remove != null && remove.isEmpty() == false) -->Line_18 $$ long sleepTime = 10[ CD ]
Line_11 $$ final List<PendingDelete> remove-->Line_15 $$ if (remove != null && remove.isEmpty() == false) [ FD ]
Line_19 $$ do -->Line_23 $$ Iterator<PendingDelete> iterator = remove.iterator()[ CD ]
Line_2 $$ public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout) throws IOException, InterruptedException -->Line_13 $$ remove = pendingDeletes.remove(index)[ FD ]
Line_25 $$ PendingDelete delete = iterator.next()-->Line_26 $$ if (delete.deleteIndex) [ FD ]
Line_24 $$ while (iterator.hasNext()) -->Line_25 $$ PendingDelete delete = iterator.next()[ CD ]
Line_15 $$ if (remove != null && remove.isEmpty() == false) -->Line_19 $$ do [ CD ]
Line_13 $$ remove = pendingDeletes.remove(index)-->Line_23 $$ Iterator<PendingDelete> iterator = remove.iterator()[ FD ]
Line_2 $$ public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout) throws IOException, InterruptedException -->Line_30 $$ nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)[ FD ]
Line_11 $$ final List<PendingDelete> remove-->Line_16 $$ CollectionUtil.timSort(remove)[ FD ]
Line_7 $$ Map<ShardId, ShardLock> locks = new HashMap()-->Line_37 $$ ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))[ FD ]
Line_2 $$ public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout) throws IOException, InterruptedException -->Line_5 $$ final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())[ FD ]
Line_2 $$ public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout) throws IOException, InterruptedException -->Line_28 $$ logger.debug("[ FD ]
Line_2 $$ public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout) throws IOException, InterruptedException -->Line_3 $$ logger.debug("[ FD ]
Line_37 $$ ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))-->Line_40 $$ deleteShardStore("pending delete", shardLock, delete.settings)[ FD ]
Line_2 $$ public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout) throws IOException, InterruptedException -->Line_33 $$ logger.debug("[ FD ]
Line_2 $$ public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout) throws IOException, InterruptedException -->Line_52 $$ logger.warn("[ FD ]
Line_13 $$ remove = pendingDeletes.remove(index)-->Line_20 $$ if (remove.isEmpty()) [ FD ]
Line_17 $$ final long maxSleepTimeMs = 10 * 1000-->Line_54 $$ sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)[ FD ]
Line_26 $$ if (delete.deleteIndex) -->Line_37 $$ ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))[ CD ]
Line_2 $$ public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout) throws IOException, InterruptedException -->Line_55 $$ logger.debug("[ FD ]
Line_2 $$ public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout) throws IOException, InterruptedException -->Line_3 $$ logger.debug("[ CD ]
Line_15 $$ if (remove != null && remove.isEmpty() == false) -->Line_17 $$ final long maxSleepTimeMs = 10 * 1000[ CD ]
Line_51 $$ if (remove.isEmpty() == false) -->Line_53 $$ Thread.sleep(sleepTime)[ CD ]
Line_23 $$ Iterator<PendingDelete> iterator = remove.iterator()-->Line_41 $$ iterator.remove()[ FD ]
Line_51 $$ if (remove.isEmpty() == false) -->Line_55 $$ logger.debug("[ CD ]
Line_15 $$ if (remove != null && remove.isEmpty() == false) -->Line_16 $$ CollectionUtil.timSort(remove)[ CD ]
Line_19 $$ do -->Line_51 $$ if (remove.isEmpty() == false) [ CD ]
Line_23 $$ Iterator<PendingDelete> iterator = remove.iterator()-->Line_24 $$ while (iterator.hasNext()) [ FD ]
Line_2 $$ public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout) throws IOException, InterruptedException -->Line_4 $$ final long startTimeNS = System.nanoTime()[ CD ]
Line_11 $$ final List<PendingDelete> remove-->Line_51 $$ if (remove.isEmpty() == false) [ FD ]
Line_51 $$ if (remove.isEmpty() == false) -->Line_54 $$ sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)[ CD ]
Line_19 $$ do -->Line_20 $$ if (remove.isEmpty()) [ CD ]
Line_26 $$ if (delete.deleteIndex) -->Line_38 $$ if (shardLock != null) [ CD ]
Line_13 $$ remove = pendingDeletes.remove(index)-->Line_16 $$ CollectionUtil.timSort(remove)[ FD ]
Line_37 $$ ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))-->Line_38 $$ if (shardLock != null) [ FD ]
Line_7 $$ Map<ShardId, ShardLock> locks = new HashMap()-->Line_9 $$ locks.put(lock.getShardId(), lock)[ FD ]
Line_5 $$ final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())-->Line_60 $$ IOUtils.close(shardLocks)[ FD ]
Line_23 $$ Iterator<PendingDelete> iterator = remove.iterator()-->Line_25 $$ PendingDelete delete = iterator.next()[ FD ]
Line_11 $$ final List<PendingDelete> remove-->Line_20 $$ if (remove.isEmpty()) [ FD ]
Line_54 $$ sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)-->Line_55 $$ logger.debug("[ FD ]
Line_11 $$ final List<PendingDelete> remove-->Line_13 $$ remove = pendingDeletes.remove(index)[ FD ]
Line_38 $$ if (shardLock != null) -->Line_46 $$ logger.warn("[ CD ]
Line_26 $$ if (delete.deleteIndex) -->Line_28 $$ logger.debug("[ CD ]
Line_51 $$ if (remove.isEmpty() == false) -->Line_52 $$ logger.warn("[ CD ]
Line_2 $$ public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout) throws IOException, InterruptedException -->Line_5 $$ final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())[ CD ]
Line_11 $$ final List<PendingDelete> remove-->Line_23 $$ Iterator<PendingDelete> iterator = remove.iterator()[ FD ]
Line_13 $$ remove = pendingDeletes.remove(index)-->Line_52 $$ logger.warn("[ FD ]
Line_11 $$ final List<PendingDelete> remove-->Line_52 $$ logger.warn("[ FD ]
Line_18 $$ long sleepTime = 10-->Line_53 $$ Thread.sleep(sleepTime)[ FD ]
Line_2 $$ public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout) throws IOException, InterruptedException -->Line_19 $$ do [ FD ]
Line_23 $$ Iterator<PendingDelete> iterator = remove.iterator()-->Line_31 $$ iterator.remove()[ FD ]
Line_13 $$ remove = pendingDeletes.remove(index)-->Line_51 $$ if (remove.isEmpty() == false) [ FD ]
