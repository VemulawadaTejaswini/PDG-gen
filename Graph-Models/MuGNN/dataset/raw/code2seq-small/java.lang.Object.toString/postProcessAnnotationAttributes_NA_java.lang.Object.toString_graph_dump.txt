Line_21 $$ if (valuePresent || aliasPresent) -->Line_22 $$ if (valuePresent && aliasPresent) [ CD ]
Line_13 $$ Object value = attributes.get(attributeName)-->Line_43 $$ value = ((DefaultValueHolder) value).defaultValue[ FD ]
Line_7 $$ Set<String> valuesAlreadyReplaced = new HashSet<String>()-->Line_16 $$ if (valuesAlreadyReplaced.contains(aliasedAttributeName)) [ FD ]
Line_14 $$ boolean valuePresent = (value != null && !(value instanceof DefaultValueHolder))-->Line_22 $$ if (valuePresent && aliasPresent) [ FD ]
Line_23 $$ if (!ObjectUtils.nullSafeEquals(value, aliasedValue)) -->Line_24 $$ String elementAsString = (annotatedElement != null ? annotatedElement.toString() : "unknown element")[ CD ]
Line_6 $$ Class<? extends Annotation> annotationType = attributes.annotationType()-->Line_25 $$ throw new AnnotationConfigurationException(String.format("In AnnotationAttributes for annotation [%s] declared on %s, " + "attribute '%s' and its alias '%s' are declared with values of [%s] and [%s], " + "but only one is permitted.", annotationType.getName(), elementAsString, attributeName, aliasedAttributeName, ObjectUtils.nullSafeToString(value), ObjectUtils.nullSafeToString(aliasedValue)))[ FD ]
Line_43 $$ value = ((DefaultValueHolder) value).defaultValue-->Line_44 $$ attributes.put(attributeName, adaptValue(annotatedElement, value, classValuesAsString, nestedAnnotationsAsMap))[ FD ]
Line_27 $$ if (aliasPresent) -->Line_28 $$ attributes.put(attributeName, adaptValue(annotatedElement, aliasedValue, classValuesAsString, nestedAnnotationsAsMap))[ CD ]
Line_22 $$ if (valuePresent && aliasPresent) -->Line_23 $$ if (!ObjectUtils.nullSafeEquals(value, aliasedValue)) [ CD ]
Line_9 $$ for (String attributeName : aliasMap.keySet()) -->Line_41 $$ Object value = attributes.get(attributeName)[ FD ]
Line_2 $$ static void postProcessAnnotationAttributes(AnnotatedElement annotatedElement, AnnotationAttributes attributes, boolean classValuesAsString, boolean nestedAnnotationsAsMap) -->Line_19 $$ Object aliasedValue = attributes.get(aliasedAttributeName)[ FD ]
Line_13 $$ Object value = attributes.get(attributeName)-->Line_23 $$ if (!ObjectUtils.nullSafeEquals(value, aliasedValue)) [ FD ]
Line_15 $$ for (String aliasedAttributeName : aliasMap.get(attributeName)) -->Line_16 $$ if (valuesAlreadyReplaced.contains(aliasedAttributeName)) [ FD ]
Line_2 $$ static void postProcessAnnotationAttributes(AnnotatedElement annotatedElement, AnnotationAttributes attributes, boolean classValuesAsString, boolean nestedAnnotationsAsMap) -->Line_37 $$ for (String attributeName : attributes.keySet()) [ FD ]
Line_9 $$ for (String attributeName : aliasMap.keySet()) -->Line_38 $$ if (valuesAlreadyReplaced.contains(attributeName)) [ FD ]
Line_14 $$ boolean valuePresent = (value != null && !(value instanceof DefaultValueHolder))-->Line_21 $$ if (valuePresent || aliasPresent) [ FD ]
Line_19 $$ Object aliasedValue = attributes.get(aliasedAttributeName)-->Line_28 $$ attributes.put(attributeName, adaptValue(annotatedElement, aliasedValue, classValuesAsString, nestedAnnotationsAsMap))[ FD ]
Line_2 $$ static void postProcessAnnotationAttributes(AnnotatedElement annotatedElement, AnnotationAttributes attributes, boolean classValuesAsString, boolean nestedAnnotationsAsMap) -->Line_24 $$ String elementAsString = (annotatedElement != null ? annotatedElement.toString() : "unknown element")[ FD ]
Line_2 $$ static void postProcessAnnotationAttributes(AnnotatedElement annotatedElement, AnnotationAttributes attributes, boolean classValuesAsString, boolean nestedAnnotationsAsMap) -->Line_3 $$ if (attributes == null) [ CD ]
Line_9 $$ for (String attributeName : aliasMap.keySet()) -->Line_44 $$ attributes.put(attributeName, adaptValue(annotatedElement, value, classValuesAsString, nestedAnnotationsAsMap))[ FD ]
Line_15 $$ for (String aliasedAttributeName : aliasMap.get(attributeName)) -->Line_31 $$ attributes.put(aliasedAttributeName, adaptValue(annotatedElement, value, classValuesAsString, nestedAnnotationsAsMap))[ FD ]
Line_9 $$ for (String attributeName : aliasMap.keySet()) -->Line_29 $$ valuesAlreadyReplaced.add(attributeName)[ FD ]
Line_20 $$ boolean aliasPresent = (aliasedValue != null && !(aliasedValue instanceof DefaultValueHolder))-->Line_21 $$ if (valuePresent || aliasPresent) [ FD ]
Line_42 $$ if (value instanceof DefaultValueHolder) -->Line_44 $$ attributes.put(attributeName, adaptValue(annotatedElement, value, classValuesAsString, nestedAnnotationsAsMap))[ CD ]
Line_19 $$ Object aliasedValue = attributes.get(aliasedAttributeName)-->Line_25 $$ throw new AnnotationConfigurationException(String.format("In AnnotationAttributes for annotation [%s] declared on %s, " + "attribute '%s' and its alias '%s' are declared with values of [%s] and [%s], " + "but only one is permitted.", annotationType.getName(), elementAsString, attributeName, aliasedAttributeName, ObjectUtils.nullSafeToString(value), ObjectUtils.nullSafeToString(aliasedValue)))[ FD ]
Line_13 $$ Object value = attributes.get(attributeName)-->Line_42 $$ if (value instanceof DefaultValueHolder) [ FD ]
Line_13 $$ Object value = attributes.get(attributeName)-->Line_25 $$ throw new AnnotationConfigurationException(String.format("In AnnotationAttributes for annotation [%s] declared on %s, " + "attribute '%s' and its alias '%s' are declared with values of [%s] and [%s], " + "but only one is permitted.", annotationType.getName(), elementAsString, attributeName, aliasedAttributeName, ObjectUtils.nullSafeToString(value), ObjectUtils.nullSafeToString(aliasedValue)))[ FD ]
Line_9 $$ for (String attributeName : aliasMap.keySet()) -->Line_10 $$ if (valuesAlreadyReplaced.contains(attributeName)) [ FD ]
Line_2 $$ static void postProcessAnnotationAttributes(AnnotatedElement annotatedElement, AnnotationAttributes attributes, boolean classValuesAsString, boolean nestedAnnotationsAsMap) -->Line_13 $$ Object value = attributes.get(attributeName)[ FD ]
Line_7 $$ Set<String> valuesAlreadyReplaced = new HashSet<String>()-->Line_38 $$ if (valuesAlreadyReplaced.contains(attributeName)) [ FD ]
Line_8 $$ Map<String, List<String>> aliasMap = getAttributeAliasMap(annotationType)-->Line_9 $$ for (String attributeName : aliasMap.keySet()) [ FD ]
Line_2 $$ static void postProcessAnnotationAttributes(AnnotatedElement annotatedElement, AnnotationAttributes attributes, boolean classValuesAsString, boolean nestedAnnotationsAsMap) -->Line_41 $$ Object value = attributes.get(attributeName)[ FD ]
Line_7 $$ Set<String> valuesAlreadyReplaced = new HashSet<String>()-->Line_10 $$ if (valuesAlreadyReplaced.contains(attributeName)) [ FD ]
Line_15 $$ for (String aliasedAttributeName : aliasMap.get(attributeName)) -->Line_19 $$ Object aliasedValue = attributes.get(aliasedAttributeName)[ FD ]
Line_24 $$ String elementAsString = (annotatedElement != null ? annotatedElement.toString() : "unknown element")-->Line_25 $$ throw new AnnotationConfigurationException(String.format("In AnnotationAttributes for annotation [%s] declared on %s, " + "attribute '%s' and its alias '%s' are declared with values of [%s] and [%s], " + "but only one is permitted.", annotationType.getName(), elementAsString, attributeName, aliasedAttributeName, ObjectUtils.nullSafeToString(value), ObjectUtils.nullSafeToString(aliasedValue)))[ FD ]
Line_2 $$ static void postProcessAnnotationAttributes(AnnotatedElement annotatedElement, AnnotationAttributes attributes, boolean classValuesAsString, boolean nestedAnnotationsAsMap) -->Line_3 $$ if (attributes == null) [ FD ]
Line_42 $$ if (value instanceof DefaultValueHolder) -->Line_43 $$ value = ((DefaultValueHolder) value).defaultValue[ CD ]
Line_9 $$ for (String attributeName : aliasMap.keySet()) -->Line_13 $$ Object value = attributes.get(attributeName)[ FD ]
Line_22 $$ if (valuePresent && aliasPresent) -->Line_27 $$ if (aliasPresent) [ CD ]
Line_2 $$ static void postProcessAnnotationAttributes(AnnotatedElement annotatedElement, AnnotationAttributes attributes, boolean classValuesAsString, boolean nestedAnnotationsAsMap) -->Line_31 $$ attributes.put(aliasedAttributeName, adaptValue(annotatedElement, value, classValuesAsString, nestedAnnotationsAsMap))[ FD ]
Line_20 $$ boolean aliasPresent = (aliasedValue != null && !(aliasedValue instanceof DefaultValueHolder))-->Line_22 $$ if (valuePresent && aliasPresent) [ FD ]
Line_9 $$ for (String attributeName : aliasMap.keySet()) -->Line_25 $$ throw new AnnotationConfigurationException(String.format("In AnnotationAttributes for annotation [%s] declared on %s, " + "attribute '%s' and its alias '%s' are declared with values of [%s] and [%s], " + "but only one is permitted.", annotationType.getName(), elementAsString, attributeName, aliasedAttributeName, ObjectUtils.nullSafeToString(value), ObjectUtils.nullSafeToString(aliasedValue)))[ FD ]
Line_27 $$ if (aliasPresent) -->Line_29 $$ valuesAlreadyReplaced.add(attributeName)[ CD ]
Line_8 $$ Map<String, List<String>> aliasMap = getAttributeAliasMap(annotationType)-->Line_15 $$ for (String aliasedAttributeName : aliasMap.get(attributeName)) [ FD ]
Line_2 $$ static void postProcessAnnotationAttributes(AnnotatedElement annotatedElement, AnnotationAttributes attributes, boolean classValuesAsString, boolean nestedAnnotationsAsMap) -->Line_8 $$ Map<String, List<String>> aliasMap = getAttributeAliasMap(annotationType)[ CD ]
Line_2 $$ static void postProcessAnnotationAttributes(AnnotatedElement annotatedElement, AnnotationAttributes attributes, boolean classValuesAsString, boolean nestedAnnotationsAsMap) -->Line_6 $$ Class<? extends Annotation> annotationType = attributes.annotationType()[ FD ]
Line_19 $$ Object aliasedValue = attributes.get(aliasedAttributeName)-->Line_23 $$ if (!ObjectUtils.nullSafeEquals(value, aliasedValue)) [ FD ]
Line_27 $$ if (aliasPresent) -->Line_31 $$ attributes.put(aliasedAttributeName, adaptValue(annotatedElement, value, classValuesAsString, nestedAnnotationsAsMap))[ CD ]
Line_2 $$ static void postProcessAnnotationAttributes(AnnotatedElement annotatedElement, AnnotationAttributes attributes, boolean classValuesAsString, boolean nestedAnnotationsAsMap) -->Line_7 $$ Set<String> valuesAlreadyReplaced = new HashSet<String>()[ CD ]
Line_15 $$ for (String aliasedAttributeName : aliasMap.get(attributeName)) -->Line_25 $$ throw new AnnotationConfigurationException(String.format("In AnnotationAttributes for annotation [%s] declared on %s, " + "attribute '%s' and its alias '%s' are declared with values of [%s] and [%s], " + "but only one is permitted.", annotationType.getName(), elementAsString, attributeName, aliasedAttributeName, ObjectUtils.nullSafeToString(value), ObjectUtils.nullSafeToString(aliasedValue)))[ FD ]
Line_9 $$ for (String attributeName : aliasMap.keySet()) -->Line_28 $$ attributes.put(attributeName, adaptValue(annotatedElement, aliasedValue, classValuesAsString, nestedAnnotationsAsMap))[ FD ]
Line_7 $$ Set<String> valuesAlreadyReplaced = new HashSet<String>()-->Line_29 $$ valuesAlreadyReplaced.add(attributeName)[ FD ]
Line_7 $$ Set<String> valuesAlreadyReplaced = new HashSet<String>()-->Line_32 $$ valuesAlreadyReplaced.add(aliasedAttributeName)[ FD ]
Line_13 $$ Object value = attributes.get(attributeName)-->Line_44 $$ attributes.put(attributeName, adaptValue(annotatedElement, value, classValuesAsString, nestedAnnotationsAsMap))[ FD ]
Line_6 $$ Class<? extends Annotation> annotationType = attributes.annotationType()-->Line_8 $$ Map<String, List<String>> aliasMap = getAttributeAliasMap(annotationType)[ FD ]
Line_2 $$ static void postProcessAnnotationAttributes(AnnotatedElement annotatedElement, AnnotationAttributes attributes, boolean classValuesAsString, boolean nestedAnnotationsAsMap) -->Line_44 $$ attributes.put(attributeName, adaptValue(annotatedElement, value, classValuesAsString, nestedAnnotationsAsMap))[ FD ]
Line_3 $$ if (attributes == null) -->Line_4 $$ return[ CD ]
Line_2 $$ static void postProcessAnnotationAttributes(AnnotatedElement annotatedElement, AnnotationAttributes attributes, boolean classValuesAsString, boolean nestedAnnotationsAsMap) -->Line_28 $$ attributes.put(attributeName, adaptValue(annotatedElement, aliasedValue, classValuesAsString, nestedAnnotationsAsMap))[ FD ]
Line_27 $$ if (aliasPresent) -->Line_32 $$ valuesAlreadyReplaced.add(aliasedAttributeName)[ CD ]
Line_2 $$ static void postProcessAnnotationAttributes(AnnotatedElement annotatedElement, AnnotationAttributes attributes, boolean classValuesAsString, boolean nestedAnnotationsAsMap) -->Line_6 $$ Class<? extends Annotation> annotationType = attributes.annotationType()[ CD ]
Line_9 $$ for (String attributeName : aliasMap.keySet()) -->Line_15 $$ for (String aliasedAttributeName : aliasMap.get(attributeName)) [ FD ]
Line_13 $$ Object value = attributes.get(attributeName)-->Line_31 $$ attributes.put(aliasedAttributeName, adaptValue(annotatedElement, value, classValuesAsString, nestedAnnotationsAsMap))[ FD ]
Line_15 $$ for (String aliasedAttributeName : aliasMap.get(attributeName)) -->Line_32 $$ valuesAlreadyReplaced.add(aliasedAttributeName)[ FD ]
