Line_10 $$ if (element instanceof PyClass) -->Line_11 $$ type = new PyClassTypeImpl((PyClass) element, myIsDefinition)[ CD ]
Line_3 $$ for (PyExpression expression : myClass.getSuperClassExpressions()) -->Line_13 $$ type = typeEvalContext.getType(expression)[ FD ]
Line_13 $$ type = typeEvalContext.getType(expression)-->Line_19 $$ Object[] ancestry = type.getCompletionVariants(name, expressionHook, context)[ FD ]
Line_9 $$ PyType type-->Line_11 $$ type = new PyClassTypeImpl((PyClass) element, myIsDefinition)[ FD ]
Line_9 $$ PyType type-->Line_15 $$ type = ((PyClassType) type).toInstance()[ FD ]
Line_9 $$ PyType type-->Line_19 $$ Object[] ancestry = type.getCompletionVariants(name, expressionHook, context)[ FD ]
Line_2 $$ private void addInheritedMembers(String name, PsiElement expressionHook, Set<String> namesAlready, ProcessingContext context, List<Object> ret, @NotNull TypeEvalContext typeEvalContext) -->Line_19 $$ Object[] ancestry = type.getCompletionVariants(name, expressionHook, context)[ FD ]
Line_2 $$ private void addInheritedMembers(String name, PsiElement expressionHook, Set<String> namesAlready, ProcessingContext context, List<Object> ret, @NotNull TypeEvalContext typeEvalContext) -->Line_27 $$ ContainerUtil.addAll(ret, ancestry)[ FD ]
Line_4 $$ final PsiReference reference = expression.getReference()-->Line_6 $$ if (reference != null) [ FD ]
Line_15 $$ type = ((PyClassType) type).toInstance()-->Line_18 $$ if (type != null) [ FD ]
Line_18 $$ if (type != null) -->Line_27 $$ ContainerUtil.addAll(ret, ancestry)[ CD ]
Line_20 $$ for (Object ob : ancestry) -->Line_21 $$ String inheritedName = ob.toString()[ FD ]
Line_22 $$ if (!namesAlready.contains(inheritedName) && !isClassPrivate(inheritedName)) -->Line_24 $$ namesAlready.add(inheritedName)[ CD ]
Line_10 $$ if (element instanceof PyClass) -->Line_13 $$ type = typeEvalContext.getType(expression)[ CD ]
Line_6 $$ if (reference != null) -->Line_7 $$ element = reference.resolve()[ CD ]
Line_11 $$ type = new PyClassTypeImpl((PyClass) element, myIsDefinition)-->Line_15 $$ type = ((PyClassType) type).toInstance()[ FD ]
Line_2 $$ private void addInheritedMembers(String name, PsiElement expressionHook, Set<String> namesAlready, ProcessingContext context, List<Object> ret, @NotNull TypeEvalContext typeEvalContext) -->Line_22 $$ if (!namesAlready.contains(inheritedName) && !isClassPrivate(inheritedName)) [ FD ]
Line_13 $$ type = typeEvalContext.getType(expression)-->Line_18 $$ if (type != null) [ FD ]
Line_5 $$ PsiElement element = null-->Line_7 $$ element = reference.resolve()[ FD ]
Line_4 $$ final PsiReference reference = expression.getReference()-->Line_7 $$ element = reference.resolve()[ FD ]
Line_2 $$ private void addInheritedMembers(String name, PsiElement expressionHook, Set<String> namesAlready, ProcessingContext context, List<Object> ret, @NotNull TypeEvalContext typeEvalContext) -->Line_23 $$ ret.add(ob)[ FD ]
Line_2 $$ private void addInheritedMembers(String name, PsiElement expressionHook, Set<String> namesAlready, ProcessingContext context, List<Object> ret, @NotNull TypeEvalContext typeEvalContext) -->Line_24 $$ namesAlready.add(inheritedName)[ FD ]
Line_9 $$ PyType type-->Line_18 $$ if (type != null) [ FD ]
Line_15 $$ type = ((PyClassType) type).toInstance()-->Line_19 $$ Object[] ancestry = type.getCompletionVariants(name, expressionHook, context)[ FD ]
Line_11 $$ type = new PyClassTypeImpl((PyClass) element, myIsDefinition)-->Line_19 $$ Object[] ancestry = type.getCompletionVariants(name, expressionHook, context)[ FD ]
Line_11 $$ type = new PyClassTypeImpl((PyClass) element, myIsDefinition)-->Line_13 $$ type = typeEvalContext.getType(expression)[ FD ]
Line_18 $$ if (type != null) -->Line_19 $$ Object[] ancestry = type.getCompletionVariants(name, expressionHook, context)[ CD ]
Line_21 $$ String inheritedName = ob.toString()-->Line_24 $$ namesAlready.add(inheritedName)[ FD ]
Line_7 $$ element = reference.resolve()-->Line_10 $$ if (element instanceof PyClass) [ FD ]
Line_14 $$ if (type instanceof PyClassType && !myIsDefinition) -->Line_15 $$ type = ((PyClassType) type).toInstance()[ CD ]
Line_22 $$ if (!namesAlready.contains(inheritedName) && !isClassPrivate(inheritedName)) -->Line_23 $$ ret.add(ob)[ CD ]
Line_10 $$ if (element instanceof PyClass) -->Line_14 $$ if (type instanceof PyClassType && !myIsDefinition) [ CD ]
Line_5 $$ PsiElement element = null-->Line_10 $$ if (element instanceof PyClass) [ FD ]
Line_11 $$ type = new PyClassTypeImpl((PyClass) element, myIsDefinition)-->Line_18 $$ if (type != null) [ FD ]
Line_19 $$ Object[] ancestry = type.getCompletionVariants(name, expressionHook, context)-->Line_27 $$ ContainerUtil.addAll(ret, ancestry)[ FD ]
Line_9 $$ PyType type-->Line_13 $$ type = typeEvalContext.getType(expression)[ FD ]
Line_2 $$ private void addInheritedMembers(String name, PsiElement expressionHook, Set<String> namesAlready, ProcessingContext context, List<Object> ret, @NotNull TypeEvalContext typeEvalContext) -->Line_13 $$ type = typeEvalContext.getType(expression)[ FD ]
Line_3 $$ for (PyExpression expression : myClass.getSuperClassExpressions()) -->Line_4 $$ final PsiReference reference = expression.getReference()[ FD ]
Line_20 $$ for (Object ob : ancestry) -->Line_23 $$ ret.add(ob)[ FD ]
Line_21 $$ String inheritedName = ob.toString()-->Line_22 $$ if (!namesAlready.contains(inheritedName) && !isClassPrivate(inheritedName)) [ FD ]
Line_13 $$ type = typeEvalContext.getType(expression)-->Line_15 $$ type = ((PyClassType) type).toInstance()[ FD ]
