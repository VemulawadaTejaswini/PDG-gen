Line_30 $$ corruptedFile = file-->Line_34 $$ assertThat(corruptedFile, notNullValue())[ FD ]
Line_2 $$ public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException -->Line_4 $$ internalCluster().ensureAtLeastNumDataNodes(2)[ CD ]
Line_2 $$ public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException -->Line_5 $$ assertAcked(prepareCreate("test").setSettings(Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0").put(MergePolicyConfig.INDEX_MERGE_ENABLED, false).put(MockFSIndexStore.CHECK_INDEX_ON_CLOSE, false).put(IndexShard.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE, new ByteSizeValue(1, ByteSizeUnit.PB)).put("indices.recovery.concurrent_streams", 10)))[ CD ]
Line_2 $$ public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException -->Line_16 $$ assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).setWaitIfOngoing(true).execute().actionGet())[ CD ]
Line_2 $$ public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException -->Line_14 $$ indexRandom(true, builders)[ CD ]
Line_2 $$ public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException -->Line_27 $$ Path corruptedFile = null[ CD ]
Line_2 $$ public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException -->Line_19 $$ ShardRouting shardRouting = corruptRandomPrimaryFile(false)[ CD ]
Line_27 $$ Path corruptedFile = null-->Line_34 $$ assertThat(corruptedFile, notNullValue())[ FD ]
Line_3 $$ int numDocs = scaledRandomIntBetween(100, 1000)-->Line_18 $$ assertHitCount(countResponse, numDocs)[ FD ]
Line_2 $$ public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException -->Line_25 $$ logger.info("failed during snapshot -- maybe SI file got corrupted")[ CD ]
Line_27 $$ Path corruptedFile = null-->Line_30 $$ corruptedFile = file[ FD ]
Line_2 $$ public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException -->Line_26 $$ final List<Path> files = listShardFiles(shardRouting)[ CD ]
Line_28 $$ for (Path file : files) -->Line_30 $$ corruptedFile = file[ FD ]
Line_10 $$ IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]-->Line_14 $$ indexRandom(true, builders)[ FD ]
Line_19 $$ ShardRouting shardRouting = corruptRandomPrimaryFile(false)-->Line_26 $$ final List<Path> files = listShardFiles(shardRouting)[ FD ]
Line_2 $$ public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException -->Line_3 $$ int numDocs = scaledRandomIntBetween(100, 1000)[ CD ]
Line_2 $$ public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException -->Line_24 $$ assertThat(createSnapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.PARTIAL))[ CD ]
Line_2 $$ public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException -->Line_10 $$ IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs][ CD ]
Line_2 $$ public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException -->Line_9 $$ ensureGreen()[ CD ]
Line_17 $$ SearchResponse countResponse = client().prepareSearch().setSize(0).get()-->Line_18 $$ assertHitCount(countResponse, numDocs)[ FD ]
Line_23 $$ CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap").setWaitForCompletion(true).setIndices("test").get()-->Line_24 $$ assertThat(createSnapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.PARTIAL))[ FD ]
Line_2 $$ public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException -->Line_15 $$ ensureGreen()[ CD ]
Line_29 $$ if (file.getFileName().toString().startsWith("corrupted_")) -->Line_30 $$ corruptedFile = file[ CD ]
Line_2 $$ public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException -->Line_34 $$ assertThat(corruptedFile, notNullValue())[ CD ]
Line_2 $$ public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException -->Line_18 $$ assertHitCount(countResponse, numDocs)[ CD ]
Line_11 $$ for (int i = 0; i < builders.length; i++) -->Line_12 $$ builders[i] = client().prepareIndex("test", "type").setSource("field", "value")[ CD ]
Line_2 $$ public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException -->Line_21 $$ assertAcked(client().admin().cluster().preparePutRepository("test-repo").setType("fs").setSettings(settingsBuilder().put("location", randomRepoPath().toAbsolutePath()).put("compress", randomBoolean()).put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))[ CD ]
Line_28 $$ for (Path file : files) -->Line_29 $$ if (file.getFileName().toString().startsWith("corrupted_")) [ FD ]
Line_2 $$ public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException -->Line_17 $$ SearchResponse countResponse = client().prepareSearch().setSize(0).get()[ CD ]
Line_2 $$ public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException -->Line_23 $$ CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap").setWaitForCompletion(true).setIndices("test").get()[ CD ]
Line_2 $$ public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException -->Line_11 $$ for (int i = 0; i < builders.length; i++) [ CD ]
