Line_2 $$ public void visitPyCallExpression(final PyCallExpression node) -->Line_20 $$ final PyExpression callee = node.getCallee()[ FD ]
Line_6 $$ for (PyClassLikeType type : types) -->Line_9 $$ final String qName = type.getClassQName()[ FD ]
Line_5 $$ final List<PyClassLikeType> types = klass.getSuperClassTypes(myTypeEvalContext)-->Line_16 $$ if (!types.isEmpty()) [ FD ]
Line_6 $$ for (PyClassLikeType type : types) -->Line_7 $$ if (type == null)[ FD ]
Line_4 $$ if (klass != null && !klass.isNewStyleClass(null)) -->Line_5 $$ final List<PyClassLikeType> types = klass.getSuperClassTypes(myTypeEvalContext)[ CD ]
Line_16 $$ if (!types.isEmpty()) -->Line_17 $$ quickFixes.add(new PyChangeBaseClassQuickFix())[ CD ]
Line_12 $$ if (!(type instanceof PyClassType))-->Line_13 $$ return[ CD ]
Line_19 $$ if (PyUtil.isSuperCall(node)) -->Line_21 $$ if (callee != null) [ CD ]
Line_4 $$ if (klass != null && !klass.isNewStyleClass(null)) -->Line_19 $$ if (PyUtil.isSuperCall(node)) [ CD ]
Line_7 $$ if (type == null)-->Line_8 $$ return[ CD ]
Line_9 $$ final String qName = type.getClassQName()-->Line_10 $$ if (qName != null && qName.contains("PyQt"))[ FD ]
Line_3 $$ PyClass klass = PsiTreeUtil.getParentOfType(node, PyClass.class)-->Line_4 $$ if (klass != null && !klass.isNewStyleClass(null)) [ FD ]
Line_10 $$ if (qName != null && qName.contains("PyQt"))-->Line_11 $$ return[ CD ]
Line_19 $$ if (PyUtil.isSuperCall(node)) -->Line_20 $$ final PyExpression callee = node.getCallee()[ CD ]
Line_15 $$ List<LocalQuickFix> quickFixes = Lists.<LocalQuickFix>newArrayList(new PyConvertToNewStyleQuickFix())-->Line_22 $$ registerProblem(callee, "Old-style class contains call for super method", ProblemHighlightType.GENERIC_ERROR_OR_WARNING, null, quickFixes.toArray(quickFixes.toArray(new LocalQuickFix[quickFixes.size()])))[ FD ]
Line_2 $$ public void visitPyCallExpression(final PyCallExpression node) -->Line_4 $$ if (klass != null && !klass.isNewStyleClass(null)) [ CD ]
Line_4 $$ if (klass != null && !klass.isNewStyleClass(null)) -->Line_15 $$ List<LocalQuickFix> quickFixes = Lists.<LocalQuickFix>newArrayList(new PyConvertToNewStyleQuickFix())[ CD ]
Line_15 $$ List<LocalQuickFix> quickFixes = Lists.<LocalQuickFix>newArrayList(new PyConvertToNewStyleQuickFix())-->Line_17 $$ quickFixes.add(new PyChangeBaseClassQuickFix())[ FD ]
Line_3 $$ PyClass klass = PsiTreeUtil.getParentOfType(node, PyClass.class)-->Line_5 $$ final List<PyClassLikeType> types = klass.getSuperClassTypes(myTypeEvalContext)[ FD ]
Line_2 $$ public void visitPyCallExpression(final PyCallExpression node) -->Line_3 $$ PyClass klass = PsiTreeUtil.getParentOfType(node, PyClass.class)[ FD ]
Line_20 $$ final PyExpression callee = node.getCallee()-->Line_21 $$ if (callee != null) [ FD ]
Line_4 $$ if (klass != null && !klass.isNewStyleClass(null)) -->Line_16 $$ if (!types.isEmpty()) [ CD ]
Line_20 $$ final PyExpression callee = node.getCallee()-->Line_22 $$ registerProblem(callee, "Old-style class contains call for super method", ProblemHighlightType.GENERIC_ERROR_OR_WARNING, null, quickFixes.toArray(quickFixes.toArray(new LocalQuickFix[quickFixes.size()])))[ FD ]
Line_2 $$ public void visitPyCallExpression(final PyCallExpression node) -->Line_3 $$ PyClass klass = PsiTreeUtil.getParentOfType(node, PyClass.class)[ CD ]
Line_2 $$ public void visitPyCallExpression(final PyCallExpression node) -->Line_19 $$ if (PyUtil.isSuperCall(node)) [ FD ]
Line_21 $$ if (callee != null) -->Line_22 $$ registerProblem(callee, "Old-style class contains call for super method", ProblemHighlightType.GENERIC_ERROR_OR_WARNING, null, quickFixes.toArray(quickFixes.toArray(new LocalQuickFix[quickFixes.size()])))[ CD ]
