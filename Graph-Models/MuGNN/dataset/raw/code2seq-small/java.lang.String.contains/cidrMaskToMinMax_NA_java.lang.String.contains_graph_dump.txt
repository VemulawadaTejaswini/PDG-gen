Line_2 $$ public static long[] cidrMaskToMinMax(String cidr) -->Line_8 $$ if (fields[0].contains(":")) [ CD ]
Line_2 $$ public static long[] cidrMaskToMinMax(String cidr) -->Line_4 $$ String[] fields = cidr.split("/")[ FD ]
Line_2 $$ public static long[] cidrMaskToMinMax(String cidr) -->Line_11 $$ byte[] addressBytes[ CD ]
Line_2 $$ public static long[] cidrMaskToMinMax(String cidr) -->Line_24 $$ if (networkMask < 0 || networkMask > 32) [ CD ]
Line_2 $$ public static long[] cidrMaskToMinMax(String cidr) -->Line_18 $$ int networkMask[ CD ]
Line_2 $$ public static long[] cidrMaskToMinMax(String cidr) -->Line_22 $$ throw new IllegalArgumentException(String.format(Locale.ROOT, "invalid IPv4/CIDR; invalid network mask [%s] in [%s]", fields[1], cidr), e)[ FD ]
Line_2 $$ public static long[] cidrMaskToMinMax(String cidr) -->Line_27 $$ long blockSize = 1L << (32 - networkMask)[ CD ]
Line_2 $$ public static long[] cidrMaskToMinMax(String cidr) -->Line_5 $$ if (fields.length != 2) [ CD ]
Line_18 $$ int networkMask-->Line_20 $$ networkMask = Integer.parseInt(fields[1])[ FD ]
Line_4 $$ String[] fields = cidr.split("/")-->Line_9 $$ throw new IllegalArgumentException(String.format(Locale.ROOT, "invalid IPv4/CIDR; expected [a.b.c.d, e] where a, b, c, d are decimal octets but was [%s] after splitting on \"/\" in [%s]", Arrays.toString(fields), cidr))[ FD ]
Line_2 $$ public static long[] cidrMaskToMinMax(String cidr) -->Line_3 $$ Objects.requireNonNull(cidr, "cidr")[ CD ]
Line_18 $$ int networkMask-->Line_29 $$ throw new IllegalArgumentException(String.format(Locale.ROOT, "invalid IPv4/CIDR; invalid address/network mask combination in [%s]; perhaps [%s] was intended?", cidr, octetsToCIDR(longToOctets(accumulator - (accumulator & (blockSize - 1))), networkMask)))[ FD ]
Line_2 $$ public static long[] cidrMaskToMinMax(String cidr) -->Line_4 $$ String[] fields = cidr.split("/")[ CD ]
Line_2 $$ public static long[] cidrMaskToMinMax(String cidr) -->Line_9 $$ throw new IllegalArgumentException(String.format(Locale.ROOT, "invalid IPv4/CIDR; expected [a.b.c.d, e] where a, b, c, d are decimal octets but was [%s] after splitting on \"/\" in [%s]", Arrays.toString(fields), cidr))[ FD ]
Line_20 $$ networkMask = Integer.parseInt(fields[1])-->Line_29 $$ throw new IllegalArgumentException(String.format(Locale.ROOT, "invalid IPv4/CIDR; invalid address/network mask combination in [%s]; perhaps [%s] was intended?", cidr, octetsToCIDR(longToOctets(accumulator - (accumulator & (blockSize - 1))), networkMask)))[ FD ]
Line_11 $$ byte[] addressBytes-->Line_13 $$ addressBytes = InetAddresses.forString(fields[0]).getAddress()[ FD ]
Line_2 $$ public static long[] cidrMaskToMinMax(String cidr) -->Line_6 $$ throw new IllegalArgumentException(String.format(Locale.ROOT, "invalid IPv4/CIDR; expected [a.b.c.d, e] but was [%s] after splitting on \"/\" in [%s]", Arrays.toString(fields), cidr))[ FD ]
Line_4 $$ String[] fields = cidr.split("/")-->Line_6 $$ throw new IllegalArgumentException(String.format(Locale.ROOT, "invalid IPv4/CIDR; expected [a.b.c.d, e] but was [%s] after splitting on \"/\" in [%s]", Arrays.toString(fields), cidr))[ FD ]
Line_2 $$ public static long[] cidrMaskToMinMax(String cidr) -->Line_31 $$ return new long[] [ CD ]
Line_2 $$ public static long[] cidrMaskToMinMax(String cidr) -->Line_25 $$ throw new IllegalArgumentException(String.format(Locale.ROOT, "invalid IPv4/CIDR; invalid network mask [%s], out of range in [%s]", fields[1], cidr))[ FD ]
Line_2 $$ public static long[] cidrMaskToMinMax(String cidr) -->Line_17 $$ long accumulator = ((addressBytes[0] & 0xFFL) << 24) + ((addressBytes[1] & 0xFFL) << 16) + ((addressBytes[2] & 0xFFL) << 8) + ((addressBytes[3] & 0xFFL))[ CD ]
Line_2 $$ public static long[] cidrMaskToMinMax(String cidr) -->Line_29 $$ throw new IllegalArgumentException(String.format(Locale.ROOT, "invalid IPv4/CIDR; invalid address/network mask combination in [%s]; perhaps [%s] was intended?", cidr, octetsToCIDR(longToOctets(accumulator - (accumulator & (blockSize - 1))), networkMask)))[ FD ]
Line_2 $$ public static long[] cidrMaskToMinMax(String cidr) -->Line_3 $$ Objects.requireNonNull(cidr, "cidr")[ FD ]
Line_2 $$ public static long[] cidrMaskToMinMax(String cidr) -->Line_28 $$ if ((accumulator & (blockSize - 1)) != 0) [ CD ]
