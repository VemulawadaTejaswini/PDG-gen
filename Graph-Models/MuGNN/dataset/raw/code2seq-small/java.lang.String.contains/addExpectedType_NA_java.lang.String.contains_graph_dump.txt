Line_2 $$ private LookupElement addExpectedType(final PsiType type, final CompletionParameters parameters) -->Line_29 $$ if (inferenceResult.getErrorMessage() == null && !psiClass.hasModifierProperty(PsiModifier.ABSTRACT) && areInferredTypesApplicable(inferenceResult.getTypes(), parameters.getPosition())) [ FD ]
Line_37 $$ final PsiTypeLookupItem item = PsiTypeLookupItem.createLookupItem(psiType, position).setShowPackage()-->Line_40 $$ item.setIndicateAnonymous(true)[ FD ]
Line_12 $$ PsiType psiType = GenericsUtil.eliminateWildcards(type)-->Line_19 $$ LOG.error("Malformed canonical text: " + canonicalText + "; presentable text: " + psiType + " of " + psiType.getClass() + "; " + (psiType instanceof PsiClassReferenceType ? ((PsiClassReferenceType) psiType).getReference().getClass() : ""))[ FD ]
Line_2 $$ private LookupElement addExpectedType(final PsiType type, final CompletionParameters parameters) -->Line_12 $$ PsiType psiType = GenericsUtil.eliminateWildcards(type)[ CD ]
Line_15 $$ if (psiClass.hasTypeParameters() && !((PsiClassType) type).isRaw()) -->Line_17 $$ String canonicalText = psiType.getCanonicalText()[ CD ]
Line_37 $$ final PsiTypeLookupItem item = PsiTypeLookupItem.createLookupItem(psiType, position).setShowPackage()-->Line_39 $$ item.setAutoCompletionPolicy(AutoCompletionPolicy.NEVER_AUTOCOMPLETE)[ FD ]
Line_8 $$ PsiElement position = parameters.getPosition()-->Line_37 $$ final PsiTypeLookupItem item = PsiTypeLookupItem.createLookupItem(psiType, position).setShowPackage()[ FD ]
Line_5 $$ final PsiClass psiClass = PsiUtil.resolveClassInType(type)-->Line_15 $$ if (psiClass.hasTypeParameters() && !((PsiClassType) type).isRaw()) [ FD ]
Line_17 $$ String canonicalText = psiType.getCanonicalText()-->Line_18 $$ if (canonicalText.contains("?extends") || canonicalText.contains("?super")) [ FD ]
Line_13 $$ if (JavaSmartCompletionContributor.AFTER_NEW.accepts(parameters.getOriginalPosition()) && PsiUtil.getLanguageLevel(parameters.getOriginalFile()).isAtLeast(LanguageLevel.JDK_1_7)) -->Line_14 $$ final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(psiClass.getProject())[ CD ]
Line_2 $$ private LookupElement addExpectedType(final PsiType type, final CompletionParameters parameters) -->Line_23 $$ final PsiStatement statement = elementFactory.createStatementFromText(canonicalText + " v = new " + erasedText + "<>()", parameters.getOriginalFile())[ FD ]
Line_2 $$ private LookupElement addExpectedType(final PsiType type, final CompletionParameters parameters) -->Line_5 $$ final PsiClass psiClass = PsiUtil.resolveClassInType(type)[ CD ]
Line_5 $$ final PsiClass psiClass = PsiUtil.resolveClassInType(type)-->Line_26 $$ final boolean hasDefaultConstructorOrNoGenericsOne = PsiDiamondTypeImpl.hasDefaultConstructor(psiClass) || !PsiDiamondTypeImpl.haveConstructorsGenericsParameters(psiClass)[ FD ]
Line_37 $$ final PsiTypeLookupItem item = PsiTypeLookupItem.createLookupItem(psiType, position).setShowPackage()-->Line_42 $$ return LookupElementDecorator.withInsertHandler(item, myConstructorInsertHandler)[ FD ]
Line_2 $$ private LookupElement addExpectedType(final PsiType type, final CompletionParameters parameters) -->Line_37 $$ final PsiTypeLookupItem item = PsiTypeLookupItem.createLookupItem(psiType, position).setShowPackage()[ CD ]
Line_12 $$ PsiType psiType = GenericsUtil.eliminateWildcards(type)-->Line_16 $$ final String erasedText = TypeConversionUtil.erasure(psiType).getCanonicalText()[ FD ]
Line_30 $$ psiType = initializer.getType()-->Line_37 $$ final PsiTypeLookupItem item = PsiTypeLookupItem.createLookupItem(psiType, position).setShowPackage()[ FD ]
Line_2 $$ private LookupElement addExpectedType(final PsiType type, final CompletionParameters parameters) -->Line_13 $$ if (JavaSmartCompletionContributor.AFTER_NEW.accepts(parameters.getOriginalPosition()) && PsiUtil.getLanguageLevel(parameters.getOriginalFile()).isAtLeast(LanguageLevel.JDK_1_7)) [ CD ]
Line_2 $$ private LookupElement addExpectedType(final PsiType type, final CompletionParameters parameters) -->Line_5 $$ final PsiClass psiClass = PsiUtil.resolveClassInType(type)[ FD ]
Line_25 $$ final PsiNewExpression initializer = (PsiNewExpression) declaredVar.getInitializer()-->Line_30 $$ psiType = initializer.getType()[ FD ]
Line_2 $$ private LookupElement addExpectedType(final PsiType type, final CompletionParameters parameters) -->Line_3 $$ if (!JavaCompletionUtil.hasAccessibleConstructor(type))[ CD ]
Line_2 $$ private LookupElement addExpectedType(final PsiType type, final CompletionParameters parameters) -->Line_9 $$ if ((parameters.getInvocationCount() < 2 || psiClass instanceof PsiCompiledElement) && HighlightClassUtil.checkCreateInnerClassFromStaticContext(position, null, psiClass) != null && !psiElement().afterLeaf(psiElement().withText(PsiKeyword.NEW).afterLeaf(".")).accepts(position)) [ FD ]
Line_13 $$ if (JavaSmartCompletionContributor.AFTER_NEW.accepts(parameters.getOriginalPosition()) && PsiUtil.getLanguageLevel(parameters.getOriginalFile()).isAtLeast(LanguageLevel.JDK_1_7)) -->Line_15 $$ if (psiClass.hasTypeParameters() && !((PsiClassType) type).isRaw()) [ CD ]
Line_18 $$ if (canonicalText.contains("?extends") || canonicalText.contains("?super")) -->Line_19 $$ LOG.error("Malformed canonical text: " + canonicalText + "; presentable text: " + psiType + " of " + psiType.getClass() + "; " + (psiType instanceof PsiClassReferenceType ? ((PsiClassReferenceType) psiType).getReference().getClass() : ""))[ CD ]
Line_2 $$ private LookupElement addExpectedType(final PsiType type, final CompletionParameters parameters) -->Line_13 $$ if (JavaSmartCompletionContributor.AFTER_NEW.accepts(parameters.getOriginalPosition()) && PsiUtil.getLanguageLevel(parameters.getOriginalFile()).isAtLeast(LanguageLevel.JDK_1_7)) [ FD ]
Line_27 $$ if (hasDefaultConstructorOrNoGenericsOne) -->Line_29 $$ if (inferenceResult.getErrorMessage() == null && !psiClass.hasModifierProperty(PsiModifier.ABSTRACT) && areInferredTypesApplicable(inferenceResult.getTypes(), parameters.getPosition())) [ CD ]
Line_12 $$ PsiType psiType = GenericsUtil.eliminateWildcards(type)-->Line_17 $$ String canonicalText = psiType.getCanonicalText()[ FD ]
Line_5 $$ final PsiClass psiClass = PsiUtil.resolveClassInType(type)-->Line_14 $$ final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(psiClass.getProject())[ FD ]
Line_12 $$ PsiType psiType = GenericsUtil.eliminateWildcards(type)-->Line_37 $$ final PsiTypeLookupItem item = PsiTypeLookupItem.createLookupItem(psiType, position).setShowPackage()[ FD ]
Line_14 $$ final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(psiClass.getProject())-->Line_23 $$ final PsiStatement statement = elementFactory.createStatementFromText(canonicalText + " v = new " + erasedText + "<>()", parameters.getOriginalFile())[ FD ]
Line_15 $$ if (psiClass.hasTypeParameters() && !((PsiClassType) type).isRaw()) -->Line_18 $$ if (canonicalText.contains("?extends") || canonicalText.contains("?super")) [ CD ]
Line_5 $$ final PsiClass psiClass = PsiUtil.resolveClassInType(type)-->Line_6 $$ if (psiClass == null || psiClass.getName() == null)[ FD ]
Line_2 $$ private LookupElement addExpectedType(final PsiType type, final CompletionParameters parameters) -->Line_6 $$ if (psiClass == null || psiClass.getName() == null)[ CD ]
Line_25 $$ final PsiNewExpression initializer = (PsiNewExpression) declaredVar.getInitializer()-->Line_28 $$ final PsiDiamondTypeImpl.DiamondInferenceResult inferenceResult = PsiDiamondTypeImpl.resolveInferredTypes(initializer)[ FD ]
Line_6 $$ if (psiClass == null || psiClass.getName() == null)-->Line_7 $$ return null[ CD ]
Line_5 $$ final PsiClass psiClass = PsiUtil.resolveClassInType(type)-->Line_38 $$ if (psiClass.isInterface() || psiClass.hasModifierProperty(PsiModifier.ABSTRACT)) [ FD ]
Line_38 $$ if (psiClass.isInterface() || psiClass.hasModifierProperty(PsiModifier.ABSTRACT)) -->Line_40 $$ item.setIndicateAnonymous(true)[ CD ]
Line_38 $$ if (psiClass.isInterface() || psiClass.hasModifierProperty(PsiModifier.ABSTRACT)) -->Line_39 $$ item.setAutoCompletionPolicy(AutoCompletionPolicy.NEVER_AUTOCOMPLETE)[ CD ]
Line_2 $$ private LookupElement addExpectedType(final PsiType type, final CompletionParameters parameters) -->Line_12 $$ PsiType psiType = GenericsUtil.eliminateWildcards(type)[ FD ]
Line_2 $$ private LookupElement addExpectedType(final PsiType type, final CompletionParameters parameters) -->Line_8 $$ PsiElement position = parameters.getPosition()[ CD ]
Line_18 $$ if (canonicalText.contains("?extends") || canonicalText.contains("?super")) -->Line_20 $$ return null[ CD ]
Line_2 $$ private LookupElement addExpectedType(final PsiType type, final CompletionParameters parameters) -->Line_9 $$ if ((parameters.getInvocationCount() < 2 || psiClass instanceof PsiCompiledElement) && HighlightClassUtil.checkCreateInnerClassFromStaticContext(position, null, psiClass) != null && !psiElement().afterLeaf(psiElement().withText(PsiKeyword.NEW).afterLeaf(".")).accepts(position)) [ CD ]
Line_15 $$ if (psiClass.hasTypeParameters() && !((PsiClassType) type).isRaw()) -->Line_16 $$ final String erasedText = TypeConversionUtil.erasure(psiType).getCanonicalText()[ CD ]
Line_5 $$ final PsiClass psiClass = PsiUtil.resolveClassInType(type)-->Line_29 $$ if (inferenceResult.getErrorMessage() == null && !psiClass.hasModifierProperty(PsiModifier.ABSTRACT) && areInferredTypesApplicable(inferenceResult.getTypes(), parameters.getPosition())) [ FD ]
Line_2 $$ private LookupElement addExpectedType(final PsiType type, final CompletionParameters parameters) -->Line_38 $$ if (psiClass.isInterface() || psiClass.hasModifierProperty(PsiModifier.ABSTRACT)) [ CD ]
Line_2 $$ private LookupElement addExpectedType(final PsiType type, final CompletionParameters parameters) -->Line_42 $$ return LookupElementDecorator.withInsertHandler(item, myConstructorInsertHandler)[ CD ]
Line_2 $$ private LookupElement addExpectedType(final PsiType type, final CompletionParameters parameters) -->Line_3 $$ if (!JavaCompletionUtil.hasAccessibleConstructor(type))[ FD ]
Line_24 $$ final PsiVariable declaredVar = (PsiVariable) ((PsiDeclarationStatement) statement).getDeclaredElements()[0]-->Line_25 $$ final PsiNewExpression initializer = (PsiNewExpression) declaredVar.getInitializer()[ FD ]
Line_9 $$ if ((parameters.getInvocationCount() < 2 || psiClass instanceof PsiCompiledElement) && HighlightClassUtil.checkCreateInnerClassFromStaticContext(position, null, psiClass) != null && !psiElement().afterLeaf(psiElement().withText(PsiKeyword.NEW).afterLeaf(".")).accepts(position)) -->Line_10 $$ return null[ CD ]
Line_28 $$ final PsiDiamondTypeImpl.DiamondInferenceResult inferenceResult = PsiDiamondTypeImpl.resolveInferredTypes(initializer)-->Line_29 $$ if (inferenceResult.getErrorMessage() == null && !psiClass.hasModifierProperty(PsiModifier.ABSTRACT) && areInferredTypesApplicable(inferenceResult.getTypes(), parameters.getPosition())) [ FD ]
Line_8 $$ PsiElement position = parameters.getPosition()-->Line_9 $$ if ((parameters.getInvocationCount() < 2 || psiClass instanceof PsiCompiledElement) && HighlightClassUtil.checkCreateInnerClassFromStaticContext(position, null, psiClass) != null && !psiElement().afterLeaf(psiElement().withText(PsiKeyword.NEW).afterLeaf(".")).accepts(position)) [ FD ]
Line_12 $$ PsiType psiType = GenericsUtil.eliminateWildcards(type)-->Line_30 $$ psiType = initializer.getType()[ FD ]
Line_27 $$ if (hasDefaultConstructorOrNoGenericsOne) -->Line_28 $$ final PsiDiamondTypeImpl.DiamondInferenceResult inferenceResult = PsiDiamondTypeImpl.resolveInferredTypes(initializer)[ CD ]
Line_29 $$ if (inferenceResult.getErrorMessage() == null && !psiClass.hasModifierProperty(PsiModifier.ABSTRACT) && areInferredTypesApplicable(inferenceResult.getTypes(), parameters.getPosition())) -->Line_30 $$ psiType = initializer.getType()[ CD ]
Line_2 $$ private LookupElement addExpectedType(final PsiType type, final CompletionParameters parameters) -->Line_8 $$ PsiElement position = parameters.getPosition()[ FD ]
Line_3 $$ if (!JavaCompletionUtil.hasAccessibleConstructor(type))-->Line_4 $$ return null[ CD ]
Line_5 $$ final PsiClass psiClass = PsiUtil.resolveClassInType(type)-->Line_9 $$ if ((parameters.getInvocationCount() < 2 || psiClass instanceof PsiCompiledElement) && HighlightClassUtil.checkCreateInnerClassFromStaticContext(position, null, psiClass) != null && !psiElement().afterLeaf(psiElement().withText(PsiKeyword.NEW).afterLeaf(".")).accepts(position)) [ FD ]
