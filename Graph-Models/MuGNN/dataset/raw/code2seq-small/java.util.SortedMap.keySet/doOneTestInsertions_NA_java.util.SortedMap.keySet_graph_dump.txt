Line_10 $$ for (int i = 0; i < iterations; i++) -->Line_36 $$ if (quickEquality)[ CD ]
Line_7 $$ Object[] btree = BTree.empty()-->Line_32 $$ if (!BTree.isWellFormed(btree, naturalOrder())) [ FD ]
Line_2 $$ private static ListenableFutureTask<List<ListenableFuture<?>>> doOneTestInsertions(final int upperBound, final int maxRunLength, final int averageModsPerIteration, final int iterations, final boolean quickEquality) -->Line_44 $$ if (DEBUG)[ CD ]
Line_14 $$ int v = rnd.nextInt(upperBound)-->Line_19 $$ v++[ FD ]
Line_36 $$ if (quickEquality)-->Line_39 $$ r.addAll(testAllSlices("RND", btree, new TreeSet(canon.keySet())))[ CD ]
Line_3 $$ ListenableFutureTask<List<ListenableFuture<?>>> f = ListenableFutureTask.create(new Callable<List<ListenableFuture<?>>>() -->Line_47 $$ MODIFY.execute(f)[ FD ]
Line_9 $$ ThreadLocalRandom rnd = ThreadLocalRandom.current()-->Line_14 $$ int v = rnd.nextInt(upperBound)[ FD ]
Line_6 $$ NavigableMap<Integer, Integer> canon = new TreeMap()-->Line_39 $$ r.addAll(testAllSlices("RND", btree, new TreeSet(canon.keySet())))[ FD ]
Line_14 $$ int v = rnd.nextInt(upperBound)-->Line_18 $$ buffer.put(v, v)[ FD ]
Line_8 $$ final TreeMap<Integer, Integer> buffer = new TreeMap()-->Line_29 $$ next = BTree.update(btree, naturalOrder(), buffer.keySet(), SPORADIC_ABORT)[ FD ]
Line_44 $$ if (DEBUG)-->Line_47 $$ MODIFY.execute(f)[ CD ]
Line_13 $$ while (mods > 0) -->Line_16 $$ int c = 1 + (rc <= 0 ? 0 : rnd.nextInt(rc))[ CD ]
Line_10 $$ for (int i = 0; i < iterations; i++) -->Line_26 $$ ctxt.stop()[ CD ]
Line_3 $$ ListenableFutureTask<List<ListenableFuture<?>>> f = ListenableFutureTask.create(new Callable<List<ListenableFuture<?>>>() -->Line_7 $$ Object[] btree = BTree.empty()[ CD ]
Line_13 $$ while (mods > 0) -->Line_14 $$ int v = rnd.nextInt(upperBound)[ CD ]
Line_6 $$ NavigableMap<Integer, Integer> canon = new TreeMap()-->Line_25 $$ canon.putAll(buffer)[ FD ]
Line_2 $$ private static ListenableFutureTask<List<ListenableFuture<?>>> doOneTestInsertions(final int upperBound, final int maxRunLength, final int averageModsPerIteration, final int iterations, final boolean quickEquality) -->Line_14 $$ int v = rnd.nextInt(upperBound)[ FD ]
Line_30 $$ btree = next-->Line_39 $$ r.addAll(testAllSlices("RND", btree, new TreeSet(canon.keySet())))[ FD ]
Line_3 $$ ListenableFutureTask<List<ListenableFuture<?>>> f = ListenableFutureTask.create(new Callable<List<ListenableFuture<?>>>() -->Line_45 $$ f.run()[ FD ]
Line_10 $$ for (int i = 0; i < iterations; i++) -->Line_13 $$ while (mods > 0) [ CD ]
Line_2 $$ private static ListenableFutureTask<List<ListenableFuture<?>>> doOneTestInsertions(final int upperBound, final int maxRunLength, final int averageModsPerIteration, final int iterations, final boolean quickEquality) -->Line_3 $$ ListenableFutureTask<List<ListenableFuture<?>>> f = ListenableFutureTask.create(new Callable<List<ListenableFuture<?>>>() [ CD ]
Line_5 $$ final List<ListenableFuture<?>> r = new ArrayList()-->Line_39 $$ r.addAll(testAllSlices("RND", btree, new TreeSet(canon.keySet())))[ FD ]
Line_2 $$ private static ListenableFutureTask<List<ListenableFuture<?>>> doOneTestInsertions(final int upperBound, final int maxRunLength, final int averageModsPerIteration, final int iterations, final boolean quickEquality) -->Line_10 $$ for (int i = 0; i < iterations; i++) [ FD ]
Line_30 $$ btree = next-->Line_37 $$ testEqual("", BTree.iterator(btree), canon.keySet().iterator())[ FD ]
Line_3 $$ ListenableFutureTask<List<ListenableFuture<?>>> f = ListenableFutureTask.create(new Callable<List<ListenableFuture<?>>>() -->Line_41 $$ return r[ CD ]
Line_2 $$ private static ListenableFutureTask<List<ListenableFuture<?>>> doOneTestInsertions(final int upperBound, final int maxRunLength, final int averageModsPerIteration, final int iterations, final boolean quickEquality) -->Line_15 $$ int rc = Math.max(0, Math.min(mods, maxRunLength) - 1)[ FD ]
Line_44 $$ if (DEBUG)-->Line_45 $$ f.run()[ CD ]
Line_7 $$ Object[] btree = BTree.empty()-->Line_29 $$ next = BTree.update(btree, naturalOrder(), buffer.keySet(), SPORADIC_ABORT)[ FD ]
Line_7 $$ Object[] btree = BTree.empty()-->Line_30 $$ btree = next[ FD ]
Line_10 $$ for (int i = 0; i < iterations; i++) -->Line_11 $$ buffer.clear()[ CD ]
Line_12 $$ int mods = rnd.nextInt(1, averageModsPerIteration * 2)-->Line_15 $$ int rc = Math.max(0, Math.min(mods, maxRunLength) - 1)[ FD ]
Line_12 $$ int mods = rnd.nextInt(1, averageModsPerIteration * 2)-->Line_13 $$ while (mods > 0) [ FD ]
Line_3 $$ ListenableFutureTask<List<ListenableFuture<?>>> f = ListenableFutureTask.create(new Callable<List<ListenableFuture<?>>>() -->Line_5 $$ final List<ListenableFuture<?>> r = new ArrayList()[ CD ]
Line_10 $$ for (int i = 0; i < iterations; i++) -->Line_31 $$ ctxt.stop()[ CD ]
Line_13 $$ while (mods > 0) -->Line_21 $$ mods -= c[ CD ]
Line_8 $$ final TreeMap<Integer, Integer> buffer = new TreeMap()-->Line_18 $$ buffer.put(v, v)[ FD ]
Line_9 $$ ThreadLocalRandom rnd = ThreadLocalRandom.current()-->Line_16 $$ int c = 1 + (rc <= 0 ? 0 : rnd.nextInt(rc))[ FD ]
Line_32 $$ if (!BTree.isWellFormed(btree, naturalOrder())) -->Line_33 $$ log("ERROR: Not well formed")[ CD ]
Line_3 $$ ListenableFutureTask<List<ListenableFuture<?>>> f = ListenableFutureTask.create(new Callable<List<ListenableFuture<?>>>() -->Line_10 $$ for (int i = 0; i < iterations; i++) [ CD ]
Line_36 $$ if (quickEquality)-->Line_37 $$ testEqual("", BTree.iterator(btree), canon.keySet().iterator())[ CD ]
Line_6 $$ NavigableMap<Integer, Integer> canon = new TreeMap()-->Line_37 $$ testEqual("", BTree.iterator(btree), canon.keySet().iterator())[ FD ]
Line_21 $$ mods -= c-->Line_13 $$ while (mods > 0) [ FD ]
Line_10 $$ for (int i = 0; i < iterations; i++) -->Line_32 $$ if (!BTree.isWellFormed(btree, naturalOrder())) [ CD ]
Line_15 $$ int rc = Math.max(0, Math.min(mods, maxRunLength) - 1)-->Line_16 $$ int c = 1 + (rc <= 0 ? 0 : rnd.nextInt(rc))[ FD ]
Line_13 $$ while (mods > 0) -->Line_17 $$ for (int j = 0; j < c; j++) [ CD ]
Line_3 $$ ListenableFutureTask<List<ListenableFuture<?>>> f = ListenableFutureTask.create(new Callable<List<ListenableFuture<?>>>() -->Line_6 $$ NavigableMap<Integer, Integer> canon = new TreeMap()[ CD ]
Line_7 $$ Object[] btree = BTree.empty()-->Line_39 $$ r.addAll(testAllSlices("RND", btree, new TreeSet(canon.keySet())))[ FD ]
Line_10 $$ for (int i = 0; i < iterations; i++) -->Line_27 $$ ctxt = BTREE_TIMER.time()[ CD ]
Line_17 $$ for (int j = 0; j < c; j++) -->Line_18 $$ buffer.put(v, v)[ CD ]
Line_10 $$ for (int i = 0; i < iterations; i++) -->Line_25 $$ canon.putAll(buffer)[ CD ]
Line_8 $$ final TreeMap<Integer, Integer> buffer = new TreeMap()-->Line_11 $$ buffer.clear()[ FD ]
Line_17 $$ for (int j = 0; j < c; j++) -->Line_19 $$ v++[ CD ]
Line_3 $$ ListenableFutureTask<List<ListenableFuture<?>>> f = ListenableFutureTask.create(new Callable<List<ListenableFuture<?>>>() -->Line_9 $$ ThreadLocalRandom rnd = ThreadLocalRandom.current()[ CD ]
Line_10 $$ for (int i = 0; i < iterations; i++) -->Line_12 $$ int mods = rnd.nextInt(1, averageModsPerIteration * 2)[ CD ]
Line_10 $$ for (int i = 0; i < iterations; i++) -->Line_30 $$ btree = next[ CD ]
Line_7 $$ Object[] btree = BTree.empty()-->Line_37 $$ testEqual("", BTree.iterator(btree), canon.keySet().iterator())[ FD ]
Line_13 $$ while (mods > 0) -->Line_15 $$ int rc = Math.max(0, Math.min(mods, maxRunLength) - 1)[ CD ]
Line_21 $$ mods -= c-->Line_15 $$ int rc = Math.max(0, Math.min(mods, maxRunLength) - 1)[ FD ]
Line_16 $$ int c = 1 + (rc <= 0 ? 0 : rnd.nextInt(rc))-->Line_17 $$ for (int j = 0; j < c; j++) [ FD ]
Line_3 $$ ListenableFutureTask<List<ListenableFuture<?>>> f = ListenableFutureTask.create(new Callable<List<ListenableFuture<?>>>() -->Line_8 $$ final TreeMap<Integer, Integer> buffer = new TreeMap()[ CD ]
Line_2 $$ private static ListenableFutureTask<List<ListenableFuture<?>>> doOneTestInsertions(final int upperBound, final int maxRunLength, final int averageModsPerIteration, final int iterations, final boolean quickEquality) -->Line_48 $$ return f[ CD ]
Line_12 $$ int mods = rnd.nextInt(1, averageModsPerIteration * 2)-->Line_21 $$ mods -= c[ FD ]
Line_9 $$ ThreadLocalRandom rnd = ThreadLocalRandom.current()-->Line_12 $$ int mods = rnd.nextInt(1, averageModsPerIteration * 2)[ FD ]
Line_10 $$ for (int i = 0; i < iterations; i++) -->Line_24 $$ ctxt = TREE_TIMER.time()[ CD ]
Line_8 $$ final TreeMap<Integer, Integer> buffer = new TreeMap()-->Line_25 $$ canon.putAll(buffer)[ FD ]
Line_30 $$ btree = next-->Line_32 $$ if (!BTree.isWellFormed(btree, naturalOrder())) [ FD ]
Line_10 $$ for (int i = 0; i < iterations; i++) -->Line_29 $$ while (next == null) next = BTree.update(btree, naturalOrder(), buffer.keySet(), SPORADIC_ABORT)[ CD ]
Line_16 $$ int c = 1 + (rc <= 0 ? 0 : rnd.nextInt(rc))-->Line_21 $$ mods -= c[ FD ]
