Line_5 $$ ThreadLocalRandom random = ThreadLocalRandom.current()-->Line_11 $$ int nextSize = maxModificationSize == 1 ? 1 : random.nextInt(1, maxModificationSize)[ FD ]
Line_13 $$ for (int i = 0; i < nextSize; i++) -->Line_16 $$ canonical.add(next)[ CD ]
Line_4 $$ TreeSet<Integer> canonical = new TreeSet()-->Line_16 $$ canonical.add(next)[ FD ]
Line_10 $$ while (curSize < targetSize) -->Line_20 $$ maxModificationSize = Math.min(maxModificationSize, targetSize - curSize)[ CD ]
Line_5 $$ ThreadLocalRandom random = ThreadLocalRandom.current()-->Line_14 $$ Integer next = random.nextInt()[ FD ]
Line_2 $$ private static RandomTree randomTreeByUpdate(int minSize, int maxSize) -->Line_6 $$ int targetSize = random.nextInt(minSize, maxSize)[ CD ]
Line_12 $$ TreeSet<Integer> build = new TreeSet()-->Line_18 $$ accmumulate = BTree.update(accmumulate, naturalOrder(), build, UpdateFunction.<Integer>noOp())[ FD ]
Line_9 $$ int curSize = 0-->Line_19 $$ curSize += nextSize[ FD ]
Line_14 $$ Integer next = random.nextInt()-->Line_15 $$ build.add(next)[ FD ]
Line_9 $$ int curSize = 0-->Line_10 $$ while (curSize < targetSize) [ FD ]
Line_2 $$ private static RandomTree randomTreeByUpdate(int minSize, int maxSize) -->Line_10 $$ while (curSize < targetSize) [ CD ]
Line_13 $$ for (int i = 0; i < nextSize; i++) -->Line_15 $$ build.add(next)[ CD ]
Line_2 $$ private static RandomTree randomTreeByUpdate(int minSize, int maxSize) -->Line_6 $$ int targetSize = random.nextInt(minSize, maxSize)[ FD ]
Line_11 $$ int nextSize = maxModificationSize == 1 ? 1 : random.nextInt(1, maxModificationSize)-->Line_13 $$ for (int i = 0; i < nextSize; i++) [ FD ]
Line_13 $$ for (int i = 0; i < nextSize; i++) -->Line_14 $$ Integer next = random.nextInt()[ CD ]
Line_8 $$ Object[] accmumulate = BTree.empty()-->Line_18 $$ accmumulate = BTree.update(accmumulate, naturalOrder(), build, UpdateFunction.<Integer>noOp())[ FD ]
Line_7 $$ int maxModificationSize = random.nextInt(2, targetSize)-->Line_20 $$ maxModificationSize = Math.min(maxModificationSize, targetSize - curSize)[ FD ]
Line_10 $$ while (curSize < targetSize) -->Line_19 $$ curSize += nextSize[ CD ]
Line_20 $$ maxModificationSize = Math.min(maxModificationSize, targetSize - curSize)-->Line_11 $$ int nextSize = maxModificationSize == 1 ? 1 : random.nextInt(1, maxModificationSize)[ FD ]
Line_6 $$ int targetSize = random.nextInt(minSize, maxSize)-->Line_10 $$ while (curSize < targetSize) [ FD ]
Line_2 $$ private static RandomTree randomTreeByUpdate(int minSize, int maxSize) -->Line_22 $$ return new RandomTree(canonical, BTreeSet.<Integer>wrap(accmumulate, naturalOrder()))[ CD ]
Line_19 $$ curSize += nextSize-->Line_10 $$ while (curSize < targetSize) [ FD ]
Line_7 $$ int maxModificationSize = random.nextInt(2, targetSize)-->Line_11 $$ int nextSize = maxModificationSize == 1 ? 1 : random.nextInt(1, maxModificationSize)[ FD ]
Line_12 $$ TreeSet<Integer> build = new TreeSet()-->Line_15 $$ build.add(next)[ FD ]
Line_10 $$ while (curSize < targetSize) -->Line_11 $$ int nextSize = maxModificationSize == 1 ? 1 : random.nextInt(1, maxModificationSize)[ CD ]
Line_6 $$ int targetSize = random.nextInt(minSize, maxSize)-->Line_7 $$ int maxModificationSize = random.nextInt(2, targetSize)[ FD ]
Line_10 $$ while (curSize < targetSize) -->Line_12 $$ TreeSet<Integer> build = new TreeSet()[ CD ]
Line_2 $$ private static RandomTree randomTreeByUpdate(int minSize, int maxSize) -->Line_8 $$ Object[] accmumulate = BTree.empty()[ CD ]
Line_5 $$ ThreadLocalRandom random = ThreadLocalRandom.current()-->Line_7 $$ int maxModificationSize = random.nextInt(2, targetSize)[ FD ]
Line_2 $$ private static RandomTree randomTreeByUpdate(int minSize, int maxSize) -->Line_9 $$ int curSize = 0[ CD ]
Line_2 $$ private static RandomTree randomTreeByUpdate(int minSize, int maxSize) -->Line_5 $$ ThreadLocalRandom random = ThreadLocalRandom.current()[ CD ]
Line_2 $$ private static RandomTree randomTreeByUpdate(int minSize, int maxSize) -->Line_4 $$ TreeSet<Integer> canonical = new TreeSet()[ CD ]
Line_10 $$ while (curSize < targetSize) -->Line_18 $$ accmumulate = BTree.update(accmumulate, naturalOrder(), build, UpdateFunction.<Integer>noOp())[ CD ]
Line_2 $$ private static RandomTree randomTreeByUpdate(int minSize, int maxSize) -->Line_7 $$ int maxModificationSize = random.nextInt(2, targetSize)[ CD ]
Line_10 $$ while (curSize < targetSize) -->Line_13 $$ for (int i = 0; i < nextSize; i++) [ CD ]
Line_14 $$ Integer next = random.nextInt()-->Line_16 $$ canonical.add(next)[ FD ]
Line_5 $$ ThreadLocalRandom random = ThreadLocalRandom.current()-->Line_6 $$ int targetSize = random.nextInt(minSize, maxSize)[ FD ]
Line_11 $$ int nextSize = maxModificationSize == 1 ? 1 : random.nextInt(1, maxModificationSize)-->Line_19 $$ curSize += nextSize[ FD ]
Line_8 $$ Object[] accmumulate = BTree.empty()-->Line_22 $$ return new RandomTree(canonical, BTreeSet.<Integer>wrap(accmumulate, naturalOrder()))[ FD ]
Line_18 $$ accmumulate = BTree.update(accmumulate, naturalOrder(), build, UpdateFunction.<Integer>noOp())-->Line_22 $$ return new RandomTree(canonical, BTreeSet.<Integer>wrap(accmumulate, naturalOrder()))[ FD ]
