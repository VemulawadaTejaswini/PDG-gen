Line_7 $$ int maxModificationSize = (int) Math.sqrt(targetSize)-->Line_13 $$ int nextSize = maxModificationSize <= 1 ? 1 : random.nextInt(1, maxModificationSize)[ FD ]
Line_4 $$ ThreadLocalRandom random = ThreadLocalRandom.current()-->Line_14 $$ (random.nextBoolean() ? ordered.headSet(random.nextInt()) : ordered.tailSet(random.nextInt())).clear()[ FD ]
Line_8 $$ TreeSet<Integer> canonical = new TreeSet()-->Line_41 $$ Assert.assertEquals(canonical.size(), btree.size())[ FD ]
Line_2 $$ private static RandomTree randomTreeByBuilder(int minSize, int maxSize) -->Line_42 $$ return new RandomTree(canonical, btree)[ CD ]
Line_2 $$ private static RandomTree randomTreeByBuilder(int minSize, int maxSize) -->Line_6 $$ int targetSize = random.nextInt(minSize, maxSize)[ FD ]
Line_4 $$ ThreadLocalRandom random = ThreadLocalRandom.current()-->Line_15 $$ shuffled = new ArrayList(shuffled.subList(0, shuffled.size() < 2 ? 0 : random.nextInt(shuffled.size() / 2)))[ FD ]
Line_12 $$ while (curSize < targetSize) -->Line_38 $$ maxModificationSize = Math.min(maxModificationSize, targetSize - curSize)[ CD ]
Line_16 $$ for (int i = 0; i < nextSize; i++) -->Line_18 $$ ordered.add(next)[ CD ]
Line_12 $$ while (curSize < targetSize) -->Line_15 $$ shuffled = new ArrayList(shuffled.subList(0, shuffled.size() < 2 ? 0 : random.nextInt(shuffled.size() / 2)))[ CD ]
Line_4 $$ ThreadLocalRandom random = ThreadLocalRandom.current()-->Line_13 $$ int nextSize = maxModificationSize <= 1 ? 1 : random.nextInt(1, maxModificationSize)[ FD ]
Line_10 $$ TreeSet<Integer> ordered = new TreeSet()-->Line_14 $$ (random.nextBoolean() ? ordered.headSet(random.nextInt()) : ordered.tailSet(random.nextInt())).clear()[ FD ]
Line_11 $$ List<Integer> shuffled = new ArrayList()-->Line_32 $$ builder.addAll(shuffled)[ FD ]
Line_38 $$ maxModificationSize = Math.min(maxModificationSize, targetSize - curSize)-->Line_13 $$ int nextSize = maxModificationSize <= 1 ? 1 : random.nextInt(1, maxModificationSize)[ FD ]
Line_9 $$ int curSize = 0-->Line_12 $$ while (curSize < targetSize) [ FD ]
Line_16 $$ for (int i = 0; i < nextSize; i++) -->Line_35 $$ builder.add(i)[ FD ]
Line_5 $$ BTree.Builder<Integer> builder = BTree.builder(naturalOrder())-->Line_27 $$ builder.addAll(BTreeSet.of(ordered))[ FD ]
Line_11 $$ List<Integer> shuffled = new ArrayList()-->Line_19 $$ shuffled.add(next)[ FD ]
Line_12 $$ while (curSize < targetSize) -->Line_13 $$ int nextSize = maxModificationSize <= 1 ? 1 : random.nextInt(1, maxModificationSize)[ CD ]
Line_12 $$ while (curSize < targetSize) -->Line_14 $$ (random.nextBoolean() ? ordered.headSet(random.nextInt()) : ordered.tailSet(random.nextInt())).clear()[ CD ]
Line_11 $$ List<Integer> shuffled = new ArrayList()-->Line_15 $$ shuffled = new ArrayList(shuffled.subList(0, shuffled.size() < 2 ? 0 : random.nextInt(shuffled.size() / 2)))[ FD ]
Line_16 $$ for (int i = 0; i < nextSize; i++) -->Line_20 $$ canonical.add(next)[ CD ]
Line_2 $$ private static RandomTree randomTreeByBuilder(int minSize, int maxSize) -->Line_9 $$ int curSize = 0[ CD ]
Line_2 $$ private static RandomTree randomTreeByBuilder(int minSize, int maxSize) -->Line_4 $$ ThreadLocalRandom random = ThreadLocalRandom.current()[ CD ]
Line_13 $$ int nextSize = maxModificationSize <= 1 ? 1 : random.nextInt(1, maxModificationSize)-->Line_16 $$ for (int i = 0; i < nextSize; i++) [ FD ]
Line_15 $$ shuffled = new ArrayList(shuffled.subList(0, shuffled.size() < 2 ? 0 : random.nextInt(shuffled.size() / 2)))-->Line_32 $$ builder.addAll(shuffled)[ FD ]
Line_9 $$ int curSize = 0-->Line_37 $$ curSize += nextSize[ FD ]
Line_5 $$ BTree.Builder<Integer> builder = BTree.builder(naturalOrder())-->Line_24 $$ builder.addAll(ordered)[ FD ]
Line_10 $$ TreeSet<Integer> ordered = new TreeSet()-->Line_24 $$ builder.addAll(ordered)[ FD ]
Line_5 $$ BTree.Builder<Integer> builder = BTree.builder(naturalOrder())-->Line_30 $$ builder.add(i)[ FD ]
Line_2 $$ private static RandomTree randomTreeByBuilder(int minSize, int maxSize) -->Line_10 $$ TreeSet<Integer> ordered = new TreeSet()[ CD ]
Line_2 $$ private static RandomTree randomTreeByBuilder(int minSize, int maxSize) -->Line_12 $$ while (curSize < targetSize) [ CD ]
Line_5 $$ BTree.Builder<Integer> builder = BTree.builder(naturalOrder())-->Line_32 $$ builder.addAll(shuffled)[ FD ]
Line_10 $$ TreeSet<Integer> ordered = new TreeSet()-->Line_27 $$ builder.addAll(BTreeSet.of(ordered))[ FD ]
Line_6 $$ int targetSize = random.nextInt(minSize, maxSize)-->Line_7 $$ int maxModificationSize = (int) Math.sqrt(targetSize)[ FD ]
Line_4 $$ ThreadLocalRandom random = ThreadLocalRandom.current()-->Line_17 $$ Integer next = random.nextInt()[ FD ]
Line_4 $$ ThreadLocalRandom random = ThreadLocalRandom.current()-->Line_6 $$ int targetSize = random.nextInt(minSize, maxSize)[ FD ]
Line_10 $$ TreeSet<Integer> ordered = new TreeSet()-->Line_18 $$ ordered.add(next)[ FD ]
Line_2 $$ private static RandomTree randomTreeByBuilder(int minSize, int maxSize) -->Line_7 $$ int maxModificationSize = (int) Math.sqrt(targetSize)[ CD ]
Line_2 $$ private static RandomTree randomTreeByBuilder(int minSize, int maxSize) -->Line_5 $$ BTree.Builder<Integer> builder = BTree.builder(naturalOrder())[ CD ]
Line_16 $$ for (int i = 0; i < nextSize; i++) -->Line_19 $$ shuffled.add(next)[ CD ]
Line_15 $$ shuffled = new ArrayList(shuffled.subList(0, shuffled.size() < 2 ? 0 : random.nextInt(shuffled.size() / 2)))-->Line_19 $$ shuffled.add(next)[ FD ]
Line_13 $$ int nextSize = maxModificationSize <= 1 ? 1 : random.nextInt(1, maxModificationSize)-->Line_37 $$ curSize += nextSize[ FD ]
Line_17 $$ Integer next = random.nextInt()-->Line_20 $$ canonical.add(next)[ FD ]
Line_2 $$ private static RandomTree randomTreeByBuilder(int minSize, int maxSize) -->Line_41 $$ Assert.assertEquals(canonical.size(), btree.size())[ CD ]
Line_6 $$ int targetSize = random.nextInt(minSize, maxSize)-->Line_12 $$ while (curSize < targetSize) [ FD ]
Line_16 $$ for (int i = 0; i < nextSize; i++) -->Line_17 $$ Integer next = random.nextInt()[ CD ]
Line_17 $$ Integer next = random.nextInt()-->Line_19 $$ shuffled.add(next)[ FD ]
Line_5 $$ BTree.Builder<Integer> builder = BTree.builder(naturalOrder())-->Line_35 $$ builder.add(i)[ FD ]
Line_12 $$ while (curSize < targetSize) -->Line_37 $$ curSize += nextSize[ CD ]
Line_37 $$ curSize += nextSize-->Line_12 $$ while (curSize < targetSize) [ FD ]
Line_2 $$ private static RandomTree randomTreeByBuilder(int minSize, int maxSize) -->Line_8 $$ TreeSet<Integer> canonical = new TreeSet()[ CD ]
Line_40 $$ BTreeSet<Integer> btree = BTreeSet.<Integer>wrap(builder.build(), naturalOrder())-->Line_41 $$ Assert.assertEquals(canonical.size(), btree.size())[ FD ]
Line_2 $$ private static RandomTree randomTreeByBuilder(int minSize, int maxSize) -->Line_6 $$ int targetSize = random.nextInt(minSize, maxSize)[ CD ]
Line_16 $$ for (int i = 0; i < nextSize; i++) -->Line_30 $$ builder.add(i)[ FD ]
Line_4 $$ ThreadLocalRandom random = ThreadLocalRandom.current()-->Line_22 $$ switch(random.nextInt(5)) [ FD ]
Line_7 $$ int maxModificationSize = (int) Math.sqrt(targetSize)-->Line_38 $$ maxModificationSize = Math.min(maxModificationSize, targetSize - curSize)[ FD ]
Line_2 $$ private static RandomTree randomTreeByBuilder(int minSize, int maxSize) -->Line_11 $$ List<Integer> shuffled = new ArrayList()[ CD ]
Line_2 $$ private static RandomTree randomTreeByBuilder(int minSize, int maxSize) -->Line_40 $$ BTreeSet<Integer> btree = BTreeSet.<Integer>wrap(builder.build(), naturalOrder())[ CD ]
Line_8 $$ TreeSet<Integer> canonical = new TreeSet()-->Line_20 $$ canonical.add(next)[ FD ]
Line_17 $$ Integer next = random.nextInt()-->Line_18 $$ ordered.add(next)[ FD ]
Line_12 $$ while (curSize < targetSize) -->Line_16 $$ for (int i = 0; i < nextSize; i++) [ CD ]
Line_5 $$ BTree.Builder<Integer> builder = BTree.builder(naturalOrder())-->Line_40 $$ BTreeSet<Integer> btree = BTreeSet.<Integer>wrap(builder.build(), naturalOrder())[ FD ]
