Line_23 $$ final PsiJavaToken lbrace = body.getLBrace()-->Line_25 $$ rangeStart = lbrace.getTextRange().getEndOffset()[ FD ]
Line_29 $$ final CharSequence seq = document.getCharsSequence()-->Line_44 $$ if (lastLineEnd > 0 && seq.charAt(lastLineEnd) == '\n')[ FD ]
Line_19 $$ if (body != null) -->Line_71 $$ if (classRBrace != null && rangeEnd + 1 < closureEnd) [ CD ]
Line_8 $$ final PsiAnonymousClass anonymousClass = (PsiAnonymousClass) aClass-->Line_9 $$ final PsiElement element = anonymousClass.getParent()[ FD ]
Line_26 $$ final PsiJavaToken rbrace = body.getRBrace()-->Line_27 $$ if (rbrace != null)[ FD ]
Line_66 $$ if (rangeStart >= rangeEnd)-->Line_67 $$ return false[ CD ]
Line_2 $$ private boolean addClosureFolding(final PsiClass aClass, final Document document, final List<FoldingDescriptor> foldElements, @NotNull Set<PsiElement> processedComments, final boolean quick) -->Line_3 $$ if (!JavaCodeFoldingSettings.getInstance().isCollapseLambdas()) [ CD ]
Line_41 $$ if (firstLineStart < seq.length() - 1 && seq.charAt(firstLineStart) == '\n')-->Line_42 $$ firstLineStart++[ CD ]
Line_19 $$ if (body != null) -->Line_40 $$ int firstLineStart = CharArrayUtil.shiftForward(seq, rangeStart, " \t")[ CD ]
Line_18 $$ final PsiCodeBlock body = method.getBody()-->Line_19 $$ if (body != null) [ FD ]
Line_27 $$ if (rbrace != null)-->Line_28 $$ rangeEnd = rbrace.getTextRange().getStartOffset()[ CD ]
Line_33 $$ final int methodEndLineStart = document.getLineStartOffset(methodEndLine)-->Line_34 $$ if ("}".equals(seq.subSequence(methodEndLineStart, document.getLineEndOffset(methodEndLine)).toString().trim())) [ FD ]
Line_2 $$ private boolean addClosureFolding(final PsiClass aClass, final Document document, final List<FoldingDescriptor> foldElements, @NotNull Set<PsiElement> processedComments, final boolean quick) -->Line_36 $$ int classEndCol = classEndStart - document.getLineStartOffset(document.getLineNumber(classEndStart))[ FD ]
Line_19 $$ if (body != null) -->Line_68 $$ FoldingGroup group = FoldingGroup.newGroup("lambda")[ CD ]
Line_7 $$ if (aClass instanceof PsiAnonymousClass) -->Line_10 $$ if (element instanceof PsiNewExpression) [ CD ]
Line_8 $$ final PsiAnonymousClass anonymousClass = (PsiAnonymousClass) aClass-->Line_30 $$ final PsiElement classRBrace = anonymousClass.getRBrace()[ FD ]
Line_35 $$ int classEndStart = classRBrace.getTextRange().getStartOffset()-->Line_36 $$ int classEndCol = classEndStart - document.getLineStartOffset(document.getLineNumber(classEndStart))[ FD ]
Line_2 $$ private boolean addClosureFolding(final PsiClass aClass, final Document document, final List<FoldingDescriptor> foldElements, @NotNull Set<PsiElement> processedComments, final boolean quick) -->Line_6 $$ boolean isClosure = false[ CD ]
Line_22 $$ int rangeEnd = body.getTextRange().getEndOffset()-->Line_32 $$ final int methodEndLine = document.getLineNumber(rangeEnd)[ FD ]
Line_13 $$ if (argumentList != null && argumentList.getExpressions().length == 0) -->Line_15 $$ PsiClass baseClass = anonymousClass.getBaseClassType().resolve()[ CD ]
Line_2 $$ private boolean addClosureFolding(final PsiClass aClass, final Document document, final List<FoldingDescriptor> foldElements, @NotNull Set<PsiElement> processedComments, final boolean quick) -->Line_16 $$ if (hasOnlyOneLambdaMethod(anonymousClass, !quick) && seemsLikeLambda(baseClass) && !PsiUtil.isLanguageLevel8OrHigher(anonymousClass)) [ FD ]
Line_11 $$ final PsiNewExpression expression = (PsiNewExpression) element-->Line_12 $$ final PsiExpressionList argumentList = expression.getArgumentList()[ FD ]
Line_37 $$ rangeEnd = classEndCol + methodEndLineStart-->Line_66 $$ if (rangeStart >= rangeEnd)[ FD ]
Line_50 $$ final String params = StringUtil.join(method.getParameterList().getParameters(), new Function<PsiParameter, String>() -->Line_52 $$ return psiParameter.getName()[ CD ]
Line_8 $$ final PsiAnonymousClass anonymousClass = (PsiAnonymousClass) aClass-->Line_16 $$ if (hasOnlyOneLambdaMethod(anonymousClass, !quick) && seemsLikeLambda(baseClass) && !PsiUtil.isLanguageLevel8OrHigher(anonymousClass)) [ FD ]
Line_29 $$ final CharSequence seq = document.getCharsSequence()-->Line_60 $$ String contents = seq.subSequence(firstLineStart, lastLineEnd).toString()[ FD ]
Line_19 $$ if (body != null) -->Line_22 $$ int rangeEnd = body.getTextRange().getEndOffset()[ CD ]
Line_2 $$ private boolean addClosureFolding(final PsiClass aClass, final Document document, final List<FoldingDescriptor> foldElements, @NotNull Set<PsiElement> processedComments, final boolean quick) -->Line_80 $$ return isClosure[ CD ]
Line_15 $$ PsiClass baseClass = anonymousClass.getBaseClassType().resolve()-->Line_49 $$ String methodName = quick || !isImplementingLambdaMethod(baseClass) ? method.getName() : ""[ FD ]
Line_2 $$ private boolean addClosureFolding(final PsiClass aClass, final Document document, final List<FoldingDescriptor> foldElements, @NotNull Set<PsiElement> processedComments, final boolean quick) -->Line_74 $$ addCodeBlockFolds(body, foldElements, processedComments, document, quick)[ FD ]
Line_71 $$ if (classRBrace != null && rangeEnd + 1 < closureEnd) -->Line_72 $$ foldElements.add(new NamedFoldingDescriptor(classRBrace, rangeEnd, closureEnd, group, prettySpace + "}"))[ CD ]
Line_33 $$ final int methodEndLineStart = document.getLineStartOffset(methodEndLine)-->Line_37 $$ rangeEnd = classEndCol + methodEndLineStart[ FD ]
Line_30 $$ final PsiElement classRBrace = anonymousClass.getRBrace()-->Line_35 $$ int classEndStart = classRBrace.getTextRange().getStartOffset()[ FD ]
Line_40 $$ int firstLineStart = CharArrayUtil.shiftForward(seq, rangeStart, " \t")-->Line_60 $$ String contents = seq.subSequence(firstLineStart, lastLineEnd).toString()[ FD ]
Line_19 $$ if (body != null) -->Line_23 $$ final PsiJavaToken lbrace = body.getLBrace()[ CD ]
Line_19 $$ if (body != null) -->Line_31 $$ if (classRBrace != null && rbrace != null) [ CD ]
Line_19 $$ if (body != null) -->Line_43 $$ int lastLineEnd = CharArrayUtil.shiftBackward(seq, rangeEnd - 1, " \t")[ CD ]
Line_19 $$ if (body != null) -->Line_49 $$ String methodName = quick || !isImplementingLambdaMethod(baseClass) ? method.getName() : ""[ CD ]
Line_19 $$ if (body != null) -->Line_61 $$ if (contents.indexOf('\n') < 0 && fitsRightMargin(aClass, document, closureStart, closureEnd, lambdas.length() + contents.length() + 5)) [ CD ]
Line_19 $$ if (body != null) -->Line_50 $$ final String params = StringUtil.join(method.getParameterList().getParameters(), new Function<PsiParameter, String>() [ CD ]
Line_21 $$ int rangeStart = body.getTextRange().getStartOffset()-->Line_40 $$ int firstLineStart = CharArrayUtil.shiftForward(seq, rangeStart, " \t")[ FD ]
Line_11 $$ final PsiNewExpression expression = (PsiNewExpression) element-->Line_48 $$ String type = quick ? "" : getOptionalLambdaType(anonymousClass, expression)[ FD ]
Line_11 $$ final PsiNewExpression expression = (PsiNewExpression) element-->Line_57 $$ final int closureStart = expression.getTextRange().getStartOffset()[ FD ]
Line_29 $$ final CharSequence seq = document.getCharsSequence()-->Line_34 $$ if ("}".equals(seq.subSequence(methodEndLineStart, document.getLineEndOffset(methodEndLine)).toString().trim())) [ FD ]
Line_10 $$ if (element instanceof PsiNewExpression) -->Line_13 $$ if (argumentList != null && argumentList.getExpressions().length == 0) [ CD ]
Line_15 $$ PsiClass baseClass = anonymousClass.getBaseClassType().resolve()-->Line_16 $$ if (hasOnlyOneLambdaMethod(anonymousClass, !quick) && seemsLikeLambda(baseClass) && !PsiUtil.isLanguageLevel8OrHigher(anonymousClass)) [ FD ]
Line_8 $$ final PsiAnonymousClass anonymousClass = (PsiAnonymousClass) aClass-->Line_14 $$ final PsiMethod[] methods = anonymousClass.getMethods()[ FD ]
Line_25 $$ rangeStart = lbrace.getTextRange().getEndOffset()-->Line_66 $$ if (rangeStart >= rangeEnd)[ FD ]
Line_19 $$ if (body != null) -->Line_70 $$ foldElements.add(new NamedFoldingDescriptor(expression, closureStart, rangeStart, group, lambdas + prettySpace))[ CD ]
Line_18 $$ final PsiCodeBlock body = method.getBody()-->Line_26 $$ final PsiJavaToken rbrace = body.getRBrace()[ FD ]
Line_2 $$ private boolean addClosureFolding(final PsiClass aClass, final Document document, final List<FoldingDescriptor> foldElements, @NotNull Set<PsiElement> processedComments, final boolean quick) -->Line_7 $$ if (aClass instanceof PsiAnonymousClass) [ CD ]
Line_2 $$ private boolean addClosureFolding(final PsiClass aClass, final Document document, final List<FoldingDescriptor> foldElements, @NotNull Set<PsiElement> processedComments, final boolean quick) -->Line_72 $$ foldElements.add(new NamedFoldingDescriptor(classRBrace, rangeEnd, closureEnd, group, prettySpace + "}"))[ FD ]
Line_23 $$ final PsiJavaToken lbrace = body.getLBrace()-->Line_24 $$ if (lbrace != null)[ FD ]
Line_22 $$ int rangeEnd = body.getTextRange().getEndOffset()-->Line_37 $$ rangeEnd = classEndCol + methodEndLineStart[ FD ]
Line_19 $$ if (body != null) -->Line_26 $$ final PsiJavaToken rbrace = body.getRBrace()[ CD ]
Line_31 $$ if (classRBrace != null && rbrace != null) -->Line_34 $$ if ("}".equals(seq.subSequence(methodEndLineStart, document.getLineEndOffset(methodEndLine)).toString().trim())) [ CD ]
Line_25 $$ rangeStart = lbrace.getTextRange().getEndOffset()-->Line_40 $$ int firstLineStart = CharArrayUtil.shiftForward(seq, rangeStart, " \t")[ FD ]
Line_22 $$ int rangeEnd = body.getTextRange().getEndOffset()-->Line_66 $$ if (rangeStart >= rangeEnd)[ FD ]
Line_34 $$ if ("}".equals(seq.subSequence(methodEndLineStart, document.getLineEndOffset(methodEndLine)).toString().trim())) -->Line_37 $$ rangeEnd = classEndCol + methodEndLineStart[ CD ]
Line_61 $$ if (contents.indexOf('\n') < 0 && fitsRightMargin(aClass, document, closureStart, closureEnd, lambdas.length() + contents.length() + 5)) -->Line_62 $$ rangeStart = CharArrayUtil.shiftForward(seq, rangeStart, " \n\t")[ CD ]
Line_2 $$ private boolean addClosureFolding(final PsiClass aClass, final Document document, final List<FoldingDescriptor> foldElements, @NotNull Set<PsiElement> processedComments, final boolean quick) -->Line_32 $$ final int methodEndLine = document.getLineNumber(rangeEnd)[ FD ]
Line_28 $$ rangeEnd = rbrace.getTextRange().getStartOffset()-->Line_66 $$ if (rangeStart >= rangeEnd)[ FD ]
Line_50 $$ final String params = StringUtil.join(method.getParameterList().getParameters(), new Function<PsiParameter, String>() -->Line_52 $$ return psiParameter.getName()[ FD ]
Line_40 $$ int firstLineStart = CharArrayUtil.shiftForward(seq, rangeStart, " \t")-->Line_41 $$ if (firstLineStart < seq.length() - 1 && seq.charAt(firstLineStart) == '\n')[ FD ]
Line_2 $$ private boolean addClosureFolding(final PsiClass aClass, final Document document, final List<FoldingDescriptor> foldElements, @NotNull Set<PsiElement> processedComments, final boolean quick) -->Line_29 $$ final CharSequence seq = document.getCharsSequence()[ FD ]
Line_12 $$ final PsiExpressionList argumentList = expression.getArgumentList()-->Line_13 $$ if (argumentList != null && argumentList.getExpressions().length == 0) [ FD ]
Line_34 $$ if ("}".equals(seq.subSequence(methodEndLineStart, document.getLineEndOffset(methodEndLine)).toString().trim())) -->Line_35 $$ int classEndStart = classRBrace.getTextRange().getStartOffset()[ CD ]
Line_2 $$ private boolean addClosureFolding(final PsiClass aClass, final Document document, final List<FoldingDescriptor> foldElements, @NotNull Set<PsiElement> processedComments, final boolean quick) -->Line_33 $$ final int methodEndLineStart = document.getLineStartOffset(methodEndLine)[ FD ]
Line_36 $$ int classEndCol = classEndStart - document.getLineStartOffset(document.getLineNumber(classEndStart))-->Line_37 $$ rangeEnd = classEndCol + methodEndLineStart[ FD ]
Line_24 $$ if (lbrace != null)-->Line_25 $$ rangeStart = lbrace.getTextRange().getEndOffset()[ CD ]
Line_31 $$ if (classRBrace != null && rbrace != null) -->Line_32 $$ final int methodEndLine = document.getLineNumber(rangeEnd)[ CD ]
Line_19 $$ if (body != null) -->Line_58 $$ final int closureEnd = expression.getTextRange().getEndOffset()[ CD ]
Line_19 $$ if (body != null) -->Line_66 $$ if (rangeStart >= rangeEnd)[ CD ]
Line_44 $$ if (lastLineEnd > 0 && seq.charAt(lastLineEnd) == '\n')-->Line_45 $$ lastLineEnd--[ CD ]
Line_17 $$ final PsiMethod method = methods[0]-->Line_18 $$ final PsiCodeBlock body = method.getBody()[ FD ]
Line_43 $$ int lastLineEnd = CharArrayUtil.shiftBackward(seq, rangeEnd - 1, " \t")-->Line_44 $$ if (lastLineEnd > 0 && seq.charAt(lastLineEnd) == '\n')[ FD ]
Line_25 $$ rangeStart = lbrace.getTextRange().getEndOffset()-->Line_62 $$ rangeStart = CharArrayUtil.shiftForward(seq, rangeStart, " \n\t")[ FD ]
Line_9 $$ final PsiElement element = anonymousClass.getParent()-->Line_10 $$ if (element instanceof PsiNewExpression) [ FD ]
Line_13 $$ if (argumentList != null && argumentList.getExpressions().length == 0) -->Line_14 $$ final PsiMethod[] methods = anonymousClass.getMethods()[ CD ]
Line_16 $$ if (hasOnlyOneLambdaMethod(anonymousClass, !quick) && seemsLikeLambda(baseClass) && !PsiUtil.isLanguageLevel8OrHigher(anonymousClass)) -->Line_17 $$ final PsiMethod method = methods[0][ CD ]
Line_2 $$ private boolean addClosureFolding(final PsiClass aClass, final Document document, final List<FoldingDescriptor> foldElements, @NotNull Set<PsiElement> processedComments, final boolean quick) -->Line_70 $$ foldElements.add(new NamedFoldingDescriptor(expression, closureStart, rangeStart, group, lambdas + prettySpace))[ FD ]
Line_8 $$ final PsiAnonymousClass anonymousClass = (PsiAnonymousClass) aClass-->Line_48 $$ String type = quick ? "" : getOptionalLambdaType(anonymousClass, expression)[ FD ]
Line_18 $$ final PsiCodeBlock body = method.getBody()-->Line_22 $$ int rangeEnd = body.getTextRange().getEndOffset()[ FD ]
Line_2 $$ private boolean addClosureFolding(final PsiClass aClass, final Document document, final List<FoldingDescriptor> foldElements, @NotNull Set<PsiElement> processedComments, final boolean quick) -->Line_34 $$ if ("}".equals(seq.subSequence(methodEndLineStart, document.getLineEndOffset(methodEndLine)).toString().trim())) [ FD ]
Line_28 $$ rangeEnd = rbrace.getTextRange().getStartOffset()-->Line_37 $$ rangeEnd = classEndCol + methodEndLineStart[ FD ]
Line_19 $$ if (body != null) -->Line_60 $$ String contents = seq.subSequence(firstLineStart, lastLineEnd).toString()[ CD ]
Line_8 $$ final PsiAnonymousClass anonymousClass = (PsiAnonymousClass) aClass-->Line_15 $$ PsiClass baseClass = anonymousClass.getBaseClassType().resolve()[ FD ]
Line_17 $$ final PsiMethod method = methods[0]-->Line_50 $$ final String params = StringUtil.join(method.getParameterList().getParameters(), new Function<PsiParameter, String>() [ FD ]
Line_19 $$ if (body != null) -->Line_44 $$ if (lastLineEnd > 0 && seq.charAt(lastLineEnd) == '\n')[ CD ]
Line_21 $$ int rangeStart = body.getTextRange().getStartOffset()-->Line_66 $$ if (rangeStart >= rangeEnd)[ FD ]
Line_6 $$ boolean isClosure = false-->Line_20 $$ isClosure = true[ FD ]
Line_7 $$ if (aClass instanceof PsiAnonymousClass) -->Line_8 $$ final PsiAnonymousClass anonymousClass = (PsiAnonymousClass) aClass[ CD ]
Line_19 $$ if (body != null) -->Line_30 $$ final PsiElement classRBrace = anonymousClass.getRBrace()[ CD ]
Line_19 $$ if (body != null) -->Line_27 $$ if (rbrace != null)[ CD ]
Line_29 $$ final CharSequence seq = document.getCharsSequence()-->Line_62 $$ rangeStart = CharArrayUtil.shiftForward(seq, rangeStart, " \n\t")[ FD ]
Line_16 $$ if (hasOnlyOneLambdaMethod(anonymousClass, !quick) && seemsLikeLambda(baseClass) && !PsiUtil.isLanguageLevel8OrHigher(anonymousClass)) -->Line_18 $$ final PsiCodeBlock body = method.getBody()[ CD ]
Line_28 $$ rangeEnd = rbrace.getTextRange().getStartOffset()-->Line_32 $$ final int methodEndLine = document.getLineNumber(rangeEnd)[ FD ]
Line_19 $$ if (body != null) -->Line_41 $$ if (firstLineStart < seq.length() - 1 && seq.charAt(firstLineStart) == '\n')[ CD ]
Line_29 $$ final CharSequence seq = document.getCharsSequence()-->Line_43 $$ int lastLineEnd = CharArrayUtil.shiftBackward(seq, rangeEnd - 1, " \t")[ FD ]
Line_3 $$ if (!JavaCodeFoldingSettings.getInstance().isCollapseLambdas()) -->Line_4 $$ return false[ CD ]
Line_32 $$ final int methodEndLine = document.getLineNumber(rangeEnd)-->Line_33 $$ final int methodEndLineStart = document.getLineStartOffset(methodEndLine)[ FD ]
Line_29 $$ final CharSequence seq = document.getCharsSequence()-->Line_41 $$ if (firstLineStart < seq.length() - 1 && seq.charAt(firstLineStart) == '\n')[ FD ]
Line_11 $$ final PsiNewExpression expression = (PsiNewExpression) element-->Line_58 $$ final int closureEnd = expression.getTextRange().getEndOffset()[ FD ]
Line_31 $$ if (classRBrace != null && rbrace != null) -->Line_33 $$ final int methodEndLineStart = document.getLineStartOffset(methodEndLine)[ CD ]
Line_19 $$ if (body != null) -->Line_46 $$ if (lastLineEnd < firstLineStart)[ CD ]
Line_29 $$ final CharSequence seq = document.getCharsSequence()-->Line_63 $$ rangeEnd = CharArrayUtil.shiftBackward(seq, rangeEnd - 1, " \n\t") + 1[ FD ]
Line_7 $$ if (aClass instanceof PsiAnonymousClass) -->Line_9 $$ final PsiElement element = anonymousClass.getParent()[ CD ]
Line_29 $$ final CharSequence seq = document.getCharsSequence()-->Line_40 $$ int firstLineStart = CharArrayUtil.shiftForward(seq, rangeStart, " \t")[ FD ]
Line_21 $$ int rangeStart = body.getTextRange().getStartOffset()-->Line_25 $$ rangeStart = lbrace.getTextRange().getEndOffset()[ FD ]
Line_19 $$ if (body != null) -->Line_20 $$ isClosure = true[ CD ]
Line_34 $$ if ("}".equals(seq.subSequence(methodEndLineStart, document.getLineEndOffset(methodEndLine)).toString().trim())) -->Line_36 $$ int classEndCol = classEndStart - document.getLineStartOffset(document.getLineNumber(classEndStart))[ CD ]
Line_40 $$ int firstLineStart = CharArrayUtil.shiftForward(seq, rangeStart, " \t")-->Line_42 $$ firstLineStart++[ FD ]
Line_2 $$ private boolean addClosureFolding(final PsiClass aClass, final Document document, final List<FoldingDescriptor> foldElements, @NotNull Set<PsiElement> processedComments, final boolean quick) -->Line_7 $$ if (aClass instanceof PsiAnonymousClass) [ FD ]
Line_19 $$ if (body != null) -->Line_21 $$ int rangeStart = body.getTextRange().getStartOffset()[ CD ]
Line_19 $$ if (body != null) -->Line_24 $$ if (lbrace != null)[ CD ]
Line_10 $$ if (element instanceof PsiNewExpression) -->Line_12 $$ final PsiExpressionList argumentList = expression.getArgumentList()[ CD ]
Line_19 $$ if (body != null) -->Line_29 $$ final CharSequence seq = document.getCharsSequence()[ CD ]
Line_43 $$ int lastLineEnd = CharArrayUtil.shiftBackward(seq, rangeEnd - 1, " \t")-->Line_45 $$ lastLineEnd--[ FD ]
Line_43 $$ int lastLineEnd = CharArrayUtil.shiftBackward(seq, rangeEnd - 1, " \t")-->Line_60 $$ String contents = seq.subSequence(firstLineStart, lastLineEnd).toString()[ FD ]
Line_32 $$ final int methodEndLine = document.getLineNumber(rangeEnd)-->Line_34 $$ if ("}".equals(seq.subSequence(methodEndLineStart, document.getLineEndOffset(methodEndLine)).toString().trim())) [ FD ]
Line_40 $$ int firstLineStart = CharArrayUtil.shiftForward(seq, rangeStart, " \t")-->Line_46 $$ if (lastLineEnd < firstLineStart)[ FD ]
Line_13 $$ if (argumentList != null && argumentList.getExpressions().length == 0) -->Line_16 $$ if (hasOnlyOneLambdaMethod(anonymousClass, !quick) && seemsLikeLambda(baseClass) && !PsiUtil.isLanguageLevel8OrHigher(anonymousClass)) [ CD ]
Line_19 $$ if (body != null) -->Line_48 $$ String type = quick ? "" : getOptionalLambdaType(anonymousClass, expression)[ CD ]
Line_26 $$ final PsiJavaToken rbrace = body.getRBrace()-->Line_28 $$ rangeEnd = rbrace.getTextRange().getStartOffset()[ FD ]
Line_2 $$ private boolean addClosureFolding(final PsiClass aClass, final Document document, final List<FoldingDescriptor> foldElements, @NotNull Set<PsiElement> processedComments, final boolean quick) -->Line_61 $$ if (contents.indexOf('\n') < 0 && fitsRightMargin(aClass, document, closureStart, closureEnd, lambdas.length() + contents.length() + 5)) [ FD ]
Line_43 $$ int lastLineEnd = CharArrayUtil.shiftBackward(seq, rangeEnd - 1, " \t")-->Line_46 $$ if (lastLineEnd < firstLineStart)[ FD ]
Line_19 $$ if (body != null) -->Line_74 $$ addCodeBlockFolds(body, foldElements, processedComments, document, quick)[ CD ]
Line_18 $$ final PsiCodeBlock body = method.getBody()-->Line_74 $$ addCodeBlockFolds(body, foldElements, processedComments, document, quick)[ FD ]
Line_18 $$ final PsiCodeBlock body = method.getBody()-->Line_21 $$ int rangeStart = body.getTextRange().getStartOffset()[ FD ]
Line_46 $$ if (lastLineEnd < firstLineStart)-->Line_47 $$ return false[ CD ]
Line_22 $$ int rangeEnd = body.getTextRange().getEndOffset()-->Line_28 $$ rangeEnd = rbrace.getTextRange().getStartOffset()[ FD ]
Line_17 $$ final PsiMethod method = methods[0]-->Line_49 $$ String methodName = quick || !isImplementingLambdaMethod(baseClass) ? method.getName() : ""[ FD ]
Line_19 $$ if (body != null) -->Line_55 $$ String arrow = rightArrow()[ CD ]
Line_21 $$ int rangeStart = body.getTextRange().getStartOffset()-->Line_62 $$ rangeStart = CharArrayUtil.shiftForward(seq, rangeStart, " \n\t")[ FD ]
Line_18 $$ final PsiCodeBlock body = method.getBody()-->Line_23 $$ final PsiJavaToken lbrace = body.getLBrace()[ FD ]
Line_19 $$ if (body != null) -->Line_57 $$ final int closureStart = expression.getTextRange().getStartOffset()[ CD ]
Line_10 $$ if (element instanceof PsiNewExpression) -->Line_11 $$ final PsiNewExpression expression = (PsiNewExpression) element[ CD ]
Line_16 $$ if (hasOnlyOneLambdaMethod(anonymousClass, !quick) && seemsLikeLambda(baseClass) && !PsiUtil.isLanguageLevel8OrHigher(anonymousClass)) -->Line_19 $$ if (body != null) [ CD ]
