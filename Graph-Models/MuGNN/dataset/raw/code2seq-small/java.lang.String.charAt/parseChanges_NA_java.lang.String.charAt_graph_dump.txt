Line_20 $$ status = FileStatus.ADDED-->Line_26 $$ if (status == null) [ FD ]
Line_13 $$ final ContentRevision before-->Line_39 $$ before = GitContentRevision.createRevision(vcsRoot, tokens[1], parentRevision, project, true, true, true)[ FD ]
Line_27 $$ status = FileStatus.MODIFIED-->Line_33 $$ status = FileStatus.DELETED[ FD ]
Line_2 $$ private static void parseChanges(Project project, VirtualFile vcsRoot, @Nullable GitRevisionNumber thisRevision, @Nullable GitRevisionNumber parentRevision, StringScanner s, Collection<Change> changes, final Set<String> ignoreNames) throws VcsException -->Line_3 $$ while (s.hasMoreData()) [ FD ]
Line_4 $$ FileStatus status = null-->Line_20 $$ status = FileStatus.ADDED[ FD ]
Line_20 $$ status = FileStatus.ADDED-->Line_27 $$ status = FileStatus.MODIFIED[ FD ]
Line_2 $$ private static void parseChanges(Project project, VirtualFile vcsRoot, @Nullable GitRevisionNumber thisRevision, @Nullable GitRevisionNumber parentRevision, StringScanner s, Collection<Change> changes, final Set<String> ignoreNames) throws VcsException -->Line_12 $$ String[] tokens = s.line().split("\t")[ FD ]
Line_3 $$ while (s.hasMoreData()) -->Line_50 $$ if (ignoreNames == null || !ignoreNames.contains(path)) [ CD ]
Line_33 $$ status = FileStatus.DELETED-->Line_38 $$ status = FileStatus.MODIFIED[ FD ]
Line_15 $$ final String path = tokens[tokens.length - 1]-->Line_30 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)[ FD ]
Line_15 $$ final String path = tokens[tokens.length - 1]-->Line_29 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, false, true, true)[ FD ]
Line_29 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, false, true, true)-->Line_34 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, true, true, true)[ FD ]
Line_4 $$ FileStatus status = null-->Line_43 $$ status = FileStatus.MODIFIED[ FD ]
Line_3 $$ while (s.hasMoreData()) -->Line_9 $$ if ("CADUMRT".indexOf(s.peek()) == -1) [ CD ]
Line_2 $$ private static void parseChanges(Project project, VirtualFile vcsRoot, @Nullable GitRevisionNumber thisRevision, @Nullable GitRevisionNumber parentRevision, StringScanner s, Collection<Change> changes, final Set<String> ignoreNames) throws VcsException -->Line_50 $$ if (ignoreNames == null || !ignoreNames.contains(path)) [ FD ]
Line_24 $$ status = FileStatus.MERGED_WITH_CONFLICTS-->Line_33 $$ status = FileStatus.DELETED[ FD ]
Line_15 $$ final String path = tokens[tokens.length - 1]-->Line_45 $$ after = GitContentRevision.createRevisionForTypeChange(project, vcsRoot, path, thisRevision, true)[ FD ]
Line_3 $$ while (s.hasMoreData()) -->Line_12 $$ String[] tokens = s.line().split("\t")[ CD ]
Line_30 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)-->Line_40 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)[ FD ]
Line_2 $$ private static void parseChanges(Project project, VirtualFile vcsRoot, @Nullable GitRevisionNumber thisRevision, @Nullable GitRevisionNumber parentRevision, StringScanner s, Collection<Change> changes, final Set<String> ignoreNames) throws VcsException -->Line_34 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, true, true, true)[ FD ]
Line_3 $$ while (s.hasMoreData()) -->Line_5 $$ if (s.isEol()) [ CD ]
Line_4 $$ FileStatus status = null-->Line_38 $$ status = FileStatus.MODIFIED[ FD ]
Line_15 $$ final String path = tokens[tokens.length - 1]-->Line_50 $$ if (ignoreNames == null || !ignoreNames.contains(path)) [ FD ]
Line_34 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, true, true, true)-->Line_44 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, true, true, true)[ FD ]
Line_24 $$ status = FileStatus.MERGED_WITH_CONFLICTS-->Line_27 $$ status = FileStatus.MODIFIED[ FD ]
Line_30 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)-->Line_45 $$ after = GitContentRevision.createRevisionForTypeChange(project, vcsRoot, path, thisRevision, true)[ FD ]
Line_20 $$ status = FileStatus.ADDED-->Line_33 $$ status = FileStatus.DELETED[ FD ]
Line_3 $$ while (s.hasMoreData()) -->Line_4 $$ FileStatus status = null[ CD ]
Line_20 $$ status = FileStatus.ADDED-->Line_43 $$ status = FileStatus.MODIFIED[ FD ]
Line_4 $$ FileStatus status = null-->Line_27 $$ status = FileStatus.MODIFIED[ FD ]
Line_2 $$ private static void parseChanges(Project project, VirtualFile vcsRoot, @Nullable GitRevisionNumber thisRevision, @Nullable GitRevisionNumber parentRevision, StringScanner s, Collection<Change> changes, final Set<String> ignoreNames) throws VcsException -->Line_40 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)[ FD ]
Line_40 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)-->Line_45 $$ after = GitContentRevision.createRevisionForTypeChange(project, vcsRoot, path, thisRevision, true)[ FD ]
Line_24 $$ status = FileStatus.MERGED_WITH_CONFLICTS-->Line_43 $$ status = FileStatus.MODIFIED[ FD ]
Line_14 $$ final ContentRevision after-->Line_21 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)[ FD ]
Line_15 $$ final String path = tokens[tokens.length - 1]-->Line_21 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)[ FD ]
Line_19 $$ before = null-->Line_34 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, true, true, true)[ FD ]
Line_15 $$ final String path = tokens[tokens.length - 1]-->Line_40 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)[ FD ]
Line_27 $$ status = FileStatus.MODIFIED-->Line_26 $$ if (status == null) [ FD ]
Line_2 $$ private static void parseChanges(Project project, VirtualFile vcsRoot, @Nullable GitRevisionNumber thisRevision, @Nullable GitRevisionNumber parentRevision, StringScanner s, Collection<Change> changes, final Set<String> ignoreNames) throws VcsException -->Line_3 $$ while (s.hasMoreData()) [ CD ]
Line_26 $$ if (status == null) -->Line_27 $$ status = FileStatus.MODIFIED[ CD ]
Line_39 $$ before = GitContentRevision.createRevision(vcsRoot, tokens[1], parentRevision, project, true, true, true)-->Line_44 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, true, true, true)[ FD ]
Line_14 $$ final ContentRevision after-->Line_45 $$ after = GitContentRevision.createRevisionForTypeChange(project, vcsRoot, path, thisRevision, true)[ FD ]
Line_19 $$ before = null-->Line_39 $$ before = GitContentRevision.createRevision(vcsRoot, tokens[1], parentRevision, project, true, true, true)[ FD ]
Line_19 $$ before = null-->Line_29 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, false, true, true)[ FD ]
Line_15 $$ final String path = tokens[tokens.length - 1]-->Line_34 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, true, true, true)[ FD ]
Line_13 $$ final ContentRevision before-->Line_19 $$ before = null[ FD ]
Line_38 $$ status = FileStatus.MODIFIED-->Line_43 $$ status = FileStatus.MODIFIED[ FD ]
Line_2 $$ private static void parseChanges(Project project, VirtualFile vcsRoot, @Nullable GitRevisionNumber thisRevision, @Nullable GitRevisionNumber parentRevision, StringScanner s, Collection<Change> changes, final Set<String> ignoreNames) throws VcsException -->Line_5 $$ if (s.isEol()) [ FD ]
Line_14 $$ final ContentRevision after-->Line_40 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)[ FD ]
Line_13 $$ final ContentRevision before-->Line_34 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, true, true, true)[ FD ]
Line_35 $$ after = null-->Line_40 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)[ FD ]
Line_30 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)-->Line_35 $$ after = null[ FD ]
Line_2 $$ private static void parseChanges(Project project, VirtualFile vcsRoot, @Nullable GitRevisionNumber thisRevision, @Nullable GitRevisionNumber parentRevision, StringScanner s, Collection<Change> changes, final Set<String> ignoreNames) throws VcsException -->Line_29 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, false, true, true)[ FD ]
Line_13 $$ final ContentRevision before-->Line_44 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, true, true, true)[ FD ]
Line_2 $$ private static void parseChanges(Project project, VirtualFile vcsRoot, @Nullable GitRevisionNumber thisRevision, @Nullable GitRevisionNumber parentRevision, StringScanner s, Collection<Change> changes, final Set<String> ignoreNames) throws VcsException -->Line_6 $$ s.nextLine()[ FD ]
Line_33 $$ status = FileStatus.DELETED-->Line_43 $$ status = FileStatus.MODIFIED[ FD ]
Line_2 $$ private static void parseChanges(Project project, VirtualFile vcsRoot, @Nullable GitRevisionNumber thisRevision, @Nullable GitRevisionNumber parentRevision, StringScanner s, Collection<Change> changes, final Set<String> ignoreNames) throws VcsException -->Line_51 $$ changes.add(new Change(before, after, status))[ FD ]
Line_4 $$ FileStatus status = null-->Line_26 $$ if (status == null) [ FD ]
Line_2 $$ private static void parseChanges(Project project, VirtualFile vcsRoot, @Nullable GitRevisionNumber thisRevision, @Nullable GitRevisionNumber parentRevision, StringScanner s, Collection<Change> changes, final Set<String> ignoreNames) throws VcsException -->Line_44 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, true, true, true)[ FD ]
Line_34 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, true, true, true)-->Line_39 $$ before = GitContentRevision.createRevision(vcsRoot, tokens[1], parentRevision, project, true, true, true)[ FD ]
Line_24 $$ status = FileStatus.MERGED_WITH_CONFLICTS-->Line_26 $$ if (status == null) [ FD ]
Line_20 $$ status = FileStatus.ADDED-->Line_38 $$ status = FileStatus.MODIFIED[ FD ]
Line_21 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)-->Line_45 $$ after = GitContentRevision.createRevisionForTypeChange(project, vcsRoot, path, thisRevision, true)[ FD ]
Line_5 $$ if (s.isEol()) -->Line_6 $$ s.nextLine()[ CD ]
Line_20 $$ status = FileStatus.ADDED-->Line_24 $$ status = FileStatus.MERGED_WITH_CONFLICTS[ FD ]
Line_13 $$ final ContentRevision before-->Line_29 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, false, true, true)[ FD ]
Line_2 $$ private static void parseChanges(Project project, VirtualFile vcsRoot, @Nullable GitRevisionNumber thisRevision, @Nullable GitRevisionNumber parentRevision, StringScanner s, Collection<Change> changes, final Set<String> ignoreNames) throws VcsException -->Line_9 $$ if ("CADUMRT".indexOf(s.peek()) == -1) [ FD ]
Line_50 $$ if (ignoreNames == null || !ignoreNames.contains(path)) -->Line_51 $$ changes.add(new Change(before, after, status))[ CD ]
Line_38 $$ status = FileStatus.MODIFIED-->Line_26 $$ if (status == null) [ FD ]
Line_21 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)-->Line_35 $$ after = null[ FD ]
Line_21 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)-->Line_40 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)[ FD ]
Line_29 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, false, true, true)-->Line_44 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, true, true, true)[ FD ]
Line_3 $$ while (s.hasMoreData()) -->Line_15 $$ final String path = tokens[tokens.length - 1][ CD ]
Line_3 $$ while (s.hasMoreData()) -->Line_14 $$ final ContentRevision after[ CD ]
Line_33 $$ status = FileStatus.DELETED-->Line_26 $$ if (status == null) [ FD ]
Line_4 $$ FileStatus status = null-->Line_33 $$ status = FileStatus.DELETED[ FD ]
Line_4 $$ FileStatus status = null-->Line_24 $$ status = FileStatus.MERGED_WITH_CONFLICTS[ FD ]
Line_15 $$ final String path = tokens[tokens.length - 1]-->Line_44 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, true, true, true)[ FD ]
Line_21 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)-->Line_30 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)[ FD ]
Line_2 $$ private static void parseChanges(Project project, VirtualFile vcsRoot, @Nullable GitRevisionNumber thisRevision, @Nullable GitRevisionNumber parentRevision, StringScanner s, Collection<Change> changes, final Set<String> ignoreNames) throws VcsException -->Line_21 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)[ FD ]
Line_19 $$ before = null-->Line_44 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, true, true, true)[ FD ]
Line_24 $$ status = FileStatus.MERGED_WITH_CONFLICTS-->Line_38 $$ status = FileStatus.MODIFIED[ FD ]
Line_27 $$ status = FileStatus.MODIFIED-->Line_38 $$ status = FileStatus.MODIFIED[ FD ]
Line_43 $$ status = FileStatus.MODIFIED-->Line_26 $$ if (status == null) [ FD ]
Line_12 $$ String[] tokens = s.line().split("\t")-->Line_48 $$ throw new VcsException("Unknown file status: " + Arrays.asList(tokens))[ FD ]
Line_2 $$ private static void parseChanges(Project project, VirtualFile vcsRoot, @Nullable GitRevisionNumber thisRevision, @Nullable GitRevisionNumber parentRevision, StringScanner s, Collection<Change> changes, final Set<String> ignoreNames) throws VcsException -->Line_30 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)[ FD ]
Line_27 $$ status = FileStatus.MODIFIED-->Line_43 $$ status = FileStatus.MODIFIED[ FD ]
Line_3 $$ while (s.hasMoreData()) -->Line_13 $$ final ContentRevision before[ CD ]
Line_29 $$ before = GitContentRevision.createRevision(vcsRoot, path, parentRevision, project, false, true, true)-->Line_39 $$ before = GitContentRevision.createRevision(vcsRoot, tokens[1], parentRevision, project, true, true, true)[ FD ]
Line_2 $$ private static void parseChanges(Project project, VirtualFile vcsRoot, @Nullable GitRevisionNumber thisRevision, @Nullable GitRevisionNumber parentRevision, StringScanner s, Collection<Change> changes, final Set<String> ignoreNames) throws VcsException -->Line_39 $$ before = GitContentRevision.createRevision(vcsRoot, tokens[1], parentRevision, project, true, true, true)[ FD ]
Line_2 $$ private static void parseChanges(Project project, VirtualFile vcsRoot, @Nullable GitRevisionNumber thisRevision, @Nullable GitRevisionNumber parentRevision, StringScanner s, Collection<Change> changes, final Set<String> ignoreNames) throws VcsException -->Line_45 $$ after = GitContentRevision.createRevisionForTypeChange(project, vcsRoot, path, thisRevision, true)[ FD ]
Line_9 $$ if ("CADUMRT".indexOf(s.peek()) == -1) -->Line_10 $$ return[ CD ]
Line_35 $$ after = null-->Line_45 $$ after = GitContentRevision.createRevisionForTypeChange(project, vcsRoot, path, thisRevision, true)[ FD ]
Line_14 $$ final ContentRevision after-->Line_30 $$ after = GitContentRevision.createRevision(vcsRoot, path, thisRevision, project, false, false, true)[ FD ]
Line_14 $$ final ContentRevision after-->Line_35 $$ after = null[ FD ]
