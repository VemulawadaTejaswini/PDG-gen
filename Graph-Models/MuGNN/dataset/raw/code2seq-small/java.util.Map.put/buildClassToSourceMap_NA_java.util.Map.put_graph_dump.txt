Line_7 $$ final SourceToOutputMapping srcToOut = context.getProjectDescriptor().dataManager.getSourceToOutputMap(target)-->Line_10 $$ final Collection<String> outs = srcToOut.getOutputs(src)[ FD ]
Line_5 $$ for (ModuleBuildTarget target : chunk.getTargets()) -->Line_6 $$ String moduleOutputPath = finalOutputs.get(target)[ FD ]
Line_2 $$ private static Map<String, String> buildClassToSourceMap(ModuleChunk chunk, CompileContext context, Set<String> toCompilePaths, Map<ModuleBuildTarget, String> finalOutputs) throws IOException -->Line_5 $$ for (ModuleBuildTarget target : chunk.getTargets()) [ FD ]
Line_2 $$ private static Map<String, String> buildClassToSourceMap(ModuleChunk chunk, CompileContext context, Set<String> toCompilePaths, Map<ModuleBuildTarget, String> finalOutputs) throws IOException -->Line_4 $$ JpsJavaCompilerConfiguration configuration = JpsJavaExtensionService.getInstance().getOrCreateCompilerConfiguration(context.getProjectDescriptor().getProject())[ CD ]
Line_8 $$ for (String src : srcToOut.getSources()) -->Line_15 $$ class2Src.put(className, src)[ FD ]
Line_4 $$ JpsJavaCompilerConfiguration configuration = JpsJavaExtensionService.getInstance().getOrCreateCompilerConfiguration(context.getProjectDescriptor().getProject())-->Line_9 $$ if (!toCompilePaths.contains(src) && isGroovyFile(src) && !configuration.getCompilerExcludes().isExcluded(new File(src))) [ FD ]
Line_13 $$ if (out.endsWith(".class") && out.startsWith(moduleOutputPath)) -->Line_14 $$ final String className = out.substring(moduleOutputPath.length(), out.length() - ".class".length()).replace('/', '.')[ CD ]
Line_3 $$ final Map<String, String> class2Src = new HashMap<String, String>()-->Line_15 $$ class2Src.put(className, src)[ FD ]
Line_9 $$ if (!toCompilePaths.contains(src) && isGroovyFile(src) && !configuration.getCompilerExcludes().isExcluded(new File(src))) -->Line_10 $$ final Collection<String> outs = srcToOut.getOutputs(src)[ CD ]
Line_2 $$ private static Map<String, String> buildClassToSourceMap(ModuleChunk chunk, CompileContext context, Set<String> toCompilePaths, Map<ModuleBuildTarget, String> finalOutputs) throws IOException -->Line_4 $$ JpsJavaCompilerConfiguration configuration = JpsJavaExtensionService.getInstance().getOrCreateCompilerConfiguration(context.getProjectDescriptor().getProject())[ FD ]
Line_2 $$ private static Map<String, String> buildClassToSourceMap(ModuleChunk chunk, CompileContext context, Set<String> toCompilePaths, Map<ModuleBuildTarget, String> finalOutputs) throws IOException -->Line_22 $$ return class2Src[ CD ]
Line_8 $$ for (String src : srcToOut.getSources()) -->Line_9 $$ if (!toCompilePaths.contains(src) && isGroovyFile(src) && !configuration.getCompilerExcludes().isExcluded(new File(src))) [ FD ]
Line_12 $$ for (String out : outs) -->Line_14 $$ final String className = out.substring(moduleOutputPath.length(), out.length() - ".class".length()).replace('/', '.')[ FD ]
Line_2 $$ private static Map<String, String> buildClassToSourceMap(ModuleChunk chunk, CompileContext context, Set<String> toCompilePaths, Map<ModuleBuildTarget, String> finalOutputs) throws IOException -->Line_7 $$ final SourceToOutputMapping srcToOut = context.getProjectDescriptor().dataManager.getSourceToOutputMap(target)[ FD ]
Line_9 $$ if (!toCompilePaths.contains(src) && isGroovyFile(src) && !configuration.getCompilerExcludes().isExcluded(new File(src))) -->Line_11 $$ if (outs != null) [ CD ]
Line_10 $$ final Collection<String> outs = srcToOut.getOutputs(src)-->Line_11 $$ if (outs != null) [ FD ]
Line_7 $$ final SourceToOutputMapping srcToOut = context.getProjectDescriptor().dataManager.getSourceToOutputMap(target)-->Line_8 $$ for (String src : srcToOut.getSources()) [ FD ]
Line_2 $$ private static Map<String, String> buildClassToSourceMap(ModuleChunk chunk, CompileContext context, Set<String> toCompilePaths, Map<ModuleBuildTarget, String> finalOutputs) throws IOException -->Line_3 $$ final Map<String, String> class2Src = new HashMap<String, String>()[ CD ]
Line_6 $$ String moduleOutputPath = finalOutputs.get(target)-->Line_13 $$ if (out.endsWith(".class") && out.startsWith(moduleOutputPath)) [ FD ]
Line_13 $$ if (out.endsWith(".class") && out.startsWith(moduleOutputPath)) -->Line_15 $$ class2Src.put(className, src)[ CD ]
Line_14 $$ final String className = out.substring(moduleOutputPath.length(), out.length() - ".class".length()).replace('/', '.')-->Line_15 $$ class2Src.put(className, src)[ FD ]
Line_6 $$ String moduleOutputPath = finalOutputs.get(target)-->Line_14 $$ final String className = out.substring(moduleOutputPath.length(), out.length() - ".class".length()).replace('/', '.')[ FD ]
Line_2 $$ private static Map<String, String> buildClassToSourceMap(ModuleChunk chunk, CompileContext context, Set<String> toCompilePaths, Map<ModuleBuildTarget, String> finalOutputs) throws IOException -->Line_9 $$ if (!toCompilePaths.contains(src) && isGroovyFile(src) && !configuration.getCompilerExcludes().isExcluded(new File(src))) [ FD ]
Line_8 $$ for (String src : srcToOut.getSources()) -->Line_10 $$ final Collection<String> outs = srcToOut.getOutputs(src)[ FD ]
Line_12 $$ for (String out : outs) -->Line_13 $$ if (out.endsWith(".class") && out.startsWith(moduleOutputPath)) [ FD ]
Line_5 $$ for (ModuleBuildTarget target : chunk.getTargets()) -->Line_7 $$ final SourceToOutputMapping srcToOut = context.getProjectDescriptor().dataManager.getSourceToOutputMap(target)[ FD ]
Line_2 $$ private static Map<String, String> buildClassToSourceMap(ModuleChunk chunk, CompileContext context, Set<String> toCompilePaths, Map<ModuleBuildTarget, String> finalOutputs) throws IOException -->Line_6 $$ String moduleOutputPath = finalOutputs.get(target)[ FD ]
