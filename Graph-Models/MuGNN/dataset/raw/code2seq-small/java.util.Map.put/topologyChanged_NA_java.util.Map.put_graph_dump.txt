Line_2 $$ public void topologyChanged(TopologyChangedEvent<Node, Map.Entry<K, V>> event) -->Line_14 $$ Cache<Node, Map.Entry<K, V>> cache = event.getCache().getAdvancedCache().withFlags(Flag.FORCE_SYNCHRONOUS)[ FD ]
Line_12 $$ List<Node> nodes = addresses.stream().filter( address -> hash.locatePrimaryOwner(address).equals(localAddress)).map( address -> this.factory.createNode(address)).collect(Collectors.toList())-->Line_24 $$ ClusteringServerLogger.ROOT_LOGGER.registryPurgeFailed(e, event.getCache().getCacheManager().getCacheManagerConfiguration().globalJmxStatistics().cacheManagerName(), event.getCache().getName(), nodes)[ FD ]
Line_19 $$ if (old != null) -->Line_20 $$ removed.put(old.getKey(), old.getValue())[ CD ]
Line_2 $$ public void topologyChanged(TopologyChangedEvent<Node, Map.Entry<K, V>> event) -->Line_3 $$ if (event.isPre())[ FD ]
Line_2 $$ public void topologyChanged(TopologyChangedEvent<Node, Map.Entry<K, V>> event) -->Line_8 $$ Set<Address> addresses = new HashSet(event.getConsistentHashAtStart().getMembers())[ FD ]
Line_3 $$ if (event.isPre())-->Line_4 $$ return[ CD ]
Line_13 $$ if (!nodes.isEmpty()) -->Line_26 $$ if (!removed.isEmpty()) [ CD ]
Line_8 $$ Set<Address> addresses = new HashSet(event.getConsistentHashAtStart().getMembers())-->Line_12 $$ List<Node> nodes = addresses.stream().filter( address -> hash.locatePrimaryOwner(address).equals(localAddress)).map( address -> this.factory.createNode(address)).collect(Collectors.toList())[ FD ]
Line_2 $$ public void topologyChanged(TopologyChangedEvent<Node, Map.Entry<K, V>> event) -->Line_3 $$ if (event.isPre())[ CD ]
Line_13 $$ if (!nodes.isEmpty()) -->Line_15 $$ Map<K, V> removed = new HashMap()[ CD ]
Line_2 $$ public void topologyChanged(TopologyChangedEvent<Node, Map.Entry<K, V>> event) -->Line_11 $$ Address localAddress = event.getCache().getCacheManager().getAddress()[ FD ]
Line_26 $$ if (!removed.isEmpty()) -->Line_27 $$ this.notifyListeners(Event.Type.CACHE_ENTRY_REMOVED, removed)[ CD ]
Line_10 $$ if (!addresses.isEmpty()) -->Line_13 $$ if (!nodes.isEmpty()) [ CD ]
Line_12 $$ List<Node> nodes = addresses.stream().filter( address -> hash.locatePrimaryOwner(address).equals(localAddress)).map( address -> this.factory.createNode(address)).collect(Collectors.toList())-->Line_13 $$ if (!nodes.isEmpty()) [ FD ]
Line_13 $$ if (!nodes.isEmpty()) -->Line_14 $$ Cache<Node, Map.Entry<K, V>> cache = event.getCache().getAdvancedCache().withFlags(Flag.FORCE_SYNCHRONOUS)[ CD ]
Line_2 $$ public void topologyChanged(TopologyChangedEvent<Node, Map.Entry<K, V>> event) -->Line_24 $$ ClusteringServerLogger.ROOT_LOGGER.registryPurgeFailed(e, event.getCache().getCacheManager().getCacheManagerConfiguration().globalJmxStatistics().cacheManagerName(), event.getCache().getName(), nodes)[ FD ]
Line_2 $$ public void topologyChanged(TopologyChangedEvent<Node, Map.Entry<K, V>> event) -->Line_6 $$ ConsistentHash hash = event.getConsistentHashAtEnd()[ FD ]
Line_11 $$ Address localAddress = event.getCache().getCacheManager().getAddress()-->Line_12 $$ hash.locatePrimaryOwner(address).equals(localAddress)[ FD ]
Line_17 $$ for (Node node : nodes) -->Line_18 $$ Map.Entry<K, V> old = cache.remove(node)[ FD ]
Line_6 $$ ConsistentHash hash = event.getConsistentHashAtEnd()-->Line_12 $$ hash.locatePrimaryOwner(address).equals(localAddress)[ FD ]
Line_10 $$ if (!addresses.isEmpty()) -->Line_12 $$ List<Node> nodes = addresses.stream().filter( address -> hash.locatePrimaryOwner(address).equals(localAddress)).map( address -> this.factory.createNode(address)).collect(Collectors.toList())[ CD ]
Line_14 $$ Cache<Node, Map.Entry<K, V>> cache = event.getCache().getAdvancedCache().withFlags(Flag.FORCE_SYNCHRONOUS)-->Line_18 $$ Map.Entry<K, V> old = cache.remove(node)[ FD ]
Line_6 $$ ConsistentHash hash = event.getConsistentHashAtEnd()-->Line_7 $$ List<Address> members = hash.getMembers()[ FD ]
Line_15 $$ Map<K, V> removed = new HashMap()-->Line_27 $$ this.notifyListeners(Event.Type.CACHE_ENTRY_REMOVED, removed)[ FD ]
Line_2 $$ public void topologyChanged(TopologyChangedEvent<Node, Map.Entry<K, V>> event) -->Line_5 $$ this.executor.execute(() -> [ CD ]
Line_15 $$ Map<K, V> removed = new HashMap()-->Line_20 $$ removed.put(old.getKey(), old.getValue())[ FD ]
Line_8 $$ Set<Address> addresses = new HashSet(event.getConsistentHashAtStart().getMembers())-->Line_10 $$ if (!addresses.isEmpty()) [ FD ]
Line_10 $$ if (!addresses.isEmpty()) -->Line_11 $$ Address localAddress = event.getCache().getCacheManager().getAddress()[ CD ]
Line_8 $$ Set<Address> addresses = new HashSet(event.getConsistentHashAtStart().getMembers())-->Line_9 $$ addresses.removeAll(members)[ FD ]
Line_18 $$ Map.Entry<K, V> old = cache.remove(node)-->Line_19 $$ if (old != null) [ FD ]
Line_18 $$ Map.Entry<K, V> old = cache.remove(node)-->Line_20 $$ removed.put(old.getKey(), old.getValue())[ FD ]
Line_15 $$ Map<K, V> removed = new HashMap()-->Line_26 $$ if (!removed.isEmpty()) [ FD ]
Line_7 $$ List<Address> members = hash.getMembers()-->Line_9 $$ addresses.removeAll(members)[ FD ]
