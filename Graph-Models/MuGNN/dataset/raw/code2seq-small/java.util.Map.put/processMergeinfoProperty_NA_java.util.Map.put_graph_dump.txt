Line_2 $$ private SvnMergeInfoCache.MergeCheckResult processMergeinfoProperty(final String pathWithRevisionNumber, final long revisionAsked, @NotNull PropertyValue value, final String trunkRelativeUrl, final boolean self) throws SvnBindException -->Line_10 $$ if (mergedPathAffectingTrunkUrl != null) [ CD ]
Line_5 $$ String mergedPathAffectingTrunkUrl = ContainerUtil.find(mergedPathsMap.keySet(), new Condition<String>() -->Line_7 $$ return trunkRelativeUrl.startsWith(path)[ FD ]
Line_13 $$ boolean isAskedRevisionMerged = ContainerUtil.or(mergeRangeList.getRanges(), new Condition<SVNMergeRange>() -->Line_15 $$ return isInRange(range, revisionAsked) && (range.isInheritable() || self)[ CD ]
Line_2 $$ private SvnMergeInfoCache.MergeCheckResult processMergeinfoProperty(final String pathWithRevisionNumber, final long revisionAsked, @NotNull PropertyValue value, final String trunkRelativeUrl, final boolean self) throws SvnBindException -->Line_3 $$ SvnMergeInfoCache.MergeCheckResult result[ CD ]
Line_5 $$ String mergedPathAffectingTrunkUrl = ContainerUtil.find(mergedPathsMap.keySet(), new Condition<String>() -->Line_7 $$ return trunkRelativeUrl.startsWith(path)[ CD ]
Line_10 $$ if (mergedPathAffectingTrunkUrl != null) -->Line_11 $$ SVNMergeRangeList mergeRangeList = mergedPathsMap.get(mergedPathAffectingTrunkUrl)[ CD ]
Line_2 $$ private SvnMergeInfoCache.MergeCheckResult processMergeinfoProperty(final String pathWithRevisionNumber, final long revisionAsked, @NotNull PropertyValue value, final String trunkRelativeUrl, final boolean self) throws SvnBindException -->Line_15 $$ return isInRange(range, revisionAsked) && (range.isInheritable() || self)[ FD ]
Line_5 $$ String mergedPathAffectingTrunkUrl = ContainerUtil.find(mergedPathsMap.keySet(), new Condition<String>() -->Line_11 $$ SVNMergeRangeList mergeRangeList = mergedPathsMap.get(mergedPathAffectingTrunkUrl)[ FD ]
Line_2 $$ private SvnMergeInfoCache.MergeCheckResult processMergeinfoProperty(final String pathWithRevisionNumber, final long revisionAsked, @NotNull PropertyValue value, final String trunkRelativeUrl, final boolean self) throws SvnBindException -->Line_23 $$ return result[ CD ]
Line_2 $$ private SvnMergeInfoCache.MergeCheckResult processMergeinfoProperty(final String pathWithRevisionNumber, final long revisionAsked, @NotNull PropertyValue value, final String trunkRelativeUrl, final boolean self) throws SvnBindException -->Line_4 $$ Map<String, SVNMergeRangeList> mergedPathsMap = parseMergeInfo(value)[ CD ]
Line_10 $$ if (mergedPathAffectingTrunkUrl != null) -->Line_20 $$ myPathMergedMap.put(pathWithRevisionNumber, Collections.<Long>emptySet())[ CD ]
Line_4 $$ Map<String, SVNMergeRangeList> mergedPathsMap = parseMergeInfo(value)-->Line_11 $$ SVNMergeRangeList mergeRangeList = mergedPathsMap.get(mergedPathAffectingTrunkUrl)[ FD ]
Line_10 $$ if (mergedPathAffectingTrunkUrl != null) -->Line_12 $$ fillMergedRevisions(pathWithRevisionNumber, mergeRangeList)[ CD ]
Line_13 $$ boolean isAskedRevisionMerged = ContainerUtil.or(mergeRangeList.getRanges(), new Condition<SVNMergeRange>() -->Line_15 $$ return isInRange(range, revisionAsked) && (range.isInheritable() || self)[ FD ]
Line_10 $$ if (mergedPathAffectingTrunkUrl != null) -->Line_13 $$ boolean isAskedRevisionMerged = ContainerUtil.or(mergeRangeList.getRanges(), new Condition<SVNMergeRange>() [ CD ]
Line_5 $$ String mergedPathAffectingTrunkUrl = ContainerUtil.find(mergedPathsMap.keySet(), new Condition<String>() -->Line_10 $$ if (mergedPathAffectingTrunkUrl != null) [ FD ]
Line_2 $$ private SvnMergeInfoCache.MergeCheckResult processMergeinfoProperty(final String pathWithRevisionNumber, final long revisionAsked, @NotNull PropertyValue value, final String trunkRelativeUrl, final boolean self) throws SvnBindException -->Line_12 $$ fillMergedRevisions(pathWithRevisionNumber, mergeRangeList)[ FD ]
Line_2 $$ private SvnMergeInfoCache.MergeCheckResult processMergeinfoProperty(final String pathWithRevisionNumber, final long revisionAsked, @NotNull PropertyValue value, final String trunkRelativeUrl, final boolean self) throws SvnBindException -->Line_5 $$ String mergedPathAffectingTrunkUrl = ContainerUtil.find(mergedPathsMap.keySet(), new Condition<String>() [ CD ]
Line_2 $$ private SvnMergeInfoCache.MergeCheckResult processMergeinfoProperty(final String pathWithRevisionNumber, final long revisionAsked, @NotNull PropertyValue value, final String trunkRelativeUrl, final boolean self) throws SvnBindException -->Line_20 $$ myPathMergedMap.put(pathWithRevisionNumber, Collections.<Long>emptySet())[ FD ]
Line_2 $$ private SvnMergeInfoCache.MergeCheckResult processMergeinfoProperty(final String pathWithRevisionNumber, final long revisionAsked, @NotNull PropertyValue value, final String trunkRelativeUrl, final boolean self) throws SvnBindException -->Line_4 $$ Map<String, SVNMergeRangeList> mergedPathsMap = parseMergeInfo(value)[ FD ]
Line_4 $$ Map<String, SVNMergeRangeList> mergedPathsMap = parseMergeInfo(value)-->Line_5 $$ String mergedPathAffectingTrunkUrl = ContainerUtil.find(mergedPathsMap.keySet(), new Condition<String>() [ FD ]
Line_10 $$ if (mergedPathAffectingTrunkUrl != null) -->Line_18 $$ result = SvnMergeInfoCache.MergeCheckResult.getInstance(isAskedRevisionMerged)[ CD ]
Line_2 $$ private SvnMergeInfoCache.MergeCheckResult processMergeinfoProperty(final String pathWithRevisionNumber, final long revisionAsked, @NotNull PropertyValue value, final String trunkRelativeUrl, final boolean self) throws SvnBindException -->Line_7 $$ return trunkRelativeUrl.startsWith(path)[ FD ]
