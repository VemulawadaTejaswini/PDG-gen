Line_12 $$ final String[] finalOutputRef = new String[1]-->Line_13 $$ fillFromArgsFile(argsFile, config, patchers, compilerMessages, srcFiles, class2File, finalOutputRef)[ FD ]
Line_46 $$ unit.addPhaseOperation(new CompilationUnit.SourceUnitOperation() -->Line_48 $$ File file = new File(source.getName())[ FD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_45 $$ final CompilationUnit unit = createCompilationUnit(forStubs, config, buildClassLoaderFor(config, resourceLoader), mailbox, wrapper)[ FD ]
Line_45 $$ final CompilationUnit unit = createCompilationUnit(forStubs, config, buildClassLoaderFor(config, resourceLoader), mailbox, wrapper)-->Line_55 $$ runPatchers(patchers, compilerMessages, unit, resourceLoader, srcFiles)[ FD ]
Line_16 $$ String[] finalOutputs = finalOutputRef[0].split(File.pathSeparator)-->Line_59 $$ renameResources(finalOutputs, TEMP_RESOURCE_SUFFIX, "")[ FD ]
Line_4 $$ final CompilerConfiguration config = new CompilerConfiguration()-->Line_35 $$ applyConfigurationScript(new File(configScript), config)[ FD ]
Line_4 $$ final CompilerConfiguration config = new CompilerConfiguration()-->Line_45 $$ final CompilationUnit unit = createCompilationUnit(forStubs, config, buildClassLoaderFor(config, resourceLoader), mailbox, wrapper)[ FD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_74 $$ return false[ CD ]
Line_22 $$ if (mailbox != null) -->Line_23 $$ config.setTargetDirectory(finalOutputs[0])[ CD ]
Line_4 $$ final CompilerConfiguration config = new CompilerConfiguration()-->Line_29 $$ config.getOptimizationOptions().put("classLoaderResolving", false)[ FD ]
Line_14 $$ if (srcFiles.isEmpty())-->Line_15 $$ return true[ CD ]
Line_27 $$ if (!"false".equals(System.getProperty(GroovyRtConstants.GROOVYC_ASM_RESOLVING_ONLY))) -->Line_29 $$ config.getOptimizationOptions().put("classLoaderResolving", false)[ CD ]
Line_10 $$ final List<File> srcFiles = new ArrayList<File>()-->Line_55 $$ runPatchers(patchers, compilerMessages, unit, resourceLoader, srcFiles)[ FD ]
Line_27 $$ if (!"false".equals(System.getProperty(GroovyRtConstants.GROOVYC_ASM_RESOLVING_ONLY))) -->Line_28 $$ config.getOptimizationOptions().put("asmResolving", true)[ CD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_6 $$ config.setOutput(new PrintWriter(System.err))[ CD ]
Line_18 $$ Map<String, Object> options = new HashMap<String, Object>()-->Line_19 $$ options.put(STUB_DIR, config.getTargetDirectory())[ FD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_33 $$ if (configScript != null && configScript.length() > 0) [ CD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_39 $$ System.out.println(GroovyRtConstants.PRESENTABLE_MESSAGE + "Groovyc: loading sources...")[ CD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_5 $$ config.setClasspath("")[ CD ]
Line_18 $$ Map<String, Object> options = new HashMap<String, Object>()-->Line_20 $$ options.put("keepStubs", Boolean.TRUE)[ FD ]
Line_44 $$ final GroovyCompilerWrapper wrapper = new GroovyCompilerWrapper(compilerMessages, forStubs)-->Line_45 $$ final CompilationUnit unit = createCompilationUnit(forStubs, config, buildClassLoaderFor(config, resourceLoader), mailbox, wrapper)[ FD ]
Line_46 $$ unit.addPhaseOperation(new CompilationUnit.SourceUnitOperation() -->Line_48 $$ File file = new File(source.getName())[ CD ]
Line_46 $$ unit.addPhaseOperation(new CompilationUnit.SourceUnitOperation() -->Line_49 $$ for (ClassNode aClass : source.getAST().getClasses()) [ FD ]
Line_48 $$ File file = new File(source.getName())-->Line_50 $$ resourceLoader.myClass2File.put(aClass.getName(), file)[ FD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_16 $$ String[] finalOutputs = finalOutputRef[0].split(File.pathSeparator)[ CD ]
Line_16 $$ String[] finalOutputs = finalOutputRef[0].split(File.pathSeparator)-->Line_40 $$ renameResources(finalOutputs, "", TEMP_RESOURCE_SUFFIX)[ FD ]
Line_4 $$ final CompilerConfiguration config = new CompilerConfiguration()-->Line_19 $$ options.put(STUB_DIR, config.getTargetDirectory())[ FD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_22 $$ if (mailbox != null) [ FD ]
Line_9 $$ final List<CompilationUnitPatcher> patchers = new ArrayList<CompilationUnitPatcher>()-->Line_55 $$ runPatchers(patchers, compilerMessages, unit, resourceLoader, srcFiles)[ FD ]
Line_4 $$ final CompilerConfiguration config = new CompilerConfiguration()-->Line_13 $$ fillFromArgsFile(argsFile, config, patchers, compilerMessages, srcFiles, class2File, finalOutputRef)[ FD ]
Line_9 $$ final List<CompilationUnitPatcher> patchers = new ArrayList<CompilationUnitPatcher>()-->Line_13 $$ fillFromArgsFile(argsFile, config, patchers, compilerMessages, srcFiles, class2File, finalOutputRef)[ FD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_54 $$ addSources(forStubs, srcFiles, unit)[ FD ]
Line_66 $$ if (message.getCategory() == GroovyCompilerMessageCategories.ERROR) -->Line_67 $$ if (errorCount > 100) [ CD ]
Line_45 $$ final CompilationUnit unit = createCompilationUnit(forStubs, config, buildClassLoaderFor(config, resourceLoader), mailbox, wrapper)-->Line_46 $$ unit.addPhaseOperation(new CompilationUnit.SourceUnitOperation() [ FD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_10 $$ final List<File> srcFiles = new ArrayList<File>()[ CD ]
Line_4 $$ final CompilerConfiguration config = new CompilerConfiguration()-->Line_28 $$ config.getOptimizationOptions().put("asmResolving", true)[ FD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_33 $$ if (configScript != null && configScript.length() > 0) [ FD ]
Line_17 $$ if (forStubs) -->Line_18 $$ Map<String, Object> options = new HashMap<String, Object>()[ CD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_17 $$ if (forStubs) [ CD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_8 $$ final List<CompilerMessage> compilerMessages = new ArrayList<CompilerMessage>()[ CD ]
Line_10 $$ final List<File> srcFiles = new ArrayList<File>()-->Line_14 $$ if (srcFiles.isEmpty())[ FD ]
Line_17 $$ if (forStubs) -->Line_21 $$ config.setJointCompilationOptions(options)[ CD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_7 $$ config.setWarningLevel(WarningMessage.PARANOIA)[ CD ]
Line_43 $$ final AstAwareResourceLoader resourceLoader = new AstAwareResourceLoader(class2File)-->Line_55 $$ runPatchers(patchers, compilerMessages, unit, resourceLoader, srcFiles)[ FD ]
Line_4 $$ final CompilerConfiguration config = new CompilerConfiguration()-->Line_21 $$ config.setJointCompilationOptions(options)[ FD ]
Line_45 $$ final CompilationUnit unit = createCompilationUnit(forStubs, config, buildClassLoaderFor(config, resourceLoader), mailbox, wrapper)-->Line_57 $$ compiledFiles = wrapper.compile(unit, forStubs && mailbox == null ? Phases.CONVERSION : Phases.ALL)[ FD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_14 $$ if (srcFiles.isEmpty())[ CD ]
Line_11 $$ final Map<String, File> class2File = new HashMap<String, File>()-->Line_13 $$ fillFromArgsFile(argsFile, config, patchers, compilerMessages, srcFiles, class2File, finalOutputRef)[ FD ]
Line_8 $$ final List<CompilerMessage> compilerMessages = new ArrayList<CompilerMessage>()-->Line_13 $$ fillFromArgsFile(argsFile, config, patchers, compilerMessages, srcFiles, class2File, finalOutputRef)[ FD ]
Line_10 $$ final List<File> srcFiles = new ArrayList<File>()-->Line_13 $$ fillFromArgsFile(argsFile, config, patchers, compilerMessages, srcFiles, class2File, finalOutputRef)[ FD ]
Line_44 $$ final GroovyCompilerWrapper wrapper = new GroovyCompilerWrapper(compilerMessages, forStubs)-->Line_57 $$ compiledFiles = wrapper.compile(unit, forStubs && mailbox == null ? Phases.CONVERSION : Phases.ALL)[ FD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_40 $$ renameResources(finalOutputs, "", TEMP_RESOURCE_SUFFIX)[ CD ]
Line_4 $$ final CompilerConfiguration config = new CompilerConfiguration()-->Line_5 $$ config.setClasspath("")[ FD ]
Line_10 $$ final List<File> srcFiles = new ArrayList<File>()-->Line_54 $$ addSources(forStubs, srcFiles, unit)[ FD ]
Line_17 $$ if (forStubs) -->Line_20 $$ options.put("keepStubs", Boolean.TRUE)[ CD ]
Line_8 $$ final List<CompilerMessage> compilerMessages = new ArrayList<CompilerMessage>()-->Line_55 $$ runPatchers(patchers, compilerMessages, unit, resourceLoader, srcFiles)[ FD ]
Line_4 $$ final CompilerConfiguration config = new CompilerConfiguration()-->Line_23 $$ config.setTargetDirectory(finalOutputs[0])[ FD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_9 $$ final List<CompilationUnitPatcher> patchers = new ArrayList<CompilationUnitPatcher>()[ CD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_4 $$ final CompilerConfiguration config = new CompilerConfiguration()[ CD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_12 $$ final String[] finalOutputRef = new String[1][ CD ]
Line_41 $$ final List<GroovyCompilerWrapper.OutputItem> compiledFiles-->Line_63 $$ reportCompiledItems(compiledFiles)[ FD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_63 $$ reportCompiledItems(compiledFiles)[ CD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_11 $$ final Map<String, File> class2File = new HashMap<String, File>()[ CD ]
Line_4 $$ final CompilerConfiguration config = new CompilerConfiguration()-->Line_7 $$ config.setWarningLevel(WarningMessage.PARANOIA)[ FD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_62 $$ System.out.println()[ CD ]
Line_17 $$ if (forStubs) -->Line_22 $$ if (mailbox != null) [ CD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_3 $$ File argsFile = new File(argsPath)[ CD ]
Line_18 $$ Map<String, Object> options = new HashMap<String, Object>()-->Line_21 $$ config.setJointCompilationOptions(options)[ FD ]
Line_17 $$ if (forStubs) -->Line_19 $$ options.put(STUB_DIR, config.getTargetDirectory())[ CD ]
Line_43 $$ final AstAwareResourceLoader resourceLoader = new AstAwareResourceLoader(class2File)-->Line_45 $$ final CompilationUnit unit = createCompilationUnit(forStubs, config, buildClassLoaderFor(config, resourceLoader), mailbox, wrapper)[ FD ]
Line_49 $$ for (ClassNode aClass : source.getAST().getClasses()) -->Line_50 $$ resourceLoader.myClass2File.put(aClass.getName(), file)[ FD ]
Line_45 $$ final CompilationUnit unit = createCompilationUnit(forStubs, config, buildClassLoaderFor(config, resourceLoader), mailbox, wrapper)-->Line_54 $$ addSources(forStubs, srcFiles, unit)[ FD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_41 $$ final List<GroovyCompilerWrapper.OutputItem> compiledFiles[ CD ]
Line_2 $$ public static boolean runGroovyc(boolean forStubs, String argsPath, String configScript, Queue mailbox) -->Line_13 $$ fillFromArgsFile(argsFile, config, patchers, compilerMessages, srcFiles, class2File, finalOutputRef)[ CD ]
Line_4 $$ final CompilerConfiguration config = new CompilerConfiguration()-->Line_6 $$ config.setOutput(new PrintWriter(System.err))[ FD ]
Line_3 $$ File argsFile = new File(argsPath)-->Line_13 $$ fillFromArgsFile(argsFile, config, patchers, compilerMessages, srcFiles, class2File, finalOutputRef)[ FD ]
