Line_2 $$ public synchronized IndexShard createShard(ShardRouting routing) throws IOException -->Line_8 $$ final ShardId shardId = routing.shardId()[ FD ]
Line_17 $$ path = ShardPath.loadShardPath(logger, nodeEnv, shardId, this.indexSettings)-->Line_39 $$ logger.debug("[ FD ]
Line_9 $$ boolean success = false-->Line_62 $$ success = true[ FD ]
Line_15 $$ ShardPath path-->Line_41 $$ logger.debug("[ FD ]
Line_7 $$ final Settings indexSettings = this.indexSettings.getSettings()-->Line_14 $$ eventListener.beforeIndexShardCreated(shardId, indexSettings)[ FD ]
Line_2 $$ public synchronized IndexShard createShard(ShardRouting routing) throws IOException -->Line_38 $$ path = ShardPath.selectNewPathForShard(nodeEnv, shardId, this.indexSettings, routing.getExpectedShardSize() == ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE ? getAvgShardSizeInBytes() : routing.getExpectedShardSize(), dataPathToShardCount)[ FD ]
Line_8 $$ final ShardId shardId = routing.shardId()-->Line_41 $$ logger.debug("[ FD ]
Line_50 $$ indexShard = new ShadowIndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider)-->Line_61 $$ shards = newMapBuilder(shards).put(shardId.id(), indexShard).immutableMap()[ FD ]
Line_17 $$ path = ShardPath.loadShardPath(logger, nodeEnv, shardId, this.indexSettings)-->Line_48 $$ store = new Store(shardId, this.indexSettings, indexStore.newDirectoryService(path), lock, new StoreCloseListener(shardId, canDeleteShardContent, () -> nodeServicesProvider.getIndicesQueryCache().onClose(shardId)))[ FD ]
Line_15 $$ ShardPath path-->Line_48 $$ store = new Store(shardId, this.indexSettings, indexStore.newDirectoryService(path), lock, new StoreCloseListener(shardId, canDeleteShardContent, () -> nodeServicesProvider.getIndicesQueryCache().onClose(shardId)))[ FD ]
Line_8 $$ final ShardId shardId = routing.shardId()-->Line_43 $$ if (shards.containsKey(shardId.id())) [ FD ]
Line_11 $$ IndexShard indexShard = null-->Line_50 $$ indexShard = new ShadowIndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider)[ FD ]
Line_17 $$ path = ShardPath.loadShardPath(logger, nodeEnv, shardId, this.indexSettings)-->Line_41 $$ logger.debug("[ FD ]
Line_28 $$ if (path == null) -->Line_39 $$ logger.debug("[ CD ]
Line_11 $$ IndexShard indexShard = null-->Line_67 $$ closeShard("initialization failed", shardId, indexShard, store, eventListener)[ FD ]
Line_8 $$ final ShardId shardId = routing.shardId()-->Line_46 $$ logger.debug("creating shard_id [ FD ]
Line_8 $$ final ShardId shardId = routing.shardId()-->Line_12 $$ final ShardLock lock = nodeEnv.shardLock(shardId, TimeUnit.SECONDS.toMillis(5))[ FD ]
Line_38 $$ path = ShardPath.selectNewPathForShard(nodeEnv, shardId, this.indexSettings, routing.getExpectedShardSize() == ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE ? getAvgShardSizeInBytes() : routing.getExpectedShardSize(), dataPathToShardCount)-->Line_41 $$ logger.debug("[ FD ]
Line_7 $$ final Settings indexSettings = this.indexSettings.getSettings()-->Line_49 $$ if (useShadowEngine(primary, indexSettings)) [ FD ]
Line_2 $$ public synchronized IndexShard createShard(ShardRouting routing) throws IOException -->Line_11 $$ IndexShard indexShard = null[ CD ]
Line_12 $$ final ShardLock lock = nodeEnv.shardLock(shardId, TimeUnit.SECONDS.toMillis(5))-->Line_21 $$ ShardPath.deleteLeftoverShardDirectory(logger, nodeEnv, lock, this.indexSettings)[ FD ]
Line_8 $$ final ShardId shardId = routing.shardId()-->Line_67 $$ closeShard("initialization failed", shardId, indexShard, store, eventListener)[ FD ]
Line_38 $$ path = ShardPath.selectNewPathForShard(nodeEnv, shardId, this.indexSettings, routing.getExpectedShardSize() == ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE ? getAvgShardSizeInBytes() : routing.getExpectedShardSize(), dataPathToShardCount)-->Line_48 $$ store = new Store(shardId, this.indexSettings, indexStore.newDirectoryService(path), lock, new StoreCloseListener(shardId, canDeleteShardContent, () -> nodeServicesProvider.getIndicesQueryCache().onClose(shardId)))[ FD ]
Line_2 $$ public synchronized IndexShard createShard(ShardRouting routing) throws IOException -->Line_12 $$ final ShardLock lock = nodeEnv.shardLock(shardId, TimeUnit.SECONDS.toMillis(5))[ CD ]
Line_15 $$ ShardPath path-->Line_38 $$ path = ShardPath.selectNewPathForShard(nodeEnv, shardId, this.indexSettings, routing.getExpectedShardSize() == ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE ? getAvgShardSizeInBytes() : routing.getExpectedShardSize(), dataPathToShardCount)[ FD ]
Line_22 $$ path = ShardPath.loadShardPath(logger, nodeEnv, shardId, this.indexSettings)-->Line_39 $$ logger.debug("[ FD ]
Line_17 $$ path = ShardPath.loadShardPath(logger, nodeEnv, shardId, this.indexSettings)-->Line_38 $$ path = ShardPath.selectNewPathForShard(nodeEnv, shardId, this.indexSettings, routing.getExpectedShardSize() == ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE ? getAvgShardSizeInBytes() : routing.getExpectedShardSize(), dataPathToShardCount)[ FD ]
Line_49 $$ if (useShadowEngine(primary, indexSettings)) -->Line_52 $$ indexShard = new IndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider)[ CD ]
Line_15 $$ ShardPath path-->Line_28 $$ if (path == null) [ FD ]
Line_62 $$ success = true-->Line_65 $$ if (success == false) [ FD ]
Line_48 $$ store = new Store(shardId, this.indexSettings, indexStore.newDirectoryService(path), lock, new StoreCloseListener(shardId, canDeleteShardContent, () -> nodeServicesProvider.getIndicesQueryCache().onClose(shardId)))-->Line_67 $$ closeShard("initialization failed", shardId, indexShard, store, eventListener)[ FD ]
Line_33 $$ if (curCount == null) -->Line_34 $$ curCount = 0[ CD ]
Line_10 $$ Store store = null-->Line_48 $$ store = new Store(shardId, this.indexSettings, indexStore.newDirectoryService(path), lock, new StoreCloseListener(shardId, canDeleteShardContent, () -> nodeServicesProvider.getIndicesQueryCache().onClose(shardId)))[ FD ]
Line_7 $$ final Settings indexSettings = this.indexSettings.getSettings()-->Line_47 $$ final boolean canDeleteShardContent = IndexMetaData.isOnSharedFilesystem(indexSettings) == false || (primary && IndexMetaData.isOnSharedFilesystem(indexSettings))[ FD ]
Line_8 $$ final ShardId shardId = routing.shardId()-->Line_39 $$ logger.debug("[ FD ]
Line_52 $$ indexShard = new IndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider)-->Line_55 $$ eventListener.afterIndexShardCreated(indexShard)[ FD ]
Line_22 $$ path = ShardPath.loadShardPath(logger, nodeEnv, shardId, this.indexSettings)-->Line_38 $$ path = ShardPath.selectNewPathForShard(nodeEnv, shardId, this.indexSettings, routing.getExpectedShardSize() == ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE ? getAvgShardSizeInBytes() : routing.getExpectedShardSize(), dataPathToShardCount)[ FD ]
Line_28 $$ if (path == null) -->Line_29 $$ Map<Path, Integer> dataPathToShardCount = new HashMap()[ CD ]
Line_2 $$ public synchronized IndexShard createShard(ShardRouting routing) throws IOException -->Line_7 $$ final Settings indexSettings = this.indexSettings.getSettings()[ CD ]
Line_8 $$ final ShardId shardId = routing.shardId()-->Line_17 $$ path = ShardPath.loadShardPath(logger, nodeEnv, shardId, this.indexSettings)[ FD ]
Line_15 $$ ShardPath path-->Line_22 $$ path = ShardPath.loadShardPath(logger, nodeEnv, shardId, this.indexSettings)[ FD ]
Line_2 $$ public synchronized IndexShard createShard(ShardRouting routing) throws IOException -->Line_56 $$ indexShard.updateRoutingEntry(routing, true)[ FD ]
Line_8 $$ final ShardId shardId = routing.shardId()-->Line_38 $$ path = ShardPath.selectNewPathForShard(nodeEnv, shardId, this.indexSettings, routing.getExpectedShardSize() == ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE ? getAvgShardSizeInBytes() : routing.getExpectedShardSize(), dataPathToShardCount)[ FD ]
Line_15 $$ ShardPath path-->Line_17 $$ path = ShardPath.loadShardPath(logger, nodeEnv, shardId, this.indexSettings)[ FD ]
Line_17 $$ path = ShardPath.loadShardPath(logger, nodeEnv, shardId, this.indexSettings)-->Line_22 $$ path = ShardPath.loadShardPath(logger, nodeEnv, shardId, this.indexSettings)[ FD ]
Line_2 $$ public synchronized IndexShard createShard(ShardRouting routing) throws IOException -->Line_3 $$ final boolean primary = routing.primary()[ FD ]
Line_29 $$ Map<Path, Integer> dataPathToShardCount = new HashMap()-->Line_38 $$ path = ShardPath.selectNewPathForShard(nodeEnv, shardId, this.indexSettings, routing.getExpectedShardSize() == ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE ? getAvgShardSizeInBytes() : routing.getExpectedShardSize(), dataPathToShardCount)[ FD ]
Line_50 $$ indexShard = new ShadowIndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider)-->Line_54 $$ eventListener.indexShardStateChanged(indexShard, null, indexShard.state(), "shard created")[ FD ]
Line_15 $$ ShardPath path-->Line_39 $$ logger.debug("[ FD ]
Line_2 $$ public synchronized IndexShard createShard(ShardRouting routing) throws IOException -->Line_10 $$ Store store = null[ CD ]
Line_31 $$ Path dataPath = shard.shardPath().getRootStatePath()-->Line_36 $$ dataPathToShardCount.put(dataPath, curCount + 1)[ FD ]
Line_57 $$ if (shards.isEmpty() && this.indexSettings.getTranslogSyncInterval().millis() != 0) -->Line_59 $$ new AsyncTranslogFSync(this, threadPool).schedule()[ CD ]
Line_2 $$ public synchronized IndexShard createShard(ShardRouting routing) throws IOException -->Line_9 $$ boolean success = false[ CD ]
Line_29 $$ Map<Path, Integer> dataPathToShardCount = new HashMap()-->Line_32 $$ Integer curCount = dataPathToShardCount.get(dataPath)[ FD ]
Line_9 $$ boolean success = false-->Line_65 $$ if (success == false) [ FD ]
Line_38 $$ path = ShardPath.selectNewPathForShard(nodeEnv, shardId, this.indexSettings, routing.getExpectedShardSize() == ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE ? getAvgShardSizeInBytes() : routing.getExpectedShardSize(), dataPathToShardCount)-->Line_39 $$ logger.debug("[ FD ]
Line_50 $$ indexShard = new ShadowIndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider)-->Line_52 $$ indexShard = new IndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider)[ FD ]
Line_32 $$ Integer curCount = dataPathToShardCount.get(dataPath)-->Line_33 $$ if (curCount == null) [ FD ]
Line_32 $$ Integer curCount = dataPathToShardCount.get(dataPath)-->Line_34 $$ curCount = 0[ FD ]
Line_8 $$ final ShardId shardId = routing.shardId()-->Line_48 $$ nodeServicesProvider.getIndicesQueryCache().onClose(shardId)[ FD ]
Line_2 $$ public synchronized IndexShard createShard(ShardRouting routing) throws IOException -->Line_3 $$ final boolean primary = routing.primary()[ CD ]
Line_8 $$ final ShardId shardId = routing.shardId()-->Line_14 $$ eventListener.beforeIndexShardCreated(shardId, indexSettings)[ FD ]
Line_2 $$ public synchronized IndexShard createShard(ShardRouting routing) throws IOException -->Line_5 $$ throw new IllegalStateException("Can't create shard " + routing.shardId() + ", closed")[ FD ]
Line_22 $$ path = ShardPath.loadShardPath(logger, nodeEnv, shardId, this.indexSettings)-->Line_48 $$ store = new Store(shardId, this.indexSettings, indexStore.newDirectoryService(path), lock, new StoreCloseListener(shardId, canDeleteShardContent, () -> nodeServicesProvider.getIndicesQueryCache().onClose(shardId)))[ FD ]
Line_2 $$ public synchronized IndexShard createShard(ShardRouting routing) throws IOException -->Line_4 $$ if (closed.get()) [ CD ]
Line_2 $$ public synchronized IndexShard createShard(ShardRouting routing) throws IOException -->Line_8 $$ final ShardId shardId = routing.shardId()[ CD ]
Line_57 $$ if (shards.isEmpty() && this.indexSettings.getTranslogSyncInterval().millis() != 0) -->Line_58 $$ ThreadPool threadPool = nodeServicesProvider.getThreadPool()[ CD ]
Line_11 $$ IndexShard indexShard = null-->Line_61 $$ shards = newMapBuilder(shards).put(shardId.id(), indexShard).immutableMap()[ FD ]
Line_49 $$ if (useShadowEngine(primary, indexSettings)) -->Line_50 $$ indexShard = new ShadowIndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider)[ CD ]
Line_52 $$ indexShard = new IndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider)-->Line_61 $$ shards = newMapBuilder(shards).put(shardId.id(), indexShard).immutableMap()[ FD ]
Line_8 $$ final ShardId shardId = routing.shardId()-->Line_22 $$ path = ShardPath.loadShardPath(logger, nodeEnv, shardId, this.indexSettings)[ FD ]
Line_29 $$ Map<Path, Integer> dataPathToShardCount = new HashMap()-->Line_36 $$ dataPathToShardCount.put(dataPath, curCount + 1)[ FD ]
Line_28 $$ if (path == null) -->Line_41 $$ logger.debug("[ CD ]
Line_11 $$ IndexShard indexShard = null-->Line_54 $$ eventListener.indexShardStateChanged(indexShard, null, indexShard.state(), "shard created")[ FD ]
Line_50 $$ indexShard = new ShadowIndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider)-->Line_67 $$ closeShard("initialization failed", shardId, indexShard, store, eventListener)[ FD ]
Line_28 $$ if (path == null) -->Line_38 $$ path = ShardPath.selectNewPathForShard(nodeEnv, shardId, this.indexSettings, routing.getExpectedShardSize() == ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE ? getAvgShardSizeInBytes() : routing.getExpectedShardSize(), dataPathToShardCount)[ CD ]
Line_52 $$ indexShard = new IndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider)-->Line_56 $$ indexShard.updateRoutingEntry(routing, true)[ FD ]
Line_3 $$ final boolean primary = routing.primary()-->Line_49 $$ if (useShadowEngine(primary, indexSettings)) [ FD ]
Line_11 $$ IndexShard indexShard = null-->Line_55 $$ eventListener.afterIndexShardCreated(indexShard)[ FD ]
Line_10 $$ Store store = null-->Line_67 $$ closeShard("initialization failed", shardId, indexShard, store, eventListener)[ FD ]
Line_52 $$ indexShard = new IndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider)-->Line_54 $$ eventListener.indexShardStateChanged(indexShard, null, indexShard.state(), "shard created")[ FD ]
Line_8 $$ final ShardId shardId = routing.shardId()-->Line_61 $$ shards = newMapBuilder(shards).put(shardId.id(), indexShard).immutableMap()[ FD ]
Line_65 $$ if (success == false) -->Line_66 $$ IOUtils.closeWhileHandlingException(lock)[ CD ]
Line_52 $$ indexShard = new IndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider)-->Line_67 $$ closeShard("initialization failed", shardId, indexShard, store, eventListener)[ FD ]
Line_8 $$ final ShardId shardId = routing.shardId()-->Line_19 $$ logger.warn("[ FD ]
Line_12 $$ final ShardLock lock = nodeEnv.shardLock(shardId, TimeUnit.SECONDS.toMillis(5))-->Line_66 $$ IOUtils.closeWhileHandlingException(lock)[ FD ]
Line_22 $$ path = ShardPath.loadShardPath(logger, nodeEnv, shardId, this.indexSettings)-->Line_28 $$ if (path == null) [ FD ]
Line_22 $$ path = ShardPath.loadShardPath(logger, nodeEnv, shardId, this.indexSettings)-->Line_41 $$ logger.debug("[ FD ]
Line_11 $$ IndexShard indexShard = null-->Line_52 $$ indexShard = new IndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider)[ FD ]
Line_65 $$ if (success == false) -->Line_67 $$ closeShard("initialization failed", shardId, indexShard, store, eventListener)[ CD ]
Line_11 $$ IndexShard indexShard = null-->Line_56 $$ indexShard.updateRoutingEntry(routing, true)[ FD ]
Line_50 $$ indexShard = new ShadowIndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider)-->Line_55 $$ eventListener.afterIndexShardCreated(indexShard)[ FD ]
Line_50 $$ indexShard = new ShadowIndexShard(shardId, this.indexSettings, path, store, indexCache, mapperService, similarityService, indexFieldData, engineFactory, eventListener, searcherWrapper, nodeServicesProvider)-->Line_56 $$ indexShard.updateRoutingEntry(routing, true)[ FD ]
Line_30 $$ for (IndexShard shard : this) -->Line_31 $$ Path dataPath = shard.shardPath().getRootStatePath()[ FD ]
Line_31 $$ Path dataPath = shard.shardPath().getRootStatePath()-->Line_32 $$ Integer curCount = dataPathToShardCount.get(dataPath)[ FD ]
Line_17 $$ path = ShardPath.loadShardPath(logger, nodeEnv, shardId, this.indexSettings)-->Line_28 $$ if (path == null) [ FD ]
