Line_60 $$ final String messageText = message.getText()-->Line_63 $$ indicator.setText(messageText)[ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_47 $$ view.clearOldMessages(compileContext.getCompileScope(), compileContext.getSessionId())[ FD ]
Line_6 $$ final boolean forceBuild = !compileContext.isMake()-->Line_17 $$ scopes = CompileScopeUtil.mergeScopes(scopes, provider.getBuildTargetScopes(scope, myCompilerFilter, myProject, forceBuild))[ FD ]
Line_129 $$ final String text = message.getMessageText()-->Line_131 $$ compileContext.addMessage(CompilerMessageCategory.INFORMATION, text, null, -1, -1)[ FD ]
Line_92 $$ if (!artifacts.isEmpty()) -->Line_96 $$ writtenArtifactOutputPaths.add(FileUtil.toSystemDependentName(DeploymentUtil.appendToPath(root, relativePath)))[ CD ]
Line_7 $$ List<TargetTypeBuildScope> explicitScopes = CompileScopeUtil.getBaseScopeForExternalBuild(scope)-->Line_8 $$ if (explicitScopes != null) [ FD ]
Line_69 $$ String sourceFilePath = message.hasSourceFilePath() ? message.getSourceFilePath() : null-->Line_70 $$ if (sourceFilePath != null) [ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_38 $$ final BuildManager buildManager = BuildManager.getInstance()[ CD ]
Line_126 $$ if (event.hasCustomBuilderMessage()) -->Line_127 $$ final CmdlineRemoteProto.Message.BuilderMessage.BuildEvent.CustomBuilderMessage message = event.getCustomBuilderMessage()[ CD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_7 $$ List<TargetTypeBuildScope> explicitScopes = CompileScopeUtil.getBaseScopeForExternalBuild(scope)[ CD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_74 $$ final long column = message.hasColumn() ? message.getColumn() : -1[ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_56 $$ compileContext.putUserData(COMPILE_SERVER_BUILD_STATUS, ExitStatus.ERRORS)[ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_51 $$ compileContext.addMessage(CompilerMessageCategory.ERROR, failure.hasDescription() ? failure.getDescription() : "", null, -1, -1)[ FD ]
Line_20 $$ final Map<String, String> builderParams-->Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) [ FD ]
Line_22 $$ builderParams = Collections.emptyMap()-->Line_33 $$ builderParams = Collections.emptyMap()[ FD ]
Line_85 $$ Set<String> writtenArtifactOutputPaths = outputToArtifact != null ? new THashSet<String>(FileUtil.PATH_HASHING_STRATEGY) : null-->Line_101 $$ ArtifactsCompiler.addWrittenPaths(compileContext, writtenArtifactOutputPaths)[ FD ]
Line_61 $$ if (kind == CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind.PROGRESS) -->Line_68 $$ final CompilerMessageCategory category = kind == CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind.ERROR ? CompilerMessageCategory.ERROR : kind == CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind.WARNING ? CompilerMessageCategory.WARNING : CompilerMessageCategory.INFORMATION[ CD ]
Line_37 $$ final MultiMap<String, Artifact> outputToArtifact = ArtifactCompilerUtil.containsArtifacts(scopes) ? ArtifactCompilerUtil.createOutputToArtifactMap(myProject) : null-->Line_91 $$ Collection<Artifact> artifacts = outputToArtifact.get(root)[ FD ]
Line_24 $$ final Map<Key, Object> exported = scope.exportUserData()-->Line_25 $$ if (!exported.isEmpty()) [ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_4 $$ final Collection<String> paths = CompileScopeUtil.fetchFiles(compileContext)[ FD ]
Line_26 $$ builderParams = new HashMap<String, String>()-->Line_30 $$ builderParams.put(_key, _value)[ FD ]
Line_110 $$ status = ExitStatus.CANCELLED-->Line_119 $$ status = ExitStatus.UP_TO_DATE[ FD ]
Line_52 $$ final String trace = failure.hasStacktrace() ? failure.getStacktrace() : null-->Line_54 $$ LOG.info(trace)[ FD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_51 $$ compileContext.addMessage(CompilerMessageCategory.ERROR, failure.hasDescription() ? failure.getDescription() : "", null, -1, -1)[ CD ]
Line_16 $$ for (BuildTargetScopeProvider provider : BuildTargetScopeProvider.EP_NAME.getExtensions()) -->Line_17 $$ scopes = CompileScopeUtil.mergeScopes(scopes, provider.getBuildTargetScopes(scope, myCompilerFilter, myProject, forceBuild))[ FD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_52 $$ final String trace = failure.hasStacktrace() ? failure.getStacktrace() : null[ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_20 $$ final Map<String, String> builderParams[ CD ]
Line_93 $$ for (Artifact artifact : artifacts) -->Line_94 $$ ArtifactsCompiler.addChangedArtifact(compileContext, artifact)[ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_5 $$ List<TargetTypeBuildScope> scopes = new ArrayList<TargetTypeBuildScope>()[ CD ]
Line_22 $$ builderParams = Collections.emptyMap()-->Line_30 $$ builderParams.put(_key, _value)[ FD ]
Line_88 $$ final String relativePath = FileUtil.toSystemIndependentName(generatedFile.getRelativePath())-->Line_89 $$ publisher.fileGenerated(root, relativePath)[ FD ]
Line_10 $$ if (!compileContext.isRebuild() && !CompileScopeUtil.allProjectModulesAffected(compileContext)) -->Line_11 $$ CompileScopeUtil.addScopesForModules(Arrays.asList(scope.getAffectedModules()), scopes, forceBuild)[ CD ]
Line_105 $$ ExitStatus status = ExitStatus.SUCCESS-->Line_119 $$ status = ExitStatus.UP_TO_DATE[ FD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_64 $$ if (message.hasDone()) [ FD ]
Line_126 $$ if (event.hasCustomBuilderMessage()) -->Line_128 $$ if (GlobalOptions.JPS_SYSTEM_BUILDER_ID.equals(message.getBuilderId()) && GlobalOptions.JPS_UNPROCESSED_FS_CHANGES_MESSAGE_ID.equals(message.getMessageType())) [ CD ]
Line_87 $$ final String root = FileUtil.toSystemIndependentName(generatedFile.getOutputRoot())-->Line_89 $$ publisher.fileGenerated(root, relativePath)[ FD ]
Line_38 $$ final BuildManager buildManager = BuildManager.getInstance()-->Line_39 $$ buildManager.cancelAutoMakeTasks(myProject)[ FD ]
Line_113 $$ status = ExitStatus.ERRORS-->Line_123 $$ compileContext.putUserDataIfAbsent(COMPILE_SERVER_BUILD_STATUS, status)[ FD ]
Line_44 $$ if (compileContext.shouldUpdateProblemsView()) -->Line_46 $$ view.clearProgress()[ CD ]
Line_21 $$ if (onlyCheckUpToDate) -->Line_25 $$ if (!exported.isEmpty()) [ CD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_51 $$ compileContext.addMessage(CompilerMessageCategory.ERROR, failure.hasDescription() ? failure.getDescription() : "", null, -1, -1)[ FD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_61 $$ if (kind == CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind.PROGRESS) [ CD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_129 $$ final String text = message.getMessageText()[ FD ]
Line_62 $$ final ProgressIndicator indicator = compileContext.getProgressIndicator()-->Line_65 $$ indicator.setFraction(message.getDone())[ FD ]
Line_91 $$ Collection<Artifact> artifacts = outputToArtifact.get(root)-->Line_92 $$ if (!artifacts.isEmpty()) [ FD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_60 $$ final String messageText = message.getText()[ CD ]
Line_71 $$ sourceFilePath = FileUtil.toSystemIndependentName(sourceFilePath)-->Line_75 $$ final String srcUrl = sourceFilePath != null ? VirtualFileManager.constructUrl(LocalFileSystem.PROTOCOL, sourceFilePath) : null[ FD ]
Line_33 $$ builderParams = Collections.emptyMap()-->Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) [ FD ]
Line_85 $$ Set<String> writtenArtifactOutputPaths = outputToArtifact != null ? new THashSet<String>(FileUtil.PATH_HASHING_STRATEGY) : null-->Line_100 $$ if (writtenArtifactOutputPaths != null && !writtenArtifactOutputPaths.isEmpty()) [ FD ]
Line_129 $$ final String text = message.getMessageText()-->Line_130 $$ if (!StringUtil.isEmpty(text)) [ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_6 $$ final boolean forceBuild = !compileContext.isMake()[ CD ]
Line_3 $$ final CompileScope scope = compileContext.getCompileScope()-->Line_11 $$ CompileScopeUtil.addScopesForModules(Arrays.asList(scope.getAffectedModules()), scopes, forceBuild)[ FD ]
Line_45 $$ final ProblemsView view = ProblemsView.SERVICE.getInstance(myProject)-->Line_47 $$ view.clearOldMessages(compileContext.getCompileScope(), compileContext.getSessionId())[ FD ]
Line_62 $$ final ProgressIndicator indicator = compileContext.getProgressIndicator()-->Line_63 $$ indicator.setText(messageText)[ FD ]
Line_53 $$ if (trace != null) -->Line_54 $$ LOG.info(trace)[ CD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_76 $$ compileContext.addMessage(category, messageText, srcUrl, (int) line, (int) column)[ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_3 $$ final CompileScope scope = compileContext.getCompileScope()[ CD ]
Line_20 $$ final Map<String, String> builderParams-->Line_26 $$ builderParams = new HashMap<String, String>()[ FD ]
Line_6 $$ final boolean forceBuild = !compileContext.isMake()-->Line_11 $$ CompileScopeUtil.addScopesForModules(Arrays.asList(scope.getAffectedModules()), scopes, forceBuild)[ FD ]
Line_5 $$ List<TargetTypeBuildScope> scopes = new ArrayList<TargetTypeBuildScope>()-->Line_13 $$ scopes.addAll(CmdlineProtoUtil.createAllModulesScopes(forceBuild))[ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_4 $$ final Collection<String> paths = CompileScopeUtil.fetchFiles(compileContext)[ CD ]
Line_21 $$ if (onlyCheckUpToDate) -->Line_24 $$ final Map<Key, Object> exported = scope.exportUserData()[ CD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_83 $$ final List<CmdlineRemoteProto.Message.BuilderMessage.BuildEvent.GeneratedFile> generated = event.getGeneratedFilesList()[ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_6 $$ final boolean forceBuild = !compileContext.isMake()[ FD ]
Line_26 $$ builderParams = new HashMap<String, String>()-->Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) [ FD ]
Line_119 $$ status = ExitStatus.UP_TO_DATE-->Line_123 $$ compileContext.putUserDataIfAbsent(COMPILE_SERVER_BUILD_STATUS, status)[ FD ]
Line_22 $$ builderParams = Collections.emptyMap()-->Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) [ FD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_52 $$ final String trace = failure.hasStacktrace() ? failure.getStacktrace() : null[ CD ]
Line_29 $$ final String _value = entry.getValue().toString()-->Line_30 $$ builderParams.put(_key, _value)[ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_123 $$ compileContext.putUserDataIfAbsent(COMPILE_SERVER_BUILD_STATUS, status)[ FD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_80 $$ final CmdlineRemoteProto.Message.BuilderMessage.BuildEvent.Type eventType = event.getEventType()[ CD ]
Line_86 $$ for (CmdlineRemoteProto.Message.BuilderMessage.BuildEvent.GeneratedFile generatedFile : generated) -->Line_88 $$ final String relativePath = FileUtil.toSystemIndependentName(generatedFile.getRelativePath())[ FD ]
Line_8 $$ if (explicitScopes != null) -->Line_9 $$ scopes.addAll(explicitScopes)[ CD ]
Line_20 $$ final Map<String, String> builderParams-->Line_33 $$ builderParams = Collections.emptyMap()[ FD ]
Line_116 $$ status = ExitStatus.SUCCESS-->Line_119 $$ status = ExitStatus.UP_TO_DATE[ FD ]
Line_52 $$ final String trace = failure.hasStacktrace() ? failure.getStacktrace() : null-->Line_53 $$ if (trace != null) [ FD ]
Line_7 $$ List<TargetTypeBuildScope> explicitScopes = CompileScopeUtil.getBaseScopeForExternalBuild(scope)-->Line_9 $$ scopes.addAll(explicitScopes)[ FD ]
Line_20 $$ final Map<String, String> builderParams-->Line_22 $$ builderParams = Collections.emptyMap()[ FD ]
Line_127 $$ final CmdlineRemoteProto.Message.BuilderMessage.BuildEvent.CustomBuilderMessage message = event.getCustomBuilderMessage()-->Line_129 $$ final String text = message.getMessageText()[ FD ]
Line_5 $$ List<TargetTypeBuildScope> scopes = new ArrayList<TargetTypeBuildScope>()-->Line_11 $$ CompileScopeUtil.addScopesForModules(Arrays.asList(scope.getAffectedModules()), scopes, forceBuild)[ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_131 $$ compileContext.addMessage(CompilerMessageCategory.INFORMATION, text, null, -1, -1)[ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) [ CD ]
Line_5 $$ List<TargetTypeBuildScope> scopes = new ArrayList<TargetTypeBuildScope>()-->Line_17 $$ scopes = CompileScopeUtil.mergeScopes(scopes, provider.getBuildTargetScopes(scope, myCompilerFilter, myProject, forceBuild))[ FD ]
Line_3 $$ final CompileScope scope = compileContext.getCompileScope()-->Line_24 $$ final Map<Key, Object> exported = scope.exportUserData()[ FD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_73 $$ final long line = message.hasLine() ? message.getLine() : -1[ FD ]
Line_5 $$ List<TargetTypeBuildScope> scopes = new ArrayList<TargetTypeBuildScope>()-->Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) [ FD ]
Line_26 $$ builderParams = new HashMap<String, String>()-->Line_33 $$ builderParams = Collections.emptyMap()[ FD ]
Line_87 $$ final String root = FileUtil.toSystemIndependentName(generatedFile.getOutputRoot())-->Line_96 $$ writtenArtifactOutputPaths.add(FileUtil.toSystemDependentName(DeploymentUtil.appendToPath(root, relativePath)))[ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_39 $$ buildManager.cancelAutoMakeTasks(myProject)[ CD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_44 $$ if (compileContext.shouldUpdateProblemsView()) [ CD ]
Line_61 $$ if (kind == CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind.PROGRESS) -->Line_70 $$ if (sourceFilePath != null) [ CD ]
Line_105 $$ ExitStatus status = ExitStatus.SUCCESS-->Line_113 $$ status = ExitStatus.ERRORS[ FD ]
Line_113 $$ status = ExitStatus.ERRORS-->Line_116 $$ status = ExitStatus.SUCCESS[ FD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_126 $$ if (event.hasCustomBuilderMessage()) [ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_15 $$ if (paths.isEmpty()) [ CD ]
Line_17 $$ scopes = CompileScopeUtil.mergeScopes(scopes, provider.getBuildTargetScopes(scope, myCompilerFilter, myProject, forceBuild))-->Line_37 $$ final MultiMap<String, Artifact> outputToArtifact = ArtifactCompilerUtil.containsArtifacts(scopes) ? ArtifactCompilerUtil.createOutputToArtifactMap(myProject) : null[ FD ]
Line_86 $$ for (CmdlineRemoteProto.Message.BuilderMessage.BuildEvent.GeneratedFile generatedFile : generated) -->Line_87 $$ final String root = FileUtil.toSystemIndependentName(generatedFile.getOutputRoot())[ FD ]
Line_44 $$ if (compileContext.shouldUpdateProblemsView()) -->Line_47 $$ view.clearOldMessages(compileContext.getCompileScope(), compileContext.getSessionId())[ CD ]
Line_36 $$ final MessageBus messageBus = myProject.getMessageBus()-->Line_84 $$ final CompilationStatusListener publisher = messageBus.syncPublisher(CompilerTopics.COMPILATION_STATUS)[ FD ]
Line_25 $$ if (!exported.isEmpty()) -->Line_33 $$ builderParams = Collections.emptyMap()[ CD ]
Line_44 $$ if (compileContext.shouldUpdateProblemsView()) -->Line_45 $$ final ProblemsView view = ProblemsView.SERVICE.getInstance(myProject)[ CD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_59 $$ final CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind kind = message.getKind()[ CD ]
Line_61 $$ if (kind == CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind.PROGRESS) -->Line_69 $$ String sourceFilePath = message.hasSourceFilePath() ? message.getSourceFilePath() : null[ CD ]
Line_127 $$ final CmdlineRemoteProto.Message.BuilderMessage.BuildEvent.CustomBuilderMessage message = event.getCustomBuilderMessage()-->Line_128 $$ if (GlobalOptions.JPS_SYSTEM_BUILDER_ID.equals(message.getBuilderId()) && GlobalOptions.JPS_UNPROCESSED_FS_CHANGES_MESSAGE_ID.equals(message.getMessageType())) [ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_94 $$ ArtifactsCompiler.addChangedArtifact(compileContext, artifact)[ FD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_65 $$ indicator.setFraction(message.getDone())[ FD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_107 $$ final CmdlineRemoteProto.Message.BuilderMessage.BuildEvent.Status completionStatus = event.getCompletionStatus()[ FD ]
Line_105 $$ ExitStatus status = ExitStatus.SUCCESS-->Line_116 $$ status = ExitStatus.SUCCESS[ FD ]
Line_90 $$ if (outputToArtifact != null) -->Line_91 $$ Collection<Artifact> artifacts = outputToArtifact.get(root)[ CD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_127 $$ final CmdlineRemoteProto.Message.BuilderMessage.BuildEvent.CustomBuilderMessage message = event.getCustomBuilderMessage()[ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_8 $$ if (explicitScopes != null) [ CD ]
Line_85 $$ Set<String> writtenArtifactOutputPaths = outputToArtifact != null ? new THashSet<String>(FileUtil.PATH_HASHING_STRATEGY) : null-->Line_96 $$ writtenArtifactOutputPaths.add(FileUtil.toSystemDependentName(DeploymentUtil.appendToPath(root, relativePath)))[ FD ]
Line_106 $$ if (event.hasCompletionStatus()) -->Line_107 $$ final CmdlineRemoteProto.Message.BuilderMessage.BuildEvent.Status completionStatus = event.getCompletionStatus()[ CD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_128 $$ if (GlobalOptions.JPS_SYSTEM_BUILDER_ID.equals(message.getBuilderId()) && GlobalOptions.JPS_UNPROCESSED_FS_CHANGES_MESSAGE_ID.equals(message.getMessageType())) [ FD ]
Line_110 $$ status = ExitStatus.CANCELLED-->Line_113 $$ status = ExitStatus.ERRORS[ FD ]
Line_27 $$ for (Map.Entry<Key, Object> entry : exported.entrySet()) -->Line_29 $$ final String _value = entry.getValue().toString()[ FD ]
Line_61 $$ if (kind == CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind.PROGRESS) -->Line_73 $$ final long line = message.hasLine() ? message.getLine() : -1[ CD ]
Line_90 $$ if (outputToArtifact != null) -->Line_92 $$ if (!artifacts.isEmpty()) [ CD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_10 $$ if (!compileContext.isRebuild() && !CompileScopeUtil.allProjectModulesAffected(compileContext)) [ FD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_106 $$ if (event.hasCompletionStatus()) [ FD ]
Line_4 $$ final Collection<String> paths = CompileScopeUtil.fetchFiles(compileContext)-->Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) [ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_37 $$ final MultiMap<String, Artifact> outputToArtifact = ArtifactCompilerUtil.containsArtifacts(scopes) ? ArtifactCompilerUtil.createOutputToArtifactMap(myProject) : null[ CD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_21 $$ if (onlyCheckUpToDate) [ CD ]
Line_110 $$ status = ExitStatus.CANCELLED-->Line_123 $$ compileContext.putUserDataIfAbsent(COMPILE_SERVER_BUILD_STATUS, status)[ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_3 $$ final CompileScope scope = compileContext.getCompileScope()[ FD ]
Line_105 $$ ExitStatus status = ExitStatus.SUCCESS-->Line_123 $$ compileContext.putUserDataIfAbsent(COMPILE_SERVER_BUILD_STATUS, status)[ FD ]
Line_61 $$ if (kind == CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind.PROGRESS) -->Line_64 $$ if (message.hasDone()) [ CD ]
Line_75 $$ final String srcUrl = sourceFilePath != null ? VirtualFileManager.constructUrl(LocalFileSystem.PROTOCOL, sourceFilePath) : null-->Line_76 $$ compileContext.addMessage(category, messageText, srcUrl, (int) line, (int) column)[ FD ]
Line_105 $$ ExitStatus status = ExitStatus.SUCCESS-->Line_110 $$ status = ExitStatus.CANCELLED[ FD ]
Line_113 $$ status = ExitStatus.ERRORS-->Line_119 $$ status = ExitStatus.UP_TO_DATE[ FD ]
Line_38 $$ final BuildManager buildManager = BuildManager.getInstance()-->Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) [ FD ]
Line_17 $$ scopes = CompileScopeUtil.mergeScopes(scopes, provider.getBuildTargetScopes(scope, myCompilerFilter, myProject, forceBuild))-->Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) [ FD ]
Line_61 $$ if (kind == CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind.PROGRESS) -->Line_75 $$ final String srcUrl = sourceFilePath != null ? VirtualFileManager.constructUrl(LocalFileSystem.PROTOCOL, sourceFilePath) : null[ CD ]
Line_68 $$ final CompilerMessageCategory category = kind == CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind.ERROR ? CompilerMessageCategory.ERROR : kind == CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind.WARNING ? CompilerMessageCategory.WARNING : CompilerMessageCategory.INFORMATION-->Line_76 $$ compileContext.addMessage(category, messageText, srcUrl, (int) line, (int) column)[ FD ]
Line_5 $$ List<TargetTypeBuildScope> scopes = new ArrayList<TargetTypeBuildScope>()-->Line_37 $$ final MultiMap<String, Artifact> outputToArtifact = ArtifactCompilerUtil.containsArtifacts(scopes) ? ArtifactCompilerUtil.createOutputToArtifactMap(myProject) : null[ FD ]
Line_27 $$ for (Map.Entry<Key, Object> entry : exported.entrySet()) -->Line_28 $$ final String _key = entry.getKey().toString()[ FD ]
Line_110 $$ status = ExitStatus.CANCELLED-->Line_116 $$ status = ExitStatus.SUCCESS[ FD ]
Line_8 $$ if (explicitScopes != null) -->Line_10 $$ if (!compileContext.isRebuild() && !CompileScopeUtil.allProjectModulesAffected(compileContext)) [ CD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_60 $$ final String messageText = message.getText()[ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_62 $$ final ProgressIndicator indicator = compileContext.getProgressIndicator()[ FD ]
Line_84 $$ final CompilationStatusListener publisher = messageBus.syncPublisher(CompilerTopics.COMPILATION_STATUS)-->Line_89 $$ publisher.fileGenerated(root, relativePath)[ FD ]
Line_128 $$ if (GlobalOptions.JPS_SYSTEM_BUILDER_ID.equals(message.getBuilderId()) && GlobalOptions.JPS_UNPROCESSED_FS_CHANGES_MESSAGE_ID.equals(message.getMessageType())) -->Line_130 $$ if (!StringUtil.isEmpty(text)) [ CD ]
Line_37 $$ final MultiMap<String, Artifact> outputToArtifact = ArtifactCompilerUtil.containsArtifacts(scopes) ? ArtifactCompilerUtil.createOutputToArtifactMap(myProject) : null-->Line_90 $$ if (outputToArtifact != null) [ FD ]
Line_20 $$ final Map<String, String> builderParams-->Line_30 $$ builderParams.put(_key, _value)[ FD ]
Line_116 $$ status = ExitStatus.SUCCESS-->Line_123 $$ compileContext.putUserDataIfAbsent(COMPILE_SERVER_BUILD_STATUS, status)[ FD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_56 $$ compileContext.putUserData(COMPILE_SERVER_BUILD_STATUS, ExitStatus.ERRORS)[ CD ]
Line_100 $$ if (writtenArtifactOutputPaths != null && !writtenArtifactOutputPaths.isEmpty()) -->Line_101 $$ ArtifactsCompiler.addWrittenPaths(compileContext, writtenArtifactOutputPaths)[ CD ]
Line_61 $$ if (kind == CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind.PROGRESS) -->Line_62 $$ final ProgressIndicator indicator = compileContext.getProgressIndicator()[ CD ]
Line_3 $$ final CompileScope scope = compileContext.getCompileScope()-->Line_7 $$ List<TargetTypeBuildScope> explicitScopes = CompileScopeUtil.getBaseScopeForExternalBuild(scope)[ FD ]
Line_3 $$ final CompileScope scope = compileContext.getCompileScope()-->Line_17 $$ scopes = CompileScopeUtil.mergeScopes(scopes, provider.getBuildTargetScopes(scope, myCompilerFilter, myProject, forceBuild))[ FD ]
Line_4 $$ final Collection<String> paths = CompileScopeUtil.fetchFiles(compileContext)-->Line_15 $$ if (paths.isEmpty()) [ FD ]
Line_88 $$ final String relativePath = FileUtil.toSystemIndependentName(generatedFile.getRelativePath())-->Line_96 $$ writtenArtifactOutputPaths.add(FileUtil.toSystemDependentName(DeploymentUtil.appendToPath(root, relativePath)))[ FD ]
Line_22 $$ builderParams = Collections.emptyMap()-->Line_26 $$ builderParams = new HashMap<String, String>()[ FD ]
Line_64 $$ if (message.hasDone()) -->Line_65 $$ indicator.setFraction(message.getDone())[ CD ]
Line_61 $$ if (kind == CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind.PROGRESS) -->Line_63 $$ indicator.setText(messageText)[ CD ]
Line_45 $$ final ProblemsView view = ProblemsView.SERVICE.getInstance(myProject)-->Line_46 $$ view.clearProgress()[ FD ]
Line_128 $$ if (GlobalOptions.JPS_SYSTEM_BUILDER_ID.equals(message.getBuilderId()) && GlobalOptions.JPS_UNPROCESSED_FS_CHANGES_MESSAGE_ID.equals(message.getMessageType())) -->Line_129 $$ final String text = message.getMessageText()[ CD ]
Line_70 $$ if (sourceFilePath != null) -->Line_71 $$ sourceFilePath = FileUtil.toSystemIndependentName(sourceFilePath)[ CD ]
Line_69 $$ String sourceFilePath = message.hasSourceFilePath() ? message.getSourceFilePath() : null-->Line_71 $$ sourceFilePath = FileUtil.toSystemIndependentName(sourceFilePath)[ FD ]
Line_5 $$ List<TargetTypeBuildScope> scopes = new ArrayList<TargetTypeBuildScope>()-->Line_9 $$ scopes.addAll(explicitScopes)[ FD ]
Line_130 $$ if (!StringUtil.isEmpty(text)) -->Line_131 $$ compileContext.addMessage(CompilerMessageCategory.INFORMATION, text, null, -1, -1)[ CD ]
Line_6 $$ final boolean forceBuild = !compileContext.isMake()-->Line_13 $$ scopes.addAll(CmdlineProtoUtil.createAllModulesScopes(forceBuild))[ FD ]
Line_60 $$ final String messageText = message.getText()-->Line_76 $$ compileContext.addMessage(category, messageText, srcUrl, (int) line, (int) column)[ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_36 $$ final MessageBus messageBus = myProject.getMessageBus()[ CD ]
Line_25 $$ if (!exported.isEmpty()) -->Line_26 $$ builderParams = new HashMap<String, String>()[ CD ]
Line_24 $$ final Map<Key, Object> exported = scope.exportUserData()-->Line_27 $$ for (Map.Entry<Key, Object> entry : exported.entrySet()) [ FD ]
Line_59 $$ final CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind kind = message.getKind()-->Line_61 $$ if (kind == CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind.PROGRESS) [ FD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_69 $$ String sourceFilePath = message.hasSourceFilePath() ? message.getSourceFilePath() : null[ FD ]
Line_87 $$ final String root = FileUtil.toSystemIndependentName(generatedFile.getOutputRoot())-->Line_91 $$ Collection<Artifact> artifacts = outputToArtifact.get(root)[ FD ]
Line_61 $$ if (kind == CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind.PROGRESS) -->Line_74 $$ final long column = message.hasColumn() ? message.getColumn() : -1[ CD ]
Line_10 $$ if (!compileContext.isRebuild() && !CompileScopeUtil.allProjectModulesAffected(compileContext)) -->Line_13 $$ scopes.addAll(CmdlineProtoUtil.createAllModulesScopes(forceBuild))[ CD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_44 $$ if (compileContext.shouldUpdateProblemsView()) [ FD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_59 $$ final CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind kind = message.getKind()[ FD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_80 $$ final CmdlineRemoteProto.Message.BuilderMessage.BuildEvent.Type eventType = event.getEventType()[ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_101 $$ ArtifactsCompiler.addWrittenPaths(compileContext, writtenArtifactOutputPaths)[ FD ]
Line_2 $$ private TaskFuture compileInExternalProcess(@NotNull final CompileContextImpl compileContext, final boolean onlyCheckUpToDate) throws Exception -->Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) [ FD ]
Line_21 $$ if (onlyCheckUpToDate) -->Line_22 $$ builderParams = Collections.emptyMap()[ CD ]
Line_40 $$ return buildManager.scheduleBuild(myProject, compileContext.isRebuild(), compileContext.isMake(), onlyCheckUpToDate, scopes, paths, builderParams, new DefaultMessageHandler(myProject) -->Line_53 $$ if (trace != null) [ CD ]
Line_69 $$ String sourceFilePath = message.hasSourceFilePath() ? message.getSourceFilePath() : null-->Line_75 $$ final String srcUrl = sourceFilePath != null ? VirtualFileManager.constructUrl(LocalFileSystem.PROTOCOL, sourceFilePath) : null[ FD ]
Line_61 $$ if (kind == CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind.PROGRESS) -->Line_76 $$ compileContext.addMessage(category, messageText, srcUrl, (int) line, (int) column)[ CD ]
Line_28 $$ final String _key = entry.getKey().toString()-->Line_30 $$ builderParams.put(_key, _value)[ FD ]
