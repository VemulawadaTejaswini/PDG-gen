Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_15 $$ final List<ModuleBuildTarget> targetsProcessed = new ArrayList<ModuleBuildTarget>(remoteClasses.size())[ CD ]
Line_5 $$ final StringBuilder buf = new StringBuilder()-->Line_12 $$ final String classpathString = buf.toString()[ FD ]
Line_62 $$ if (children == null) -->Line_64 $$ if (children == null) [ CD ]
Line_21 $$ final BaseOSProcessHandler handler = new BaseOSProcessHandler(process, StringUtil.join(cmdLine, " "), null) -->Line_23 $$ return SharedThreadPool.getInstance().executeOnPooledThread(task)[ FD ]
Line_32 $$ if (outputType == ProcessOutputTypes.STDERR) -->Line_33 $$ stdErrParser.append(event.getText())[ CD ]
Line_21 $$ final BaseOSProcessHandler handler = new BaseOSProcessHandler(process, StringUtil.join(cmdLine, " "), null) -->Line_28 $$ handler.addProcessListener(new ProcessAdapter() [ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_16 $$ for (Map.Entry<ModuleBuildTarget, Collection<ClassItem>> entry : remoteClasses.entrySet()) [ FD ]
Line_21 $$ final BaseOSProcessHandler handler = new BaseOSProcessHandler(process, StringUtil.join(cmdLine, " "), null) -->Line_41 $$ handler.waitFor()[ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_14 $$ final RmicCompilerOptions options = getOptions(context)[ CD ]
Line_5 $$ final StringBuilder buf = new StringBuilder()-->Line_8 $$ buf.append(File.pathSeparator)[ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_15 $$ final List<ModuleBuildTarget> targetsProcessed = new ArrayList<ModuleBuildTarget>(remoteClasses.size())[ FD ]
Line_28 $$ handler.addProcessListener(new ProcessAdapter() -->Line_31 $$ stdOutParser.append(event.getText())[ FD ]
Line_28 $$ handler.addProcessListener(new ProcessAdapter() -->Line_37 $$ super.processTerminated(event)[ CD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_3 $$ ExitCode exitCode = ExitCode.NOTHING_DONE[ CD ]
Line_47 $$ if (exitValue != 0) -->Line_48 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, "RMI stub generation failed"))[ CD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_12 $$ final String classpathString = buf.toString()[ CD ]
Line_16 $$ for (Map.Entry<ModuleBuildTarget, Collection<ClassItem>> entry : remoteClasses.entrySet()) -->Line_19 $$ final Collection<String> cmdLine = createStartupCommand(target, rmicPath, classpathString, options, entry.getValue())[ FD ]
Line_43 $$ if (stdErrParser.isErrorsReported() || stdOutParser.isErrorsReported()) -->Line_46 $$ final int exitValue = handler.getProcess().exitValue()[ CD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_59 $$ final Collection<ClassItem> items = remoteClasses.get(target)[ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_53 $$ context.processMessage(new CompilerMessage(getPresentableName(), e))[ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_76 $$ context.processMessage(new CompilerMessage(getPresentableName(), e))[ FD ]
Line_14 $$ final RmicCompilerOptions options = getOptions(context)-->Line_19 $$ final Collection<String> cmdLine = createStartupCommand(target, rmicPath, classpathString, options, entry.getValue())[ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_4 $$ final Collection<File> classpath = ProjectPaths.getCompilationClasspath(chunk, false)[ FD ]
Line_18 $$ final ModuleBuildTarget target = entry.getKey()-->Line_19 $$ final Collection<String> cmdLine = createStartupCommand(target, rmicPath, classpathString, options, entry.getValue())[ FD ]
Line_18 $$ final ModuleBuildTarget target = entry.getKey()-->Line_59 $$ final Collection<ClassItem> items = remoteClasses.get(target)[ FD ]
Line_5 $$ final StringBuilder buf = new StringBuilder()-->Line_10 $$ buf.append(file.getPath())[ FD ]
Line_19 $$ final Collection<String> cmdLine = createStartupCommand(target, rmicPath, classpathString, options, entry.getValue())-->Line_21 $$ final BaseOSProcessHandler handler = new BaseOSProcessHandler(process, StringUtil.join(cmdLine, " "), null) [ FD ]
Line_28 $$ handler.addProcessListener(new ProcessAdapter() -->Line_37 $$ super.processTerminated(event)[ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_4 $$ final Collection<File> classpath = ProjectPaths.getCompilationClasspath(chunk, false)[ CD ]
Line_28 $$ handler.addProcessListener(new ProcessAdapter() -->Line_30 $$ if (outputType == ProcessOutputTypes.STDOUT) [ CD ]
Line_16 $$ for (Map.Entry<ModuleBuildTarget, Collection<ClassItem>> entry : remoteClasses.entrySet()) -->Line_18 $$ final ModuleBuildTarget target = entry.getKey()[ FD ]
Line_28 $$ handler.addProcessListener(new ProcessAdapter() -->Line_30 $$ if (outputType == ProcessOutputTypes.STDOUT) [ FD ]
Line_30 $$ if (outputType == ProcessOutputTypes.STDOUT) -->Line_32 $$ if (outputType == ProcessOutputTypes.STDERR) [ CD ]
Line_5 $$ final StringBuilder buf = new StringBuilder()-->Line_7 $$ if (buf.length() > 0) [ FD ]
Line_18 $$ final ModuleBuildTarget target = entry.getKey()-->Line_42 $$ targetsProcessed.add(target)[ FD ]
Line_70 $$ if (!files.isEmpty()) -->Line_71 $$ final Collection<String> sources = Collections.singleton(item.compiledClass.getSourceFile().getPath())[ CD ]
Line_30 $$ if (outputType == ProcessOutputTypes.STDOUT) -->Line_31 $$ stdOutParser.append(event.getText())[ CD ]
Line_6 $$ for (File file : classpath) -->Line_10 $$ buf.append(file.getPath())[ FD ]
Line_15 $$ final List<ModuleBuildTarget> targetsProcessed = new ArrayList<ModuleBuildTarget>(remoteClasses.size())-->Line_42 $$ targetsProcessed.add(target)[ FD ]
Line_62 $$ if (children == null) -->Line_63 $$ children = item.parentDir.listFiles()[ CD ]
Line_28 $$ handler.addProcessListener(new ProcessAdapter() -->Line_33 $$ stdErrParser.append(event.getText())[ FD ]
Line_18 $$ final ModuleBuildTarget target = entry.getKey()-->Line_74 $$ outputConsumer.registerOutputFile(target, generated, sources)[ FD ]
Line_62 $$ if (children == null) -->Line_67 $$ fsCache.put(item.parentDir, children)[ CD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_48 $$ context.processMessage(new CompilerMessage(getPresentableName(), BuildMessage.Kind.ERROR, "RMI stub generation failed"))[ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_13 $$ final String rmicPath = getPathToRmic(chunk)[ FD ]
Line_13 $$ final String rmicPath = getPathToRmic(chunk)-->Line_19 $$ final Collection<String> cmdLine = createStartupCommand(target, rmicPath, classpathString, options, entry.getValue())[ FD ]
Line_21 $$ final BaseOSProcessHandler handler = new BaseOSProcessHandler(process, StringUtil.join(cmdLine, " "), null) -->Line_46 $$ final int exitValue = handler.getProcess().exitValue()[ FD ]
Line_12 $$ final String classpathString = buf.toString()-->Line_19 $$ final Collection<String> cmdLine = createStartupCommand(target, rmicPath, classpathString, options, entry.getValue())[ FD ]
Line_21 $$ final BaseOSProcessHandler handler = new BaseOSProcessHandler(process, StringUtil.join(cmdLine, " "), null) -->Line_40 $$ handler.startNotify()[ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_74 $$ outputConsumer.registerOutputFile(target, generated, sources)[ FD ]
Line_7 $$ if (buf.length() > 0) -->Line_8 $$ buf.append(File.pathSeparator)[ CD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_13 $$ final String rmicPath = getPathToRmic(chunk)[ CD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_14 $$ final RmicCompilerOptions options = getOptions(context)[ FD ]
Line_19 $$ final Collection<String> cmdLine = createStartupCommand(target, rmicPath, classpathString, options, entry.getValue())-->Line_20 $$ final Process process = Runtime.getRuntime().exec(ArrayUtil.toStringArray(cmdLine))[ FD ]
Line_21 $$ final BaseOSProcessHandler handler = new BaseOSProcessHandler(process, StringUtil.join(cmdLine, " "), null) -->Line_23 $$ return SharedThreadPool.getInstance().executeOnPooledThread(task)[ CD ]
Line_43 $$ if (stdErrParser.isErrorsReported() || stdOutParser.isErrorsReported()) -->Line_47 $$ if (exitValue != 0) [ CD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_82 $$ return exitCode[ CD ]
Line_28 $$ handler.addProcessListener(new ProcessAdapter() -->Line_32 $$ if (outputType == ProcessOutputTypes.STDERR) [ FD ]
Line_2 $$ private ExitCode generateRmiStubs(final CompileContext context, Map<ModuleBuildTarget, Collection<ClassItem>> remoteClasses, ModuleChunk chunk, OutputConsumer outputConsumer) -->Line_5 $$ final StringBuilder buf = new StringBuilder()[ CD ]
