Line_40 $$ if (requestType == JavacRemoteProto.Message.Request.Type.SHUTDOWN) -->Line_41 $$ cancelBuild()[ CD ]
Line_8 $$ final JavacRemoteProto.Message.Request request = message.getRequest()-->Line_13 $$ final List<File> files = toFiles(request.getFileList())[ FD ]
Line_7 $$ if (messageType == JavacRemoteProto.Message.Type.REQUEST) -->Line_10 $$ if (requestType == JavacRemoteProto.Message.Request.Type.COMPILE) [ CD ]
Line_9 $$ final JavacRemoteProto.Message.Request.Type requestType = request.getRequestType()-->Line_10 $$ if (requestType == JavacRemoteProto.Message.Request.Type.COMPILE) [ FD ]
Line_11 $$ if (myCancelHandler == null) -->Line_17 $$ final Map<File, Set<File>> outs = new HashMap<File, Set<File>>()[ CD ]
Line_8 $$ final JavacRemoteProto.Message.Request request = message.getRequest()-->Line_9 $$ final JavacRemoteProto.Message.Request.Type requestType = request.getRequestType()[ FD ]
Line_8 $$ final JavacRemoteProto.Message.Request request = message.getRequest()-->Line_14 $$ final List<File> cp = toFiles(request.getClasspathList())[ FD ]
Line_11 $$ if (myCancelHandler == null) -->Line_25 $$ final CancelHandler cancelHandler = new CancelHandler()[ CD ]
Line_12 $$ final List<String> options = request.getOptionList()-->Line_30 $$ context.channel().writeAndFlush(compile(context, sessionId, options, files, cp, platformCp, srcPath, outs, cancelHandler)).awaitUninterruptibly()[ FD ]
Line_9 $$ final JavacRemoteProto.Message.Request.Type requestType = request.getRequestType()-->Line_48 $$ reply = JavacProtoUtil.toMessage(sessionId, JavacProtoUtil.createFailure("Unsupported request type: " + requestType.name(), null))[ FD ]
Line_3 $$ final UUID sessionId = JavacProtoUtil.fromProtoUUID(message.getSessionId())-->Line_51 $$ reply = JavacProtoUtil.toMessage(sessionId, JavacProtoUtil.createFailure("Unsupported message: " + messageType.name(), null))[ FD ]
Line_17 $$ final Map<File, Set<File>> outs = new HashMap<File, Set<File>>()-->Line_30 $$ context.channel().writeAndFlush(compile(context, sessionId, options, files, cp, platformCp, srcPath, outs, cancelHandler)).awaitUninterruptibly()[ FD ]
Line_40 $$ if (requestType == JavacRemoteProto.Message.Request.Type.SHUTDOWN) -->Line_42 $$ new Thread("StopThread") [ CD ]
Line_38 $$ if (requestType == JavacRemoteProto.Message.Request.Type.CANCEL) -->Line_40 $$ if (requestType == JavacRemoteProto.Message.Request.Type.SHUTDOWN) [ CD ]
Line_9 $$ final JavacRemoteProto.Message.Request.Type requestType = request.getRequestType()-->Line_40 $$ if (requestType == JavacRemoteProto.Message.Request.Type.SHUTDOWN) [ FD ]
Line_2 $$ public void channelRead0(final ChannelHandlerContext context, JavacRemoteProto.Message message) throws Exception -->Line_55 $$ context.channel().writeAndFlush(reply)[ FD ]
Line_2 $$ public void channelRead0(final ChannelHandlerContext context, JavacRemoteProto.Message message) throws Exception -->Line_4 $$ final JavacRemoteProto.Message.Type messageType = message.getMessageType()[ FD ]
Line_3 $$ final UUID sessionId = JavacProtoUtil.fromProtoUUID(message.getSessionId())-->Line_30 $$ context.channel().writeAndFlush(compile(context, sessionId, options, files, cp, platformCp, srcPath, outs, cancelHandler)).awaitUninterruptibly()[ FD ]
Line_42 $$ new Thread("StopThread") -->Line_44 $$ ExternalJavacProcess.this.stop()[ CD ]
Line_10 $$ if (requestType == JavacRemoteProto.Message.Request.Type.COMPILE) -->Line_11 $$ if (myCancelHandler == null) [ CD ]
Line_8 $$ final JavacRemoteProto.Message.Request request = message.getRequest()-->Line_16 $$ final List<File> srcPath = toFiles(request.getSourcepathList())[ FD ]
Line_18 $$ for (JavacRemoteProto.Message.Request.OutputGroup outputGroup : request.getOutputList()) -->Line_20 $$ for (String root : outputGroup.getSourceRootList()) [ FD ]
Line_2 $$ public void channelRead0(final ChannelHandlerContext context, JavacRemoteProto.Message message) throws Exception -->Line_30 $$ context.channel().writeAndFlush(compile(context, sessionId, options, files, cp, platformCp, srcPath, outs, cancelHandler)).awaitUninterruptibly()[ FD ]
Line_13 $$ final List<File> files = toFiles(request.getFileList())-->Line_30 $$ context.channel().writeAndFlush(compile(context, sessionId, options, files, cp, platformCp, srcPath, outs, cancelHandler)).awaitUninterruptibly()[ FD ]
Line_10 $$ if (requestType == JavacRemoteProto.Message.Request.Type.COMPILE) -->Line_38 $$ if (requestType == JavacRemoteProto.Message.Request.Type.CANCEL) [ CD ]
Line_11 $$ if (myCancelHandler == null) -->Line_15 $$ final List<File> platformCp = toFiles(request.getPlatformClasspathList())[ CD ]
Line_38 $$ if (requestType == JavacRemoteProto.Message.Request.Type.CANCEL) -->Line_39 $$ cancelBuild()[ CD ]
Line_5 $$ JavacRemoteProto.Message reply = null-->Line_54 $$ if (reply != null) [ FD ]
Line_5 $$ JavacRemoteProto.Message reply = null-->Line_55 $$ context.channel().writeAndFlush(reply)[ FD ]
Line_4 $$ final JavacRemoteProto.Message.Type messageType = message.getMessageType()-->Line_7 $$ if (messageType == JavacRemoteProto.Message.Type.REQUEST) [ FD ]
Line_18 $$ for (JavacRemoteProto.Message.Request.OutputGroup outputGroup : request.getOutputList()) -->Line_23 $$ outs.put(new File(outputGroup.getOutputRoot()), srcRoots)[ FD ]
Line_2 $$ public void channelRead0(final ChannelHandlerContext context, JavacRemoteProto.Message message) throws Exception -->Line_4 $$ final JavacRemoteProto.Message.Type messageType = message.getMessageType()[ CD ]
Line_4 $$ final JavacRemoteProto.Message.Type messageType = message.getMessageType()-->Line_51 $$ reply = JavacProtoUtil.toMessage(sessionId, JavacProtoUtil.createFailure("Unsupported message: " + messageType.name(), null))[ FD ]
Line_15 $$ final List<File> platformCp = toFiles(request.getPlatformClasspathList())-->Line_30 $$ context.channel().writeAndFlush(compile(context, sessionId, options, files, cp, platformCp, srcPath, outs, cancelHandler)).awaitUninterruptibly()[ FD ]
Line_19 $$ final Set<File> srcRoots = new HashSet<File>()-->Line_21 $$ srcRoots.add(new File(root))[ FD ]
Line_7 $$ if (messageType == JavacRemoteProto.Message.Type.REQUEST) -->Line_8 $$ final JavacRemoteProto.Message.Request request = message.getRequest()[ CD ]
Line_8 $$ final JavacRemoteProto.Message.Request request = message.getRequest()-->Line_12 $$ final List<String> options = request.getOptionList()[ FD ]
Line_3 $$ final UUID sessionId = JavacProtoUtil.fromProtoUUID(message.getSessionId())-->Line_48 $$ reply = JavacProtoUtil.toMessage(sessionId, JavacProtoUtil.createFailure("Unsupported request type: " + requestType.name(), null))[ FD ]
Line_9 $$ final JavacRemoteProto.Message.Request.Type requestType = request.getRequestType()-->Line_38 $$ if (requestType == JavacRemoteProto.Message.Request.Type.CANCEL) [ FD ]
Line_8 $$ final JavacRemoteProto.Message.Request request = message.getRequest()-->Line_15 $$ final List<File> platformCp = toFiles(request.getPlatformClasspathList())[ FD ]
Line_17 $$ final Map<File, Set<File>> outs = new HashMap<File, Set<File>>()-->Line_23 $$ outs.put(new File(outputGroup.getOutputRoot()), srcRoots)[ FD ]
Line_2 $$ public void channelRead0(final ChannelHandlerContext context, JavacRemoteProto.Message message) throws Exception -->Line_5 $$ JavacRemoteProto.Message reply = null[ CD ]
Line_2 $$ public void channelRead0(final ChannelHandlerContext context, JavacRemoteProto.Message message) throws Exception -->Line_3 $$ final UUID sessionId = JavacProtoUtil.fromProtoUUID(message.getSessionId())[ CD ]
Line_11 $$ if (myCancelHandler == null) -->Line_27 $$ SharedThreadPool.getInstance().executeOnPooledThread(new Runnable() [ CD ]
Line_7 $$ if (messageType == JavacRemoteProto.Message.Type.REQUEST) -->Line_51 $$ reply = JavacProtoUtil.toMessage(sessionId, JavacProtoUtil.createFailure("Unsupported message: " + messageType.name(), null))[ CD ]
Line_11 $$ if (myCancelHandler == null) -->Line_14 $$ final List<File> cp = toFiles(request.getClasspathList())[ CD ]
Line_54 $$ if (reply != null) -->Line_55 $$ context.channel().writeAndFlush(reply)[ CD ]
Line_11 $$ if (myCancelHandler == null) -->Line_13 $$ final List<File> files = toFiles(request.getFileList())[ CD ]
Line_7 $$ if (messageType == JavacRemoteProto.Message.Type.REQUEST) -->Line_9 $$ final JavacRemoteProto.Message.Request.Type requestType = request.getRequestType()[ CD ]
Line_11 $$ if (myCancelHandler == null) -->Line_16 $$ final List<File> srcPath = toFiles(request.getSourcepathList())[ CD ]
Line_8 $$ final JavacRemoteProto.Message.Request request = message.getRequest()-->Line_18 $$ for (JavacRemoteProto.Message.Request.OutputGroup outputGroup : request.getOutputList()) [ FD ]
Line_14 $$ final List<File> cp = toFiles(request.getClasspathList())-->Line_30 $$ context.channel().writeAndFlush(compile(context, sessionId, options, files, cp, platformCp, srcPath, outs, cancelHandler)).awaitUninterruptibly()[ FD ]
Line_2 $$ public void channelRead0(final ChannelHandlerContext context, JavacRemoteProto.Message message) throws Exception -->Line_8 $$ final JavacRemoteProto.Message.Request request = message.getRequest()[ FD ]
Line_11 $$ if (myCancelHandler == null) -->Line_12 $$ final List<String> options = request.getOptionList()[ CD ]
Line_16 $$ final List<File> srcPath = toFiles(request.getSourcepathList())-->Line_30 $$ context.channel().writeAndFlush(compile(context, sessionId, options, files, cp, platformCp, srcPath, outs, cancelHandler)).awaitUninterruptibly()[ FD ]
Line_19 $$ final Set<File> srcRoots = new HashSet<File>()-->Line_23 $$ outs.put(new File(outputGroup.getOutputRoot()), srcRoots)[ FD ]
Line_2 $$ public void channelRead0(final ChannelHandlerContext context, JavacRemoteProto.Message message) throws Exception -->Line_3 $$ final UUID sessionId = JavacProtoUtil.fromProtoUUID(message.getSessionId())[ FD ]
Line_40 $$ if (requestType == JavacRemoteProto.Message.Request.Type.SHUTDOWN) -->Line_48 $$ reply = JavacProtoUtil.toMessage(sessionId, JavacProtoUtil.createFailure("Unsupported request type: " + requestType.name(), null))[ CD ]
Line_25 $$ final CancelHandler cancelHandler = new CancelHandler()-->Line_30 $$ context.channel().writeAndFlush(compile(context, sessionId, options, files, cp, platformCp, srcPath, outs, cancelHandler)).awaitUninterruptibly()[ FD ]
