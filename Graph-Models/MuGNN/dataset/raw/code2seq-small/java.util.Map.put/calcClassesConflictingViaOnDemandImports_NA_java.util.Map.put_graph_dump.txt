Line_44 $$ String fqn = ((PsiClass) element).getQualifiedName()-->Line_45 $$ namesToUseSingle.add(fqn)[ FD ]
Line_38 $$ file.accept(new JavaRecursiveElementVisitor() -->Line_42 $$ PsiElement element = reference.resolve()[ FD ]
Line_38 $$ file.accept(new JavaRecursiveElementVisitor() -->Line_40 $$ if (reference.getQualifier() != null)[ FD ]
Line_43 $$ if (element instanceof PsiClass && conflicts.contains(((PsiClass) element).getName())) -->Line_45 $$ namesToUseSingle.add(fqn)[ CD ]
Line_27 $$ final Set<String> conflicts = new THashSet<String>()-->Line_34 $$ conflicts.addAll(inter)[ FD ]
Line_9 $$ if (onDemands.size() < 2)-->Line_10 $$ return[ CD ]
Line_13 $$ for (int i = onDemands.size() - 1; i >= 0; i--) -->Line_29 $$ String on1 = onDemands.get(i)[ FD ]
Line_2 $$ private static void calcClassesConflictingViaOnDemandImports(PsiJavaFile file, Collection<String> onDemandImportsList, GlobalSearchScope resolveScope, final Set<String> namesToUseSingle) -->Line_28 $$ for (int i = 0; i < onDemands.size(); i++) [ CD ]
Line_30 $$ for (int j = i + 1; j < onDemands.size(); j++) -->Line_33 $$ inter.retainAll(classNames.get(on2))[ CD ]
Line_11 $$ Map<String, Set<String>> classNames = new THashMap<String, Set<String>>()-->Line_33 $$ inter.retainAll(classNames.get(on2))[ FD ]
Line_28 $$ for (int i = 0; i < onDemands.size(); i++) -->Line_30 $$ for (int j = i + 1; j < onDemands.size(); j++) [ CD ]
Line_30 $$ for (int j = i + 1; j < onDemands.size(); j++) -->Line_34 $$ conflicts.addAll(inter)[ CD ]
Line_3 $$ List<String> onDemands = new ArrayList<String>(Arrays.asList(file.getImplicitlyImportedPackages()))-->Line_6 $$ onDemands.add(onDemand)[ FD ]
Line_27 $$ final Set<String> conflicts = new THashSet<String>()-->Line_43 $$ if (element instanceof PsiClass && conflicts.contains(((PsiClass) element).getName())) [ FD ]
Line_3 $$ List<String> onDemands = new ArrayList<String>(Arrays.asList(file.getImplicitlyImportedPackages()))-->Line_5 $$ if (!onDemands.contains(onDemand)) [ FD ]
Line_2 $$ private static void calcClassesConflictingViaOnDemandImports(PsiJavaFile file, Collection<String> onDemandImportsList, GlobalSearchScope resolveScope, final Set<String> namesToUseSingle) -->Line_9 $$ if (onDemands.size() < 2)[ CD ]
Line_4 $$ for (String onDemand : onDemandImportsList) -->Line_15 $$ PsiPackage aPackage = facade.findPackage(onDemand)[ FD ]
Line_2 $$ private static void calcClassesConflictingViaOnDemandImports(PsiJavaFile file, Collection<String> onDemandImportsList, GlobalSearchScope resolveScope, final Set<String> namesToUseSingle) -->Line_13 $$ for (int i = onDemands.size() - 1; i >= 0; i--) [ CD ]
Line_30 $$ for (int j = i + 1; j < onDemands.size(); j++) -->Line_31 $$ String on2 = onDemands.get(j)[ FD ]
Line_30 $$ for (int j = i + 1; j < onDemands.size(); j++) -->Line_32 $$ Set<String> inter = new THashSet<String>(classNames.get(on1))[ CD ]
Line_3 $$ List<String> onDemands = new ArrayList<String>(Arrays.asList(file.getImplicitlyImportedPackages()))-->Line_13 $$ for (int i = onDemands.size() - 1; i >= 0; i--) [ FD ]
Line_4 $$ for (String onDemand : onDemandImportsList) -->Line_25 $$ classNames.put(onDemand, set)[ FD ]
Line_30 $$ for (int j = i + 1; j < onDemands.size(); j++) -->Line_31 $$ String on2 = onDemands.get(j)[ CD ]
Line_2 $$ private static void calcClassesConflictingViaOnDemandImports(PsiJavaFile file, Collection<String> onDemandImportsList, GlobalSearchScope resolveScope, final Set<String> namesToUseSingle) -->Line_38 $$ file.accept(new JavaRecursiveElementVisitor() [ FD ]
Line_37 $$ if (!conflicts.isEmpty() && !(file instanceof PsiCompiledElement)) -->Line_38 $$ file.accept(new JavaRecursiveElementVisitor() [ CD ]
Line_2 $$ private static void calcClassesConflictingViaOnDemandImports(PsiJavaFile file, Collection<String> onDemandImportsList, GlobalSearchScope resolveScope, final Set<String> namesToUseSingle) -->Line_20 $$ PsiClass[] psiClasses = aPackage.getClasses(resolveScope)[ FD ]
Line_28 $$ for (int i = 0; i < onDemands.size(); i++) -->Line_29 $$ String on1 = onDemands.get(i)[ CD ]
Line_38 $$ file.accept(new JavaRecursiveElementVisitor() -->Line_42 $$ PsiElement element = reference.resolve()[ CD ]
Line_13 $$ for (int i = onDemands.size() - 1; i >= 0; i--) -->Line_20 $$ PsiClass[] psiClasses = aPackage.getClasses(resolveScope)[ CD ]
Line_11 $$ Map<String, Set<String>> classNames = new THashMap<String, Set<String>>()-->Line_25 $$ classNames.put(onDemand, set)[ FD ]
Line_11 $$ Map<String, Set<String>> classNames = new THashMap<String, Set<String>>()-->Line_32 $$ Set<String> inter = new THashSet<String>(classNames.get(on1))[ FD ]
Line_13 $$ for (int i = onDemands.size() - 1; i >= 0; i--) -->Line_15 $$ PsiPackage aPackage = facade.findPackage(onDemand)[ CD ]
Line_32 $$ Set<String> inter = new THashSet<String>(classNames.get(on1))-->Line_34 $$ conflicts.addAll(inter)[ FD ]
Line_38 $$ file.accept(new JavaRecursiveElementVisitor() -->Line_43 $$ if (element instanceof PsiClass && conflicts.contains(((PsiClass) element).getName())) [ CD ]
Line_3 $$ List<String> onDemands = new ArrayList<String>(Arrays.asList(file.getImplicitlyImportedPackages()))-->Line_30 $$ for (int j = i + 1; j < onDemands.size(); j++) [ FD ]
Line_32 $$ Set<String> inter = new THashSet<String>(classNames.get(on1))-->Line_33 $$ inter.retainAll(classNames.get(on2))[ FD ]
Line_4 $$ for (String onDemand : onDemandImportsList) -->Line_6 $$ onDemands.add(onDemand)[ FD ]
Line_3 $$ List<String> onDemands = new ArrayList<String>(Arrays.asList(file.getImplicitlyImportedPackages()))-->Line_14 $$ String onDemand = onDemands.get(i)[ FD ]
Line_28 $$ for (int i = 0; i < onDemands.size(); i++) -->Line_29 $$ String on1 = onDemands.get(i)[ FD ]
Line_2 $$ private static void calcClassesConflictingViaOnDemandImports(PsiJavaFile file, Collection<String> onDemandImportsList, GlobalSearchScope resolveScope, final Set<String> namesToUseSingle) -->Line_11 $$ Map<String, Set<String>> classNames = new THashMap<String, Set<String>>()[ CD ]
Line_13 $$ for (int i = onDemands.size() - 1; i >= 0; i--) -->Line_21 $$ Set<String> set = new THashSet<String>(psiClasses.length)[ CD ]
Line_14 $$ String onDemand = onDemands.get(i)-->Line_25 $$ classNames.put(onDemand, set)[ FD ]
Line_15 $$ PsiPackage aPackage = facade.findPackage(onDemand)-->Line_20 $$ PsiClass[] psiClasses = aPackage.getClasses(resolveScope)[ FD ]
Line_2 $$ private static void calcClassesConflictingViaOnDemandImports(PsiJavaFile file, Collection<String> onDemandImportsList, GlobalSearchScope resolveScope, final Set<String> namesToUseSingle) -->Line_12 $$ JavaPsiFacade facade = JavaPsiFacade.getInstance(file.getProject())[ CD ]
Line_5 $$ if (!onDemands.contains(onDemand)) -->Line_6 $$ onDemands.add(onDemand)[ CD ]
Line_13 $$ for (int i = onDemands.size() - 1; i >= 0; i--) -->Line_14 $$ String onDemand = onDemands.get(i)[ FD ]
Line_13 $$ for (int i = onDemands.size() - 1; i >= 0; i--) -->Line_28 $$ for (int i = 0; i < onDemands.size(); i++) [ FD ]
Line_21 $$ Set<String> set = new THashSet<String>(psiClasses.length)-->Line_23 $$ set.add(psiClass.getName())[ FD ]
Line_2 $$ private static void calcClassesConflictingViaOnDemandImports(PsiJavaFile file, Collection<String> onDemandImportsList, GlobalSearchScope resolveScope, final Set<String> namesToUseSingle) -->Line_45 $$ namesToUseSingle.add(fqn)[ FD ]
Line_13 $$ for (int i = onDemands.size() - 1; i >= 0; i--) -->Line_16 $$ if (aPackage == null) [ CD ]
Line_2 $$ private static void calcClassesConflictingViaOnDemandImports(PsiJavaFile file, Collection<String> onDemandImportsList, GlobalSearchScope resolveScope, final Set<String> namesToUseSingle) -->Line_27 $$ final Set<String> conflicts = new THashSet<String>()[ CD ]
Line_3 $$ List<String> onDemands = new ArrayList<String>(Arrays.asList(file.getImplicitlyImportedPackages()))-->Line_28 $$ for (int i = 0; i < onDemands.size(); i++) [ FD ]
Line_15 $$ PsiPackage aPackage = facade.findPackage(onDemand)-->Line_16 $$ if (aPackage == null) [ FD ]
Line_3 $$ List<String> onDemands = new ArrayList<String>(Arrays.asList(file.getImplicitlyImportedPackages()))-->Line_29 $$ String on1 = onDemands.get(i)[ FD ]
Line_3 $$ List<String> onDemands = new ArrayList<String>(Arrays.asList(file.getImplicitlyImportedPackages()))-->Line_31 $$ String on2 = onDemands.get(j)[ FD ]
Line_3 $$ List<String> onDemands = new ArrayList<String>(Arrays.asList(file.getImplicitlyImportedPackages()))-->Line_17 $$ onDemands.remove(i)[ FD ]
Line_13 $$ for (int i = onDemands.size() - 1; i >= 0; i--) -->Line_25 $$ classNames.put(onDemand, set)[ CD ]
Line_31 $$ String on2 = onDemands.get(j)-->Line_33 $$ inter.retainAll(classNames.get(on2))[ FD ]
Line_12 $$ JavaPsiFacade facade = JavaPsiFacade.getInstance(file.getProject())-->Line_15 $$ PsiPackage aPackage = facade.findPackage(onDemand)[ FD ]
Line_21 $$ Set<String> set = new THashSet<String>(psiClasses.length)-->Line_25 $$ classNames.put(onDemand, set)[ FD ]
Line_22 $$ for (PsiClass psiClass : psiClasses) -->Line_23 $$ set.add(psiClass.getName())[ FD ]
Line_43 $$ if (element instanceof PsiClass && conflicts.contains(((PsiClass) element).getName())) -->Line_44 $$ String fqn = ((PsiClass) element).getQualifiedName()[ CD ]
Line_40 $$ if (reference.getQualifier() != null)-->Line_41 $$ return[ CD ]
Line_2 $$ private static void calcClassesConflictingViaOnDemandImports(PsiJavaFile file, Collection<String> onDemandImportsList, GlobalSearchScope resolveScope, final Set<String> namesToUseSingle) -->Line_12 $$ JavaPsiFacade facade = JavaPsiFacade.getInstance(file.getProject())[ FD ]
Line_14 $$ String onDemand = onDemands.get(i)-->Line_15 $$ PsiPackage aPackage = facade.findPackage(onDemand)[ FD ]
Line_29 $$ String on1 = onDemands.get(i)-->Line_32 $$ Set<String> inter = new THashSet<String>(classNames.get(on1))[ FD ]
Line_27 $$ final Set<String> conflicts = new THashSet<String>()-->Line_37 $$ if (!conflicts.isEmpty() && !(file instanceof PsiCompiledElement)) [ FD ]
Line_38 $$ file.accept(new JavaRecursiveElementVisitor() -->Line_40 $$ if (reference.getQualifier() != null)[ CD ]
Line_4 $$ for (String onDemand : onDemandImportsList) -->Line_5 $$ if (!onDemands.contains(onDemand)) [ FD ]
Line_13 $$ for (int i = onDemands.size() - 1; i >= 0; i--) -->Line_14 $$ String onDemand = onDemands.get(i)[ CD ]
Line_16 $$ if (aPackage == null) -->Line_17 $$ onDemands.remove(i)[ CD ]
Line_13 $$ for (int i = onDemands.size() - 1; i >= 0; i--) -->Line_17 $$ onDemands.remove(i)[ FD ]
Line_3 $$ List<String> onDemands = new ArrayList<String>(Arrays.asList(file.getImplicitlyImportedPackages()))-->Line_9 $$ if (onDemands.size() < 2)[ FD ]
Line_2 $$ private static void calcClassesConflictingViaOnDemandImports(PsiJavaFile file, Collection<String> onDemandImportsList, GlobalSearchScope resolveScope, final Set<String> namesToUseSingle) -->Line_3 $$ List<String> onDemands = new ArrayList<String>(Arrays.asList(file.getImplicitlyImportedPackages()))[ CD ]
Line_2 $$ private static void calcClassesConflictingViaOnDemandImports(PsiJavaFile file, Collection<String> onDemandImportsList, GlobalSearchScope resolveScope, final Set<String> namesToUseSingle) -->Line_37 $$ if (!conflicts.isEmpty() && !(file instanceof PsiCompiledElement)) [ CD ]
Line_2 $$ private static void calcClassesConflictingViaOnDemandImports(PsiJavaFile file, Collection<String> onDemandImportsList, GlobalSearchScope resolveScope, final Set<String> namesToUseSingle) -->Line_3 $$ List<String> onDemands = new ArrayList<String>(Arrays.asList(file.getImplicitlyImportedPackages()))[ FD ]
